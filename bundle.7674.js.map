{"version":3,"file":"bundle.7674.js","mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,YAAY,2CAAyB;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4BAA4B;AACvC,WAAW,kDAAkD;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA,aAAa,mCAA2B;AACxC,0CAAkC;AAClC;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;;AAED,gBAAgB","sources":["webpack://ace-playground/./node_modules/ace-code/src/ext/hardwrap.js"],"sourcesContent":["/**\n * ## Text hard wrapping extension for automatic line breaking and text formatting.\n *\n * Provides intelligent line wrapping functionality that breaks long lines at configurable column limits while\n * preserving indentation and optionally merging short adjacent lines. Supports both automatic wrapping during text\n * input and manual formatting of selected text ranges.\n *\n * **Enable:** `editor.setOption(\"hardWrap\", true)`\n * or configure it during editor initialization in the options object.\n * @module\n */\n\n\"use strict\";\n\nvar Range = require(\"../range\").Range;\n\n/**\n * Wraps lines at specified column limits and optionally merges short adjacent lines.\n *\n * Processes text within the specified row range, breaking lines that exceed the maximum column\n * width at appropriate word boundaries while preserving indentation. When merge is enabled,\n * combines short consecutive lines that can fit within the column limit. Automatically adjusts\n * the end row when new line breaks are inserted to ensure all affected content is processed.\n *\n * @param {import(\"../editor\").Editor} editor - The editor instance containing the text to wrap\n * @param {import(\"../../ace-internal\").Ace.HardWrapOptions} options - Configuration options for wrapping behavior\n */\n\nfunction hardWrap(editor, options) {\n    var max = options.column || editor.getOption(\"printMarginColumn\");\n    var allowMerge = options.allowMerge != false;\n       \n    var row = Math.min(options.startRow, options.endRow);\n    var endRow = Math.max(options.startRow, options.endRow);\n    \n    var session = editor.session;\n    \n    while (row <= endRow) {\n        var line = session.getLine(row);\n        if (line.length > max) {\n            var space = findSpace(line, max, 5);\n            if (space) {\n                var indentation = /^\\s*/.exec(line)[0];\n                session.replace(new Range(row,space.start,row,space.end), \"\\n\" + indentation);\n            }\n            endRow++;\n        } else if (allowMerge && /\\S/.test(line) && row != endRow) {\n            var nextLine = session.getLine(row + 1);\n            if (nextLine && /\\S/.test(nextLine)) {\n                var trimmedLine = line.replace(/\\s+$/, \"\");\n                var trimmedNextLine = nextLine.replace(/^\\s+/, \"\");\n                var mergedLine = trimmedLine + \" \" + trimmedNextLine;\n\n                var space = findSpace(mergedLine, max, 5);\n                if (space && space.start > trimmedLine.length || mergedLine.length < max) {\n                    var replaceRange = new Range(row,trimmedLine.length,row + 1,nextLine.length - trimmedNextLine.length);\n                    session.replace(replaceRange, \" \");\n                    row--;\n                    endRow--;\n                } else if (trimmedLine.length < line.length) {\n                    session.remove(new Range(row, trimmedLine.length, row, line.length));\n                }\n            }\n        }\n        row++;\n    }\n\n    /**\n     * @param {string} line\n     * @param {number} max\n     * @param {number} min\n     */\n    function findSpace(line, max, min) {\n        if (line.length < max)\n            return;\n        var before = line.slice(0, max);\n        var after = line.slice(max);\n        var spaceAfter = /^(?:(\\s+)|(\\S+)(\\s+))/.exec(after);\n        var spaceBefore = /(?:(\\s+)|(\\s+)(\\S+))$/.exec(before);\n        var start = 0;\n        var end = 0;\n        if (spaceBefore && !spaceBefore[2]) {\n            start = max - spaceBefore[1].length;\n            end = max;\n        }\n        if (spaceAfter && !spaceAfter[2]) {\n            if (!start)\n                start = max;\n            end = max + spaceAfter[1].length;\n        }\n        if (start) {\n            return {\n                start: start,\n                end: end\n            };\n        }\n        if (spaceBefore && spaceBefore[2] && spaceBefore.index > min) {\n            return {\n                start: spaceBefore.index,\n                end: spaceBefore.index + spaceBefore[2].length\n            };\n        }\n        if (spaceAfter && spaceAfter[2]) {\n            start =  max + spaceAfter[2].length;\n            return {\n                start: start,\n                end: start + spaceAfter[3].length\n            };\n        }\n    }\n\n}\n\nfunction wrapAfterInput(e) {\n    if (e.command.name == \"insertstring\" && /\\S/.test(e.args)) {\n        var editor = e.editor;\n        var cursor = editor.selection.cursor;\n        if (cursor.column <= editor.renderer.$printMarginColumn) return;\n        var lastDelta = editor.session.$undoManager.$lastDelta;\n\n        hardWrap(editor, {\n            startRow: cursor.row, endRow: cursor.row,\n            allowMerge: false\n        });\n        if (lastDelta != editor.session.$undoManager.$lastDelta) \n            editor.session.markUndoGroup();\n    }\n}\n\nvar Editor = require(\"../editor\").Editor;\nrequire(\"../config\").defineOptions(Editor.prototype, \"editor\", {\n    hardWrap: {\n        set: function(val) {\n            if (val) {\n                this.commands.on(\"afterExec\", wrapAfterInput);\n            } else {\n                this.commands.off(\"afterExec\", wrapAfterInput);\n            }\n        },\n        value: false\n    }\n});\n\nexports.hardWrap = hardWrap;\n"],"names":[],"sourceRoot":""}