{"version":3,"file":"bundle.7760.js","mappings":";;;;;;AAAa;;;AAGb,qBAAqB,yCAAwC;AAC7D,iBAAiB,4CAAiD;AAClE,eAAe,mBAAO,CAAC,KAAc;;AAErC;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;;AAEb,SAAS;AACT,kDAAkD,OAAO,QAAQ,SAAS;AAC1E,kDAAkD,OAAO,QAAQ,SAAS;AAC1E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,oCAAoC;AACnD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAAsB;;;;;;;;;ACjZT;;AAEb,mBAAmB,yCAAwC;AAC3D,aAAa,mBAAO,CAAC,KAAc;;AAEnC;AACA;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT,kDAAkD,OAAO,QAAQ,SAAS;AAC1E,kDAAkD,OAAO,QAAQ,SAAS;AAC1E;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,kDAAkD;AACjE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,+BAA+B;AAC9C,eAAe,0CAA0C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,+BAA+B;AAC9C,eAAe,0CAA0C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA,SAAqB;;;;;;;;ACtNrB,UAAU,mBAAO,CAAC,KAAe;;AAEjC;AACA;AACA,eAAe,+BAA+B;AAC9C,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAkC;;;;;;;;;;ACrErB;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW,IAAI,kBAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,gBAAgB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,gBAAgB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,iBAAiB,yCAAyC,uBAAuB;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8BAA8B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yBAAyB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,sCAAsC;AAClF;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,wCAAwC;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,QAAQ,yBAAyB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,kDAAkD,gDAAgD;AAClG,qBAAqB,2BAA2B,GAAG,+BAA+B,GAAG,+BAA+B;AACpH,qCAAqC,gCAAgC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gDAAgD;AAClG,qBAAqB,2BAA2B,GAAG,+BAA+B,GAAG,+BAA+B;AACpH;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6BAA6B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA,yBAAmB;;AAEnB,eAAe,2CAA+B;;AAE9C,KAAK,WAAW,EAAE,mBAAO,CAAC,KAAmB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAoB;;;;;;;AC76EpB,gBAAgB,+CAA2C;;AAE3D;AACA;AACA,eAAe,gDAAgD;AAC/D,eAAe,kDAAkD;AACjE,eAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,eAAe,0CAA0C;AACzD,eAAe,0CAA0C;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;;AAEb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAA2B;;;;;;;;ACpJd;;AAEb,UAAU,mBAAO,CAAC,IAAe;AACjC,YAAY,2CAA4B;AACxC,UAAU,mBAAO,CAAC,KAAe;AACjC,aAAa,mBAAO,CAAC,KAAc;AACnC,kBAAkB,iDAAyC;AAC3D,0BAA0B,yDAAsD;;AAEhF;AACA,UAAU,6CAAkC;;AAE5C,aAAa,mCAA8B;AAC3C,eAAe,4CAAiD;AAChE,kBAAkB,iDAAwC;AAC1D,gBAAgB,+CAA2C;;AAE3D,mBAAO,CAAC,KAAsB;AAC9B;AACA,mBAAO,CAAC,KAAoB;;AAE5B,kBAAkB,iDAAyC;;AAE3D,iCAAiC,gEAAwD;;AAEzF;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mEAAmE;AACrF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2DAA2D;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,eAAe,uBAAuB,uBAAuB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,YAAY,wCAAwC;AACvE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,UAAU;AACzB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,eAAe,4CAA4C;AAC3D;AACA;AACA;AACA;;AAEA;AACA,eAAe,aAAa;AAC5B,iBAAiB,kBAAkB,mBAAmB,gBAAgB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,2CAA2C;AAC1D,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO,QAAQ,SAAS;AAC/D;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA,eAAe,8BAA8B;AAC7C,eAAe,SAAS;AACxB,gBAAgB;AAChB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8BAA8B;AAC9D;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,gBAAgB;AAChB;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,oBAAoB;;;AAGpB;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA,6FAA6F,IAAI;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,yCAAyC;AACxD;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4CAA4C,uBAAuB;AACnE;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gCAAgC,mCAAmC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB;AACjB,qBAAqB;;;;;;;ACvhCrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA,qBAAqB,oDAAiD;AACtE,oBAAoB,mDAA+C;AACnE,mBAAmB,kDAAgD;;AAEnE;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,4BAA4B;AAC1C,cAAc,4BAA4B;AAC1C,cAAc,uCAAuC;AACrD,cAAc,uCAAuC;AACrD,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,SAAS;AACvB,cAAc,eAAe;AAC7B;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,+CAA+C;AAC7D;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc,+GAA+G;AAC7H;;;AAGA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,iBAAiB;AAC5B,aAAa,8BAA8B;AAC3C;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB;AACtB,qBAAqB;AACrB,oBAAoB;AACpB,sBAAsB;;;;;;;;ACrFtB,SAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA","sources":["webpack://ace-playground/./node_modules/ace-code/src/ext/diff/inline_diff_view.js","webpack://ace-playground/./node_modules/ace-code/src/ext/diff/split_diff_view.js","webpack://ace-playground/./node_modules/ace-code/src/ext/diff/gutter_decorator.js","webpack://ace-playground/./node_modules/ace-code/src/ext/diff/providers/default.js","webpack://ace-playground/./node_modules/ace-code/src/ext/diff/scroll_diff_decorator.js","webpack://ace-playground/./node_modules/ace-code/src/ext/diff/base_diff_view.js","webpack://ace-playground/./node_modules/ace-code/src/ext/diff.js","webpack://ace-playground/./node_modules/ace-code/src/ext/diff/styles-css.js"],"sourcesContent":["\"use strict\";\n\n\nconst BaseDiffView = require(\"./base_diff_view\").BaseDiffView;\nconst Renderer = require(\"../../virtual_renderer\").VirtualRenderer;\nconst config = require(\"../../config\");\n\nclass InlineDiffView extends BaseDiffView {\n    /**\n     * Constructs a new inline DiffView instance.\n     * @param {import(\"../diff\").DiffModel} [diffModel] - The model for the diff view.\n     * @param {HTMLElement} [container] - optional container element for the DiffView.\n     */\n    constructor(diffModel, container) {\n        diffModel = diffModel || {};\n        diffModel.inline = diffModel.inline || \"a\";\n        super( true, container);\n        this.init(diffModel);\n    }\n\n    init(diffModel) {\n        this.onSelect = this.onSelect.bind(this);\n        this.onAfterRender = this.onAfterRender.bind(this);\n        \n\n        this.$setupModels(diffModel);\n        this.onChangeTheme();\n        config.resetOptions(this);\n        config[\"_signal\"](\"diffView\", this);\n\n        var padding = this.activeEditor.renderer.$padding;\n\n        this.addGutterDecorators();\n\n        this.otherEditor.renderer.setPadding(padding);\n        this.textLayer = this.otherEditor.renderer.$textLayer;\n        this.markerLayer = this.otherEditor.renderer.$markerBack;\n        this.gutterLayer = this.otherEditor.renderer.$gutterLayer;\n        this.cursorLayer = this.otherEditor.renderer.$cursorLayer;\n\n        this.otherEditor.renderer.$updateCachedSize = function() {\n        };\n\n        var textLayerElement = this.activeEditor.renderer.$textLayer.element;\n        textLayerElement.parentNode.insertBefore(\n            this.textLayer.element,\n            textLayerElement\n        );\n\n        var markerLayerElement = this.activeEditor.renderer.$markerBack.element;\n        markerLayerElement.parentNode.insertBefore(\n            this.markerLayer.element,\n            markerLayerElement.nextSibling\n        );\n\n        var gutterLayerElement = this.activeEditor.renderer.$gutterLayer.element;\n        gutterLayerElement.parentNode.insertBefore(\n            this.gutterLayer.element,\n            gutterLayerElement.nextSibling\n        );\n        gutterLayerElement.style.position = \"absolute\";\n        this.gutterLayer.element.style.position = \"absolute\";\n        this.gutterLayer.element.style.width = \"100%\";\n        this.gutterLayer.element.classList.add(\"ace_mini-diff_gutter_other\");\n        \n\n        this.gutterLayer.$updateGutterWidth = function() {};\n        this.initMouse();\n        this.initTextInput();\n        this.initTextLayer();\n        this.initRenderer();\n\n        this.$attachEventHandlers();\n        this.selectEditor(this.activeEditor);\n    }\n\n    initRenderer(restore) {\n        if (restore) {\n            delete this.activeEditor.renderer.$getLongestLine;\n        } else {\n            this.editorA.renderer.$getLongestLine =\n            this.editorB.renderer.$getLongestLine = () => {\n                var getLongestLine = Renderer.prototype.$getLongestLine;\n                return Math.max(\n                    getLongestLine.call(this.editorA.renderer),\n                    getLongestLine.call(this.editorB.renderer)\n                );\n            };\n        }\n    }\n\n    initTextLayer() {\n        var renderLine = this.textLayer.$renderLine;\n        var diffView = this;\n        this.otherEditor.renderer.$textLayer.$renderLine = function(parent, row, foldLIne) {\n            if (isVisibleRow(diffView.chunks, row)) {\n                renderLine.call(this, parent, row, foldLIne);\n            }\n        };\n        var side = this.showSideA ? \"new\" : \"old\";\n        function isVisibleRow(chunks, row) {\n            var min = 0;\n            var max = chunks.length - 1;\n            var result = -1;\n            while (min < max) {\n                var mid = Math.floor((min + max) / 2);\n                var chunkStart = chunks[mid][side].start.row;\n                if (chunkStart < row) {\n                    result = mid;\n                    min = mid + 1;\n                } else if (chunkStart > row) {\n                    max = mid - 1;\n                } else {\n                    result = mid;\n                    break;\n                }\n            }\n            if (chunks[result + 1] && chunks[result + 1][side].start.row <= row) {\n                result++;\n            }\n            var range = chunks[result] && chunks[result][side];\n            if (range && range.end.row > row) {\n                return true;\n            }\n            return false;\n        }\n    }\n\n    initTextInput(restore) {\n        if (restore) {\n            this.otherEditor.textInput = this.othertextInput;\n            this.otherEditor.container = this.otherEditorContainer;\n        } else {\n            this.othertextInput = this.otherEditor.textInput;\n            this.otherEditor.textInput = this.activeEditor.textInput;\n            this.otherEditorContainer = this.otherEditor.container;\n            this.otherEditor.container = this.activeEditor.container;\n        }\n    }\n\n    selectEditor(editor) {\n        if (editor == this.activeEditor) {\n            this.otherEditor.selection.clearSelection();\n            this.activeEditor.textInput.setHost(this.activeEditor);\n            this.activeEditor.setStyle(\"ace_diff_other\", false);\n            this.cursorLayer.element.remove();\n            this.activeEditor.renderer.$cursorLayer.element.style.display = \"block\";\n            if (this.showSideA) {\n                this.sessionA.removeMarker(this.syncSelectionMarkerA.id);\n                this.sessionA.addDynamicMarker(this.syncSelectionMarkerA, true);\n            }\n            this.markerLayer.element.classList.add(\"ace_hidden_marker-layer\");\n            this.activeEditor.renderer.$markerBack.element.classList.remove(\"ace_hidden_marker-layer\");\n            this.removeBracketHighlight(this.otherEditor); \n        } else {\n            this.activeEditor.selection.clearSelection();\n            this.activeEditor.textInput.setHost(this.otherEditor);\n            this.activeEditor.setStyle(\"ace_diff_other\");\n            this.activeEditor.renderer.$cursorLayer.element.parentNode.appendChild(\n                this.cursorLayer.element\n            );\n            this.activeEditor.renderer.$cursorLayer.element.style.display = \"none\";\n            if (this.activeEditor.$isFocused) {\n                this.otherEditor.onFocus();\n            }\n            if (this.showSideA) {\n                this.sessionA.removeMarker(this.syncSelectionMarkerA.id);\n            }\n            this.markerLayer.element.classList.remove(\"ace_hidden_marker-layer\");\n            this.activeEditor.renderer.$markerBack.element.classList.add(\"ace_hidden_marker-layer\");\n            this.removeBracketHighlight(this.activeEditor); \n        }\n    }\n\n    removeBracketHighlight(editor) {\n        var session = editor.session;\n        if (session.$bracketHighlight) {\n            session.$bracketHighlight.markerIds.forEach(function(id) {\n                session.removeMarker(id);\n            });\n            session.$bracketHighlight = null;\n        }\n    }\n\n    initMouse() {\n        this.otherEditor.renderer.$loop = this.activeEditor.renderer.$loop;\n        \n        this.otherEditor.renderer.scroller = {\n            getBoundingClientRect: () => {\n                return this.activeEditor.renderer.scroller.getBoundingClientRect();\n            },\n            style: this.activeEditor.renderer.scroller.style,\n        };\n        \n        var forwardEvent = (ev) => {\n            if (!ev.domEvent) return; \n            var screenPos = ev.editor.renderer.pixelToScreenCoordinates(ev.clientX, ev.clientY);\n            var sessionA = this.activeEditor.session;\n            var sessionB = this.otherEditor.session;\n            var posA = sessionA.screenToDocumentPosition(screenPos.row, screenPos.column, screenPos.offsetX); \n            var posB = sessionB.screenToDocumentPosition(screenPos.row, screenPos.column, screenPos.offsetX); \n        \n            var posAx = sessionA.documentToScreenPosition(posA); \n            var posBx = sessionB.documentToScreenPosition(posB); \n            \n            if (ev.editor == this.activeEditor) {\n                if (posBx.row == screenPos.row && posAx.row != screenPos.row) {\n                    if (ev.type == \"mousedown\") {\n                        this.selectEditor(this.otherEditor);\n                    }\n                    ev.propagationStopped = true;\n                    ev.defaultPrevented = true;\n                    this.otherEditor.$mouseHandler.onMouseEvent(ev.type, ev.domEvent);\n                } else if (ev.type == \"mousedown\") {\n                    this.selectEditor(this.activeEditor);\n                }\n            }\n        };\n        \n        \n        var events = [\n            \"mousedown\",\n            \"click\",\n            \"mouseup\",\n            \"dblclick\",\n            \"tripleclick\",\n            \"quadclick\",\n        ];\n        events.forEach((event) => {\n            this.activeEditor.on(event, forwardEvent, true);\n            this.activeEditor.on(\"gutter\" + event, forwardEvent, true);\n        });\n\n        var onFocus = (e) => {\n            this.activeEditor.onFocus(e);\n        };\n        var onBlur = (e) => {\n            this.activeEditor.onBlur(e);\n        };\n        this.otherEditor.on(\"focus\", onFocus);\n        this.otherEditor.on(\"blur\", onBlur);\n\n        this.onMouseDetach = () => {\n            events.forEach((event) => {\n                this.activeEditor.off(event, forwardEvent, true);\n                this.activeEditor.off(\"gutter\" + event, forwardEvent, true);\n            });\n            this.otherEditor.off(\"focus\", onFocus);\n            this.otherEditor.off(\"blur\", onBlur);\n        };\n    }\n\n    align() {\n        var diffView = this;\n\n        this.$initWidgets(diffView.editorA);\n        this.$initWidgets(diffView.editorB);\n\n        diffView.chunks.forEach(function (ch) {\n            var diff1 = diffView.$screenRow(ch.old.end, diffView.sessionA)\n                - diffView.$screenRow(ch.old.start, diffView.sessionA);\n            var diff2 = diffView.$screenRow(ch.new.end, diffView.sessionB)\n                - diffView.$screenRow(ch.new.start, diffView.sessionB);\n\n            diffView.$addWidget(diffView.sessionA, {\n                rowCount: diff2,\n                rowsAbove: ch.old.end.row === 0 ? diff2 : 0,\n                row: ch.old.end.row === 0 ? 0 : ch.old.end.row - 1\n            });\n            diffView.$addWidget(diffView.sessionB, {\n                rowCount: diff1,\n                rowsAbove: diff1,\n                row: ch.new.start.row,\n            });\n\n        });\n        diffView.sessionA[\"_emit\"](\"changeFold\", {data: {start: {row: 0}}});\n        diffView.sessionB[\"_emit\"](\"changeFold\", {data: {start: {row: 0}}});\n    }\n\n    onChangeWrapLimit() {\n        this.sessionB.adjustWrapLimit(this.sessionA.$wrapLimit);\n        this.scheduleRealign();\n    }\n\n    $attachSessionsEventHandlers() {\n        this.$attachSessionEventHandlers(this.editorA, this.markerA);\n        this.$attachSessionEventHandlers(this.editorB, this.markerB);\n        this.sessionA.on(\"changeWrapLimit\", this.onChangeWrapLimit);\n        this.sessionA.on(\"changeWrapMode\", this.onChangeWrapLimit);\n    }\n\n    $attachSessionEventHandlers(editor, marker) {\n        editor.session.on(\"changeFold\", this.onChangeFold);\n        editor.session.addDynamicMarker(marker);\n        editor.selection.on(\"changeCursor\", this.onSelect);\n        editor.selection.on(\"changeSelection\", this.onSelect);\n    }\n\n    $detachSessionsEventHandlers() {\n        this.$detachSessionHandlers(this.editorA, this.markerA);\n        this.$detachSessionHandlers(this.editorB, this.markerB);\n        this.otherSession.bgTokenizer.lines.fill(undefined);\n        this.sessionA.off(\"changeWrapLimit\", this.onChangeWrapLimit);\n        this.sessionA.off(\"changeWrapMode\", this.onChangeWrapLimit);\n    }\n\n    $detachSessionHandlers(editor, marker) {\n        editor.session.removeMarker(marker.id);\n        editor.selection.off(\"changeCursor\", this.onSelect);\n        editor.selection.off(\"changeSelection\", this.onSelect);\n        editor.session.off(\"changeFold\", this.onChangeFold);\n    }\n\n    $attachEventHandlers() {\n        this.activeEditor.on(\"input\", this.onInput);\n        this.activeEditor.renderer.on(\"afterRender\", this.onAfterRender);\n        this.otherSession.on(\"change\", this.onInput);\n    }\n\n    $detachEventHandlers() {\n        this.$detachSessionsEventHandlers();\n        this.activeEditor.off(\"input\", this.onInput);\n        this.activeEditor.renderer.off(\"afterRender\", this.onAfterRender);\n        this.otherSession.off(\"change\", this.onInput);\n\n        this.textLayer.element.textContent = \"\";\n        this.textLayer.element.remove();\n        this.gutterLayer.element.textContent = \"\";\n        this.gutterLayer.element.remove();\n        this.markerLayer.element.textContent = \"\";\n        this.markerLayer.element.remove();\n\n        this.onMouseDetach();\n\n        this.selectEditor(this.activeEditor);\n        this.clearSelectionMarkers();\n        this.otherEditor.setSession(null);\n        this.otherEditor.renderer.$loop = null;\n        this.initTextInput(true);\n        this.initRenderer(true);\n\n        this.otherEditor.destroy();\n    }\n\n    /**\n     * @param {number} changes\n     * @param {import(\"ace-code\").VirtualRenderer} renderer\n     */\n    onAfterRender(changes, renderer) {\n        var config = renderer.layerConfig;\n\n        var session = this.otherSession;\n        var cloneRenderer = this.otherEditor.renderer;\n\n        session.$scrollTop = renderer.scrollTop;\n        session.$scrollLeft = renderer.scrollLeft;\n\n        [\n            \"characterWidth\",\n            \"lineHeight\",\n            \"scrollTop\",\n            \"scrollLeft\",\n            \"scrollMargin\",\n            \"$padding\",\n            \"$size\",\n            \"layerConfig\",\n            \"$horizScroll\",\n            \"$vScroll\",\n        ]. forEach(function(prop) {\n            cloneRenderer[prop] = renderer[prop];\n        });\n\n        cloneRenderer.$computeLayerConfig();\n\n        var newConfig = cloneRenderer.layerConfig;\n        \n        this.gutterLayer.update(newConfig);\n\n        newConfig.firstRowScreen = config.firstRowScreen;\n        \n        cloneRenderer.$cursorLayer.config = newConfig;\n        cloneRenderer.$cursorLayer.update(newConfig);\n\n        if (changes & cloneRenderer.CHANGE_LINES\n            || changes & cloneRenderer.CHANGE_FULL\n            || changes & cloneRenderer.CHANGE_SCROLL\n            || changes & cloneRenderer.CHANGE_TEXT\n        )\n            this.textLayer.update(newConfig);\n\n        this.markerLayer.setMarkers(this.otherSession.getMarkers());\n        this.markerLayer.update(newConfig);\n    }\n\n    detach() {\n        super.detach();\n        this.otherEditor && this.otherEditor.destroy();\n    }\n}\n\nexports.InlineDiffView = InlineDiffView;\n","\"use strict\";\n\nvar BaseDiffView = require(\"./base_diff_view\").BaseDiffView;\nvar config = require(\"../../config\");\n\nclass SplitDiffView extends BaseDiffView {\n    /**\n     * Constructs a new side by side DiffView instance.\n     *\n     * @param {import(\"../diff\").DiffModel} [diffModel] - The model for the diff view.\n     */\n    constructor(diffModel) {\n        diffModel = diffModel || {};\n        super();\n        this.init(diffModel);\n    }\n\n    init(diffModel) {\n        this.onChangeTheme = this.onChangeTheme.bind(this);\n        this.onMouseWheel = this.onMouseWheel.bind(this);\n        this.onScroll = this.onScroll.bind(this);\n\n        this.$setupModels(diffModel);\n\n        this.addGutterDecorators();\n\n        this.onChangeTheme();\n\n        config.resetOptions(this);\n        config[\"_signal\"](\"diffView\", this);\n\n        this.$attachEventHandlers();\n    }\n\n    onChangeWrapLimit() {\n        this.scheduleRealign();\n    }\n\n    /*** scroll locking ***/\n    align() {\n        var diffView = this;\n\n        this.$initWidgets(diffView.editorA);\n        this.$initWidgets(diffView.editorB);\n\n        diffView.chunks.forEach(function (ch) {\n            var diff1 = diffView.$screenRow(ch.old.start, diffView.sessionA);\n            var diff2 = diffView.$screenRow(ch.new.start, diffView.sessionB); \n\n            if (diff1 < diff2) {\n                diffView.$addWidget(diffView.sessionA, {\n                    rowCount: diff2 - diff1,\n                    rowsAbove: ch.old.start.row === 0 ? diff2 - diff1 : 0,\n                    row: ch.old.start.row === 0 ? 0 : ch.old.start.row - 1\n                });\n            }\n            else if (diff1 > diff2) {\n                diffView.$addWidget(diffView.sessionB, {\n                    rowCount: diff1 - diff2,\n                    rowsAbove: ch.new.start.row === 0 ? diff1 - diff2 : 0,\n                    row: ch.new.start.row === 0 ? 0 : ch.new.start.row - 1\n                });\n            }\n\n            var diff1 = diffView.$screenRow(ch.old.end, diffView.sessionA);\n            var diff2 = diffView.$screenRow(ch.new.end, diffView.sessionB); \n            if (diff1 < diff2) {\n                diffView.$addWidget(diffView.sessionA, {\n                    rowCount: diff2 - diff1,\n                    rowsAbove: ch.old.end.row === 0 ? diff2 - diff1 : 0,\n                    row: ch.old.end.row === 0 ? 0 : ch.old.end.row - 1\n                });\n            }\n            else if (diff1 > diff2) {\n                diffView.$addWidget(diffView.sessionB, {\n                    rowCount: diff1 - diff2,\n                    rowsAbove: ch.new.end.row === 0 ? diff1 - diff2 : 0,\n                    row: ch.new.end.row === 0 ? 0 : ch.new.end.row - 1\n                });\n            }\n        });\n        diffView.sessionA[\"_emit\"](\"changeFold\", {data: {start: {row: 0}}});\n        diffView.sessionB[\"_emit\"](\"changeFold\", {data: {start: {row: 0}}});\n    }\n\n    onScroll(e, session) {\n        this.syncScroll(this.sessionA === session ? this.editorA.renderer : this.editorB.renderer);\n    }\n\n    /**\n     * @param {import(\"../../virtual_renderer\").VirtualRenderer} renderer\n     */\n    syncScroll(renderer) {\n        if (this.$syncScroll == false) return;\n\n        var r1 = this.editorA.renderer;\n        var r2 = this.editorB.renderer;\n        var isOrig = renderer == r1;\n        if (r1[\"$scrollAnimation\"] && r2[\"$scrollAnimation\"]) return;\n\n        var now = Date.now();\n        if (this.scrollSetBy != renderer && now - this.scrollSetAt < 500) return;\n\n        var r = isOrig ? r1 : r2;\n        if (this.scrollSetBy != renderer) {\n            if (isOrig && this.scrollA == r.session.getScrollTop()) return; else if (!isOrig && this.scrollB\n                == r.session.getScrollTop()) return;\n        }\n        var rOther = isOrig ? r2 : r1;\n\n        var targetPos = r.session.getScrollTop();\n\n        this.$syncScroll = false;\n\n        if (isOrig) {\n            this.scrollA = r.session.getScrollTop();\n            this.scrollB = targetPos;\n        }\n        else {\n            this.scrollA = targetPos;\n            this.scrollB = r.session.getScrollTop();\n        }\n        this.scrollSetBy = renderer;\n        rOther.session.setScrollTop(targetPos);\n        this.$syncScroll = true;\n        this.scrollSetAt = now;\n    }\n\n    onMouseWheel(ev) {\n        if (ev.getAccelKey()) return;\n        if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {\n            ev.wheelX = ev.wheelY;\n            ev.wheelY = 0;\n        }\n\n        var editor = ev.editor;\n        var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);\n        if (!isScrolable) {\n            var other = editor == this.editorA ? this.editorB : this.editorA;\n            if (other.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed)) other.renderer.scrollBy(\n                ev.wheelX * ev.speed, ev.wheelY * ev.speed);\n            return ev.stop();\n        }\n    }\n\n    $attachSessionsEventHandlers() {\n        this.$attachSessionEventHandlers(this.editorA, this.markerA);\n        this.$attachSessionEventHandlers(this.editorB, this.markerB);\n    }\n\n    /**\n     * @param {import(\"../../editor\").Editor} editor\n     * @param {import(\"./base_diff_view\").DiffHighlight} marker\n     */\n    $attachSessionEventHandlers(editor, marker) {\n        editor.session.on(\"changeScrollTop\", this.onScroll);\n        editor.session.on(\"changeFold\", this.onChangeFold);\n        // @ts-expect-error\n        editor.session.addDynamicMarker(marker);\n        editor.selection.on(\"changeCursor\", this.onSelect);\n        editor.selection.on(\"changeSelection\", this.onSelect);\n\n        editor.session.on(\"changeWrapLimit\", this.onChangeWrapLimit);\n        editor.session.on(\"changeWrapMode\", this.onChangeWrapLimit);\n    }\n\n    $detachSessionsEventHandlers() {\n        this.$detachSessionHandlers(this.editorA, this.markerA);\n        this.$detachSessionHandlers(this.editorB, this.markerB);\n    }\n\n    /**\n     * @param {import(\"../../editor\").Editor} editor\n     * @param {import(\"./base_diff_view\").DiffHighlight} marker\n     */\n    $detachSessionHandlers(editor, marker) {\n        editor.session.off(\"changeScrollTop\", this.onScroll);\n        editor.session.off(\"changeFold\", this.onChangeFold);\n        editor.session.removeMarker(marker.id);\n        editor.selection.off(\"changeCursor\", this.onSelect);\n        editor.selection.off(\"changeSelection\", this.onSelect);\n\n        editor.session.off(\"changeWrapLimit\", this.onChangeWrapLimit);\n        editor.session.off(\"changeWrapMode\", this.onChangeWrapLimit);\n    }\n\n    $attachEventHandlers() {\n        this.editorA.renderer.on(\"themeChange\", this.onChangeTheme);\n        this.editorB.renderer.on(\"themeChange\", this.onChangeTheme);\n\n        this.editorA.on(\"mousewheel\", this.onMouseWheel);\n        this.editorB.on(\"mousewheel\", this.onMouseWheel);\n\n        this.editorA.on(\"input\", this.onInput);\n        this.editorB.on(\"input\", this.onInput);\n\n    }\n\n    $detachEventHandlers() {\n        this.$detachSessionsEventHandlers();\n        this.clearSelectionMarkers();\n        this.editorA.renderer.off(\"themeChange\", this.onChangeTheme);\n        this.editorB.renderer.off(\"themeChange\", this.onChangeTheme);\n        this.$detachEditorEventHandlers(this.editorA);\n        this.$detachEditorEventHandlers(this.editorB);\n    }\n\n    $detachEditorEventHandlers(editor) {\n        editor.off(\"mousewheel\", this.onMouseWheel);\n        editor.off(\"input\", this.onInput);\n    }\n}\n\n\nexports.SplitDiffView = SplitDiffView;\n","var dom = require(\"../../lib/dom\");\n\nclass MinimalGutterDiffDecorator {\n    /**\n     * @param {import(\"../../editor\").Editor} editor\n     * @param {number} type\n     */\n    constructor(editor, type) {\n        this.gutterClass =\"ace_mini-diff_gutter-enabled\";\n        this.gutterCellsClasses = {\n            add: \"mini-diff-added\",\n            delete: \"mini-diff-deleted\",\n        };\n\n        this.editor = editor;\n        this.type = type;\n        this.chunks = [];\n        this.attachToEditor();\n    }\n\n    attachToEditor() {\n        this.renderGutters = this.renderGutters.bind(this);\n\n        dom.addCssClass(\n            this.editor.renderer.$gutterLayer.element,\n            this.gutterClass\n        );\n        this.editor.renderer.$gutterLayer.on(\n            \"afterRender\",\n            this.renderGutters\n        );\n    }\n\n    renderGutters(e, gutterLayer) {\n        const cells = this.editor.renderer.$gutterLayer.$lines.cells;\n        cells.forEach((cell) => {\n            cell.element.classList.remove(Object.values(this.gutterCellsClasses));\n        });\n        const dir = this.type === -1 ? \"old\" : \"new\";\n        const diffClass = this.type === -1 ? this.gutterCellsClasses.delete : this.gutterCellsClasses.add;\n        this.chunks.forEach((lineChange) => {\n            let startRow = lineChange[dir].start.row;\n            let endRow = lineChange[dir].end.row - 1;\n\n            cells.forEach((cell) => {\n                if (cell.row >= startRow && cell.row <= endRow) {\n                    cell.element.classList.add(diffClass);\n                }\n            });\n        });\n    }\n\n    setDecorations(changes) {\n        this.chunks = changes;\n        this.renderGutters();\n    }\n\n    dispose() {\n        dom.removeCssClass(\n            this.editor.renderer.$gutterLayer.element,\n            this.gutterClass\n        );\n        this.editor.renderer.$gutterLayer.off(\n            \"afterRender\",\n            this.renderGutters\n        );\n    }\n}\n\nexports.MinimalGutterDiffDecorator = MinimalGutterDiffDecorator;\n","'use strict';\n\nfunction equals(one, other, itemEquals = (a, b) => a === b) {\n  if (one === other) {\n    return true;\n  }\n  if (!one || !other) {\n    return false;\n  }\n  if (one.length !== other.length) {\n    return false;\n  }\n  for (let i = 0, len = one.length; i < len; i++) {\n    if (!itemEquals(one[i], other[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction* groupAdjacentBy(items, shouldBeGrouped) {\n  let currentGroup;\n  let last;\n  for (const item of items) {\n    if (last !== undefined && shouldBeGrouped(last, item)) {\n      currentGroup.push(item);\n    } else {\n      if (currentGroup) {\n        yield currentGroup;\n      }\n      currentGroup = [item];\n    }\n    last = item;\n  }\n  if (currentGroup) {\n    yield currentGroup;\n  }\n}\nfunction forEachAdjacent(arr, f) {\n  for (let i = 0; i <= arr.length; i++) {\n    f(i === 0 ? undefined : arr[i - 1], i === arr.length ? undefined : arr[i]);\n  }\n}\nfunction forEachWithNeighbors(arr, f) {\n  for (let i = 0; i < arr.length; i++) {\n    f(i === 0 ? undefined : arr[i - 1], arr[i], i + 1 === arr.length ? undefined : arr[i + 1]);\n  }\n}\nfunction pushMany(arr, items) {\n  for (const item of items) {\n    arr.push(item);\n  }\n}\nfunction compareBy(selector, comparator) {\n  return (a, b) => comparator(selector(a), selector(b));\n}\nconst numberComparator = (a, b) => a - b;\nfunction reverseOrder(comparator) {\n  return (a, b) => -comparator(a, b);\n}\n\nclass BugIndicatingError extends Error {\n  constructor(message) {\n    super(message || \"An unexpected bug occurred.\");\n    Object.setPrototypeOf(this, BugIndicatingError.prototype);\n  }\n}\n\nfunction assert(condition, message = \"unexpected state\") {\n  if (!condition) {\n    throw new BugIndicatingError(`Assertion Failed: ${message}`);\n  }\n}\nfunction assertFn(condition) {\n  condition();\n}\nfunction checkAdjacentItems(items, predicate) {\n  let i = 0;\n  while (i < items.length - 1) {\n    const a = items[i];\n    const b = items[i + 1];\n    if (!predicate(a, b)) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n}\n\nclass OffsetRange {\n  constructor(start, endExclusive) {\n    this.start = start;\n    this.endExclusive = endExclusive;\n    if (start > endExclusive) {\n      throw new BugIndicatingError(`Invalid range: ${this.toString()}`);\n    }\n  }\n  static fromTo(start, endExclusive) {\n    return new OffsetRange(start, endExclusive);\n  }\n  static addRange(range, sortedRanges) {\n    let i = 0;\n    while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {\n      i++;\n    }\n    let j = i;\n    while (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {\n      j++;\n    }\n    if (i === j) {\n      sortedRanges.splice(i, 0, range);\n    } else {\n      const start = Math.min(range.start, sortedRanges[i].start);\n      const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);\n      sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n    }\n  }\n  static tryCreate(start, endExclusive) {\n    if (start > endExclusive) {\n      return undefined;\n    }\n    return new OffsetRange(start, endExclusive);\n  }\n  static ofLength(length) {\n    return new OffsetRange(0, length);\n  }\n  static ofStartAndLength(start, length) {\n    return new OffsetRange(start, start + length);\n  }\n  static emptyAt(offset) {\n    return new OffsetRange(offset, offset);\n  }\n  get isEmpty() {\n    return this.start === this.endExclusive;\n  }\n  delta(offset) {\n    return new OffsetRange(this.start + offset, this.endExclusive + offset);\n  }\n  deltaStart(offset) {\n    return new OffsetRange(this.start + offset, this.endExclusive);\n  }\n  deltaEnd(offset) {\n    return new OffsetRange(this.start, this.endExclusive + offset);\n  }\n  get length() {\n    return this.endExclusive - this.start;\n  }\n  toString() {\n    return `[${this.start}, ${this.endExclusive})`;\n  }\n  equals(other) {\n    return this.start === other.start && this.endExclusive === other.endExclusive;\n  }\n  containsRange(other) {\n    return this.start <= other.start && other.endExclusive <= this.endExclusive;\n  }\n  contains(offset) {\n    return this.start <= offset && offset < this.endExclusive;\n  }\n  /**\n   * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)\n   * The joined range is the smallest range that contains both ranges.\n   */\n  join(other) {\n    return new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));\n  }\n  /**\n   * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)\n   *\n   * The resulting range is empty if the ranges do not intersect, but touch.\n   * If the ranges don't even touch, the result is undefined.\n   */\n  intersect(other) {\n    const start = Math.max(this.start, other.start);\n    const end = Math.min(this.endExclusive, other.endExclusive);\n    if (start <= end) {\n      return new OffsetRange(start, end);\n    }\n    return undefined;\n  }\n  intersectionLength(range) {\n    const start = Math.max(this.start, range.start);\n    const end = Math.min(this.endExclusive, range.endExclusive);\n    return Math.max(0, end - start);\n  }\n  intersects(other) {\n    const start = Math.max(this.start, other.start);\n    const end = Math.min(this.endExclusive, other.endExclusive);\n    return start < end;\n  }\n  intersectsOrTouches(other) {\n    const start = Math.max(this.start, other.start);\n    const end = Math.min(this.endExclusive, other.endExclusive);\n    return start <= end;\n  }\n  isBefore(other) {\n    return this.endExclusive <= other.start;\n  }\n  isAfter(other) {\n    return this.start >= other.endExclusive;\n  }\n  slice(arr) {\n    return arr.slice(this.start, this.endExclusive);\n  }\n  substring(str) {\n    return str.substring(this.start, this.endExclusive);\n  }\n  /**\n   * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.\n   * The range must not be empty.\n   */\n  clip(value) {\n    if (this.isEmpty) {\n      throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n    }\n    return Math.max(this.start, Math.min(this.endExclusive - 1, value));\n  }\n  /**\n   * Returns `r := value + k * length` such that `r` is contained in this range.\n   * The range must not be empty.\n   *\n   * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.\n   */\n  clipCyclic(value) {\n    if (this.isEmpty) {\n      throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n    }\n    if (value < this.start) {\n      return this.endExclusive - (this.start - value) % this.length;\n    }\n    if (value >= this.endExclusive) {\n      return this.start + (value - this.start) % this.length;\n    }\n    return value;\n  }\n  map(f) {\n    const result = [];\n    for (let i = this.start; i < this.endExclusive; i++) {\n      result.push(f(i));\n    }\n    return result;\n  }\n  forEach(f) {\n    for (let i = this.start; i < this.endExclusive; i++) {\n      f(i);\n    }\n  }\n}\n\nclass Position {\n  constructor(lineNumber, column) {\n    this.lineNumber = lineNumber;\n    this.column = column;\n  }\n  /**\n   * Test if this position equals other position\n   */\n  equals(other) {\n    return Position.equals(this, other);\n  }\n  /**\n   * Test if position `a` equals position `b`\n   */\n  static equals(a, b) {\n    if (!a && !b) {\n      return true;\n    }\n    return !!a && !!b && a.lineNumber === b.lineNumber && a.column === b.column;\n  }\n  /**\n   * Test if this position is before other position.\n   * If the two positions are equal, the result will be false.\n   */\n  isBefore(other) {\n    return Position.isBefore(this, other);\n  }\n  /**\n   * Test if position `a` is before position `b`.\n   * If the two positions are equal, the result will be false.\n   */\n  static isBefore(a, b) {\n    if (a.lineNumber < b.lineNumber) {\n      return true;\n    }\n    if (b.lineNumber < a.lineNumber) {\n      return false;\n    }\n    return a.column < b.column;\n  }\n  /**\n   * Test if this position is before other position.\n   * If the two positions are equal, the result will be true.\n   */\n  isBeforeOrEqual(other) {\n    return Position.isBeforeOrEqual(this, other);\n  }\n  /**\n   * Test if position `a` is before position `b`.\n   * If the two positions are equal, the result will be true.\n   */\n  static isBeforeOrEqual(a, b) {\n    if (a.lineNumber < b.lineNumber) {\n      return true;\n    }\n    if (b.lineNumber < a.lineNumber) {\n      return false;\n    }\n    return a.column <= b.column;\n  }\n}\n\nclass Range {\n  constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n    if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {\n      this.startLineNumber = endLineNumber;\n      this.startColumn = endColumn;\n      this.endLineNumber = startLineNumber;\n      this.endColumn = startColumn;\n    } else {\n      this.startLineNumber = startLineNumber;\n      this.startColumn = startColumn;\n      this.endLineNumber = endLineNumber;\n      this.endColumn = endColumn;\n    }\n  }\n  /**\n   * Test if this range is empty.\n   */\n  isEmpty() {\n    return Range.isEmpty(this);\n  }\n  /**\n   * Test if `range` is empty.\n   */\n  static isEmpty(range) {\n    return range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn;\n  }\n  /**\n   * Test if position is in this range. If the position is at the edges, will return true.\n   */\n  containsPosition(position) {\n    return Range.containsPosition(this, position);\n  }\n  /**\n   * Test if `position` is in `range`. If the position is at the edges, will return true.\n   */\n  static containsPosition(range, position) {\n    if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n      return false;\n    }\n    if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n      return false;\n    }\n    if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Test if range is in this range. If the range is equal to this range, will return true.\n   */\n  containsRange(range) {\n    return Range.containsRange(this, range);\n  }\n  /**\n   * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n   */\n  static containsRange(range, otherRange) {\n    if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n      return false;\n    }\n    if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n      return false;\n    }\n    if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n      return false;\n    }\n    if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n   */\n  strictContainsRange(range) {\n    return Range.strictContainsRange(this, range);\n  }\n  /**\n   * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n   */\n  static strictContainsRange(range, otherRange) {\n    if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n      return false;\n    }\n    if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n      return false;\n    }\n    if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n      return false;\n    }\n    if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * A reunion of the two ranges.\n   * The smallest position will be used as the start point, and the largest one as the end point.\n   */\n  plusRange(range) {\n    return Range.plusRange(this, range);\n  }\n  /**\n   * A reunion of the two ranges.\n   * The smallest position will be used as the start point, and the largest one as the end point.\n   */\n  static plusRange(a, b) {\n    let startLineNumber;\n    let startColumn;\n    let endLineNumber;\n    let endColumn;\n    if (b.startLineNumber < a.startLineNumber) {\n      startLineNumber = b.startLineNumber;\n      startColumn = b.startColumn;\n    } else if (b.startLineNumber === a.startLineNumber) {\n      startLineNumber = b.startLineNumber;\n      startColumn = Math.min(b.startColumn, a.startColumn);\n    } else {\n      startLineNumber = a.startLineNumber;\n      startColumn = a.startColumn;\n    }\n    if (b.endLineNumber > a.endLineNumber) {\n      endLineNumber = b.endLineNumber;\n      endColumn = b.endColumn;\n    } else if (b.endLineNumber === a.endLineNumber) {\n      endLineNumber = b.endLineNumber;\n      endColumn = Math.max(b.endColumn, a.endColumn);\n    } else {\n      endLineNumber = a.endLineNumber;\n      endColumn = a.endColumn;\n    }\n    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n  }\n  /**\n   * A intersection of the two ranges.\n   */\n  intersectRanges(range) {\n    return Range.intersectRanges(this, range);\n  }\n  /**\n   * A intersection of the two ranges.\n   */\n  static intersectRanges(a, b) {\n    let resultStartLineNumber = a.startLineNumber;\n    let resultStartColumn = a.startColumn;\n    let resultEndLineNumber = a.endLineNumber;\n    let resultEndColumn = a.endColumn;\n    const otherStartLineNumber = b.startLineNumber;\n    const otherStartColumn = b.startColumn;\n    const otherEndLineNumber = b.endLineNumber;\n    const otherEndColumn = b.endColumn;\n    if (resultStartLineNumber < otherStartLineNumber) {\n      resultStartLineNumber = otherStartLineNumber;\n      resultStartColumn = otherStartColumn;\n    } else if (resultStartLineNumber === otherStartLineNumber) {\n      resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n    }\n    if (resultEndLineNumber > otherEndLineNumber) {\n      resultEndLineNumber = otherEndLineNumber;\n      resultEndColumn = otherEndColumn;\n    } else if (resultEndLineNumber === otherEndLineNumber) {\n      resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n    }\n    if (resultStartLineNumber > resultEndLineNumber) {\n      return null;\n    }\n    if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n      return null;\n    }\n    return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n  }\n  /**\n   * Test if this range equals other.\n   */\n  equalsRange(other) {\n    return Range.equalsRange(this, other);\n  }\n  /**\n   * Test if range `a` equals `b`.\n   */\n  static equalsRange(a, b) {\n    if (!a && !b) {\n      return true;\n    }\n    return !!a && !!b && a.startLineNumber === b.startLineNumber && a.startColumn === b.startColumn && a.endLineNumber === b.endLineNumber && a.endColumn === b.endColumn;\n  }\n  /**\n   * Return the end position (which will be after or equal to the start position)\n   */\n  getEndPosition() {\n    return Range.getEndPosition(this);\n  }\n  /**\n   * Return the end position (which will be after or equal to the start position)\n   */\n  static getEndPosition(range) {\n    return new Position(range.endLineNumber, range.endColumn);\n  }\n  /**\n   * Return the start position (which will be before or equal to the end position)\n   */\n  getStartPosition() {\n    return Range.getStartPosition(this);\n  }\n  /**\n   * Return the start position (which will be before or equal to the end position)\n   */\n  static getStartPosition(range) {\n    return new Position(range.startLineNumber, range.startColumn);\n  }\n  /**\n   * Create a new empty range using this range's start position.\n   */\n  collapseToStart() {\n    return Range.collapseToStart(this);\n  }\n  /**\n   * Create a new empty range using this range's start position.\n   */\n  static collapseToStart(range) {\n    return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n  }\n  /**\n   * Create a new empty range using this range's end position.\n   */\n  collapseToEnd() {\n    return Range.collapseToEnd(this);\n  }\n  /**\n   * Create a new empty range using this range's end position.\n   */\n  static collapseToEnd(range) {\n    return new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\n  }\n  // ---\n  static fromPositions(start, end = start) {\n    return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n  }\n}\n\nfunction findLastMonotonous(array, predicate) {\n  const idx = findLastIdxMonotonous(array, predicate);\n  return idx === -1 ? undefined : array[idx];\n}\nfunction findLastIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {\n  let i = startIdx;\n  let j = endIdxEx;\n  while (i < j) {\n    const k = Math.floor((i + j) / 2);\n    if (predicate(array[k])) {\n      i = k + 1;\n    } else {\n      j = k;\n    }\n  }\n  return i - 1;\n}\nfunction findFirstMonotonous(array, predicate) {\n  const idx = findFirstIdxMonotonousOrArrLen(array, predicate);\n  return idx === array.length ? undefined : array[idx];\n}\nfunction findFirstIdxMonotonousOrArrLen(array, predicate, startIdx = 0, endIdxEx = array.length) {\n  let i = startIdx;\n  let j = endIdxEx;\n  while (i < j) {\n    const k = Math.floor((i + j) / 2);\n    if (predicate(array[k])) {\n      j = k;\n    } else {\n      i = k + 1;\n    }\n  }\n  return i;\n}\nclass MonotonousArray {\n  constructor(_array) {\n    this._array = _array;\n    this._findLastMonotonousLastIdx = 0;\n  }\n  static {\n    this.assertInvariants = false;\n  }\n  /**\n   * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n   * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.\n   */\n  findLastMonotonous(predicate) {\n    if (MonotonousArray.assertInvariants) {\n      if (this._prevFindLastPredicate) {\n        for (const item of this._array) {\n          if (this._prevFindLastPredicate(item) && !predicate(item)) {\n            throw new Error(\"MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.\");\n          }\n        }\n      }\n      this._prevFindLastPredicate = predicate;\n    }\n    const idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);\n    this._findLastMonotonousLastIdx = idx + 1;\n    return idx === -1 ? undefined : this._array[idx];\n  }\n}\n\nclass LineRange {\n  static fromRangeInclusive(range) {\n    return new LineRange(range.startLineNumber, range.endLineNumber + 1);\n  }\n  static join(lineRanges) {\n    if (lineRanges.length === 0) {\n      throw new BugIndicatingError(\"lineRanges cannot be empty\");\n    }\n    let startLineNumber = lineRanges[0].startLineNumber;\n    let endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;\n    for (let i = 1; i < lineRanges.length; i++) {\n      startLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);\n      endLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);\n    }\n    return new LineRange(startLineNumber, endLineNumberExclusive);\n  }\n  static ofLength(startLineNumber, length) {\n    return new LineRange(startLineNumber, startLineNumber + length);\n  }\n  constructor(startLineNumber, endLineNumberExclusive) {\n    if (startLineNumber > endLineNumberExclusive) {\n      throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n    }\n    this.startLineNumber = startLineNumber;\n    this.endLineNumberExclusive = endLineNumberExclusive;\n  }\n  /**\n   * Indicates if this line range is empty.\n   */\n  get isEmpty() {\n    return this.startLineNumber === this.endLineNumberExclusive;\n  }\n  /**\n   * Moves this line range by the given offset of line numbers.\n   */\n  delta(offset) {\n    return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n  }\n  /**\n   * The number of lines this line range spans.\n   */\n  get length() {\n    return this.endLineNumberExclusive - this.startLineNumber;\n  }\n  /**\n   * Creates a line range that combines this and the given line range.\n   */\n  join(other) {\n    return new LineRange(\n      Math.min(this.startLineNumber, other.startLineNumber),\n      Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive)\n    );\n  }\n  /**\n   * The resulting range is empty if the ranges do not intersect, but touch.\n   * If the ranges don't even touch, the result is undefined.\n   */\n  intersect(other) {\n    const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n    const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n    if (startLineNumber <= endLineNumberExclusive) {\n      return new LineRange(startLineNumber, endLineNumberExclusive);\n    }\n    return undefined;\n  }\n  overlapOrTouch(other) {\n    return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n  }\n  toInclusiveRange() {\n    if (this.isEmpty) {\n      return null;\n    }\n    return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n  }\n  /**\n   * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n   * @internal\n   */\n  toOffsetRange() {\n    return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n  }\n}\nclass LineRangeSet {\n  constructor(_normalizedRanges = []) {\n    this._normalizedRanges = _normalizedRanges;\n  }\n  get ranges() {\n    return this._normalizedRanges;\n  }\n  addRange(range) {\n    if (range.length === 0) {\n      return;\n    }\n    const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, (r) => r.endLineNumberExclusive >= range.startLineNumber);\n    const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, (r) => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n    if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n      this._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n    } else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n      const joinRange = this._normalizedRanges[joinRangeStartIdx];\n      this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n    } else {\n      const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n      this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n    }\n  }\n  contains(lineNumber) {\n    const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, (r) => r.startLineNumber <= lineNumber);\n    return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n  }\n  /**\n   * Subtracts all ranges in this set from `range` and returns the result.\n   */\n  subtractFrom(range) {\n    const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, (r) => r.endLineNumberExclusive >= range.startLineNumber);\n    const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, (r) => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n    if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n      return new LineRangeSet([range]);\n    }\n    const result = [];\n    let startLineNumber = range.startLineNumber;\n    for (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n      const r = this._normalizedRanges[i];\n      if (r.startLineNumber > startLineNumber) {\n        result.push(new LineRange(startLineNumber, r.startLineNumber));\n      }\n      startLineNumber = r.endLineNumberExclusive;\n    }\n    if (startLineNumber < range.endLineNumberExclusive) {\n      result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n    }\n    return new LineRangeSet(result);\n  }\n  getIntersection(other) {\n    const result = [];\n    let i1 = 0;\n    let i2 = 0;\n    while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n      const r1 = this._normalizedRanges[i1];\n      const r2 = other._normalizedRanges[i2];\n      const i = r1.intersect(r2);\n      if (i && !i.isEmpty) {\n        result.push(i);\n      }\n      if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n        i1++;\n      } else {\n        i2++;\n      }\n    }\n    return new LineRangeSet(result);\n  }\n  getWithDelta(value) {\n    return new LineRangeSet(this._normalizedRanges.map((r) => r.delta(value)));\n  }\n}\n\nclass TextLength {\n  constructor(lineCount, columnCount) {\n    this.lineCount = lineCount;\n    this.columnCount = columnCount;\n  }\n  static {\n    this.zero = new TextLength(0, 0);\n  }\n  toLineRange() {\n    return LineRange.ofLength(1, this.lineCount);\n  }\n  addToPosition(position) {\n    if (this.lineCount === 0) {\n      return new Position(position.lineNumber, position.column + this.columnCount);\n    } else {\n      return new Position(position.lineNumber + this.lineCount, this.columnCount + 1);\n    }\n  }\n}\n\n \nclass LineBasedText  {\n  constructor(_getLineContent, _lineCount) {\n    assert(_lineCount >= 1);\n    this._getLineContent = _getLineContent;\n    this._lineCount = _lineCount;\n  }\n  getValueOfRange(range) {\n    if (range.startLineNumber === range.endLineNumber) {\n      return this._getLineContent(range.startLineNumber).substring(range.startColumn - 1, range.endColumn - 1);\n    }\n    let result = this._getLineContent(range.startLineNumber).substring(range.startColumn - 1);\n    for (let i = range.startLineNumber + 1; i < range.endLineNumber; i++) {\n      result += \"\\n\" + this._getLineContent(i);\n    }\n    result += \"\\n\" + this._getLineContent(range.endLineNumber).substring(0, range.endColumn - 1);\n    return result;\n  }\n  getLineLength(lineNumber) {\n    return this._getLineContent(lineNumber).length;\n  }\n  get length() {\n    const lastLine = this._getLineContent(this._lineCount);\n    return new TextLength(this._lineCount - 1, lastLine.length);\n  }\n}\nclass ArrayText extends LineBasedText {\n  constructor(lines) {\n    super(\n      (lineNumber) => lines[lineNumber - 1],\n      lines.length\n    );\n  }\n}\n\nclass LinesDiff {\n  constructor(changes, moves, hitTimeout) {\n    this.changes = changes;\n    this.moves = moves;\n    this.hitTimeout = hitTimeout;\n  }\n}\nclass MovedText {\n  constructor(lineRangeMapping, changes) {\n    this.lineRangeMapping = lineRangeMapping;\n    this.changes = changes;\n  }\n}\n\nclass LineRangeMapping {\n  constructor(originalRange, modifiedRange) {\n    this.original = originalRange;\n    this.modified = modifiedRange;\n  }\n  join(other) {\n    return new LineRangeMapping(\n      this.original.join(other.original),\n      this.modified.join(other.modified)\n    );\n  }\n  get changedLineCount() {\n    return Math.max(this.original.length, this.modified.length);\n  }\n  /**\n   * This method assumes that the LineRangeMapping describes a valid diff!\n   * I.e. if one range is empty, the other range cannot be the entire document.\n   * It avoids various problems when the line range points to non-existing line-numbers.\n  */\n  toRangeMapping() {\n    const origInclusiveRange = this.original.toInclusiveRange();\n    const modInclusiveRange = this.modified.toInclusiveRange();\n    if (origInclusiveRange && modInclusiveRange) {\n      return new RangeMapping(origInclusiveRange, modInclusiveRange);\n    } else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {\n      if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {\n        throw new BugIndicatingError(\"not a valid diff\");\n      }\n      return new RangeMapping(\n        new Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1),\n        new Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1)\n      );\n    } else {\n      return new RangeMapping(\n        new Range(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER),\n        new Range(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER)\n      );\n    }\n  }\n  /**\n   * This method assumes that the LineRangeMapping describes a valid diff!\n   * I.e. if one range is empty, the other range cannot be the entire document.\n   * It avoids various problems when the line range points to non-existing line-numbers.\n  */\n  toRangeMapping2(original, modified) {\n    if (isValidLineNumber(this.original.endLineNumberExclusive, original) && isValidLineNumber(this.modified.endLineNumberExclusive, modified)) {\n      return new RangeMapping(\n        new Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1),\n        new Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1)\n      );\n    }\n    if (!this.original.isEmpty && !this.modified.isEmpty) {\n      return new RangeMapping(\n        Range.fromPositions(\n          new Position(this.original.startLineNumber, 1),\n          normalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)\n        ),\n        Range.fromPositions(\n          new Position(this.modified.startLineNumber, 1),\n          normalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)\n        )\n      );\n    }\n    if (this.original.startLineNumber > 1 && this.modified.startLineNumber > 1) {\n      return new RangeMapping(\n        Range.fromPositions(\n          normalizePosition(new Position(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER), original),\n          normalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)\n        ),\n        Range.fromPositions(\n          normalizePosition(new Position(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER), modified),\n          normalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)\n        )\n      );\n    }\n    throw new BugIndicatingError();\n  }\n}\nfunction normalizePosition(position, content) {\n  if (position.lineNumber < 1) {\n    return new Position(1, 1);\n  }\n  if (position.lineNumber > content.length) {\n    return new Position(content.length, content[content.length - 1].length + 1);\n  }\n  const line = content[position.lineNumber - 1];\n  if (position.column > line.length + 1) {\n    return new Position(position.lineNumber, line.length + 1);\n  }\n  return position;\n}\nfunction isValidLineNumber(lineNumber, lines) {\n  return lineNumber >= 1 && lineNumber <= lines.length;\n}\nclass DetailedLineRangeMapping extends LineRangeMapping {\n  static fromRangeMappings(rangeMappings) {\n    const originalRange = LineRange.join(rangeMappings.map((r) => LineRange.fromRangeInclusive(r.originalRange)));\n    const modifiedRange = LineRange.join(rangeMappings.map((r) => LineRange.fromRangeInclusive(r.modifiedRange)));\n    return new DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);\n  }\n  constructor(originalRange, modifiedRange, innerChanges) {\n    super(originalRange, modifiedRange);\n    this.innerChanges = innerChanges;\n  }\n  flip() {\n    return new DetailedLineRangeMapping(this.modified, this.original, this.innerChanges?.map((c) => c.flip()));\n  }\n  withInnerChangesFromLineRanges() {\n    return new DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);\n  }\n}\nclass RangeMapping {\n  static join(rangeMappings) {\n    if (rangeMappings.length === 0) {\n      throw new BugIndicatingError(\"Cannot join an empty list of range mappings\");\n    }\n    let result = rangeMappings[0];\n    for (let i = 1; i < rangeMappings.length; i++) {\n      result = result.join(rangeMappings[i]);\n    }\n    return result;\n  }\n  static assertSorted(rangeMappings) {\n    for (let i = 1; i < rangeMappings.length; i++) {\n      const previous = rangeMappings[i - 1];\n      const current = rangeMappings[i];\n      if (!(previous.originalRange.getEndPosition().isBeforeOrEqual(current.originalRange.getStartPosition()) && previous.modifiedRange.getEndPosition().isBeforeOrEqual(current.modifiedRange.getStartPosition()))) {\n        throw new BugIndicatingError(\"Range mappings must be sorted\");\n      }\n    }\n  }\n  constructor(originalRange, modifiedRange) {\n    this.originalRange = originalRange;\n    this.modifiedRange = modifiedRange;\n  }\n  flip() {\n    return new RangeMapping(this.modifiedRange, this.originalRange);\n  }\n  /**\n   * Creates a single text edit that describes the change from the original to the modified text.\n  */\n  join(other) {\n    return new RangeMapping(\n      this.originalRange.plusRange(other.originalRange),\n      this.modifiedRange.plusRange(other.modifiedRange)\n    );\n  }\n}\nfunction lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {\n  const changes = [];\n  for (const g of groupAdjacentBy(\n    alignments.map((a) => getLineRangeMapping(a, originalLines, modifiedLines)),\n    (a1, a2) => a1.original.overlapOrTouch(a2.original) || a1.modified.overlapOrTouch(a2.modified)\n  )) {\n    const first = g[0];\n    const last = g[g.length - 1];\n    changes.push(new DetailedLineRangeMapping(\n      first.original.join(last.original),\n      first.modified.join(last.modified),\n      g.map((a) => a.innerChanges[0])\n    ));\n  }\n  assertFn(() => {\n    if (!dontAssertStartLine && changes.length > 0) {\n      if (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {\n        return false;\n      }\n      if (modifiedLines.length.lineCount - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length.lineCount - changes[changes.length - 1].original.endLineNumberExclusive) {\n        return false;\n      }\n    }\n    return checkAdjacentItems(\n      changes,\n      (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n      m1.original.endLineNumberExclusive < m2.original.startLineNumber && m1.modified.endLineNumberExclusive < m2.modified.startLineNumber\n    );\n  });\n  return changes;\n}\nfunction getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {\n  let lineStartDelta = 0;\n  let lineEndDelta = 0;\n  if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1 && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n    lineEndDelta = -1;\n  }\n  if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines.getLineLength(rangeMapping.modifiedRange.startLineNumber) && rangeMapping.originalRange.startColumn - 1 >= originalLines.getLineLength(rangeMapping.originalRange.startLineNumber) && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n    lineStartDelta = 1;\n  }\n  const originalLineRange = new LineRange(\n    rangeMapping.originalRange.startLineNumber + lineStartDelta,\n    rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta\n  );\n  const modifiedLineRange = new LineRange(\n    rangeMapping.modifiedRange.startLineNumber + lineStartDelta,\n    rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta\n  );\n  return new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\n\nclass DiffAlgorithmResult {\n  constructor(diffs, hitTimeout) {\n    this.diffs = diffs;\n    this.hitTimeout = hitTimeout;\n  }\n  static trivial(seq1, seq2) {\n    return new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], false);\n  }\n  static trivialTimedOut(seq1, seq2) {\n    return new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], true);\n  }\n}\nclass SequenceDiff {\n  constructor(seq1Range, seq2Range) {\n    this.seq1Range = seq1Range;\n    this.seq2Range = seq2Range;\n  }\n  static invert(sequenceDiffs, doc1Length) {\n    const result = [];\n    forEachAdjacent(sequenceDiffs, (a, b) => {\n      result.push(SequenceDiff.fromOffsetPairs(\n        a ? a.getEndExclusives() : OffsetPair.zero,\n        b ? b.getStarts() : new OffsetPair(doc1Length, (a ? a.seq2Range.endExclusive - a.seq1Range.endExclusive : 0) + doc1Length)\n      ));\n    });\n    return result;\n  }\n  static fromOffsetPairs(start, endExclusive) {\n    return new SequenceDiff(\n      new OffsetRange(start.offset1, endExclusive.offset1),\n      new OffsetRange(start.offset2, endExclusive.offset2)\n    );\n  }\n  static assertSorted(sequenceDiffs) {\n    let last = undefined;\n    for (const cur of sequenceDiffs) {\n      if (last) {\n        if (!(last.seq1Range.endExclusive <= cur.seq1Range.start && last.seq2Range.endExclusive <= cur.seq2Range.start)) {\n          throw new BugIndicatingError(\"Sequence diffs must be sorted\");\n        }\n      }\n      last = cur;\n    }\n  }\n  swap() {\n    return new SequenceDiff(this.seq2Range, this.seq1Range);\n  }\n  join(other) {\n    return new SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));\n  }\n  delta(offset) {\n    if (offset === 0) {\n      return this;\n    }\n    return new SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));\n  }\n  deltaStart(offset) {\n    if (offset === 0) {\n      return this;\n    }\n    return new SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));\n  }\n  deltaEnd(offset) {\n    if (offset === 0) {\n      return this;\n    }\n    return new SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));\n  }\n  intersect(other) {\n    const i1 = this.seq1Range.intersect(other.seq1Range);\n    const i2 = this.seq2Range.intersect(other.seq2Range);\n    if (!i1 || !i2) {\n      return undefined;\n    }\n    return new SequenceDiff(i1, i2);\n  }\n  getStarts() {\n    return new OffsetPair(this.seq1Range.start, this.seq2Range.start);\n  }\n  getEndExclusives() {\n    return new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);\n  }\n}\nclass OffsetPair {\n  constructor(offset1, offset2) {\n    this.offset1 = offset1;\n    this.offset2 = offset2;\n  }\n  static {\n    this.zero = new OffsetPair(0, 0);\n  }\n  static {\n    this.max = new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\n  }\n  delta(offset) {\n    if (offset === 0) {\n      return this;\n    }\n    return new OffsetPair(this.offset1 + offset, this.offset2 + offset);\n  }\n  equals(other) {\n    return this.offset1 === other.offset1 && this.offset2 === other.offset2;\n  }\n}\nclass InfiniteTimeout {\n  static {\n    this.instance = new InfiniteTimeout();\n  }\n  isValid() {\n    return true;\n  }\n}\nclass DateTimeout {\n  constructor(timeout) {\n    this.timeout = timeout;\n    this.startTime = Date.now();\n    this.valid = true;\n    if (timeout <= 0) {\n      throw new BugIndicatingError(\"timeout must be positive\");\n    }\n  }\n  // Recommendation: Set a log-point `{this.disable()}` in the body\n  isValid() {\n    const valid = Date.now() - this.startTime < this.timeout;\n    if (!valid && this.valid) {\n      this.valid = false;\n    }\n    return this.valid;\n  }\n  disable() {\n    this.timeout = Number.MAX_SAFE_INTEGER;\n    this.isValid = () => true;\n    this.valid = true;\n  }\n}\n\nclass Array2D {\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n    this.array = [];\n    this.array = new Array(width * height);\n  }\n  get(x, y) {\n    return this.array[x + y * this.width];\n  }\n  set(x, y, value) {\n    this.array[x + y * this.width] = value;\n  }\n}\nfunction isSpace(charCode) {\n  return charCode === 32 || charCode === 9;\n}\nclass LineRangeFragment {\n  constructor(range, lines, source) {\n    this.range = range;\n    this.lines = lines;\n    this.source = source;\n    this.histogram = [];\n    let counter = 0;\n    for (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {\n      const line = lines[i];\n      for (let j = 0; j < line.length; j++) {\n        counter++;\n        const chr = line[j];\n        const key2 = LineRangeFragment.getKey(chr);\n        this.histogram[key2] = (this.histogram[key2] || 0) + 1;\n      }\n      counter++;\n      const key = LineRangeFragment.getKey(\"\\n\");\n      this.histogram[key] = (this.histogram[key] || 0) + 1;\n    }\n    this.totalCount = counter;\n  }\n  static {\n    this.chrKeys = /* @__PURE__ */ new Map();\n  }\n  static getKey(chr) {\n    let key = this.chrKeys.get(chr);\n    if (key === undefined) {\n      key = this.chrKeys.size;\n      this.chrKeys.set(chr, key);\n    }\n    return key;\n  }\n  computeSimilarity(other) {\n    let sumDifferences = 0;\n    const maxLength = Math.max(this.histogram.length, other.histogram.length);\n    for (let i = 0; i < maxLength; i++) {\n      sumDifferences += Math.abs((this.histogram[i] ?? 0) - (other.histogram[i] ?? 0));\n    }\n    return 1 - sumDifferences / (this.totalCount + other.totalCount);\n  }\n}\n\nclass DynamicProgrammingDiffing {\n  compute(sequence1, sequence2, timeout = InfiniteTimeout.instance, equalityScore) {\n    if (sequence1.length === 0 || sequence2.length === 0) {\n      return DiffAlgorithmResult.trivial(sequence1, sequence2);\n    }\n    const lcsLengths = new Array2D(sequence1.length, sequence2.length);\n    const directions = new Array2D(sequence1.length, sequence2.length);\n    const lengths = new Array2D(sequence1.length, sequence2.length);\n    for (let s12 = 0; s12 < sequence1.length; s12++) {\n      for (let s22 = 0; s22 < sequence2.length; s22++) {\n        if (!timeout.isValid()) {\n          return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n        }\n        const horizontalLen = s12 === 0 ? 0 : lcsLengths.get(s12 - 1, s22);\n        const verticalLen = s22 === 0 ? 0 : lcsLengths.get(s12, s22 - 1);\n        let extendedSeqScore;\n        if (sequence1.getElement(s12) === sequence2.getElement(s22)) {\n          if (s12 === 0 || s22 === 0) {\n            extendedSeqScore = 0;\n          } else {\n            extendedSeqScore = lcsLengths.get(s12 - 1, s22 - 1);\n          }\n          if (s12 > 0 && s22 > 0 && directions.get(s12 - 1, s22 - 1) === 3) {\n            extendedSeqScore += lengths.get(s12 - 1, s22 - 1);\n          }\n          extendedSeqScore += equalityScore ? equalityScore(s12, s22) : 1;\n        } else {\n          extendedSeqScore = -1;\n        }\n        const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n        if (newValue === extendedSeqScore) {\n          const prevLen = s12 > 0 && s22 > 0 ? lengths.get(s12 - 1, s22 - 1) : 0;\n          lengths.set(s12, s22, prevLen + 1);\n          directions.set(s12, s22, 3);\n        } else if (newValue === horizontalLen) {\n          lengths.set(s12, s22, 0);\n          directions.set(s12, s22, 1);\n        } else if (newValue === verticalLen) {\n          lengths.set(s12, s22, 0);\n          directions.set(s12, s22, 2);\n        }\n        lcsLengths.set(s12, s22, newValue);\n      }\n    }\n    const result = [];\n    let lastAligningPosS1 = sequence1.length;\n    let lastAligningPosS2 = sequence2.length;\n    function reportDecreasingAligningPositions(s12, s22) {\n      if (s12 + 1 !== lastAligningPosS1 || s22 + 1 !== lastAligningPosS2) {\n        result.push(new SequenceDiff(\n          new OffsetRange(s12 + 1, lastAligningPosS1),\n          new OffsetRange(s22 + 1, lastAligningPosS2)\n        ));\n      }\n      lastAligningPosS1 = s12;\n      lastAligningPosS2 = s22;\n    }\n    let s1 = sequence1.length - 1;\n    let s2 = sequence2.length - 1;\n    while (s1 >= 0 && s2 >= 0) {\n      if (directions.get(s1, s2) === 3) {\n        reportDecreasingAligningPositions(s1, s2);\n        s1--;\n        s2--;\n      } else {\n        if (directions.get(s1, s2) === 1) {\n          s1--;\n        } else {\n          s2--;\n        }\n      }\n    }\n    reportDecreasingAligningPositions(-1, -1);\n    result.reverse();\n    return new DiffAlgorithmResult(result, false);\n  }\n}\n\nclass MyersDiffAlgorithm {\n  compute(seq1, seq2, timeout = InfiniteTimeout.instance) {\n    if (seq1.length === 0 || seq2.length === 0) {\n      return DiffAlgorithmResult.trivial(seq1, seq2);\n    }\n    const seqX = seq1;\n    const seqY = seq2;\n    function getXAfterSnake(x, y) {\n      while (x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y)) {\n        x++;\n        y++;\n      }\n      return x;\n    }\n    let d = 0;\n    const V = new FastInt32Array();\n    V.set(0, getXAfterSnake(0, 0));\n    const paths = new FastArrayNegativeIndices();\n    paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n    let k = 0;\n    loop: while (true) {\n      d++;\n      if (!timeout.isValid()) {\n        return DiffAlgorithmResult.trivialTimedOut(seqX, seqY);\n      }\n      const lowerBound = -Math.min(d, seqY.length + d % 2);\n      const upperBound = Math.min(d, seqX.length + d % 2);\n      for (k = lowerBound; k <= upperBound; k += 2) {\n        const maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1);\n        const maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1;\n        const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);\n        const y = x - k;\n        if (x > seqX.length || y > seqY.length) {\n          continue;\n        }\n        const newMaxX = getXAfterSnake(x, y);\n        V.set(k, newMaxX);\n        const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n        paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n        if (V.get(k) === seqX.length && V.get(k) - k === seqY.length) {\n          break loop;\n        }\n      }\n    }\n    let path = paths.get(k);\n    const result = [];\n    let lastAligningPosS1 = seqX.length;\n    let lastAligningPosS2 = seqY.length;\n    while (true) {\n      const endX = path ? path.x + path.length : 0;\n      const endY = path ? path.y + path.length : 0;\n      if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n        result.push(new SequenceDiff(\n          new OffsetRange(endX, lastAligningPosS1),\n          new OffsetRange(endY, lastAligningPosS2)\n        ));\n      }\n      if (!path) {\n        break;\n      }\n      lastAligningPosS1 = path.x;\n      lastAligningPosS2 = path.y;\n      path = path.prev;\n    }\n    result.reverse();\n    return new DiffAlgorithmResult(result, false);\n  }\n}\nclass SnakePath {\n  constructor(prev, x, y, length) {\n    this.prev = prev;\n    this.x = x;\n    this.y = y;\n    this.length = length;\n  }\n}\nclass FastInt32Array {\n  constructor() {\n    this.positiveArr = new Int32Array(10);\n    this.negativeArr = new Int32Array(10);\n  }\n  get(idx) {\n    if (idx < 0) {\n      idx = -idx - 1;\n      return this.negativeArr[idx];\n    } else {\n      return this.positiveArr[idx];\n    }\n  }\n  set(idx, value) {\n    if (idx < 0) {\n      idx = -idx - 1;\n      if (idx >= this.negativeArr.length) {\n        const arr = this.negativeArr;\n        this.negativeArr = new Int32Array(arr.length * 2);\n        this.negativeArr.set(arr);\n      }\n      this.negativeArr[idx] = value;\n    } else {\n      if (idx >= this.positiveArr.length) {\n        const arr = this.positiveArr;\n        this.positiveArr = new Int32Array(arr.length * 2);\n        this.positiveArr.set(arr);\n      }\n      this.positiveArr[idx] = value;\n    }\n  }\n}\nclass FastArrayNegativeIndices {\n  constructor() {\n    this.positiveArr = [];\n    this.negativeArr = [];\n  }\n  get(idx) {\n    if (idx < 0) {\n      idx = -idx - 1;\n      return this.negativeArr[idx];\n    } else {\n      return this.positiveArr[idx];\n    }\n  }\n  set(idx, value) {\n    if (idx < 0) {\n      idx = -idx - 1;\n      this.negativeArr[idx] = value;\n    } else {\n      this.positiveArr[idx] = value;\n    }\n  }\n}\n\nclass SetMap {\n  constructor() {\n    this.map = /* @__PURE__ */ new Map();\n  }\n  add(key, value) {\n    let values = this.map.get(key);\n    if (!values) {\n      values = /* @__PURE__ */ new Set();\n      this.map.set(key, values);\n    }\n    values.add(value);\n  }\n  forEach(key, fn) {\n    const values = this.map.get(key);\n    if (!values) {\n      return;\n    }\n    values.forEach(fn);\n  }\n  get(key) {\n    const values = this.map.get(key);\n    if (!values) {\n      return /* @__PURE__ */ new Set();\n    }\n    return values;\n  }\n}\n\nclass LinesSliceCharSequence {\n  constructor(lines, range, considerWhitespaceChanges) {\n    this.lines = lines;\n    this.range = range;\n    this.considerWhitespaceChanges = considerWhitespaceChanges;\n    this.elements = [];\n    this.firstElementOffsetByLineIdx = [];\n    this.lineStartOffsets = [];\n    this.trimmedWsLengthsByLineIdx = [];\n    this.firstElementOffsetByLineIdx.push(0);\n    for (let lineNumber = this.range.startLineNumber; lineNumber <= this.range.endLineNumber; lineNumber++) {\n      let line = lines[lineNumber - 1];\n      let lineStartOffset = 0;\n      if (lineNumber === this.range.startLineNumber && this.range.startColumn > 1) {\n        lineStartOffset = this.range.startColumn - 1;\n        line = line.substring(lineStartOffset);\n      }\n      this.lineStartOffsets.push(lineStartOffset);\n      let trimmedWsLength = 0;\n      if (!considerWhitespaceChanges) {\n        const trimmedStartLine = line.trimStart();\n        trimmedWsLength = line.length - trimmedStartLine.length;\n        line = trimmedStartLine.trimEnd();\n      }\n      this.trimmedWsLengthsByLineIdx.push(trimmedWsLength);\n      const lineLength = lineNumber === this.range.endLineNumber ? Math.min(this.range.endColumn - 1 - lineStartOffset - trimmedWsLength, line.length) : line.length;\n      for (let i = 0; i < lineLength; i++) {\n        this.elements.push(line.charCodeAt(i));\n      }\n      if (lineNumber < this.range.endLineNumber) {\n        this.elements.push(\"\\n\".charCodeAt(0));\n        this.firstElementOffsetByLineIdx.push(this.elements.length);\n      }\n    }\n  }\n  toString() {\n    return `Slice: \"${this.text}\"`;\n  }\n  get text() {\n    return this.getText(new OffsetRange(0, this.length));\n  }\n  getText(range) {\n    return this.elements.slice(range.start, range.endExclusive).map((e) => String.fromCharCode(e)).join(\"\");\n  }\n  getElement(offset) {\n    return this.elements[offset];\n  }\n  get length() {\n    return this.elements.length;\n  }\n  getBoundaryScore(length) {\n    const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n    const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n    if (prevCategory === 7 /* LineBreakCR */ && nextCategory === 8 /* LineBreakLF */) {\n      return 0;\n    }\n    if (prevCategory === 8 /* LineBreakLF */) {\n      return 150;\n    }\n    let score2 = 0;\n    if (prevCategory !== nextCategory) {\n      score2 += 10;\n      if (prevCategory === 0 /* WordLower */ && nextCategory === 1 /* WordUpper */) {\n        score2 += 1;\n      }\n    }\n    score2 += getCategoryBoundaryScore(prevCategory);\n    score2 += getCategoryBoundaryScore(nextCategory);\n    return score2;\n  }\n  translateOffset(offset, preference = \"right\") {\n    const i = findLastIdxMonotonous(this.firstElementOffsetByLineIdx, (value) => value <= offset);\n    const lineOffset = offset - this.firstElementOffsetByLineIdx[i];\n    return new Position(\n      this.range.startLineNumber + i,\n      1 + this.lineStartOffsets[i] + lineOffset + (lineOffset === 0 && preference === \"left\" ? 0 : this.trimmedWsLengthsByLineIdx[i])\n    );\n  }\n  translateRange(range) {\n    const pos1 = this.translateOffset(range.start, \"right\");\n    const pos2 = this.translateOffset(range.endExclusive, \"left\");\n    if (pos2.isBefore(pos1)) {\n      return Range.fromPositions(pos2, pos2);\n    }\n    return Range.fromPositions(pos1, pos2);\n  }\n  /**\n   * Finds the word that contains the character at the given offset\n   */\n  findWordContaining(offset) {\n    if (offset < 0 || offset >= this.elements.length) {\n      return undefined;\n    }\n    if (!isWordChar(this.elements[offset])) {\n      return undefined;\n    }\n    let start = offset;\n    while (start > 0 && isWordChar(this.elements[start - 1])) {\n      start--;\n    }\n    let end = offset;\n    while (end < this.elements.length && isWordChar(this.elements[end])) {\n      end++;\n    }\n    return new OffsetRange(start, end);\n  }\n  /** fooBar has the two sub-words foo and bar */\n  findSubWordContaining(offset) {\n    if (offset < 0 || offset >= this.elements.length) {\n      return undefined;\n    }\n    if (!isWordChar(this.elements[offset])) {\n      return undefined;\n    }\n    let start = offset;\n    while (start > 0 && isWordChar(this.elements[start - 1]) && !isUpperCase(this.elements[start])) {\n      start--;\n    }\n    let end = offset;\n    while (end < this.elements.length && isWordChar(this.elements[end]) && !isUpperCase(this.elements[end])) {\n      end++;\n    }\n    return new OffsetRange(start, end);\n  }\n  countLinesIn(range) {\n    return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n  }\n  isStronglyEqual(offset1, offset2) {\n    return this.elements[offset1] === this.elements[offset2];\n  }\n  extendToFullLines(range) {\n    const start = findLastMonotonous(this.firstElementOffsetByLineIdx, (x) => x <= range.start) ?? 0;\n    const end = findFirstMonotonous(this.firstElementOffsetByLineIdx, (x) => range.endExclusive <= x) ?? this.elements.length;\n    return new OffsetRange(start, end);\n  }\n}\nfunction isWordChar(charCode) {\n  return charCode >= 97 && charCode <= 122 || charCode >= 65 && charCode <= 90 || charCode >= 48 && charCode <= 57;\n}\nfunction isUpperCase(charCode) {\n  return charCode >= 65 && charCode <= 90;\n}\nconst score = {\n  [0 /* WordLower */]: 0,\n  [1 /* WordUpper */]: 0,\n  [2 /* WordNumber */]: 0,\n  [3 /* End */]: 10,\n  [4 /* Other */]: 2,\n  [5 /* Separator */]: 30,\n  [6 /* Space */]: 3,\n  [7 /* LineBreakCR */]: 10,\n  [8 /* LineBreakLF */]: 10\n};\nfunction getCategoryBoundaryScore(category) {\n  return score[category];\n}\nfunction getCategory(charCode) {\n  if (charCode === 10) {\n    return 8 /* LineBreakLF */;\n  } else if (charCode === 13) {\n    return 7 /* LineBreakCR */;\n  } else if (isSpace(charCode)) {\n    return 6 /* Space */;\n  } else if (charCode >= 97 && charCode <= 122) {\n    return 0 /* WordLower */;\n  } else if (charCode >= 65 && charCode <= 90) {\n    return 1 /* WordUpper */;\n  } else if (charCode >= 48 && charCode <= 57) {\n    return 2 /* WordNumber */;\n  } else if (charCode === -1) {\n    return 3 /* End */;\n  } else if (charCode === 44 || charCode === 59) {\n    return 5 /* Separator */;\n  } else {\n    return 4 /* Other */;\n  }\n}\n\nfunction computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {\n  let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);\n  if (!timeout.isValid()) {\n    return [];\n  }\n  const filteredChanges = changes.filter((c) => !excludedChanges.has(c));\n  const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);\n  pushMany(moves, unchangedMoves);\n  moves = joinCloseConsecutiveMoves(moves);\n  moves = moves.filter((current) => {\n    const lines = current.original.toOffsetRange().slice(originalLines).map((l) => l.trim());\n    const originalText = lines.join(\"\\n\");\n    return originalText.length >= 15 && countWhere(lines, (l) => l.length >= 2) >= 2;\n  });\n  moves = removeMovesInSameDiff(changes, moves);\n  return moves;\n}\nfunction countWhere(arr, predicate) {\n  let count = 0;\n  for (const t of arr) {\n    if (predicate(t)) {\n      count++;\n    }\n  }\n  return count;\n}\nfunction computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {\n  const moves = [];\n  const deletions = changes.filter((c) => c.modified.isEmpty && c.original.length >= 3).map((d) => new LineRangeFragment(d.original, originalLines, d));\n  const insertions = new Set(changes.filter((c) => c.original.isEmpty && c.modified.length >= 3).map((d) => new LineRangeFragment(d.modified, modifiedLines, d)));\n  const excludedChanges = /* @__PURE__ */ new Set();\n  for (const deletion of deletions) {\n    let highestSimilarity = -1;\n    let best;\n    for (const insertion of insertions) {\n      const similarity = deletion.computeSimilarity(insertion);\n      if (similarity > highestSimilarity) {\n        highestSimilarity = similarity;\n        best = insertion;\n      }\n    }\n    if (highestSimilarity > 0.9 && best) {\n      insertions.delete(best);\n      moves.push(new LineRangeMapping(deletion.range, best.range));\n      excludedChanges.add(deletion.source);\n      excludedChanges.add(best.source);\n    }\n    if (!timeout.isValid()) {\n      return { moves, excludedChanges };\n    }\n  }\n  return { moves, excludedChanges };\n}\nfunction computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {\n  const moves = [];\n  const original3LineHashes = new SetMap();\n  for (const change of changes) {\n    for (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {\n      const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;\n      original3LineHashes.add(key, { range: new LineRange(i, i + 3) });\n    }\n  }\n  const possibleMappings = [];\n  changes.sort(compareBy((c) => c.modified.startLineNumber, numberComparator));\n  for (const change of changes) {\n    let lastMappings = [];\n    for (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {\n      const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;\n      const currentModifiedRange = new LineRange(i, i + 3);\n      const nextMappings = [];\n      original3LineHashes.forEach(key, ({ range }) => {\n        for (const lastMapping of lastMappings) {\n          if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive && lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {\n            lastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);\n            lastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);\n            nextMappings.push(lastMapping);\n            return;\n          }\n        }\n        const mapping = {\n          modifiedLineRange: currentModifiedRange,\n          originalLineRange: range\n        };\n        possibleMappings.push(mapping);\n        nextMappings.push(mapping);\n      });\n      lastMappings = nextMappings;\n    }\n    if (!timeout.isValid()) {\n      return [];\n    }\n  }\n  possibleMappings.sort(reverseOrder(compareBy((m) => m.modifiedLineRange.length, numberComparator)));\n  const modifiedSet = new LineRangeSet();\n  const originalSet = new LineRangeSet();\n  for (const mapping of possibleMappings) {\n    const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;\n    const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);\n    const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);\n    const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);\n    for (const s of modifiedIntersectedSections.ranges) {\n      if (s.length < 3) {\n        continue;\n      }\n      const modifiedLineRange = s;\n      const originalLineRange = s.delta(-diffOrigToMod);\n      moves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));\n      modifiedSet.addRange(modifiedLineRange);\n      originalSet.addRange(originalLineRange);\n    }\n  }\n  moves.sort(compareBy((m) => m.original.startLineNumber, numberComparator));\n  const monotonousChanges = new MonotonousArray(changes);\n  for (let i = 0; i < moves.length; i++) {\n    const move = moves[i];\n    const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous((c) => c.original.startLineNumber <= move.original.startLineNumber);\n    const firstTouchingChangeMod = findLastMonotonous(changes, (c) => c.modified.startLineNumber <= move.modified.startLineNumber);\n    const linesAbove = Math.max(\n      move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber,\n      move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber\n    );\n    const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous((c) => c.original.startLineNumber < move.original.endLineNumberExclusive);\n    const lastTouchingChangeMod = findLastMonotonous(changes, (c) => c.modified.startLineNumber < move.modified.endLineNumberExclusive);\n    const linesBelow = Math.max(\n      lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive,\n      lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive\n    );\n    let extendToTop;\n    for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {\n      const origLine = move.original.startLineNumber - extendToTop - 1;\n      const modLine = move.modified.startLineNumber - extendToTop - 1;\n      if (origLine > originalLines.length || modLine > modifiedLines.length) {\n        break;\n      }\n      if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n        break;\n      }\n      if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n        break;\n      }\n    }\n    if (extendToTop > 0) {\n      originalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));\n      modifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));\n    }\n    let extendToBottom;\n    for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {\n      const origLine = move.original.endLineNumberExclusive + extendToBottom;\n      const modLine = move.modified.endLineNumberExclusive + extendToBottom;\n      if (origLine > originalLines.length || modLine > modifiedLines.length) {\n        break;\n      }\n      if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n        break;\n      }\n      if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n        break;\n      }\n    }\n    if (extendToBottom > 0) {\n      originalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));\n      modifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));\n    }\n    if (extendToTop > 0 || extendToBottom > 0) {\n      moves[i] = new LineRangeMapping(\n        new LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom),\n        new LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom)\n      );\n    }\n  }\n  return moves;\n}\nfunction areLinesSimilar(line1, line2, timeout) {\n  if (line1.trim() === line2.trim()) {\n    return true;\n  }\n  if (line1.length > 300 && line2.length > 300) {\n    return false;\n  }\n  const myersDiffingAlgorithm = new MyersDiffAlgorithm();\n  const result = myersDiffingAlgorithm.compute(\n    new LinesSliceCharSequence([line1], new Range(1, 1, 1, line1.length), false),\n    new LinesSliceCharSequence([line2], new Range(1, 1, 1, line2.length), false),\n    timeout\n  );\n  let commonNonSpaceCharCount = 0;\n  const inverted = SequenceDiff.invert(result.diffs, line1.length);\n  for (const seq of inverted) {\n    seq.seq1Range.forEach((idx) => {\n      if (!isSpace(line1.charCodeAt(idx))) {\n        commonNonSpaceCharCount++;\n      }\n    });\n  }\n  function countNonWsChars(str) {\n    let count = 0;\n    for (let i = 0; i < line1.length; i++) {\n      if (!isSpace(str.charCodeAt(i))) {\n        count++;\n      }\n    }\n    return count;\n  }\n  const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);\n  const r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;\n  return r;\n}\nfunction joinCloseConsecutiveMoves(moves) {\n  if (moves.length === 0) {\n    return moves;\n  }\n  moves.sort(compareBy((m) => m.original.startLineNumber, numberComparator));\n  const result = [moves[0]];\n  for (let i = 1; i < moves.length; i++) {\n    const last = result[result.length - 1];\n    const current = moves[i];\n    const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;\n    const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;\n    const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;\n    if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {\n      result[result.length - 1] = last.join(current);\n      continue;\n    }\n    result.push(current);\n  }\n  return result;\n}\nfunction removeMovesInSameDiff(changes, moves) {\n  const changesMonotonous = new MonotonousArray(changes);\n  moves = moves.filter((m) => {\n    const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous((c) => c.original.startLineNumber < m.original.endLineNumberExclusive) || new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));\n    const diffBeforeEndOfMoveModified = findLastMonotonous(changes, (c) => c.modified.startLineNumber < m.modified.endLineNumberExclusive);\n    const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;\n    return differentDiffs;\n  });\n  return moves;\n}\n\nfunction optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n  let result = sequenceDiffs;\n  result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n  result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n  result = shiftSequenceDiffs(sequence1, sequence2, result);\n  return result;\n}\nfunction joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {\n  if (sequenceDiffs.length === 0) {\n    return sequenceDiffs;\n  }\n  const result = [];\n  result.push(sequenceDiffs[0]);\n  for (let i = 1; i < sequenceDiffs.length; i++) {\n    const prevResult = result[result.length - 1];\n    let cur = sequenceDiffs[i];\n    if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n      const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n      let d;\n      for (d = 1; d <= length; d++) {\n        if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) || sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n          break;\n        }\n      }\n      d--;\n      if (d === length) {\n        result[result.length - 1] = new SequenceDiff(\n          new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length),\n          new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length)\n        );\n        continue;\n      }\n      cur = cur.delta(-d);\n    }\n    result.push(cur);\n  }\n  const result2 = [];\n  for (let i = 0; i < result.length - 1; i++) {\n    const nextResult = result[i + 1];\n    let cur = result[i];\n    if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n      const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\n      let d;\n      for (d = 0; d < length; d++) {\n        if (!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) || !sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)) {\n          break;\n        }\n      }\n      if (d === length) {\n        result[i + 1] = new SequenceDiff(\n          new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive),\n          new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive)\n        );\n        continue;\n      }\n      if (d > 0) {\n        cur = cur.delta(d);\n      }\n    }\n    result2.push(cur);\n  }\n  if (result.length > 0) {\n    result2.push(result[result.length - 1]);\n  }\n  return result2;\n}\nfunction shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n  if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n    return sequenceDiffs;\n  }\n  for (let i = 0; i < sequenceDiffs.length; i++) {\n    const prevDiff = i > 0 ? sequenceDiffs[i - 1] : undefined;\n    const diff = sequenceDiffs[i];\n    const nextDiff = i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined;\n    const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length);\n    const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length);\n    if (diff.seq1Range.isEmpty) {\n      sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n    } else if (diff.seq2Range.isEmpty) {\n      sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();\n    }\n  }\n  return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {\n  const maxShiftLimit = 100;\n  let deltaBefore = 1;\n  while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start && diff.seq2Range.start - deltaBefore >= seq2ValidRange.start && sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n    deltaBefore++;\n  }\n  deltaBefore--;\n  let deltaAfter = 0;\n  while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive && diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive && sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n    deltaAfter++;\n  }\n  if (deltaBefore === 0 && deltaAfter === 0) {\n    return diff;\n  }\n  let bestDelta = 0;\n  let bestScore = -1;\n  for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n    const seq2OffsetStart = diff.seq2Range.start + delta;\n    const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n    const seq1Offset = diff.seq1Range.start + delta;\n    const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n    if (score > bestScore) {\n      bestScore = score;\n      bestDelta = delta;\n    }\n  }\n  return diff.delta(bestDelta);\n}\nfunction removeShortMatches(sequence1, sequence2, sequenceDiffs) {\n  const result = [];\n  for (const s of sequenceDiffs) {\n    const last = result[result.length - 1];\n    if (!last) {\n      result.push(s);\n      continue;\n    }\n    if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n      result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n    } else {\n      result.push(s);\n    }\n  }\n  return result;\n}\nfunction extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs, findParent, force = false) {\n  const equalMappings = SequenceDiff.invert(sequenceDiffs, sequence1.length);\n  const additional = [];\n  let lastPoint = new OffsetPair(0, 0);\n  function scanWord(pair, equalMapping) {\n    if (pair.offset1 < lastPoint.offset1 || pair.offset2 < lastPoint.offset2) {\n      return;\n    }\n    const w1 = findParent(sequence1, pair.offset1);\n    const w2 = findParent(sequence2, pair.offset2);\n    if (!w1 || !w2) {\n      return;\n    }\n    let w = new SequenceDiff(w1, w2);\n    const equalPart = w.intersect(equalMapping);\n    let equalChars1 = equalPart.seq1Range.length;\n    let equalChars2 = equalPart.seq2Range.length;\n    while (equalMappings.length > 0) {\n      const next = equalMappings[0];\n      const intersects = next.seq1Range.intersects(w.seq1Range) || next.seq2Range.intersects(w.seq2Range);\n      if (!intersects) {\n        break;\n      }\n      const v1 = findParent(sequence1, next.seq1Range.start);\n      const v2 = findParent(sequence2, next.seq2Range.start);\n      const v = new SequenceDiff(v1, v2);\n      const equalPart2 = v.intersect(next);\n      equalChars1 += equalPart2.seq1Range.length;\n      equalChars2 += equalPart2.seq2Range.length;\n      w = w.join(v);\n      if (w.seq1Range.endExclusive >= next.seq1Range.endExclusive) {\n        equalMappings.shift();\n      } else {\n        break;\n      }\n    }\n    if (force && equalChars1 + equalChars2 < w.seq1Range.length + w.seq2Range.length || equalChars1 + equalChars2 < (w.seq1Range.length + w.seq2Range.length) * 2 / 3) {\n      additional.push(w);\n    }\n    lastPoint = w.getEndExclusives();\n  }\n  while (equalMappings.length > 0) {\n    const next = equalMappings.shift();\n    if (next.seq1Range.isEmpty) {\n      continue;\n    }\n    scanWord(next.getStarts(), next);\n    scanWord(next.getEndExclusives().delta(-1), next);\n  }\n  const merged = mergeSequenceDiffs(sequenceDiffs, additional);\n  return merged;\n}\nfunction mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {\n  const result = [];\n  while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n    const sd1 = sequenceDiffs1[0];\n    const sd2 = sequenceDiffs2[0];\n    let next;\n    if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n      next = sequenceDiffs1.shift();\n    } else {\n      next = sequenceDiffs2.shift();\n    }\n    if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n      result[result.length - 1] = result[result.length - 1].join(next);\n    } else {\n      result.push(next);\n    }\n  }\n  return result;\n}\nfunction removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {\n  let diffs = sequenceDiffs;\n  if (diffs.length === 0) {\n    return diffs;\n  }\n  let counter = 0;\n  let shouldRepeat;\n  do {\n    shouldRepeat = false;\n    const result = [\n      diffs[0]\n    ];\n    for (let i = 1; i < diffs.length; i++) {\n      let shouldJoinDiffs = function(before, after) {\n        const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n        const unchangedText = sequence1.getText(unchangedRange);\n        const unchangedTextWithoutWs = unchangedText.replace(/\\s/g, \"\");\n        if (unchangedTextWithoutWs.length <= 4 && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {\n          return true;\n        }\n        return false;\n      };\n      const cur = diffs[i];\n      const lastResult = result[result.length - 1];\n      const shouldJoin = shouldJoinDiffs(lastResult, cur);\n      if (shouldJoin) {\n        shouldRepeat = true;\n        result[result.length - 1] = result[result.length - 1].join(cur);\n      } else {\n        result.push(cur);\n      }\n    }\n    diffs = result;\n  } while (counter++ < 10 && shouldRepeat);\n  return diffs;\n}\nfunction removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {\n  let diffs = sequenceDiffs;\n  if (diffs.length === 0) {\n    return diffs;\n  }\n  let counter = 0;\n  let shouldRepeat;\n  do {\n    shouldRepeat = false;\n    const result = [\n      diffs[0]\n    ];\n    for (let i = 1; i < diffs.length; i++) {\n      let shouldJoinDiffs = function(before, after) {\n        const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n        const unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n        if (unchangedLineCount > 5 || unchangedRange.length > 500) {\n          return false;\n        }\n        const unchangedText = sequence1.getText(unchangedRange).trim();\n        if (unchangedText.length > 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length > 1) {\n          return false;\n        }\n        const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n        const beforeSeq1Length = before.seq1Range.length;\n        const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n        const beforeSeq2Length = before.seq2Range.length;\n        const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n        const afterSeq1Length = after.seq1Range.length;\n        const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n        const afterSeq2Length = after.seq2Range.length;\n        const max = 2 * 40 + 50;\n        function cap(v) {\n          return Math.min(v, max);\n        }\n        if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5) + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > (max ** 1.5) ** 1.5 * 1.3) {\n          return true;\n        }\n        return false;\n      };\n      const cur = diffs[i];\n      const lastResult = result[result.length - 1];\n      const shouldJoin = shouldJoinDiffs(lastResult, cur);\n      if (shouldJoin) {\n        shouldRepeat = true;\n        result[result.length - 1] = result[result.length - 1].join(cur);\n      } else {\n        result.push(cur);\n      }\n    }\n    diffs = result;\n  } while (counter++ < 10 && shouldRepeat);\n  const newDiffs = [];\n  forEachWithNeighbors(diffs, (prev, cur, next) => {\n    let newDiff = cur;\n    function shouldMarkAsChanged(text) {\n      return text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;\n    }\n    const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);\n    const prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));\n    if (shouldMarkAsChanged(prefix)) {\n      newDiff = newDiff.deltaStart(-prefix.length);\n    }\n    const suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));\n    if (shouldMarkAsChanged(suffix)) {\n      newDiff = newDiff.deltaEnd(suffix.length);\n    }\n    const availableSpace = SequenceDiff.fromOffsetPairs(\n      prev ? prev.getEndExclusives() : OffsetPair.zero,\n      next ? next.getStarts() : OffsetPair.max\n    );\n    const result = newDiff.intersect(availableSpace);\n    if (newDiffs.length > 0 && result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {\n      newDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);\n    } else {\n      newDiffs.push(result);\n    }\n  });\n  return newDiffs;\n}\n\nclass LineSequence {\n  constructor(trimmedHash, lines) {\n    this.trimmedHash = trimmedHash;\n    this.lines = lines;\n  }\n  getElement(offset) {\n    return this.trimmedHash[offset];\n  }\n  get length() {\n    return this.trimmedHash.length;\n  }\n  getBoundaryScore(length) {\n    const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n    const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n    return 1e3 - (indentationBefore + indentationAfter);\n  }\n  getText(range) {\n    return this.lines.slice(range.start, range.endExclusive).join(\"\\n\");\n  }\n  isStronglyEqual(offset1, offset2) {\n    return this.lines[offset1] === this.lines[offset2];\n  }\n}\nfunction getIndentation(str) {\n  let i = 0;\n  while (i < str.length && (str.charCodeAt(i) === 32 || str.charCodeAt(i) === 9)) {\n    i++;\n  }\n  return i;\n}\n\nclass DefaultLinesDiffComputer {\n  constructor() {\n    this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n    this.myersDiffingAlgorithm = new MyersDiffAlgorithm();\n  }\n  computeDiff(originalLines, modifiedLines, options) {\n    if (originalLines.length <= 1 && equals(originalLines, modifiedLines, (a, b) => a === b)) {\n      return new LinesDiff([], [], false);\n    }\n    if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {\n      return new LinesDiff([\n        new DetailedLineRangeMapping(\n          new LineRange(1, originalLines.length + 1),\n          new LineRange(1, modifiedLines.length + 1),\n          [\n            new RangeMapping(\n              new Range(1, 1, originalLines.length, originalLines[originalLines.length - 1].length + 1),\n              new Range(1, 1, modifiedLines.length, modifiedLines[modifiedLines.length - 1].length + 1)\n            )\n          ]\n        )\n      ], [], false);\n    }\n    const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n    const considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n    const perfectHashes = /* @__PURE__ */ new Map();\n    function getOrCreateHash(text) {\n      let hash = perfectHashes.get(text);\n      if (hash === undefined) {\n        hash = perfectHashes.size;\n        perfectHashes.set(text, hash);\n      }\n      return hash;\n    }\n    const originalLinesHashes = originalLines.map((l) => getOrCreateHash(l.trim()));\n    const modifiedLinesHashes = modifiedLines.map((l) => getOrCreateHash(l.trim()));\n    const sequence1 = new LineSequence(originalLinesHashes, originalLines);\n    const sequence2 = new LineSequence(modifiedLinesHashes, modifiedLines);\n    const lineAlignmentResult = (() => {\n      if (sequence1.length + sequence2.length < 1700) {\n        return this.dynamicProgrammingDiffing.compute(\n          sequence1,\n          sequence2,\n          timeout,\n          (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2] ? modifiedLines[offset2].length === 0 ? 0.1 : 1 + Math.log(1 + modifiedLines[offset2].length) : 0.99\n        );\n      }\n      return this.myersDiffingAlgorithm.compute(\n        sequence1,\n        sequence2,\n        timeout\n      );\n    })();\n    let lineAlignments = lineAlignmentResult.diffs;\n    let hitTimeout = lineAlignmentResult.hitTimeout;\n    lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n    lineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);\n    const alignments = [];\n    const scanForWhitespaceChanges = (equalLinesCount) => {\n      if (!considerWhitespaceChanges) {\n        return;\n      }\n      for (let i = 0; i < equalLinesCount; i++) {\n        const seq1Offset = seq1LastStart + i;\n        const seq2Offset = seq2LastStart + i;\n        if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n          const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(\n            new OffsetRange(seq1Offset, seq1Offset + 1),\n            new OffsetRange(seq2Offset, seq2Offset + 1)\n          ), timeout, considerWhitespaceChanges, options);\n          for (const a of characterDiffs.mappings) {\n            alignments.push(a);\n          }\n          if (characterDiffs.hitTimeout) {\n            hitTimeout = true;\n          }\n        }\n      }\n    };\n    let seq1LastStart = 0;\n    let seq2LastStart = 0;\n    for (const diff of lineAlignments) {\n      assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n      const equalLinesCount = diff.seq1Range.start - seq1LastStart;\n      scanForWhitespaceChanges(equalLinesCount);\n      seq1LastStart = diff.seq1Range.endExclusive;\n      seq2LastStart = diff.seq2Range.endExclusive;\n      const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges, options);\n      if (characterDiffs.hitTimeout) {\n        hitTimeout = true;\n      }\n      for (const a of characterDiffs.mappings) {\n        alignments.push(a);\n      }\n    }\n    scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n    const changes = lineRangeMappingFromRangeMappings(alignments, new ArrayText(originalLines), new ArrayText(modifiedLines));\n    let moves = [];\n    if (options.computeMoves) {\n      moves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges, options);\n    }\n    assertFn(() => {\n      function validatePosition(pos, lines) {\n        if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {\n          return false;\n        }\n        const line = lines[pos.lineNumber - 1];\n        if (pos.column < 1 || pos.column > line.length + 1) {\n          return false;\n        }\n        return true;\n      }\n      function validateRange(range, lines) {\n        if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {\n          return false;\n        }\n        if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {\n          return false;\n        }\n        return true;\n      }\n      for (const c of changes) {\n        if (!c.innerChanges) {\n          return false;\n        }\n        for (const ic of c.innerChanges) {\n          const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) && validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);\n          if (!valid) {\n            return false;\n          }\n        }\n        if (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {\n          return false;\n        }\n      }\n      return true;\n    });\n    return new LinesDiff(changes, moves, hitTimeout);\n  }\n  computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges, options) {\n    const moves = computeMovedLines(\n      changes,\n      originalLines,\n      modifiedLines,\n      hashedOriginalLines,\n      hashedModifiedLines,\n      timeout\n    );\n    const movesWithDiffs = moves.map((m) => {\n      const moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(\n        m.original.toOffsetRange(),\n        m.modified.toOffsetRange()\n      ), timeout, considerWhitespaceChanges, options);\n      const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, new ArrayText(originalLines), new ArrayText(modifiedLines), true);\n      return new MovedText(m, mappings);\n    });\n    return movesWithDiffs;\n  }\n  refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges, options) {\n    const lineRangeMapping = toLineRangeMapping(diff);\n    const rangeMapping = lineRangeMapping.toRangeMapping2(originalLines, modifiedLines);\n    const slice1 = new LinesSliceCharSequence(originalLines, rangeMapping.originalRange, considerWhitespaceChanges);\n    const slice2 = new LinesSliceCharSequence(modifiedLines, rangeMapping.modifiedRange, considerWhitespaceChanges);\n    const diffResult = slice1.length + slice2.length < 500 ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout) : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\n    let diffs = diffResult.diffs;\n    diffs = optimizeSequenceDiffs(slice1, slice2, diffs);\n    diffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs, (seq, idx) => seq.findWordContaining(idx));\n    if (options.extendToSubwords) {\n      diffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs, (seq, idx) => seq.findSubWordContaining(idx), true);\n    }\n    diffs = removeShortMatches(slice1, slice2, diffs);\n    diffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);\n    const result = diffs.map(\n      (d) => new RangeMapping(\n        slice1.translateRange(d.seq1Range),\n        slice2.translateRange(d.seq2Range)\n      )\n    );\n    return {\n      mappings: result,\n      hitTimeout: diffResult.hitTimeout\n    };\n  }\n}\nfunction toLineRangeMapping(sequenceDiff) {\n  return new LineRangeMapping(\n    new LineRange(sequenceDiff.seq1Range.start + 1, sequenceDiff.seq1Range.endExclusive + 1),\n    new LineRange(sequenceDiff.seq2Range.start + 1, sequenceDiff.seq2Range.endExclusive + 1)\n  );\n}\n\nfunction computeDiff(originalLines, modifiedLines, options) {\n  let diffComputer = new DefaultLinesDiffComputer();\n  var result = diffComputer.computeDiff(originalLines, modifiedLines, options);\n  return result?.changes.map((changes) => {\n    let originalStartLineNumber;\n    let originalEndLineNumber;\n    let modifiedStartLineNumber;\n    let modifiedEndLineNumber;\n    let innerChanges = changes.innerChanges;\n    originalStartLineNumber = changes.original.startLineNumber - 1;\n    originalEndLineNumber = changes.original.endLineNumberExclusive - 1;\n    modifiedStartLineNumber = changes.modified.startLineNumber - 1;\n    modifiedEndLineNumber = changes.modified.endLineNumberExclusive - 1;\n    return {\n      origStart: originalStartLineNumber,\n      origEnd: originalEndLineNumber,\n      editStart: modifiedStartLineNumber,\n      editEnd: modifiedEndLineNumber,\n      charChanges: innerChanges?.map((m) => ({\n        originalStartLineNumber: m.originalRange.startLineNumber - 1,\n        originalStartColumn: m.originalRange.startColumn - 1,\n        originalEndLineNumber: m.originalRange.endLineNumber - 1,\n        originalEndColumn: m.originalRange.endColumn - 1,\n        modifiedStartLineNumber: m.modifiedRange.startLineNumber - 1,\n        modifiedStartColumn: m.modifiedRange.startColumn - 1,\n        modifiedEndLineNumber: m.modifiedRange.endLineNumber - 1,\n        modifiedEndColumn: m.modifiedRange.endColumn - 1\n      }))\n    };\n  });\n}\n\nexports.computeDiff = computeDiff;\n\nvar AceRange = require(\"../../../range\").Range;\n\nvar {DiffChunk} = require(\"../base_diff_view\"); \n \n/**\n * VSCodes computeDiff provider\n */\n\nclass DiffProvider {\n    compute(originalLines, modifiedLines, opts) {\n        if (!opts) opts = {};\n        if (!opts.maxComputationTimeMs) opts.maxComputationTimeMs = 500;\n        const chunks = computeDiff(originalLines, modifiedLines, opts) || [];\n        return chunks.map(\n            c => new DiffChunk(new AceRange(c.origStart, 0, c.origEnd, 0), new AceRange(c.editStart, 0, c.editEnd, 0),\n                c.charChanges\n            ));\n    }\n}\n\nexports.DiffProvider = DiffProvider;","var Decorator = require(\"../../layer/decorators\").Decorator;\n\nclass ScrollDiffDecorator extends Decorator {\n    /**\n     * @param {import(\"../../../ace-internal\").Ace.VScrollbar} scrollbarV\n     * @param {import(\"../../virtual_renderer\").VirtualRenderer} renderer\n     * @param {boolean} [forInlineDiff]\n     */\n    constructor(scrollbarV, renderer, forInlineDiff) {\n        super(scrollbarV, renderer);\n\n        this.colors.dark[\"delete\"] = \"rgba(255, 18, 18, 1)\";\n        this.colors.dark[\"insert\"] = \"rgba(18, 136, 18, 1)\";\n        this.colors.light[\"delete\"] = \"rgb(255,51,51)\";\n        this.colors.light[\"insert\"] = \"rgb(32,133,72)\";\n\n        this.$zones = [];\n        this.$forInlineDiff = forInlineDiff;\n    }\n\n    /**\n     * @param {number} startRow\n     * @param {number} endRow\n     * @param {\"delete\"|\"insert\"} type\n     */\n    addZone(startRow, endRow, type) {\n        this.$zones.push({\n            startRow,\n            endRow,\n            type\n        });\n    }\n\n    /**\n     * @param {import(\"../../edit_session\").EditSession} sessionA\n     * @param {import(\"../../edit_session\").EditSession} sessionB\n     */\n    setSessions(sessionA, sessionB) {\n        this.sessionA = sessionA;\n        this.sessionB = sessionB;\n    }\n\n    $updateDecorators(config) {\n        if (typeof this.canvas.getContext !== \"function\") {\n            return;\n        }\n        super.$updateDecorators(config);\n        if (this.$zones.length > 0) {\n            var colors = (this.renderer.theme.isDark === true) ? this.colors.dark : this.colors.light;\n            var ctx = this.canvas.getContext(\"2d\");\n            this.$setDiffDecorators(ctx, colors);\n        }\n    }\n\n    /**\n     * @param {number} row\n     * @param {string} type\n     */\n    $transformPosition(row, type) {\n        if (type == \"delete\") {\n            return this.sessionA.documentToScreenRow(row, 0);\n        } else {\n            return this.sessionB.documentToScreenRow(row, 0);\n        }\n    }\n\n    $setDiffDecorators(ctx, colors) {\n        function compare(a, b) {\n            if (a.from === b.from) {\n                return a.to - b.to;\n            }\n            return a.from - b.from;\n        }\n\n        var zones = this.$zones;\n        if (zones) {\n            var resolvedZones = [];\n\n            const deleteZones = zones.filter(z => z.type === \"delete\");\n            const insertZones = zones.filter(z => z.type === \"insert\");\n\n            [deleteZones, insertZones].forEach((typeZones) => {\n                typeZones.forEach((zone, i) => {\n                    const offset1 = this.$transformPosition(zone.startRow, zone.type) * this.lineHeight;\n                    let offset2 = this.$transformPosition(zone.endRow, zone.type) * this.lineHeight + this.lineHeight;\n\n                    const y1 = Math.round(this.heightRatio * offset1);\n                    const y2 = Math.round(this.heightRatio * offset2);\n\n                    const padding = 1;\n\n                    let ycenter = Math.round((y1 + y2) / 2);\n                    let halfHeight = (y2 - ycenter);\n\n                    if (halfHeight < this.halfMinDecorationHeight) {\n                        halfHeight = this.halfMinDecorationHeight;\n                    }\n\n                    const previousZone = resolvedZones[resolvedZones.length - 1];\n\n                    if (i > 0 && previousZone && previousZone.type === zone.type && ycenter - halfHeight < previousZone.to + padding) {\n                        ycenter = resolvedZones[resolvedZones.length - 1].to + padding + halfHeight;\n                    }\n\n                    if (ycenter - halfHeight < 0) {\n                        ycenter = halfHeight;\n                    }\n                    if (ycenter + halfHeight > this.canvasHeight) {\n                        ycenter = this.canvasHeight - halfHeight;\n                    }\n\n                    resolvedZones.push({\n                        type: zone.type,\n                        from: ycenter - halfHeight,\n                        to: ycenter + halfHeight,\n                        color: colors[zone.type] || null\n                    });\n                });\n            });\n\n            resolvedZones = resolvedZones.sort(compare);\n\n            for (const zone of resolvedZones) {\n                ctx.fillStyle = zone.color || null;\n\n                const zoneFrom = zone.from;\n                const zoneTo = zone.to;\n                const zoneHeight = zoneTo - zoneFrom;\n                if (this.$forInlineDiff) {\n                    ctx.fillRect(this.oneZoneWidth, zoneFrom, 2 * this.oneZoneWidth, zoneHeight);\n                } else {\n                    if (zone.type == \"delete\") {\n                        ctx.fillRect(this.oneZoneWidth, zoneFrom, this.oneZoneWidth, zoneHeight);\n                    }\n                    else {\n                        ctx.fillRect(2 * this.oneZoneWidth, zoneFrom, this.oneZoneWidth, zoneHeight);\n                    }\n                }\n            }\n\n        }\n    }\n\n    setZoneWidth() {\n        this.oneZoneWidth = Math.round(this.canvasWidth / 3);\n    }\n}\n\nexports.ScrollDiffDecorator = ScrollDiffDecorator;","\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar Range = require(\"../../range\").Range;\nvar dom = require(\"../../lib/dom\");\nvar config = require(\"../../config\");\nvar LineWidgets = require(\"../../line_widgets\").LineWidgets;\nvar ScrollDiffDecorator = require(\"./scroll_diff_decorator\").ScrollDiffDecorator;\n\n// @ts-ignore\nvar css = require(\"./styles-css.js\").cssText;\n\nvar Editor = require(\"../../editor\").Editor;\nvar Renderer = require(\"../../virtual_renderer\").VirtualRenderer;\nvar UndoManager = require(\"../../undomanager\").UndoManager;\nvar Decorator = require(\"../../layer/decorators\").Decorator;\n\nrequire(\"../../theme/textmate\");\n// enable multiselect\nrequire(\"../../multi_select\");\n\nvar EditSession = require(\"../../edit_session\").EditSession;\n\nvar MinimalGutterDiffDecorator = require(\"./gutter_decorator\").MinimalGutterDiffDecorator;\n\nvar dummyDiffProvider = {\n    compute: function(val1, val2, options) {\n        return [];\n    }\n};\n\ndom.importCssString(css, \"diffview.css\");\n\nclass BaseDiffView {\n    /**\n     * Constructs a new base DiffView instance.\n     * @param {boolean} [inlineDiffEditor] - Whether to use an inline diff editor.\n     * @param {HTMLElement} [container] - optional container element for the DiffView.\n     */\n    constructor(inlineDiffEditor, container) {\n        this.onChangeTheme = this.onChangeTheme.bind(this);\n        this.onInput = this.onInput.bind(this);\n        this.onChangeFold = this.onChangeFold.bind(this);\n        this.realign = this.realign.bind(this);\n        this.onSelect = this.onSelect.bind(this);\n        this.onChangeWrapLimit = this.onChangeWrapLimit.bind(this);\n        this.realignPending = false;\n\n        /**@type{{sessionA: EditSession, sessionB: EditSession, chunks: DiffChunk[]}}*/this.diffSession;\n        /**@type DiffChunk[]*/this.chunks;\n        this.inlineDiffEditor = inlineDiffEditor || false;\n        this.currentDiffIndex = 0;\n        this.diffProvider = dummyDiffProvider;\n\n        if (container) {\n            this.container = container;\n        }\n\n        this.$ignoreTrimWhitespace = false;\n        this.$maxDiffs = 5000;\n        this.$maxComputationTimeMs = 150;\n        this.$syncSelections = false;\n        this.$foldUnchangedOnInput = false;\n\n        this.markerB = new DiffHighlight(this, 1);\n        this.markerA = new DiffHighlight(this, -1);\n    }\n\n    /**\n     * @param {import(\"../diff\").DiffModel} [diffModel] - The model for the diff view.\n     */\n    $setupModels(diffModel) {\n        if (diffModel.diffProvider) {\n            this.setProvider(diffModel.diffProvider);\n        }\n        this.showSideA = diffModel.inline == undefined ? true : diffModel.inline === \"a\";\n        var diffEditorOptions = /**@type {Partial<import(\"../../../ace-internal\").Ace.EditorOptions>}*/({\n            scrollPastEnd: 0.5,\n            highlightActiveLine: false,\n            highlightGutterLine: false,\n            animatedScroll: true,\n            customScrollbar: true,\n            vScrollBarAlwaysVisible: true,\n            fadeFoldWidgets: true,\n            showFoldWidgets: true,\n            selectionStyle: \"text\",\n        });\n\n        this.savedOptionsA = diffModel.editorA && diffModel.editorA.getOptions(diffEditorOptions);\n        this.savedOptionsB = diffModel.editorB && diffModel.editorB.getOptions(diffEditorOptions);\n\n        if (!this.inlineDiffEditor || diffModel.inline === \"a\") {\n            this.editorA = diffModel.editorA || this.$setupModel(diffModel.sessionA, diffModel.valueA);\n            this.container && this.container.appendChild(this.editorA.container);\n            this.editorA.setOptions(diffEditorOptions);\n        }\n        if (!this.inlineDiffEditor || diffModel.inline === \"b\") {\n            this.editorB = diffModel.editorB || this.$setupModel(diffModel.sessionB, diffModel.valueB);\n            this.container && this.container.appendChild(this.editorB.container);\n            this.editorB.setOptions(diffEditorOptions);\n        }\n        \n        if (this.inlineDiffEditor) {\n            this.activeEditor = this.showSideA ? this.editorA : this.editorB;\n            this.otherSession = this.showSideA ? this.sessionB : this.sessionA;\n            var cloneOptions = this.activeEditor.getOptions();\n            cloneOptions.readOnly = true;\n            delete cloneOptions.mode;\n            this.otherEditor = new Editor(new Renderer(null), undefined, cloneOptions);\n            if (this.showSideA) {\n                this.editorB = this.otherEditor;\n            } else {\n                this.editorA = this.otherEditor;\n            }\n        }\n\n        this.setDiffSession({\n            sessionA: diffModel.sessionA || (diffModel.editorA ? diffModel.editorA.session : new EditSession(\n                diffModel.valueA || \"\")),\n            sessionB: diffModel.sessionB || (diffModel.editorB ? diffModel.editorB.session : new EditSession(\n                diffModel.valueB || \"\")),\n            chunks: []\n        });\n\n        this.setupScrollbars();\n    }\n\n    addGutterDecorators() { \n        if (!this.gutterDecoratorA)\n            this.gutterDecoratorA = new MinimalGutterDiffDecorator(this.editorA, -1);\n        if (!this.gutterDecoratorB)\n            this.gutterDecoratorB = new MinimalGutterDiffDecorator(this.editorB, 1);\n    }\n\n    /**\n     * @param {EditSession} [session]\n     * @param {string} [value]\n     */\n    $setupModel(session, value) {\n        var editor = new Editor(new Renderer(), session);\n        editor.session.setUndoManager(new UndoManager());\n        if (value != undefined) {\n            editor.setValue(value, -1);\n        }\n        return editor;\n    }\n\n    foldUnchanged() {\n        var chunks = this.chunks;\n        var placeholder = \"-\".repeat(120);\n        var prev = {\n            old: new Range(0, 0, 0, 0),\n            new: new Range(0, 0, 0, 0)\n        };\n        var foldsChanged = false;\n        for (var i = 0; i < chunks.length + 1; i++) {\n            let current = chunks[i] || {\n                old: new Range(this.sessionA.getLength(), 0, this.sessionA.getLength(), 0),\n                new: new Range(this.sessionB.getLength(), 0, this.sessionB.getLength(), 0)\n            };\n            var l = current.new.start.row - prev.new.end.row - 5;\n            if (l > 2) {\n                var s = prev.old.end.row + 2;\n                var fold1 = this.sessionA.addFold(placeholder, new Range(s, 0, s + l, Number.MAX_VALUE));\n                s = prev.new.end.row + 2;\n                var fold2 = this.sessionB.addFold(placeholder, new Range(s, 0, s + l, Number.MAX_VALUE));\n                if (fold1 || fold2) foldsChanged = true;\n                if (fold2 && fold1) {\n                    fold1[\"other\"] = fold2;\n                    fold2[\"other\"] = fold1;\n                }\n            }\n\n            prev = current;\n        }\n        return foldsChanged;\n    }\n\n    unfoldUnchanged() {\n        var folds = this.sessionA.getAllFolds();\n        for (var i = folds.length - 1; i >= 0; i--) {\n            var fold = folds[i];\n            if (fold.placeholder.length == 120) {\n                this.sessionA.removeFold(fold);\n            }\n        }\n    }\n\n    toggleFoldUnchanged() {\n        if (!this.foldUnchanged()) {\n            this.unfoldUnchanged();\n        }\n    }\n\n    /**\n     * @param {{ sessionA: any; sessionB: EditSession; chunks: DiffChunk[] }} session\n     */\n    setDiffSession(session) {\n        if (this.diffSession) {\n            this.$detachSessionsEventHandlers();\n            this.clearSelectionMarkers();\n        }\n        this.diffSession = session;\n        this.sessionA = this.sessionB = null;\n        if (this.diffSession) {\n            this.chunks = this.diffSession.chunks || [];\n            this.editorA && this.editorA.setSession(session.sessionA);\n            this.editorB && this.editorB.setSession(session.sessionB);\n            this.sessionA = this.diffSession.sessionA;\n            this.sessionB = this.diffSession.sessionB;\n            this.$attachSessionsEventHandlers();\n            this.initSelectionMarkers();\n        }\n\n        this.otherSession = this.showSideA ? this.sessionB : this.sessionA;\n    }\n\n    /**\n     * @abstract\n     */\n    $attachSessionsEventHandlers() {\n    }\n\n    /**\n     * @abstract\n     */\n    $detachSessionsEventHandlers() {\n    }\n\n    getDiffSession() {\n        return this.diffSession;\n    }\n\n    setTheme(theme) {\n        this.editorA && this.editorA.setTheme(theme);\n        this.editorB && this.editorB.setTheme(theme);\n    }\n\n    getTheme() {\n        return (this.editorA || this.editorB).getTheme();\n    }\n\n    onChangeTheme(e) {\n        var theme = e && e.theme || this.getTheme();\n\n        if (this.editorA && this.editorA.getTheme() !== theme) {\n            this.editorA.setTheme(theme);\n        }\n        if (this.editorB && this.editorB.getTheme() !== theme) {\n            this.editorB.setTheme(theme);\n        }\n    }\n\n    resize(force) {\n        this.editorA && this.editorA.resize(force);\n        this.editorB && this.editorB.resize(force);\n    }\n\n    scheduleOnInput() {\n        if (this.$onInputTimer) return;\n        this.$onInputTimer = setTimeout(() => {\n            this.$onInputTimer = null;\n            this.onInput();\n        });\n    }\n    onInput() {\n        if (this.$onInputTimer) clearTimeout(this.$onInputTimer);\n\n        var val1 = this.sessionA.doc.getAllLines();\n        var val2 = this.sessionB.doc.getAllLines();\n\n        this.selectionRangeA = null;\n        this.selectionRangeB = null;\n\n        var chunks = this.$diffLines(val1, val2);\n\n        this.diffSession.chunks = this.chunks = chunks;\n        this.gutterDecoratorA && this.gutterDecoratorA.setDecorations(chunks);\n        this.gutterDecoratorB && this.gutterDecoratorB.setDecorations(chunks);\n        // if we\"re dealing with too many chunks, fail silently\n        if (this.chunks && this.chunks.length > this.$maxDiffs) {\n            return;\n        }\n\n        this.align();\n\n        this.editorA && this.editorA.renderer.updateBackMarkers();\n        this.editorB && this.editorB.renderer.updateBackMarkers();\n\n        setTimeout(() => {\n            this.updateScrollBarDecorators();\n        }, 0);\n\n        if (this.$foldUnchangedOnInput) {\n            this.foldUnchanged();\n        }\n    }\n\n    setupScrollbars() {\n        /**\n         * @param {Renderer & {$scrollDecorator: ScrollDiffDecorator}} renderer\n         */\n        const setupScrollBar = (renderer) => {\n            setTimeout(() => {\n                this.$setScrollBarDecorators(renderer);\n                this.updateScrollBarDecorators();\n            }, 0);\n        };\n\n        if (this.inlineDiffEditor) {\n            setupScrollBar(this.activeEditor.renderer);\n        }\n        else {\n            setupScrollBar(this.editorA.renderer);\n            setupScrollBar(this.editorB.renderer);\n        }\n\n    }\n\n    $setScrollBarDecorators(renderer) {\n        if (renderer.$scrollDecorator) {\n            renderer.$scrollDecorator.destroy();\n        }\n        renderer.$scrollDecorator = new ScrollDiffDecorator(renderer.scrollBarV, renderer, this.inlineDiffEditor);\n        renderer.$scrollDecorator.setSessions(this.sessionA, this.sessionB);\n        renderer.scrollBarV.setVisible(true);\n        renderer.scrollBarV.element.style.bottom = renderer.scrollBarH.getHeight() + \"px\";\n    }\n\n    $resetDecorators(renderer) {\n        if (renderer.$scrollDecorator) {\n            renderer.$scrollDecorator.destroy();\n        }\n        renderer.$scrollDecorator = new Decorator(renderer.scrollBarV, renderer);\n    }\n\n    updateScrollBarDecorators() {\n        if (this.inlineDiffEditor) {\n            if (!this.activeEditor) {\n                return;\n            }\n            this.activeEditor.renderer.$scrollDecorator.$zones = [];\n        }\n        else {\n            if (!this.editorA || !this.editorB) {\n                return;\n            }\n            this.editorA.renderer.$scrollDecorator.$zones = [];\n            this.editorB.renderer.$scrollDecorator.$zones = [];\n        }\n\n        /**\n         * @param {DiffChunk} change\n         */\n        const updateDecorators = (editor, change) => {\n            if (!editor) {\n                return;\n            }\n            if (typeof editor.renderer.$scrollDecorator.addZone !== \"function\") {\n                return;\n            }\n            if (change.old.start.row != change.old.end.row) {\n                editor.renderer.$scrollDecorator.addZone(change.old.start.row, change.old.end.row - 1, \"delete\");\n            }\n            if (change.new.start.row != change.new.end.row) {\n                editor.renderer.$scrollDecorator.addZone(change.new.start.row, change.new.end.row - 1, \"insert\");\n            }\n        };\n\n        if (this.inlineDiffEditor) {\n            this.chunks && this.chunks.forEach((lineChange) => {\n                updateDecorators(this.activeEditor, lineChange);\n            });\n            this.activeEditor.renderer.$scrollDecorator.$updateDecorators(this.activeEditor.renderer.layerConfig);\n        }\n        else {\n            this.chunks && this.chunks.forEach((lineChange) => {\n                updateDecorators(this.editorA, lineChange);\n                updateDecorators(this.editorB, lineChange);\n            });\n\n            this.editorA.renderer.$scrollDecorator.$updateDecorators(this.editorA.renderer.layerConfig);\n            this.editorB.renderer.$scrollDecorator.$updateDecorators(this.editorB.renderer.layerConfig);\n        }\n    }\n\n    /**\n     *\n     * @param {string[]} val1\n     * @param {string[]} val2\n     * @return {DiffChunk[]}\n     */\n    $diffLines(val1, val2) {\n        return this.diffProvider.compute(val1, val2, {\n            ignoreTrimWhitespace: this.$ignoreTrimWhitespace,\n            maxComputationTimeMs: this.$maxComputationTimeMs\n        });\n    }\n\n    /**\n     * @param {import(\"./providers/default\").DiffProvider} provider\n     */\n    setProvider(provider) {\n        this.diffProvider = provider;\n    }\n\n    /**\n     * @param {EditSession} session\n     * @param {{ rowCount: number; rowsAbove: number; row: number; }} w\n     */\n    $addWidget(session, w) {\n        let lineWidget = session.lineWidgets[w.row];\n        if (lineWidget) {\n            w.rowsAbove += lineWidget.rowsAbove > w.rowsAbove ? lineWidget.rowsAbove : w.rowsAbove;\n            w.rowCount += lineWidget.rowCount;\n        }\n        session.lineWidgets[w.row] = w;\n        session.widgetManager.lineWidgets[w.row] = w;\n        session.$resetRowCache(w.row);\n        var fold = session.getFoldAt(w.row, 0);\n        if (fold) {\n            session.widgetManager.updateOnFold({\n                data: fold,\n                action: \"add\",\n            }, session);\n        }\n    }\n\n    /**\n     * @param {Editor} editor\n     */\n    $initWidgets(editor) {\n        var session = editor.session;\n        if (!session.widgetManager) {\n            session.widgetManager = new LineWidgets(session);\n            session.widgetManager.attach(editor);\n        }\n        editor.session.lineWidgets = [];\n        editor.session.widgetManager.lineWidgets = [];\n        editor.session.$resetRowCache(0);\n    }\n\n    /**\n     * @param {import(\"../../../ace-internal\").Ace.Point} pos\n     * @param {EditSession} session\n     */\n    $screenRow(pos, session) {\n        var row = session.documentToScreenPosition(pos).row;\n        var afterEnd = pos.row - session.getLength() + 1;\n        if (afterEnd > 0) {\n            row += afterEnd;\n        }\n        return row;\n    }\n\n    /**\n     * scroll locking\n     * @abstract\n     **/\n    align() {}\n\n    onChangeWrapLimit(e, session) {}\n\n    onSelect(e, selection) {\n        this.searchHighlight(selection);\n        this.syncSelect(selection);\n    }\n\n    syncSelect(selection) {\n        if (this.$updatingSelection) return;\n        var isOld = selection.session === this.sessionA;\n        var selectionRange = selection.getRange();\n\n        var currSelectionRange = isOld ? this.selectionRangeA : this.selectionRangeB;\n        if (currSelectionRange && selectionRange.isEqual(currSelectionRange))\n            return;\n\n        if (isOld) {\n            this.selectionRangeA = selectionRange;\n        } else {\n            this.selectionRangeB = selectionRange;\n        }\n\n        this.$updatingSelection = true;\n        var newRange = this.transformRange(selectionRange, isOld);\n\n        if (this.$syncSelections) {\n            (isOld ? this.editorB : this.editorA).session.selection.setSelectionRange(newRange);\n        }\n        this.$updatingSelection = false;\n\n        if (isOld) {\n            this.selectionRangeA = selectionRange;\n            this.selectionRangeB = newRange;\n        } else {\n            this.selectionRangeA = newRange;\n            this.selectionRangeB = selectionRange;\n        }\n\n        this.updateSelectionMarker(this.syncSelectionMarkerA, this.sessionA, this.selectionRangeA);\n        this.updateSelectionMarker(this.syncSelectionMarkerB, this.sessionB, this.selectionRangeB);\n    }\n\n    updateSelectionMarker(marker, session, range) {\n        marker.setRange(range);\n        session._signal(\"changeFrontMarker\");\n    }\n\n    /**\n     * @param ev\n     * @param {EditSession} session\n     */\n    onChangeFold(ev, session) {\n        var fold = ev.data;\n        if (this.$syncingFold || !fold || !ev.action) return;\n        this.scheduleRealign();\n\n        const isOrig = session === this.sessionA;\n        const other = isOrig ? this.sessionB : this.sessionA;\n\n        if (ev.action === \"remove\") {\n            if (fold.other) {\n                fold.other.other = null;\n                other.removeFold(fold.other);\n            }\n            else if (fold.lineWidget) {\n                other.widgetManager.addLineWidget(fold.lineWidget);\n                fold.lineWidget = null;\n                if (other[\"$editor\"]) {\n                    other[\"$editor\"].renderer.updateBackMarkers();\n                }\n            }\n        }\n\n        if (ev.action === \"add\") {\n            const range = this.transformRange(fold.range, isOrig);\n            if (range.isEmpty()) {\n                const row = range.start.row + 1;\n                if (other.lineWidgets[row]) {\n                    fold.lineWidget = other.lineWidgets[row];\n                    other.widgetManager.removeLineWidget(fold.lineWidget);\n                    if (other[\"$editor\"]) {\n                        other[\"$editor\"].renderer.updateBackMarkers();\n                    }\n                }\n            }\n            else {\n                this.$syncingFold = true;\n\n                fold.other = other.addFold(fold.placeholder, range);\n                if (fold.other) {\n                    fold.other.other = fold;\n                }\n                this.$syncingFold = false;\n            }\n        }\n    }\n\n    scheduleRealign() {\n        if (!this.realignPending) {\n            this.realignPending = true;\n            this.editorA.renderer.on(\"beforeRender\", this.realign);\n            this.editorB.renderer.on(\"beforeRender\", this.realign);\n        }\n    }\n\n    realign() {\n        this.realignPending = true;\n        this.editorA.renderer.off(\"beforeRender\", this.realign);\n        this.editorB.renderer.off(\"beforeRender\", this.realign);\n        this.align();\n        this.realignPending = false;\n    }\n\n    detach() {\n        if (!this.editorA || !this.editorB) return;\n        if (this.savedOptionsA)\n            this.editorA.setOptions(this.savedOptionsA);\n        if (this.savedOptionsB)\n            this.editorB.setOptions(this.savedOptionsB);\n        this.editorA.renderer.off(\"beforeRender\", this.realign);\n        this.editorB.renderer.off(\"beforeRender\", this.realign);\n        this.$detachEventHandlers();\n        this.$removeLineWidgets(this.sessionA);\n        this.$removeLineWidgets(this.sessionB);\n        this.gutterDecoratorA && this.gutterDecoratorA.dispose();\n        this.gutterDecoratorB && this.gutterDecoratorB.dispose();\n        this.sessionA.selection.clearSelection();\n        this.sessionB.selection.clearSelection();\n\n        if (this.savedOptionsA && this.savedOptionsA.customScrollbar) {\n            this.$resetDecorators(this.editorA.renderer);\n        }\n        if (this.savedOptionsB &&this.savedOptionsB.customScrollbar) {\n            this.$resetDecorators(this.editorB.renderer);\n        }\n        \n    }\n\n    $removeLineWidgets(session) {\n        // TODO remove only our widgets\n        // session.widgetManager.removeLineWidget\n        session.lineWidgets = [];\n        session.widgetManager.lineWidgets = [];\n        session._signal(\"changeFold\", {data: {start: {row: 0}}});\n    }\n\n    /**\n     * @abstract\n     */\n    $detachEventHandlers() {\n\n    }\n\n    destroy() {\n        this.detach();\n        this.editorA && this.editorA.destroy();\n        this.editorB && this.editorB.destroy();\n        this.editorA = this.editorB = null;\n    }\n\n    gotoNext(dir) {\n        var ace = this.activeEditor || this.editorA;\n        if (this.inlineDiffEditor) {\n            ace = this.editorA;\n        }\n        var sideA = ace == this.editorA;\n\n        var row = ace.selection.lead.row;\n        var i = this.findChunkIndex(this.chunks, row, sideA);\n        var chunk = this.chunks[i + dir] || this.chunks[i];\n\n        var scrollTop = ace.session.getScrollTop();\n        if (chunk) {\n            var range = chunk[sideA ? \"old\" : \"new\"];\n            var line = Math.max(range.start.row, range.end.row - 1);\n            ace.selection.setRange(new Range(line, 0, line, 0));\n        }\n        ace.renderer.scrollSelectionIntoView(ace.selection.lead, ace.selection.anchor, 0.5);\n        ace.renderer.animateScrolling(scrollTop);\n    }\n\n\n    firstDiffSelected() {\n        return this.currentDiffIndex <= 1;\n    }\n\n    lastDiffSelected() {\n        return this.currentDiffIndex > this.chunks.length - 1;\n    }\n\n    /**\n     * @param {Range} range\n     * @param {boolean} isOriginal\n     */\n    transformRange(range, isOriginal) {\n        return Range.fromPoints(this.transformPosition(range.start, isOriginal), this.transformPosition(range.end, isOriginal));\n    }\n\n    /**\n     * @param {import(\"ace-code\").Ace.Point} pos\n     * @param {boolean} isOriginal\n     * @return {import(\"ace-code\").Ace.Point}\n     */\n    transformPosition(pos, isOriginal) {\n        var chunkIndex = this.findChunkIndex(this.chunks, pos.row, isOriginal);\n\n        var chunk = this.chunks[chunkIndex];\n\n        var clonePos = this.sessionB.doc.clonePos;\n        var result = clonePos(pos);\n\n        var [from, to] = isOriginal ? [\"old\", \"new\"] : [\"new\", \"old\"];\n        var deltaChar = 0;\n        var ignoreIndent = false;\n\n        if (chunk) {\n            if (chunk[from].end.row <= pos.row) {\n                result.row -= chunk[from].end.row - chunk[to].end.row;\n            }\n            else if (chunk.charChanges) {\n                for (let i = 0; i < chunk.charChanges.length; i++) {\n                    let change = chunk.charChanges[i];\n\n                    let fromRange = change[from];\n                    let toRange = change[to];\n\n                    if (fromRange.end.row < pos.row) continue;\n\n                    if (fromRange.start.row > pos.row) break;\n\n                    if (fromRange.isMultiLine() && fromRange.contains(pos.row, pos.column)) {\n                        result.row = toRange.start.row + pos.row - fromRange.start.row;\n                        var maxRow = toRange.end.row;\n                        if (toRange.end.column === 0) maxRow--;\n\n                        if (result.row > maxRow) {\n                            result.row = maxRow;\n                            result.column = (isOriginal ? this.sessionB : this.sessionA).getLine(maxRow).length;\n                            ignoreIndent = true;\n                        }\n                        result.row = Math.min(result.row, maxRow);\n                    }\n                    else {\n                        result.row = toRange.start.row;\n                        if (fromRange.start.column > pos.column) break;\n                        ignoreIndent = true;\n\n                        if (!fromRange.isEmpty() && fromRange.contains(pos.row, pos.column)) {\n                            result.column = toRange.start.column;\n                            deltaChar = pos.column - fromRange.start.column;\n                            deltaChar = Math.min(deltaChar, toRange.end.column - toRange.start.column);\n                        }\n                        else {\n                            result = clonePos(toRange.end);\n                            deltaChar = pos.column - fromRange.end.column;\n                        }\n                    }\n                }\n            }\n            else if (chunk[from].start.row <= pos.row) {\n                result.row += chunk[to].start.row - chunk[from].start.row;\n                if (result.row >= chunk[to].end.row) {\n                    result.row = chunk[to].end.row - 1;\n                    result.column = (isOriginal ? this.sessionB : this.sessionA).getLine(result.row).length;\n                }\n            }\n        }\n\n\n        if (!ignoreIndent) { //TODO:\n            var [fromEditSession, toEditSession] = isOriginal ? [this.sessionA, this.sessionB] : [\n                this.sessionB, this.sessionA\n            ];\n            deltaChar -= this.$getDeltaIndent(fromEditSession, toEditSession, pos.row, result.row);\n        }\n\n        result.column += deltaChar;\n        return result;\n    }\n\n    /**\n     * @param {EditSession} fromEditSession\n     * @param {EditSession} toEditSession\n     * @param {number} fromLine\n     * @param {number} toLine\n     */\n    $getDeltaIndent(fromEditSession, toEditSession, fromLine, toLine) {\n        let origIndent = this.$getIndent(fromEditSession, fromLine);\n        let editIndent = this.$getIndent(toEditSession, toLine);\n        return origIndent - editIndent;\n    }\n\n    /**\n     * @param {EditSession} editSession\n     * @param {number} line\n     */\n    $getIndent(editSession, line) {\n        return editSession.getLine(line).match(/^\\s*/)[0].length;\n    }\n\n    printDiffs() {\n        this.chunks.forEach((diff) => {\n            console.log(diff.toString());\n        });\n    }\n\n    /**\n     *\n     * @param {DiffChunk[]} chunks\n     * @param {number} row\n     * @param {boolean} isOriginal\n     * @return {number}\n     */\n    findChunkIndex(chunks, row, isOriginal) {\n        for (var i = 0; i < chunks.length; i++) {\n            var ch = chunks[i];\n            var chunk = isOriginal ? ch.old : ch.new;\n            if (chunk.end.row < row) continue;\n            if (chunk.start.row > row) break;\n        }\n\n        this.currentDiffIndex = i;\n\n        return i - 1;\n    }\n\n    searchHighlight(selection) {\n        if (this.$syncSelections || this.inlineDiffEditor) {\n            return;\n        }\n        let currSession = selection.session;\n        let otherSession = currSession === this.sessionA\n            ? this.sessionB : this.sessionA;\n        otherSession.highlight(currSession.$searchHighlight.regExp);\n        otherSession._signal(\"changeBackMarker\");\n    }\n\n    initSelectionMarkers() {\n        this.syncSelectionMarkerA = new SyncSelectionMarker();\n        this.syncSelectionMarkerB = new SyncSelectionMarker();\n        this.sessionA.addDynamicMarker(this.syncSelectionMarkerA, true);\n        this.sessionB.addDynamicMarker(this.syncSelectionMarkerB, true);\n    }\n    clearSelectionMarkers() {\n        this.sessionA.removeMarker(this.syncSelectionMarkerA.id);\n        this.sessionB.removeMarker(this.syncSelectionMarkerB.id);\n    }\n}\n\n/*** options ***/\n\nconfig.defineOptions(BaseDiffView.prototype, \"DiffView\", {\n    showOtherLineNumbers: {\n        set: function(value) {\n            if (this.gutterLayer) {\n                this.gutterLayer.$renderer = value ?  null : emptyGutterRenderer;\n                this.editorA.renderer.updateFull();\n            }\n        },\n        initialValue: true\n    },\n    folding: {\n        set: function(value) {\n            this.editorA.setOption(\"showFoldWidgets\", value);\n            this.editorB.setOption(\"showFoldWidgets\", value);\n            if (!value) {\n                var posA = [];\n                var posB = [];\n                if (this.chunks) {\n                    this.chunks.forEach(x=>{\n                        posA.push(x.old.start, x.old.end);\n                        posB.push(x.new.start, x.new.end);\n                     });\n                }\n                this.sessionA.unfold(posA);\n                this.sessionB.unfold(posB);\n            }\n        }\n    },\n    syncSelections: {\n        set: function(value) {\n\n        },\n    },\n    ignoreTrimWhitespace: {\n        set: function(value) {\n            this.scheduleOnInput();\n        },\n    },\n    wrap: {\n        set: function(value) {\n            this.sessionA.setOption(\"wrap\", value);\n            this.sessionB.setOption(\"wrap\", value);\n        }\n    },\n    maxDiffs: {\n        value: 5000,\n    },\n    theme: {\n        set: function(value) {\n            this.setTheme(value);\n        },\n        get: function() {\n            return this.editorA.getTheme();\n        }\n    },\n});\n\nvar emptyGutterRenderer =  {\n    getText: function name(params) {\n        return \"\";\n    },\n    getWidth() {\n        return 0;\n    }\n};\n\nexports.BaseDiffView = BaseDiffView;\n\n\nclass DiffChunk {\n    /**\n     * @param {Range} originalRange\n     * @param {Range} modifiedRange\n     * @param {{originalStartLineNumber: number, originalStartColumn: number,\n     * originalEndLineNumber: number, originalEndColumn: number, modifiedStartLineNumber: number,\n     * modifiedStartColumn: number, modifiedEndLineNumber: number, modifiedEndColumn: number}[]} [charChanges]\n     */\n    constructor(originalRange, modifiedRange, charChanges) {\n        this.old = originalRange;\n        this.new = modifiedRange;\n        this.charChanges = charChanges && charChanges.map(m => new DiffChunk(\n            new Range(m.originalStartLineNumber, m.originalStartColumn,\n                m.originalEndLineNumber, m.originalEndColumn\n            ), new Range(m.modifiedStartLineNumber, m.modifiedStartColumn,\n                m.modifiedEndLineNumber, m.modifiedEndColumn\n            )));\n    }\n}\n\nclass DiffHighlight {\n    /**\n     * @param {import(\"./base_diff_view\").BaseDiffView} diffView\n     * @param type\n     */\n    constructor(diffView, type) {\n        /**@type{number}*/this.id;\n        this.diffView = diffView;\n        this.type = type;\n    }\n\n    update(html, markerLayer, session, config) {\n        let dir, operation, opOperation;\n        var diffView = this.diffView;\n        if (this.type === -1) {// original editor\n            dir = \"old\";\n            operation = \"delete\";\n            opOperation = \"insert\";\n        }\n        else { //modified editor\n            dir = \"new\";\n            operation = \"insert\";\n            opOperation = \"delete\";\n        }\n\n        var ignoreTrimWhitespace = diffView.$ignoreTrimWhitespace;\n        var lineChanges = diffView.chunks;\n\n        if (session.lineWidgets && !diffView.inlineDiffEditor) {\n            for (var row = config.firstRow; row <= config.lastRow; row++) {\n                var lineWidget = session.lineWidgets[row];\n                if (!lineWidget || lineWidget.hidden)\n                    continue;\n\n                let start = session.documentToScreenRow(row, 0);\n\n                if (lineWidget.rowsAbove > 0) {\n                    var range = new Range(start - lineWidget.rowsAbove, 0, start - 1, Number.MAX_VALUE);\n                    markerLayer.drawFullLineMarker(html, range, \"ace_diff aligned_diff\", config);\n                }\n                let end = start + lineWidget.rowCount - (lineWidget.rowsAbove || 0);\n                var range = new Range(start + 1, 0, end, Number.MAX_VALUE);\n                markerLayer.drawFullLineMarker(html, range, \"ace_diff aligned_diff\", config);\n            }\n        }\n\n        lineChanges.forEach((lineChange) => {\n            let startRow = lineChange[dir].start.row;\n            let endRow = lineChange[dir].end.row;\n            if (endRow < config.firstRow || startRow > config.lastRow)\n                return;\n            let range = new Range(startRow, 0, endRow - 1, 1 << 30);\n            if (startRow !== endRow) {\n                range = range.toScreenRange(session);\n\n                markerLayer.drawFullLineMarker(html, range, \"ace_diff \" + operation, config);\n            }\n\n            if (lineChange.charChanges) {\n                for (var i = 0; i < lineChange.charChanges.length; i++) {\n                    var changeRange = lineChange.charChanges[i][dir];\n                    if (changeRange.end.column == 0 && changeRange.end.row > changeRange.start.row && changeRange.end.row == lineChange[dir].end.row ) {\n                        changeRange.end.row --;\n                        changeRange.end.column = Number.MAX_VALUE;\n                    }\n                        \n                    if (ignoreTrimWhitespace) {\n                        for (let lineNumber = changeRange.start.row;\n                             lineNumber <= changeRange.end.row; lineNumber++) {\n                            let startColumn;\n                            let endColumn;\n                            let sessionLineStart = session.getLine(lineNumber).match(/^\\s*/)[0].length;\n                            let sessionLineEnd = session.getLine(lineNumber).length;\n\n                            if (lineNumber === changeRange.start.row) {\n                                startColumn = changeRange.start.column;\n                            }\n                            else {\n                                startColumn = sessionLineStart;\n                            }\n                            if (lineNumber === changeRange.end.row) {\n                                endColumn = changeRange.end.column;\n                            }\n                            else {\n                                endColumn = sessionLineEnd;\n                            }\n                            let range = new Range(lineNumber, startColumn, lineNumber, endColumn);\n                            var screenRange = range.toScreenRange(session);\n\n                            if (sessionLineStart === startColumn && sessionLineEnd === endColumn) {\n                                continue;\n                            }\n\n                            let cssClass = \"inline \" + operation;\n                            if (range.isEmpty() && startColumn !== 0) {\n                                cssClass = \"inline \" + opOperation + \" empty\";\n                            }\n\n                            markerLayer.drawSingleLineMarker(html, screenRange, \"ace_diff \" + cssClass, config);\n                        }\n                    }\n                    else {\n                        let range = new Range(changeRange.start.row, changeRange.start.column,\n                            changeRange.end.row, changeRange.end.column\n                        );\n                        var screenRange = range.toScreenRange(session);\n                        let cssClass = \"inline \" + operation;\n                        if (range.isEmpty() && changeRange.start.column !== 0) {\n                            cssClass = \"inline empty \" + opOperation;\n                        }\n\n                        if (screenRange.isMultiLine()) {\n                            markerLayer.drawTextMarker(html, screenRange, \"ace_diff \" + cssClass, config);\n                        }\n                        else {\n                            markerLayer.drawSingleLineMarker(html, screenRange, \"ace_diff \" + cssClass, config);\n                        }\n                    }\n                }\n            }\n        });\n    }\n}\n\nclass SyncSelectionMarker {\n    constructor() {\n        /**@type{number}*/this.id;\n        this.type = \"fullLine\";\n        this.clazz = \"ace_diff-active-line\";\n    }\n\n    update(html, markerLayer, session, config) {\n    }\n\n    /**\n     * @param {Range} range\n     */\n    setRange(range) {//TODO\n        var newRange = range.clone();\n        newRange.end.column++;\n\n        this.range = newRange;\n    }\n}\n\nexports.DiffChunk = DiffChunk;\nexports.DiffHighlight = DiffHighlight;","/**\n * ## Diff extension\n *\n * Provides side-by-side and inline diff view capabilities for comparing code differences between two versions.\n * Supports visual highlighting of additions, deletions, and modifications with customizable diff providers\n * and rendering options. Includes features for synchronized scrolling, line number alignment, and\n * various diff computation algorithms.\n *\n * **Components:**\n * - `InlineDiffView`: Single editor view showing changes inline with markers\n * - `SplitDiffView`: Side-by-side comparison view with two synchronized editors\n * - `DiffProvider`: Configurable algorithms for computing differences\n *\n * **Usage:**\n * ```javascript\n * const diffView = createDiffView({\n *   valueA: originalContent,\n *   valueB: modifiedContent,\n *   inline: false // or 'a'/'b' for inline view\n * });\n * ```\n *\n * @module\n */\n\nvar InlineDiffView = require(\"./diff/inline_diff_view\").InlineDiffView;\nvar SplitDiffView = require(\"./diff/split_diff_view\").SplitDiffView;\nvar DiffProvider = require(\"./diff/providers/default\").DiffProvider;\n\n/**\n * Interface representing a model for handling differences between two views or states.\n * @typedef {Object} DiffModel\n * @property {import(\"../editor\").Editor} [editorA] - The editor for the original view.\n * @property {import(\"../editor\").Editor} [editorB] - The editor for the edited view.\n * @property {import(\"../edit_session\").EditSession} [sessionA] - The edit session for the original view.\n * @property {import(\"../edit_session\").EditSession} [sessionB] - The edit session for the edited view.\n * @property {string} [valueA] - The original content.\n * @property {string} [valueB] - The modified content.\n * @property {\"a\"|\"b\"} [inline] - Whether to show the original view(\"a\") or modified view(\"b\") for inline diff view\n * @property {IDiffProvider} [diffProvider] - Provider for computing differences between original and modified content.\n */\n\n/**\n * @typedef {Object} DiffViewOptions\n * @property {boolean} [showOtherLineNumbers=true] - Whether to show line numbers in the other editor's gutter\n * @property {boolean} [folding] - Whether to enable code folding widgets\n * @property {boolean} [syncSelections] - Whether to synchronize selections between both editors\n * @property {boolean} [ignoreTrimWhitespace] - Whether to ignore trimmed whitespace when computing diffs\n * @property {boolean} [wrap] - Whether to enable word wrapping in both editors\n * @property {number} [maxDiffs=5000] - Maximum number of diffs to compute before failing silently\n * @property {string|import(\"../../ace-internal\").Ace.Theme} [theme] - Theme to apply to both editors\n */\n\n/**\n * @typedef {Object} IDiffProvider\n * @property {(originalLines: string[], modifiedLines: string[], opts?: any) => import(\"./diff/base_diff_view\").DiffChunk[]} compute - Computes differences between original and modified lines\n */\n\n\n/**\n * Creates a diff view for comparing code.\n * @param {DiffModel} [diffModel] model for the diff view\n * @param {DiffViewOptions} [options] options for the diff view\n * @returns {InlineDiffView|SplitDiffView} Configured diff view instance\n */\nfunction createDiffView(diffModel, options) {\n    diffModel = diffModel || {};\n    diffModel.diffProvider = diffModel.diffProvider || new DiffProvider(); //use default diff provider;\n    let diffView;\n    if (diffModel.inline) {\n        diffView = new InlineDiffView(diffModel);\n    }\n    else {\n        diffView = new SplitDiffView(diffModel);\n    }\n    if (options) {\n        diffView.setOptions(options);\n    }\n\n    return diffView;\n}\n\nexports.InlineDiffView = InlineDiffView;\nexports.SplitDiffView = SplitDiffView;\nexports.DiffProvider = DiffProvider;\nexports.createDiffView = createDiffView;\n","exports.cssText = `\n/*\n * Line Markers\n */\n.ace_diff {\n    position: absolute;\n    z-index: 0;\n}\n.ace_diff.inline {\n    z-index: 20;\n}\n/*\n * Light Colors \n */\n.ace_diff.insert {\n    background-color: #EFFFF1;\n}\n.ace_diff.delete {\n    background-color: #FFF1F1;\n}\n.ace_diff.aligned_diff {\n    background: rgba(206, 194, 191, 0.26);\n    background: repeating-linear-gradient(\n                45deg,\n              rgba(122, 111, 108, 0.26),\n              rgba(122, 111, 108, 0.26) 5px,\n              rgba(0, 0, 0, 0) 5px,\n              rgba(0, 0, 0, 0) 10px \n    );\n}\n\n.ace_diff.insert.inline {\n    background-color:  rgb(74 251 74 / 18%); \n}\n.ace_diff.delete.inline {\n    background-color: rgb(251 74 74 / 15%);\n}\n\n.ace_diff.delete.inline.empty {\n    background-color: rgba(255, 128, 79, 0.7);\n    width: 2px !important;\n}\n\n.ace_diff.insert.inline.empty {\n    background-color: rgba(49, 230, 96, 0.7);\n    width: 2px !important;\n}\n\n.ace_diff-active-line {\n    border-bottom: 1px solid;\n    border-top: 1px solid;\n    background: transparent;\n    position: absolute;\n    box-sizing: border-box;\n    border-color: #9191ac;\n}\n\n.ace_dark .ace_diff-active-line {\n    background: transparent;\n    border-color: #75777a;\n}\n \n\n/* gutter changes */\n.ace_mini-diff_gutter-enabled > .ace_gutter-cell,\n.ace_mini-diff_gutter-enabled > .ace_gutter-cell_svg-icons {\n    padding-right: 13px;\n}\n\n.ace_mini-diff_gutter_other > .ace_gutter-cell,\n.ace_mini-diff_gutter_other > .ace_gutter-cell_svg-icons  {\n    display: none;\n}\n\n.ace_mini-diff_gutter_other {\n    pointer-events: none;\n}\n\n\n.ace_mini-diff_gutter-enabled > .mini-diff-added {\n    background-color: #EFFFF1;\n    border-left: 3px solid #2BB534;\n    padding-left: 16px;\n    display: block;\n}\n\n.ace_mini-diff_gutter-enabled > .mini-diff-deleted {\n    background-color: #FFF1F1;\n    border-left: 3px solid #EA7158;\n    padding-left: 16px;\n    display: block;\n}\n\n\n.ace_mini-diff_gutter-enabled > .mini-diff-added:after {\n    position: absolute;\n    right: 2px;\n    content: \"+\";\n    color: darkgray;\n    background-color: inherit;\n}\n\n.ace_mini-diff_gutter-enabled > .mini-diff-deleted:after {\n    position: absolute;\n    right: 2px;\n    content: \"-\";\n    color: darkgray;\n    background-color: inherit;\n}\n.ace_fade-fold-widgets:hover > .ace_folding-enabled > .mini-diff-added:after,\n.ace_fade-fold-widgets:hover > .ace_folding-enabled > .mini-diff-deleted:after {\n    display: none;\n}\n\n.ace_diff_other .ace_selection {\n    filter: drop-shadow(1px 2px 3px darkgray);\n}\n\n.ace_hidden_marker-layer .ace_bracket {\n    display: none;\n}\n\n\n\n/*\n * Dark Colors \n */\n\n.ace_dark .ace_diff.insert {\n    background-color: #212E25;\n}\n.ace_dark .ace_diff.delete {\n    background-color: #3F2222;\n}\n\n.ace_dark .ace_mini-diff_gutter-enabled > .mini-diff-added {\n    background-color: #212E25;\n    border-left-color:#00802F;\n}\n\n.ace_dark .ace_mini-diff_gutter-enabled > .mini-diff-deleted {\n    background-color: #3F2222;\n    border-left-color: #9C3838;\n}\n\n`;\n"],"names":[],"sourceRoot":""}