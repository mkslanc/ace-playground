{"version":3,"file":"bundle.4848.js","mappings":";;;;;;AAAa;;AAEb,UAAU,mBAAO,CAAC,IAAY;AAC9B,yBAAyB,wDAAoD;;AAE7E;AACA,0BAA0B,2BAA2B;AACrD;AACA;AACA;;AAEA,eAAe;AACf;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA;;AAEA,eAAe;AACf;AACA;AACA;;AAEA,yBAAyB,0BAA0B;AACnD;AACA;AACA;;AAEA,4BAA4B,6BAA6B;AACzD;AACA;AACA;;AAEA,6BAA6B,8BAA8B;AAC3D;AACA;AACA;;AAEA,2BAA2B,8BAA8B;AACzD;AACA;AACA;;AAEA,8BAA8B,+BAA+B;AAC7D;AACA;AACA;;AAEA,6BAA6B,8BAA8B;AAC3D;AACA;AACA;;AAEA,2BAA2B,4BAA4B;AACvD;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA,eAAe,IAAI;AACnB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,8CAA8C,IAAI,+EAA+E,EAAE,cAAc,EAAE,cAAc,EAAE,GAAG,YAAY,IAAI,kBAAkB,IAAI,GAAG;;AAE/M;AACA;AACA;AACA,UAAU,KAAK;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,8BAA8B;AAC9B;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,8BAA8B;AAC9B;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mCAAmC;AAC5D,yBAAyB,iCAAiC;AAC1D,yBAAyB,wCAAwC;AACjE,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,4BAA4B;AAC5B,aAAa;AACb;AACA,8BAA8B;AAC9B;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,sBAAsB;AACtB;AACA,SAAS;AACT;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,sBAAsB;AACtB;AACA,SAAS;AACT;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB;AACtB;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,aAAa,iBAAiB;AAC9B;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,6BAA6B,o0BAAo0B;AACj2B,aAAa;AACb;AACA,6BAA6B,aAAa;AAC1C,aAAa,GAAG;AAChB;AACA,4CAA4C,EAAE,cAAc,EAAE;AAC9D,aAAa,GAAG;AAChB;AACA;AACA;AACA,aAAa,GAAG;AAChB;AACA,0BAA0B,YAAY,4BAA4B,GAAG;AACrE,aAAa,GAAG;AAChB;AACA,kEAAkE,YAAY;AAC9E,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,4CAA4C,EAAE,cAAc,EAAE;AAC9D,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,0BAA0B","sources":["webpack://ace-playground/./node_modules/ace-code/src/mode/ruby_highlight_rules.js"],"sourcesContent":["\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\n// exports is for Haml\nvar constantOtherSymbol = exports.constantOtherSymbol = {\n    token : \"constant.other.symbol.ruby\", // symbol\n    regex : \"[:](?:[A-Za-z_]|[@$](?=[a-zA-Z0-9_]))[a-zA-Z0-9_]*[!=?]?\"\n};\n\nexports.qString = {\n    token : \"string\", // single line\n    regex : \"['](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[']\"\n};\n\nexports.qqString = {\n    token : \"string\", // single line\n    regex : '[\"](?:(?:\\\\\\\\.)|(?:[^\"\\\\\\\\]))*?[\"]'\n};\n\nexports.tString = {\n    token : \"string\", // backtick string\n    regex : \"[`](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[`]\"\n};\n\nvar constantNumericHex = exports.constantNumericHex = {\n    token : \"constant.numeric\", // hex\n    regex : \"0[xX][0-9a-fA-F](?:[0-9a-fA-F]|_(?=[0-9a-fA-F]))*\\\\b\"\n};\n\nvar constantNumericBinary = exports.constantNumericBinary = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[bB][01](?:[01]|_(?=[01]))*)\\b/\n};\n\nvar constantNumericDecimal = exports.constantNumericDecimal = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[dD](?:[1-9](?:[\\d]|_(?=[\\d]))*|0))\\b/\n};\n\nvar constantNumericOctal = exports.constantNumericDecimal = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[oO]?(?:[1-7](?:[0-7]|_(?=[0-7]))*|0))\\b/\n};\n\nvar constantNumericRational = exports.constantNumericRational = {\n    token: \"constant.numeric\", //rational + complex\n    regex: /\\b([\\d]+(?:[./][\\d]+)?ri?)\\b/\n};\n\nvar constantNumericComplex = exports.constantNumericComplex = {\n    token: \"constant.numeric\", //simple complex numbers\n    regex: /\\b([\\d]i)\\b/\n};\n\nvar constantNumericFloat = exports.constantNumericFloat = {\n    token : \"constant.numeric\", // float + complex\n    regex : \"[+-]?\\\\d(?:\\\\d|_(?=\\\\d))*(?:(?:\\\\.\\\\d(?:\\\\d|_(?=\\\\d))*)?(?:[eE][+-]?\\\\d+)?)?i?\\\\b\"\n};\n\nvar instanceVariable = exports.instanceVariable = {\n    token : \"variable.instance\", // instance variable\n    regex : \"@{1,2}[a-zA-Z_\\\\d]+\"\n};\n\nvar RubyHighlightRules = function() {\n\n    var builtinFunctions = (\n        \"abort|Array|assert|assert_equal|assert_not_equal|assert_same|assert_not_same|\" +\n        \"assert_nil|assert_not_nil|assert_match|assert_no_match|assert_in_delta|assert_throws|\" +\n        \"assert_raise|assert_nothing_raised|assert_instance_of|assert_kind_of|assert_respond_to|\" +\n        \"assert_operator|assert_send|assert_difference|assert_no_difference|assert_recognizes|\" +\n        \"assert_generates|assert_response|assert_redirected_to|assert_template|assert_select|\" +\n        \"assert_select_email|assert_select_rjs|assert_select_encoded|css_select|at_exit|\" +\n        \"attr|attr_writer|attr_reader|attr_accessor|attr_accessible|autoload|binding|block_given?|callcc|\" +\n        \"caller|catch|chomp|chomp!|chop|chop!|defined?|delete_via_redirect|eval|exec|exit|\" +\n        \"exit!|fail|Float|flunk|follow_redirect!|fork|form_for|form_tag|format|gets|global_variables|gsub|\" +\n        \"gsub!|get_via_redirect|host!|https?|https!|include|Integer|lambda|link_to|\" +\n        \"link_to_unless_current|link_to_function|link_to_remote|load|local_variables|loop|open|open_session|\" +\n        \"p|print|printf|proc|putc|puts|post_via_redirect|put_via_redirect|raise|rand|\" +\n        \"raw|readline|readlines|redirect?|request_via_redirect|require|scan|select|\" +\n        \"set_trace_func|sleep|split|sprintf|srand|String|stylesheet_link_tag|syscall|system|sub|sub!|test|\" +\n        \"throw|trace_var|trap|untrace_var|atan2|cos|exp|frexp|ldexp|log|log10|sin|sqrt|tan|\" +\n        \"render|javascript_include_tag|csrf_meta_tag|label_tag|text_field_tag|submit_tag|check_box_tag|\" +\n        \"content_tag|radio_button_tag|text_area_tag|password_field_tag|hidden_field_tag|\" +\n        \"fields_for|select_tag|options_for_select|options_from_collection_for_select|collection_select|\" +\n        \"time_zone_select|select_date|select_time|select_datetime|date_select|time_select|datetime_select|\" +\n        \"select_year|select_month|select_day|select_hour|select_minute|select_second|file_field_tag|\" +\n        \"file_field|respond_to|skip_before_filter|around_filter|after_filter|verify|\" +\n        \"protect_from_forgery|rescue_from|helper_method|redirect_to|before_filter|\" +\n        \"send_data|send_file|validates_presence_of|validates_uniqueness_of|validates_length_of|\" +\n        \"validates_format_of|validates_acceptance_of|validates_associated|validates_exclusion_of|\" +\n        \"validates_inclusion_of|validates_numericality_of|validates_with|validates_each|\" +\n        \"authenticate_or_request_with_http_basic|authenticate_or_request_with_http_digest|\" +\n        \"filter_parameter_logging|match|get|post|resources|redirect|scope|assert_routing|\" +\n        \"translate|localize|extract_locale_from_tld|caches_page|expire_page|caches_action|expire_action|\" +\n        \"cache|expire_fragment|expire_cache_for|observe|cache_sweeper|\" +\n        \"has_many|has_one|belongs_to|has_and_belongs_to_many|p|warn|refine|using|module_function|extend|alias_method|\" +\n        \"private_class_method|remove_method|undef_method\"\n    );\n\n    var keywords = (\n        \"alias|and|BEGIN|begin|break|case|class|def|defined|do|else|elsif|END|end|ensure|\" +\n        \"__FILE__|finally|for|gem|if|in|__LINE__|module|next|not|or|private|protected|public|\" +\n        \"redo|rescue|retry|return|super|then|undef|unless|until|when|while|yield|__ENCODING__|prepend\"\n    );\n\n    var buildinConstants = (\n        \"true|TRUE|false|FALSE|nil|NIL|ARGF|ARGV|DATA|ENV|RUBY_PLATFORM|RUBY_RELEASE_DATE|\" +\n        \"RUBY_VERSION|STDERR|STDIN|STDOUT|TOPLEVEL_BINDING|RUBY_PATCHLEVEL|RUBY_REVISION|RUBY_COPYRIGHT|RUBY_ENGINE|RUBY_ENGINE_VERSION|RUBY_DESCRIPTION\"\n    );\n\n    var builtinVariables = (\n        \"$DEBUG|$defout|$FILENAME|$LOAD_PATH|$SAFE|$stdin|$stdout|$stderr|$VERBOSE|\" +\n        \"$!|root_url|flash|session|cookies|params|request|response|logger|self\"\n    );\n\n    var keywordMapper = this.$keywords = this.createKeywordMapper({\n        \"keyword\": keywords,\n        \"constant.language\": buildinConstants,\n        \"variable.language\": builtinVariables,\n        \"support.function\": builtinFunctions,\n        \"invalid.deprecated\": \"debugger\" // TODO is this a remnant from js mode?\n    }, \"identifier\");\n\n    var escapedChars = \"\\\\\\\\(?:n(?:[1-7][0-7]{0,2}|0)|[nsrtvfbae'\\\"\\\\\\\\]|c(?:\\\\\\\\M-)?.|M-(?:\\\\\\\\C-|\\\\\\\\c)?.|C-(?:\\\\\\\\M-)?.|[0-7]{3}|x[\\\\da-fA-F]{2}|u[\\\\da-fA-F]{4}|u{[\\\\da-fA-F]{1,6}(?:\\\\s[\\\\da-fA-F]{1,6})*})\";\n\n    var closeParen = {\n        \"(\": \")\",\n        \"[\": \"]\",\n        \"{\": \"}\",\n        \"<\": \">\",\n        \"^\": \"^\",\n        \"|\": \"|\",\n        \"%\": \"%\"\n    };\n    // regexp must not have capturing parentheses. Use (?:) instead.\n    // regexps are ordered -> the first match is used\n\n    this.$rules = {\n        \"start\": [\n            {\n                token: \"comment\",\n                regex: \"#.*$\"\n            }, {\n                token: \"comment.multiline\", // multi line comment\n                regex: \"^=begin(?=$|\\\\s.*$)\",\n                next: \"comment\"\n            }, {\n                token: \"string.regexp\",\n                regex: /[/](?=.*\\/)/,\n                next: \"regex\"\n            },\n\n            [{\n                token: [\"constant.other.symbol.ruby\", \"string.start\"],\n                regex: /(:)?(\")/,\n                push: [{\n                    token: \"constant.language.escape\",\n                    regex: escapedChars\n                }, {\n                    token: \"paren.start\",\n                    regex: /#{/,\n                    push: \"start\"\n                }, {\n                    token: \"string.end\",\n                    regex: /\"/,\n                    next: \"pop\"\n                }, {\n                    defaultToken: \"string\"\n                }]\n            }, {\n                token: \"string.start\",\n                regex: /`/,\n                push: [{\n                    token: \"constant.language.escape\",\n                    regex: escapedChars\n                }, {\n                    token: \"paren.start\",\n                    regex: /#{/,\n                    push: \"start\"\n                }, {\n                    token: \"string.end\",\n                    regex: /`/,\n                    next: \"pop\"\n                }, {\n                    defaultToken: \"string\"\n                }]\n            }, {\n                token: [\"constant.other.symbol.ruby\", \"string.start\"],\n                regex: /(:)?(')/,\n                push: [{\n                    token: \"constant.language.escape\",\n                    regex: /\\\\['\\\\]/\n                }, {\n                    token: \"string.end\",\n                    regex: /'/,\n                    next: \"pop\"\n                }, {\n                    defaultToken: \"string\"\n                }]\n            }, {\n                token: \"string.start\",//doesn't see any differences between strings and array of strings in highlighting\n                regex: /%[qwx]([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                    if (stack.length)\n                        stack = [];\n                    var paren = val[val.length - 1];\n                    stack.unshift(paren, state);\n                    this.next = \"qStateWithoutInterpolation\";\n                    return this.token;\n                }\n            }, {\n                token: \"string.start\", //doesn't see any differences between strings and array of strings in highlighting\n                regex: /%[QWX]?([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                    if (stack.length)\n                        stack = [];\n                    var paren = val[val.length - 1];\n                    stack.unshift(paren, state);\n                    this.next = \"qStateWithInterpolation\";\n                    return this.token;\n                }\n            }, {\n                token: \"constant.other.symbol.ruby\", //doesn't see any differences between symbols and array of symbols in highlighting\n                regex: /%[si]([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                    if (stack.length)\n                        stack = [];\n                    var paren = val[val.length - 1];\n                    stack.unshift(paren, state);\n                    this.next = \"sStateWithoutInterpolation\";\n                    return this.token;\n                }\n            }, {\n                token: \"constant.other.symbol.ruby\", //doesn't see any differences between symbols and array of symbols in highlighting\n                regex: /%[SI]([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                    if (stack.length)\n                        stack = [];\n                    var paren = val[val.length - 1];\n                    stack.unshift(paren, state);\n                    this.next = \"sStateWithInterpolation\";\n                    return this.token;\n                }\n            }, {\n                token: \"string.regexp\",\n                regex: /%[r]([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                    if (stack.length)\n                        stack = [];\n                    var paren = val[val.length - 1];\n                    stack.unshift(paren, state);\n                    this.next = \"rState\";\n                    return this.token;\n                }\n            }],\n\n            {\n                token: \"punctuation\", // namespaces aren't symbols\n                regex: \"::\"\n            },\n            instanceVariable,\n            {\n                token: \"variable.global\", // global variable\n                regex: \"[$][a-zA-Z_\\\\d]+\"\n            }, {\n                token: \"support.class\", // class name\n                regex: \"[A-Z][a-zA-Z_\\\\d]*\"\n            }, {\n                token: [\"punctuation.operator\", \"support.function\"],\n                regex: /(\\.)([a-zA-Z_\\d]+)(?=\\()/\n            }, {\n                token: [\"punctuation.operator\", \"identifier\"],\n                regex: /(\\.)([a-zA-Z_][a-zA-Z_\\d]*)/\n            }, {\n                token: \"string.character\",\n                regex: \"\\\\B\\\\?(?:\" + escapedChars + \"|\\\\S)\"\n            }, {\n                token: \"punctuation.operator\",\n                regex: /\\?(?=.+:)/\n            },\n\n            constantNumericRational,\n            constantNumericComplex,\n            constantOtherSymbol,\n            constantNumericHex,\n            constantNumericFloat,\n            constantNumericBinary,\n            constantNumericDecimal,\n            constantNumericOctal,\n            {\n                token: \"constant.language.boolean\",\n                regex: \"(?:true|false)\\\\b\"\n            }, {\n                token: keywordMapper,\n                regex: \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"\n            }, {\n                token: \"punctuation.separator.key-value\",\n                regex: \"=>\"\n            }, {\n                stateName: \"heredoc\",\n                onMatch: function (value, currentState, stack) {\n                    var next = (value[2] == '-' || value[2] == '~') ? \"indentedHeredoc\" : \"heredoc\";\n                    var tokens = value.split(this.splitRegex);\n                    stack.push(next, tokens[3]);\n                    return [\n                        {type: \"constant\", value: tokens[1]},\n                        {type: \"string\", value: tokens[2]},\n                        {type: \"support.class\", value: tokens[3]},\n                        {type: \"string\", value: tokens[4]}\n                    ];\n                },\n                regex: \"(<<[-~]?)(['\\\"`]?)([\\\\w]+)(['\\\"`]?)\",\n                rules: {\n                    heredoc: [{\n                        onMatch: function(value, currentState, stack) {\n                            if (value === stack[1]) {\n                                stack.shift();\n                                stack.shift();\n                                this.next = stack[0] || \"start\";\n                                return \"support.class\";\n                            }\n                            this.next = \"\";\n                            return \"string\";\n                        },\n                        regex: \".*$\",\n                        next: \"start\"\n                    }],\n                    indentedHeredoc: [{\n                        token: \"string\",\n                        regex: \"^ +\"\n                    }, {\n                        onMatch: function(value, currentState, stack) {\n                            if (value === stack[1]) {\n                                stack.shift();\n                                stack.shift();\n                                this.next = stack[0] || \"start\";\n                                return \"support.class\";\n                            }\n                            this.next = \"\";\n                            return \"string\";\n                        },\n                        regex: \".*$\",\n                        next: \"start\"\n                    }]\n                }\n            }, {\n                regex: \"$\",\n                token: \"empty\",\n                next: function(currentState, stack) {\n                    if (stack[0] === \"heredoc\" || stack[0] === \"indentedHeredoc\")\n                        return stack[0];\n                    return currentState;\n                }\n            },  {\n                token: \"keyword.operator\",\n                regex: \"!|\\\\$|%|&|\\\\*|/|\\\\-\\\\-|\\\\-|\\\\+\\\\+|\\\\+|~|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|&&|\\\\|\\\\||\\\\?\\\\:|\\\\*=|%=|\\\\+=|\\\\-=|&=|\\\\^=|\\\\||\\\\b(?:in|instanceof|new|delete|typeof|void)\"\n            }, {\n                token: \"paren.lparen\",\n                regex: \"[[({]\"\n            }, {\n                token: \"paren.rparen\",\n                regex: \"[\\\\])}]\",\n                onMatch: function(value, currentState, stack) {\n                    this.next = '';\n                    if (value == \"}\" && stack.length > 1 && stack[1] != \"start\") {\n                        stack.shift();\n                        this.next = stack.shift();\n                    }\n                    return this.token;\n                }\n            }, {\n                token: \"text\",\n                regex: \"\\\\s+\"\n            }, {\n                token: \"punctuation.operator\",\n                regex: /[?:,;.]/\n            }\n        ],\n        \"comment\": [\n            {\n                token: \"comment.multiline\", // closing comment\n                regex: \"^=end(?=$|\\\\s.*$)\",\n                next: \"start\"\n            }, {\n                token: \"comment\", // comment spanning whole line\n                regex: \".+\"\n            }\n        ],\n        \"qStateWithInterpolation\": [{\n            token: \"string.start\",// excluded nested |^% due to difficulty in realization\n            regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === stack[0]) {\n                    stack.unshift(val, state);\n                    return this.token;\n                }\n                return \"string\";\n            }\n        }, {\n            token: \"constant.language.escape\",\n            regex: escapedChars\n        }, {\n            token: \"constant.language.escape\",\n            regex: /\\\\./\n        }, {\n            token: \"paren.start\",\n            regex: /#{/,\n            push: \"start\"\n        }, {\n            token: \"string.end\",\n            regex: /[)\\]>}^|%]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === closeParen[stack[0]]) {\n                    stack.shift();\n                    this.next = stack.shift();\n                    return this.token;\n                }\n                this.next = '';\n                return \"string\";\n            }\n        }, {\n            defaultToken: \"string\"\n        }],\n        \"qStateWithoutInterpolation\": [{\n            token: \"string.start\",// excluded nested |^% due to difficulty in realization\n            regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === stack[0]) {\n                    stack.unshift(val, state);\n                    return this.token;\n                }\n                return \"string\";\n            }\n        }, {\n            token: \"constant.language.escape\",\n            regex: /\\\\['\\\\]/\n        }, {\n            token: \"constant.language.escape\",\n            regex: /\\\\./\n        }, {\n            token: \"string.end\",\n            regex: /[)\\]>}^|%]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === closeParen[stack[0]]) {\n                    stack.shift();\n                    this.next = stack.shift();\n                    return this.token;\n                }\n                this.next = '';\n                return \"string\";\n            }\n        }, {\n            defaultToken: \"string\"\n        }],\n        \"sStateWithoutInterpolation\": [{\n            token: \"constant.other.symbol.ruby\",// excluded nested |^% due to difficulty in realization\n            regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === stack[0]) {\n                    stack.unshift(val, state);\n                    return this.token;\n                }\n                return \"constant.other.symbol.ruby\";\n            }\n        }, {\n            token: \"constant.other.symbol.ruby\",\n            regex: /[)\\]>}^|%]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === closeParen[stack[0]]) {\n                    stack.shift();\n                    this.next = stack.shift();\n                    return this.token;\n                }\n                this.next = '';\n                return \"constant.other.symbol.ruby\";\n            }\n        }, {\n            defaultToken: \"constant.other.symbol.ruby\"\n        }],\n        \"sStateWithInterpolation\": [{\n            token: \"constant.other.symbol.ruby\",// excluded nested |^% due to difficulty in realization\n            regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === stack[0]) {\n                    stack.unshift(val, state);\n                    return this.token;\n                }\n                return \"constant.other.symbol.ruby\";\n            }\n        }, {\n            token: \"constant.language.escape\",\n            regex: escapedChars\n        }, {\n            token: \"constant.language.escape\",\n            regex: /\\\\./\n        }, {\n            token: \"paren.start\",\n            regex: /#{/,\n            push: \"start\"\n        }, {\n            token: \"constant.other.symbol.ruby\",\n            regex: /[)\\]>}^|%]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === closeParen[stack[0]]) {\n                    stack.shift();\n                    this.next = stack.shift();\n                    return this.token;\n                }\n                this.next = '';\n                return \"constant.other.symbol.ruby\";\n            }\n        }, {\n            defaultToken: \"constant.other.symbol.ruby\"\n        }],\n        \"rState\": [{\n            token: \"string.regexp\",// excluded nested |^% due to difficulty in realization\n            regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === stack[0]) {\n                    stack.unshift(val, state);\n                    return this.token;\n                }\n                return \"constant.language.escape\";\n            }\n        }, {\n            token: \"paren.start\",\n            regex: /#{/,\n            push: \"start\"\n        }, {\n            token: \"string.regexp\",\n            regex: /\\//\n        }, {\n            token: \"string.regexp\",\n            regex: /[)\\]>}^|%][imxouesn]*/, onMatch: function (val, state, stack) {\n                if (stack.length && val[0] === closeParen[stack[0]]) {\n                    stack.shift();\n                    this.next = stack.shift();\n                    return this.token;\n                }\n                this.next = '';\n                return \"constant.language.escape\";\n            }\n        },\n            {include: \"regex\"},\n            {\n                defaultToken: \"string.regexp\"\n            }],\n        \"regex\": [\n            {// character classes\n                token: \"regexp.keyword\",\n                regex: /\\\\[wWdDhHsS]/\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\\\[AGbBzZ]/\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\\\g<[a-zA-Z0-9]*>/\n            }, {\n                token: [\"constant.language.escape\", \"regexp.keyword\", \"constant.language.escape\"],\n                regex: /(\\\\p{\\^?)(Alnum|Alpha|Blank|Cntrl|Digit|Graph|Lower|Print|Punct|Space|Upper|XDigit|Word|ASCII|Any|Assigned|Arabic|Armenian|Balinese|Bengali|Bopomofo|Braille|Buginese|Buhid|Canadian_Aboriginal|Carian|Cham|Cherokee|Common|Coptic|Cuneiform|Cypriot|Cyrillic|Deseret|Devanagari|Ethiopic|Georgian|Glagolitic|Gothic|Greek|Gujarati|Gurmukhi|Han|Hangul|Hanunoo|Hebrew|Hiragana|Inherited|Kannada|Katakana|Kayah_Li|Kharoshthi|Khmer|Lao|Latin|Lepcha|Limbu|Linear_B|Lycian|Lydian|Malayalam|Mongolian|Myanmar|New_Tai_Lue|Nko|Ogham|Ol_Chiki|Old_Italic|Old_Persian|Oriya|Osmanya|Phags_Pa|Phoenician|Rejang|Runic|Saurashtra|Shavian|Sinhala|Sundanese|Syloti_Nagri|Syriac|Tagalog|Tagbanwa|Tai_Le|Tamil|Telugu|Thaana|Thai|Tibetan|Tifinagh|Ugaritic|Vai|Yi|Ll|Lm|Lt|Lu|Lo|Mn|Mc|Me|Nd|Nl|Pc|Pd|Ps|Pe|Pi|Pf|Po|No|Sm|Sc|Sk|So|Zs|Zl|Zp|Cc|Cf|Cn|Co|Cs|N|L|M|P|S|Z|C)(})/\n            }, {\n                token: [\"constant.language.escape\", \"invalid\", \"constant.language.escape\"],\n                regex: /(\\\\p{\\^?)([^/]*)(})/\n            }, {// escapes\n                token: \"regexp.keyword.operator\",\n                regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n            }, {// flag\n                token: \"string.regexp\",\n                regex: /[/][imxouesn]*/,\n                next: \"start\"\n            }, {// invalid operators\n                token: \"invalid\",\n                regex: /\\{\\d+\\b,?\\d*\\}[+*]|[+*$^?][+*]|[$^][?]|\\?{3,}/\n            }, {// operators\n                token: \"constant.language.escape\",\n                regex: /\\(\\?(?:[:=!>]|<'?[a-zA-Z]*'?>|<[=!])|\\)|\\{\\d+\\b,?\\d*\\}|[+*]\\?|[()$^+*?.]/\n            }, {\n                token: \"constant.language.delimiter\",\n                regex: /\\|/\n            }, {\n                token: \"regexp.keyword\",\n                regex: /\\[\\[:(?:alnum|alpha|blank|cntrl|digit|graph|lower|print|punct|space|upper|xdigit|word|ascii):\\]\\]/\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\[\\^?/,\n                push: \"regex_character_class\"\n            }, {\n                defaultToken: \"string.regexp\"\n            }\n        ],\n        \"regex_character_class\": [\n            {\n                // character classes\n                token: \"regexp.keyword\",\n                regex: /\\\\[wWdDhHsS]/\n            }, {\n                token: \"regexp.charclass.keyword.operator\",\n                regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n            }, {\n                token: \"constant.language.escape\",\n                regex: /&?&?\\[\\^?/,\n                push: \"regex_character_class\"\n            }, {\n                token: \"constant.language.escape\",\n                regex: \"]\",\n                next: \"pop\"\n            }, {\n                token: \"constant.language.escape\",\n                regex: \"-\"\n            }, {\n                defaultToken: \"string.regexp.characterclass\"\n            }\n        ]\n    };\n\n    this.normalizeRules();\n};\n\noop.inherits(RubyHighlightRules, TextHighlightRules);\n\nexports.RubyHighlightRules = RubyHighlightRules;\n"],"names":[],"sourceRoot":""}