/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 2645:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.inherits = function(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
};

/**
 * Implements mixin properties into the prototype of an object.
 * @template T
 * @param {T} obj - The prototype of the target object.
 * @param {Object} mixin - The source object.
 * @returns {T & Object} The merged prototype.
 */
exports.mixin = function(obj, mixin) {
    for (var key in mixin) {
        obj[key] = mixin[key];
    }
    return obj;
};

/**
 * Implements mixin properties into the prototype of an object.
 * @template T
 * @param {T} proto - The prototype of the target object.
 * @param {Object} mixin - The source object.
 * @returns {T & Object} The merged prototype.
 */
exports.implement = function(proto, mixin) {
    exports.mixin(proto, mixin);
};


/***/ }),

/***/ 4126:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * ## Error Marker extension
 *
 * Provides inline error display functionality for Ace editor. Creates visual error markers that appear as tooltips
 * below editor lines containing annotations (errors, warnings, info). Enables navigation between error locations with
 * keyboard shortcuts and displays context-sensitive messages with proper styling based on annotation severity.
 *
 * @module
 */


var dom = __webpack_require__(71435);
var Range = (__webpack_require__(91902)/* .Range */ .Q);
var nls = (__webpack_require__(76321).nls);

function binarySearch(array, needle, comparator) {
    var first = 0;
    var last = array.length - 1;

    while (first <= last) {
        var mid = (first + last) >> 1;
        var c = comparator(needle, array[mid]);
        if (c > 0)
            first = mid + 1;
        else if (c < 0)
            last = mid - 1;
        else
            return mid;
    }

    // Return the nearest lesser index, "-1" means "0, "-2" means "1", etc.
    return -(first + 1);
}

/**
 * @param {import("../edit_session").EditSession} session
 * @param {number} row
 * @param {number} dir
 */
function findAnnotations(session, row, dir) {
    var annotations = session.getAnnotations().sort(Range.comparePoints);
    if (!annotations.length)
        return;
    
    var i = binarySearch(annotations, {row: row, column: -1}, Range.comparePoints);
    if (i < 0)
        i = -i - 1;
    
    if (i >= annotations.length)
        i = dir > 0 ? 0 : annotations.length - 1;
    else if (i === 0 && dir < 0)
        i = annotations.length - 1;
    
    var annotation = annotations[i];
    if (!annotation || !dir)
        return;

        if (annotation.row === row) {
        do {
            annotation = annotations[i += dir];
        } while (annotation && annotation.row === row);
        if (!annotation)
            return annotations.slice();
    }
    
    
    var matched = [];
    row = annotation.row;
    do {
        matched[dir < 0 ? "unshift" : "push"](annotation);
        annotation = annotations[i += dir];
    } while (annotation && annotation.row == row);
    return matched.length && matched;
}

/**
 * Displays an error marker widget in the editor for annotations at the current cursor position.
 *
 * @param {import("../editor").Editor} editor - The Ace editor instance
 * @param {number} dir - The direction of navigation through annotations (-1 or 1)
 */
exports.showErrorMarker = function(editor, dir) {
    var session = editor.session;
    var pos = editor.getCursorPosition();
    var row = pos.row;
    var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w) {
        return w.type == "errorMarker";
    })[0];
    if (oldWidget) {
        oldWidget.destroy();
    } else {
        row -= dir;
    }
    var annotations = findAnnotations(session, row, dir);
    var gutterAnno;
    if (annotations) {
        var annotation = annotations[0];
        pos.column = (annotation.pos && typeof annotation.column != "number"
            ? annotation.pos.sc
            : annotation.column) || 0;
        pos.row = annotation.row;
        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
    } else if (oldWidget) {
        return;
    } else {
        gutterAnno = {
            displayText: [nls("error-marker.good-state", "Looks good!")],
            className: "ace_ok"
        };
    }
    editor.session.unfold(pos.row);
    editor.selection.moveToPosition(pos);
    
    var w = {
        row: pos.row, 
        fixedWidth: true,
        coverGutter: true,
        el: dom.createElement("div"),
        type: "errorMarker"
    };
    var el = w.el.appendChild(dom.createElement("div"));
    var arrow = w.el.appendChild(dom.createElement("div"));
    arrow.className = "error_widget_arrow " + gutterAnno.className;
    
    var left = editor.renderer.$cursorLayer
        .getPixelPosition(pos).left;
    arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
    
    w.el.className = "error_widget_wrapper";
    el.className = "error_widget " + gutterAnno.className;
    gutterAnno.displayText.forEach(function (annoTextLine, i) {
        el.appendChild(dom.createTextNode(annoTextLine));
        if (i < gutterAnno.displayText.length - 1) {
            el.appendChild(dom.createElement("br"));
        }
    });
    
    el.appendChild(dom.createElement("div"));
    
    var kb = function(_, hashId, keyString) {
        if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
            w.destroy();
            return {command: "null"};
        }
    };
    
    w.destroy = function() {
        if (editor.$mouseHandler.isMousePressed)
            return;
        // @ts-ignore
        editor.keyBinding.removeKeyboardHandler(kb);
        session.widgetManager.removeLineWidget(w);
        editor.off("changeSelection", w.destroy);
        editor.off("changeSession", w.destroy);
        editor.off("mouseup", w.destroy);
        editor.off("change", w.destroy);
    };

    // @ts-ignore
    editor.keyBinding.addKeyboardHandler(kb);
    editor.on("changeSelection", w.destroy);
    editor.on("changeSession", w.destroy);
    editor.on("mouseup", w.destroy);
    editor.on("change", w.destroy);
    
    editor.session.widgetManager.addLineWidget(w);
    
    w.el.onmousedown = editor.focus.bind(editor);
    
    editor.renderer.scrollCursorIntoView(null, 0.5, {bottom: w.el.offsetHeight});
};


dom.importCssString(`
    .error_widget_wrapper {
        background: inherit;
        color: inherit;
        border:none
    }
    .error_widget {
        border-top: solid 2px;
        border-bottom: solid 2px;
        margin: 5px 0;
        padding: 10px 40px;
        white-space: pre-wrap;
    }
    .error_widget.ace_error, .error_widget_arrow.ace_error{
        border-color: #ff5a5a
    }
    .error_widget.ace_warning, .error_widget_arrow.ace_warning{
        border-color: #F1D817
    }
    .error_widget.ace_info, .error_widget_arrow.ace_info{
        border-color: #5a5a5a
    }
    .error_widget.ace_ok, .error_widget_arrow.ace_ok{
        border-color: #5aaa5a
    }
    .error_widget_arrow {
        position: absolute;
        border: solid 5px;
        border-top-color: transparent!important;
        border-right-color: transparent!important;
        border-left-color: transparent!important;
        top: -5px;
    }
`, "error_marker.css", false);


/***/ }),

/***/ 6166:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("../edit_session").EditSession} EditSession
 * @typedef {import("../editor").Editor} Editor
 * @typedef {import("../../ace-internal").Ace.LayerConfig} LayerConfig
 */
/**
 * @typedef {Object} GutterRenderer
 * @property {(session: EditSession, row: number) => string} getText - Gets the text to display for a given row
 * @property {(session: EditSession, lastLineNumber: number, config: Object) => number} getWidth - Calculates the width needed for the gutter
 * @property {(e: undefined, editor: Editor) => void} [update] - Updates the gutter display
 * @property {(editor: Editor) => void} [attach] - Attaches the renderer to an editor
 * @property {(editor: Editor) => void} [detach] - Detaches the renderer from an editor
 */

var dom = __webpack_require__(71435);
var oop = __webpack_require__(2645);
var lang = __webpack_require__(39955);
var EventEmitter = (__webpack_require__(87366).EventEmitter);
var Lines = (__webpack_require__(6406)/* .Lines */ .q);
var nls = (__webpack_require__(76321).nls);

class Gutter{
    /**
     * @param {HTMLElement} parentEl
     */
    constructor(parentEl) {
        this.$showCursorMarker = null;
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_gutter-layer";
        parentEl.appendChild(this.element);
        this.setShowFoldWidgets(this.$showFoldWidgets);

        this.gutterWidth = 0;

        this.$annotations = [];
        this.$updateAnnotations = this.$updateAnnotations.bind(this);

        this.$lines = new Lines(this.element);
        this.$lines.$offsetCoefficient = 1;
    }

    /**
     * @param {EditSession} session
     */
    setSession(session) {
        if (this.session)
            this.session.off("change", this.$updateAnnotations);
        this.session = session;
        if (session)
            session.on("change", this.$updateAnnotations);
    }

    /**
     * @param {number} row
     * @param {string} className
     */
    addGutterDecoration(row, className) {
        if (window.console)
            console.warn && console.warn("deprecated use session.addGutterDecoration");
        this.session.addGutterDecoration(row, className);
    }

    /**
     * @param {number} row
     * @param {string} className
     */
    removeGutterDecoration(row, className) {
        if (window.console)
            console.warn && console.warn("deprecated use session.removeGutterDecoration");
        this.session.removeGutterDecoration(row, className);
    }

    /**
     * @param {any[]} annotations
     */
    setAnnotations(annotations) {
        // iterate over sparse array
        this.$annotations = [];
        for (var i = 0; i < annotations.length; i++) {
            var annotation = annotations[i];
            var row = annotation.row;
            var rowInfo = this.$annotations[row];
            if (!rowInfo)
                rowInfo = this.$annotations[row] = {text: [], type: [], displayText: []};
           
            var annoText = annotation.text;
            var displayAnnoText = annotation.text;
            var annoType = annotation.type;
            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";
            displayAnnoText = displayAnnoText ? displayAnnoText : annotation.html || "";

            if (rowInfo.text.indexOf(annoText) === -1){
                rowInfo.text.push(annoText);
                rowInfo.type.push(annoType);
                rowInfo.displayText.push(displayAnnoText);
            }

            var className = annotation.className;
            if (className) {
                rowInfo.className = className;
            } else if (annoType === "error") {
                rowInfo.className = " ace_error";
            } else if (annoType === "security" && !/\bace_error\b/.test(rowInfo.className)) {
                rowInfo.className = " ace_security";
            } else if (annoType === "warning" && !/\bace_(error|security)\b/.test(rowInfo.className)) {
                rowInfo.className = " ace_warning";
            } else if (annoType === "info" && !rowInfo.className) {
                rowInfo.className = " ace_info";
            } else if (annoType === "hint" && !rowInfo.className) {
                rowInfo.className = " ace_hint";
            }
        }
    }

    /**
     * @param {import("../../ace-internal").Ace.Delta} delta
     */
    $updateAnnotations(delta) {
        if (!this.$annotations.length)
            return;
        var firstRow = delta.start.row;
        var len = delta.end.row - firstRow;
        if (len === 0) {
            // do nothing
        } else if (delta.action == 'remove') {
            this.$annotations.splice(firstRow, len + 1, null);
        } else {
            var args = new Array(len + 1);
            args.unshift(firstRow, 1);
            this.$annotations.splice.apply(this.$annotations, args);
        }
    }

    /**
     * @param {LayerConfig} config
     */
    update(config) {
        this.config = config;
        
        var session = this.session;
        var firstRow = config.firstRow;
        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar
            session.getLength() - 1);
            
        this.oldLastRow = lastRow;
        this.config = config;
        
        this.$lines.moveContainer(config);
        this.$updateCursorRow();
            
        var fold = session.getNextFoldLine(firstRow);
        var foldStart = fold ? fold.start.row : Infinity;

        var cell = null;
        var index = -1;
        var row = firstRow;
        
        while (true) {
            if (row > foldStart) {
                row = fold.end.row + 1;
                fold = session.getNextFoldLine(row, fold);
                foldStart = fold ? fold.start.row : Infinity;
            }
            if (row > lastRow) {
                while (this.$lines.getLength() > index + 1)
                    this.$lines.pop();
                    
                break;
            }

            cell = this.$lines.get(++index);
            if (cell) {
                cell.row = row;
            } else {
                cell = this.$lines.createCell(row, config, this.session, onCreateCell);
                this.$lines.push(cell);
            }

            this.$renderCell(cell, config, fold, row);
            row++;
        }
        
        this._signal("afterRender");
        this.$updateGutterWidth(config);
        
        if (this.$showCursorMarker && this.$highlightGutterLine)
            this.$updateCursorMarker();
    }

    /**
     * @param {LayerConfig} config
     */
    $updateGutterWidth(config) {
        var session = this.session;
        
        var gutterRenderer = session.gutterRenderer || this.$renderer;
        
        var firstLineNumber = session.$firstLineNumber;
        var lastLineText = this.$lines.last() ? this.$lines.last().text : "";
        
        if (this.$fixedWidth || session.$useWrapMode)
            lastLineText = session.getLength() + firstLineNumber - 1;

        var gutterWidth = gutterRenderer 
            ? gutterRenderer.getWidth(session, lastLineText, config)
            : lastLineText.toString().length * config.characterWidth;
        
        var padding = this.$padding || this.$computePadding();
        gutterWidth += padding.left + padding.right;
        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
            this.gutterWidth = gutterWidth;
            /**@type{any}*/(this.element.parentNode).style.width = 
            this.element.style.width = Math.ceil(this.gutterWidth) + "px";
            this._signal("changeGutterWidth", gutterWidth);
        }
    }
    
    $updateCursorRow() {
        if (!this.$highlightGutterLine)
            return;
            
        var position = this.session.selection.getCursor();
        if (this.$cursorRow === position.row)
            return;
        
        this.$cursorRow = position.row;
    }
    
    updateLineHighlight() {
        if (this.$showCursorMarker)
            this.$updateCursorMarker();

        if (!this.$highlightGutterLine)
            return;
        var row = this.session.selection.cursor.row;
        this.$cursorRow = row;

        if (this.$cursorCell && this.$cursorCell.row == row)
            return;
        if (this.$cursorCell)
            this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
        var cells = this.$lines.cells;
        this.$cursorCell = null;
        for (var i = 0; i < cells.length; i++) {
            var cell = cells[i];
            if (cell.row >= this.$cursorRow) {
                if (cell.row > this.$cursorRow) {
                    var fold = this.session.getFoldLine(this.$cursorRow);
                    if (i > 0 && fold && fold.start.row == cells[i - 1].row)
                        cell = cells[i - 1];
                    else
                        break;
                }
                cell.element.className = "ace_gutter-active-line " + cell.element.className;
                this.$cursorCell = cell;
                break;
            }
        }
    }

    $updateCursorMarker() {
        if (!this.session)
            return;
        var session = this.session;
        if (!this.$highlightElement) {
            this.$highlightElement = dom.createElement("div");
            this.$highlightElement.className = "ace_gutter-cursor";
            this.$highlightElement.style.pointerEvents = "none";
            this.element.appendChild(this.$highlightElement);
        }
        var pos = session.selection.cursor;
        var config = this.config;
        var lines = this.$lines;

        var screenTop = config.firstRowScreen * config.lineHeight;
        var screenPage = Math.floor(screenTop / lines.canvasHeight);
        var lineTop = session.documentToScreenRow(pos) * config.lineHeight;
        var top = lineTop - (screenPage * lines.canvasHeight);

        dom.setStyle(this.$highlightElement.style, "height", config.lineHeight + "px");
        dom.setStyle(this.$highlightElement.style, "top", top + "px");
    }

    /**
     * @param {LayerConfig} config
     */
    scrollLines(config) {
        var oldConfig = this.config;
        this.config = config;
        
        this.$updateCursorRow();
        if (this.$lines.pageChanged(oldConfig, config))
            return this.update(config);
        
        this.$lines.moveContainer(config);

        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar
            this.session.getLength() - 1);
        var oldLastRow = this.oldLastRow;
        this.oldLastRow = lastRow;
        
        if (!oldConfig || oldLastRow < config.firstRow)
            return this.update(config);

        if (lastRow < oldConfig.firstRow)
            return this.update(config);

        if (oldConfig.firstRow < config.firstRow)
            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)
                this.$lines.shift();

        if (oldLastRow > lastRow)
            for (var row=this.session.getFoldedRowCount(lastRow + 1, oldLastRow); row>0; row--)
                this.$lines.pop();

        if (config.firstRow < oldConfig.firstRow) {
            this.$lines.unshift(this.$renderLines(config, config.firstRow, oldConfig.firstRow - 1));
        }

        if (lastRow > oldLastRow) {
            this.$lines.push(this.$renderLines(config, oldLastRow + 1, lastRow));
        }
        
        this.updateLineHighlight();
        
        this._signal("afterRender");
        this.$updateGutterWidth(config);
    }

    /**
     * @param {LayerConfig} config
     * @param {number} firstRow
     * @param {number} lastRow
     */
    $renderLines(config, firstRow, lastRow) {
        var fragment = [];
        var row = firstRow;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > lastRow)
                break;

            var cell = this.$lines.createCell(row, config, this.session, onCreateCell);
            this.$renderCell(cell, config, foldLine, row);
            fragment.push(cell);

            row++;
        }
        return fragment;
    }


    /**
     * @param {any} cell
     * @param {LayerConfig} config
     * @param {import("../../ace-internal").Ace.IRange | undefined} fold
     * @param {number} row
     */
    $renderCell(cell, config, fold, row) {
        var element = cell.element;
        
        var session = this.session;
        
        var textNode = element.childNodes[0];
        var foldWidget = element.childNodes[1];
        var annotationNode = element.childNodes[2];
        var customWidget = element.childNodes[3];
        var annotationIconNode = annotationNode.firstChild;

        var firstLineNumber = session.$firstLineNumber;
        
        var breakpoints = session.$breakpoints;
        var decorations = session.$decorations;
        var gutterRenderer = session.gutterRenderer || this.$renderer;
        var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
        var foldStart = fold ? fold.start.row : Number.MAX_VALUE;
        
        var lineHeight = config.lineHeight + "px";

        var className = this.$useSvgGutterIcons ? "ace_gutter-cell_svg-icons " : "ace_gutter-cell ";
        var iconClassName = this.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon";
        
        var rowText = (gutterRenderer
            ? gutterRenderer.getText(session, row)
            : row + firstLineNumber).toString();

        if (this.$highlightGutterLine) {
            if (row == this.$cursorRow || (fold && row < this.$cursorRow && row >= foldStart &&  this.$cursorRow <= fold.end.row)) {
                className += "ace_gutter-active-line ";
                if (this.$cursorCell != cell) {
                    if (this.$cursorCell)
                        this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
                    this.$cursorCell = cell;
                }
            }
        }
        
        if (breakpoints[row])
            className += breakpoints[row];
        if (decorations[row])
            className += decorations[row];
        if (this.$annotations[row] && row !== foldStart)
            className += this.$annotations[row].className;

        if (foldWidgets) {
            var c = foldWidgets[row];
            // check if cached value is invalidated and we need to recompute
            if (c == null)
                c = foldWidgets[row] = session.getFoldWidget(row);
        }

        if (c) {
            var foldClass = "ace_fold-widget ace_" + c;
            var isClosedFold = c == "start" && row == foldStart && row < fold.end.row;
            if (isClosedFold) {
                foldClass += " ace_closed";
                var foldAnnotationClass = "";
                var annotationInFold = false;

                for (var i = row + 1; i <= fold.end.row; i++) {
                    if (!this.$annotations[i]) continue;

                    if (this.$annotations[i].className === " ace_error") {
                        annotationInFold = true;
                        foldAnnotationClass = " ace_error_fold";
                        break;
                    }

                    if (this.$annotations[i].className === " ace_security") {
                        annotationInFold = true;
                        foldAnnotationClass = " ace_security_fold";
                    } else if (
                        this.$annotations[i].className === " ace_warning" &&
                        foldAnnotationClass !== " ace_security_fold"
                    ) {
                        annotationInFold = true;
                        foldAnnotationClass = " ace_warning_fold";
                    }
                }

                className += foldAnnotationClass;
            }
            else
                foldClass += " ace_open";
            if (foldWidget.className != foldClass)
                foldWidget.className = foldClass;

            dom.setStyle(foldWidget.style, "height", lineHeight);
            dom.setStyle(foldWidget.style, "display", "inline-block");

            // Set a11y properties.
            foldWidget.setAttribute("role", "button");
            foldWidget.setAttribute("tabindex", "-1");

            var foldRange = session.getFoldWidgetRange(row);

            // getFoldWidgetRange is optional to be implemented by fold modes, if not available we fall-back.
            if (foldRange)
                foldWidget.setAttribute(
                    "aria-label",
                    nls("gutter.code-folding.range.aria-label", "Toggle code folding, rows $0 through $1", [
                        foldRange.start.row + 1,
                        foldRange.end.row + 1
                    ])
                );
            else {
                if (fold)
                    foldWidget.setAttribute(
                        "aria-label",
                        nls("gutter.code-folding.closed.aria-label", "Toggle code folding, rows $0 through $1", [
                            fold.start.row + 1,
                            fold.end.row + 1
                        ])
                    );
                else
                    foldWidget.setAttribute(
                        "aria-label",
                        nls("gutter.code-folding.open.aria-label", "Toggle code folding, row $0", [row + 1])
                    );
            }

            if (isClosedFold) {
                foldWidget.setAttribute("aria-expanded", "false");
                foldWidget.setAttribute("title", nls("gutter.code-folding.closed.title", "Unfold code"));
            } else {
                foldWidget.setAttribute("aria-expanded", "true");
                foldWidget.setAttribute("title", nls("gutter.code-folding.open.title", "Fold code"));
            }
        } else {
            if (foldWidget) {
                dom.setStyle(foldWidget.style, "display", "none");
                foldWidget.setAttribute("tabindex", "0");
                foldWidget.removeAttribute("role");
                foldWidget.removeAttribute("aria-label");
            }
        }
        // fold logic ends here 
        const customWidgetAttributes = this.session.$gutterCustomWidgets[row];
        if (customWidgetAttributes) {
            this.$addCustomWidget(row, customWidgetAttributes,cell);
        }
        else if (customWidget){
            this.$removeCustomWidget(row,cell);
        }

        if (annotationInFold && this.$showFoldedAnnotations){
            annotationNode.className = "ace_gutter_annotation";
            annotationIconNode.className = iconClassName;
            annotationIconNode.className += foldAnnotationClass;

            dom.setStyle(annotationIconNode.style, "height", lineHeight);
            dom.setStyle(annotationNode.style, "display", "block");
            dom.setStyle(annotationNode.style, "height", lineHeight);
            var ariaLabel;
            switch(foldAnnotationClass) {
                case " ace_error_fold":
                    ariaLabel = nls("gutter.annotation.aria-label.error", "Error, read annotations row $0", [rowText]);
                    break;

                case " ace_security_fold":
                    ariaLabel = nls("gutter.annotation.aria-label.security", "Security finding, read annotations row $0", [rowText]);
                    break;

                case " ace_warning_fold":
                    ariaLabel = nls("gutter.annotation.aria-label.warning", "Warning, read annotations row $0", [rowText]);
                    break;
            }
            annotationNode.setAttribute("aria-label", ariaLabel);
            annotationNode.setAttribute("tabindex", "-1");
            annotationNode.setAttribute("role", "button");
        }
        else if (this.$annotations[row]){
            annotationNode.className = "ace_gutter_annotation";
            annotationIconNode.className = iconClassName;

            if (this.$useSvgGutterIcons)
                annotationIconNode.className += this.$annotations[row].className;
            else 
                element.classList.add(this.$annotations[row].className.replace(" ", ""));

            dom.setStyle(annotationIconNode.style, "height", lineHeight);
            dom.setStyle(annotationNode.style, "display", "block");
            dom.setStyle(annotationNode.style, "height", lineHeight);
            var ariaLabel;
            switch(this.$annotations[row].className) {
                case " ace_error":
                    ariaLabel = nls("gutter.annotation.aria-label.error", "Error, read annotations row $0", [rowText]);
                    break;

                case " ace_security":
                    ariaLabel = nls("gutter.annotation.aria-label.security", "Security finding, read annotations row $0", [rowText]);
                    break;

                case " ace_warning":
                    ariaLabel = nls("gutter.annotation.aria-label.warning", "Warning, read annotations row $0", [rowText]);
                    break;

                case " ace_info":
                    ariaLabel = nls("gutter.annotation.aria-label.info", "Info, read annotations row $0", [rowText]);
                    break;

                case " ace_hint":
                    ariaLabel = nls("gutter.annotation.aria-label.hint", "Suggestion, read annotations row $0", [rowText]);
                    break;
            }
            annotationNode.setAttribute("aria-label", ariaLabel);
            annotationNode.setAttribute("tabindex", "-1");
            annotationNode.setAttribute("role", "button");
        }
        else {
            dom.setStyle(annotationNode.style, "display", "none");
            annotationNode.removeAttribute("aria-label");
            annotationNode.removeAttribute("role");
            annotationNode.setAttribute("tabindex", "0");
        }
        if (rowText !== textNode.data) {
            textNode.data = rowText;
        } 

        if (element.className != className)
            element.className = className;
        dom.setStyle(cell.element.style, "height", this.$lines.computeLineHeight(row, config, session) + "px");
        dom.setStyle(cell.element.style, "top", this.$lines.computeLineTop(row, config, session) + "px");
        
        cell.text = rowText;

        // If there are no annotations or fold widgets in the gutter cell, hide it from assistive tech.
        if (annotationNode.style.display === "none" && foldWidget.style.display === "none" && !customWidgetAttributes)
            cell.element.setAttribute("aria-hidden", true);
        else
            cell.element.setAttribute("aria-hidden", false);
        
        return cell;
    }

    /**
     * @param {boolean} highlightGutterLine
     */
    setHighlightGutterLine(highlightGutterLine) {
        this.$highlightGutterLine = highlightGutterLine;
        if (!highlightGutterLine && this.$highlightElement) {
            this.$highlightElement.remove();
            this.$highlightElement = null;
        }
    }

    /**
     * @param {boolean} show
     */
    setShowLineNumbers(show) {
        /**@type{GutterRenderer}*/
        this.$renderer = !show && {
            getWidth: function() {return 0;},
            getText: function() {return "";}
        };
    }
    
    getShowLineNumbers() {
        return this.$showLineNumbers;
    }

    /**
     * @param {boolean} [show]
     */
    setShowFoldWidgets(show) {
        if (show)
            dom.addCssClass(this.element, "ace_folding-enabled");
        else
            dom.removeCssClass(this.element, "ace_folding-enabled");

        this.$showFoldWidgets = show;
        this.$padding = null;
    }
    
    getShowFoldWidgets() {
        return this.$showFoldWidgets;
    }
    
    /**
     * Hides the fold widget/icon from a specific row in the gutter
     * @param {number} row The row number from which to hide the fold icon
     * @param {any} cell - Gutter cell 
     * @experimental
     */
    $hideFoldWidget(row, cell) {
        const rowCell = cell || this.$getGutterCell(row);
        if (rowCell && rowCell.element) {
            const foldWidget = rowCell.element.childNodes[1];
            if (foldWidget) {
                dom.setStyle(foldWidget.style, "display", "none");
            }
        }
    }

    /**
     * Shows the fold widget/icon from a specific row in the gutter
     * @param {number} row The row number from which to show the fold icon
     * @param {any} cell - Gutter cell 
     * @experimental
     */
    $showFoldWidget(row,cell) {
        const rowCell = cell || this.$getGutterCell(row);
        if (rowCell && rowCell.element) {
            const foldWidget = rowCell.element.childNodes[1];
            if (foldWidget && this.session.foldWidgets && this.session.foldWidgets[rowCell.row]) {
                dom.setStyle(foldWidget.style, "display", "inline-block");
            }
        }
    }

    /**
    * Retrieves the gutter cell element at the specified cursor row position.
    * @param {number} row - The row number in the editor where the gutter cell is located starts from 0
    * @returns {HTMLElement|undefined} The gutter cell element at the specified row, or undefined if not found
    * @experimental
    */
    $getGutterCell(row) {
        var cells = this.$lines.cells;
        var min = 0;
        var max = cells.length - 1;
        
        if (row < cells[0].row || row > cells[max].row)
            return;

        while (min <= max) {
            var mid = Math.floor((min + max) / 2);
            var cell = cells[mid];
            if (cell.row > row) {
                max = mid - 1;
            } else if (cell.row < row) {
                min = mid + 1;
            } else {
                return cell;
            }
        }
        return cell;
    }

    /**
    * Displays a custom widget for a specific row
    * @param {number} row - The row number where the widget will be displayed
    * @param {Object} attributes - Configuration attributes for the widget
    * @param {string} attributes.className - CSS class name for styling the widget
    * @param {string} attributes.label - Text label to display in the widget
    * @param {string} attributes.title - Tooltip text for the widget
    * @param {Object} attributes.callbacks - Event callback functions for the widget e.g onClick; 
    * @param {any} cell - Gutter cell 
    * @returns {void}
    * @experimental
    */
    $addCustomWidget(row, {className, label, title, callbacks}, cell) {
        this.session.$gutterCustomWidgets[row] = {className, label, title, callbacks};
        this.$hideFoldWidget(row,cell);

        // cell is required because when cached cell is used to render, $lines won't have that cell
        const rowCell = cell || this.$getGutterCell(row);
        if (rowCell && rowCell.element) {
            let customWidget = rowCell.element.querySelector(".ace_custom-widget");
            // deleting the old custom widget to remove the old click event listener
            if (customWidget) {
                customWidget.remove();
            }

            customWidget = dom.createElement("span");
            customWidget.className = `ace_custom-widget ${className}`;
            customWidget.setAttribute("tabindex", "-1");
            customWidget.setAttribute("role", 'button');
            customWidget.setAttribute("aria-label", label);
            customWidget.setAttribute("title", title);
            dom.setStyle(customWidget.style, "display", "inline-block");
            dom.setStyle(customWidget.style, "height", "inherit");
            
            if (callbacks&& callbacks.onClick) {
                customWidget.addEventListener("click", (e) => {
                    callbacks.onClick(e, row);
                    e.stopPropagation();
                });
            }

            rowCell.element.appendChild(customWidget);
        }
    }
    
    /**
    * Remove a custom widget for a specific row
    * @param {number} row - The row number where the widget will be removed
    * @param {any} cell - Gutter cell 
    * @returns {void}
    * @experimental
    */
    $removeCustomWidget(row, cell) {
        delete this.session.$gutterCustomWidgets[row];
        this.$showFoldWidget(row,cell);

        // cell is required because when cached cell is used to render, $lines won't have that cell
        const rowCell = cell || this.$getGutterCell(row);
        if (rowCell && rowCell.element) {
            const customWidget = rowCell.element.querySelector(".ace_custom-widget");
            if (customWidget) {
                rowCell.element.removeChild(customWidget);
            }
        }
    }

    $computePadding() {
        if (!this.element.firstChild)
            return {left: 0, right: 0};
        var style = dom.computedStyle(/**@type{Element}*/(this.element.firstChild));
        this.$padding = {};
        this.$padding.left = (parseInt(style.borderLeftWidth) || 0)
            + (parseInt(style.paddingLeft) || 0) + 1;
        this.$padding.right = (parseInt(style.borderRightWidth) || 0)
            + (parseInt(style.paddingRight) || 0);
        return this.$padding;
    }

    /**
     * @param {{ x: number; }} point
     */
    getRegion(point) {
        var padding = this.$padding || this.$computePadding();
        var rect = this.element.getBoundingClientRect();
        if (point.x < padding.left + rect.left)
            return "markers";
        if (this.$showFoldWidgets && point.x > rect.right - padding.right)
            return "foldWidgets";
    }

}

Gutter.prototype.$fixedWidth = false;
Gutter.prototype.$highlightGutterLine = true;
Gutter.prototype.$renderer = undefined;
Gutter.prototype.$showLineNumbers = true;
Gutter.prototype.$showFoldWidgets = true;

oop.implement(Gutter.prototype, EventEmitter);

function onCreateCell(element) {
    var textNode = document.createTextNode('');
    element.appendChild(textNode);
    
    var foldWidget = dom.createElement("span");
    element.appendChild(foldWidget);

    var annotationNode = dom.createElement("span");
    element.appendChild(annotationNode);

    var annotationIconNode = dom.createElement("span");
    annotationNode.appendChild(annotationIconNode);
    
    return element;
}

exports.W = Gutter;


/***/ }),

/***/ 6406:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("../edit_session").EditSession} EditSession
 * @typedef {import("../../ace-internal").Ace.LayerConfig} LayerConfig
 */
var dom = __webpack_require__(71435);

class Lines {
    /**
     * @param {HTMLElement} element
     * @param {number} [canvasHeight]
     */
    constructor(element, canvasHeight) {
        this.element = element;
        this.canvasHeight = canvasHeight || 500000;
        this.element.style.height = (this.canvasHeight * 2) + "px";

        this.cells = [];
        this.cellCache = [];
        this.$offsetCoefficient = 0;
    }

    /**
     * @param {LayerConfig} config
     */
    moveContainer(config) {
        dom.translate(this.element, 0, -((config.firstRowScreen * config.lineHeight) % this.canvasHeight) - config.offset * this.$offsetCoefficient);
    }

    /**
     * @param {LayerConfig} oldConfig
     * @param {LayerConfig} newConfig
     */
    pageChanged(oldConfig, newConfig) {
        return (
            Math.floor((oldConfig.firstRowScreen * oldConfig.lineHeight) / this.canvasHeight) !==
            Math.floor((newConfig.firstRowScreen * newConfig.lineHeight) / this.canvasHeight)
        );
    }

    /**
     * @param {number} row
     * @param {Partial<LayerConfig>} config
     * @param {EditSession} session
     */
    computeLineTop(row, config, session) {
        var screenTop = config.firstRowScreen * config.lineHeight;
        var screenPage = Math.floor(screenTop / this.canvasHeight);
        var lineTop = session.documentToScreenRow(row, 0) * config.lineHeight;
        return lineTop - (screenPage * this.canvasHeight);
    }

    /**
     * @param {number} row
     * @param {LayerConfig} config
     * @param {EditSession} session
     */
    computeLineHeight(row, config, session) {
        return config.lineHeight * session.getRowLineCount(row);
    }
    
    getLength() {
        return this.cells.length;
    }

    /**
     * @param {number} index
     */
    get(index) {
        return this.cells[index];
    }
    
    shift() {
        this.$cacheCell(this.cells.shift());
    }
    
    pop() {
        this.$cacheCell(this.cells.pop());
    }
    
    push(cell) {
        if (Array.isArray(cell)) {
            this.cells.push.apply(this.cells, cell);
            var fragment = dom.createFragment(this.element);
            for (var i=0; i<cell.length; i++) {
                fragment.appendChild(cell[i].element);
            }
            this.element.appendChild(fragment);
        } else {
            this.cells.push(cell);
            this.element.appendChild(cell.element);
        }
    }
    
    unshift(cell) {
        if (Array.isArray(cell)) {
            this.cells.unshift.apply(this.cells, cell);
            var fragment = dom.createFragment(this.element);
            for (var i=0; i<cell.length; i++) {
                fragment.appendChild(cell[i].element);
            }
            if (this.element.firstChild)
                this.element.insertBefore(fragment, this.element.firstChild);
            else
                this.element.appendChild(fragment);
        } else {
            this.cells.unshift(cell);
            this.element.insertAdjacentElement("afterbegin", cell.element);
        }
    }
    
    last() {
        if (this.cells.length)
            return this.cells[this.cells.length-1];
        else
            return null;
    }
    
    $cacheCell(cell) {
        if (!cell)
            return;
            
        cell.element.remove();
        this.cellCache.push(cell);
    }
    
    createCell(row, config, session, initElement) {
        var cell = this.cellCache.pop();
        if (!cell) {
            var element = dom.createElement("div");
            if (initElement)
                initElement(element);
            
            this.element.appendChild(element);
            
            cell = {
                element: element,
                text: "",
                row: row
            };
        }
        cell.row = row;
        
        return cell;
    }
    
}

exports.q = Lines;


/***/ }),

/***/ 6672:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// generated by tool/unicode.js
var wordChars = [48,9,8,25,5,0,2,25,48,0,11,0,5,0,6,22,2,30,2,457,5,11,15,4,8,0,2,0,18,116,2,1,3,3,9,0,2,2,2,0,2,19,2,82,2,138,2,4,3,155,12,37,3,0,8,38,10,44,2,0,2,1,2,1,2,0,9,26,6,2,30,10,7,61,2,9,5,101,2,7,3,9,2,18,3,0,17,58,3,100,15,53,5,0,6,45,211,57,3,18,2,5,3,11,3,9,2,1,7,6,2,2,2,7,3,1,3,21,2,6,2,0,4,3,3,8,3,1,3,3,9,0,5,1,2,4,3,11,16,2,2,5,5,1,3,21,2,6,2,1,2,1,2,1,3,0,2,4,5,1,3,2,4,0,8,3,2,0,8,15,12,2,2,8,2,2,2,21,2,6,2,1,2,4,3,9,2,2,2,2,3,0,16,3,3,9,18,2,2,7,3,1,3,21,2,6,2,1,2,4,3,8,3,1,3,2,9,1,5,1,2,4,3,9,2,0,17,1,2,5,4,2,2,3,4,1,2,0,2,1,4,1,4,2,4,11,5,4,4,2,2,3,3,0,7,0,15,9,18,2,2,7,2,2,2,22,2,9,2,4,4,7,2,2,2,3,8,1,2,1,7,3,3,9,19,1,2,7,2,2,2,22,2,9,2,4,3,8,2,2,2,3,8,1,8,0,2,3,3,9,19,1,2,7,2,2,2,22,2,15,4,7,2,2,2,3,10,0,9,3,3,9,11,5,3,1,2,17,4,23,2,8,2,0,3,6,4,0,5,5,2,0,2,7,19,1,14,57,6,14,2,9,40,1,2,0,3,1,2,0,3,0,7,3,2,6,2,2,2,0,2,0,3,1,2,12,2,2,3,4,2,0,2,5,3,9,3,1,35,0,24,1,7,9,12,0,2,0,2,0,5,9,2,35,5,19,2,5,5,7,2,35,10,0,58,73,7,77,3,37,11,42,2,0,4,328,2,3,3,6,2,0,2,3,3,40,2,3,3,32,2,3,3,6,2,0,2,3,3,14,2,56,2,3,3,66,5,0,33,15,17,84,13,619,3,16,2,25,6,74,22,12,2,6,12,20,12,19,13,12,2,2,2,1,13,51,3,29,4,0,5,1,3,9,34,2,3,9,7,87,9,42,6,69,11,28,4,11,5,11,11,39,3,4,12,43,5,25,7,10,38,27,5,62,2,28,3,10,7,9,14,0,89,75,5,9,18,8,13,42,4,11,71,55,9,9,4,48,83,2,2,30,14,230,23,280,3,5,3,37,3,5,3,7,2,0,2,0,2,0,2,30,3,52,2,6,2,0,4,2,2,6,4,3,3,5,5,12,6,2,2,6,67,1,20,0,29,0,14,0,17,4,60,12,5,0,4,11,18,0,5,0,3,9,2,0,4,4,7,0,2,0,2,0,2,3,2,10,3,3,6,4,5,0,53,1,2684,46,2,46,2,132,7,6,15,37,11,53,10,0,17,22,10,6,2,6,2,6,2,6,2,6,2,6,2,6,2,6,2,31,48,0,470,1,36,5,2,4,6,1,5,85,3,1,3,2,2,89,2,3,6,40,4,93,18,23,57,15,513,6581,75,20939,53,1164,68,45,3,268,4,27,21,31,3,13,13,1,2,24,9,69,11,1,38,8,3,102,3,1,111,44,25,51,13,68,12,9,7,23,4,0,5,45,3,35,13,28,4,64,15,10,39,54,10,13,3,9,7,22,4,1,5,66,25,2,227,42,2,1,3,9,7,11171,13,22,5,48,8453,301,3,61,3,105,39,6,13,4,6,11,2,12,2,4,2,0,2,1,2,1,2,107,34,362,19,63,3,53,41,11,5,15,17,6,13,1,25,2,33,4,2,134,20,9,8,25,5,0,2,25,12,88,4,5,3,5,3,5,3,2];

var code = 0;
var str = [];
for (var i = 0; i < wordChars.length; i += 2) {
    str.push(code += wordChars[i]);
    if (wordChars[i + 1])
        str.push(45, code += wordChars[i + 1]);
}

exports.wordChars = String.fromCharCode.apply(null, str);


/***/ }),

/***/ 10464:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./layer/marker").Marker} Marker
 * @typedef {import("./edit_session").EditSession} EditSession
 */
var lang = __webpack_require__(39955);
var Range = (__webpack_require__(91902)/* .Range */ .Q);

class SearchHighlight {
    /**
     * @param {any} regExp
     * @param {string} clazz
     */
    constructor(regExp, clazz, type = "text") {
        this.setRegexp(regExp);
        this.clazz = clazz;
        this.type = type;
        this.docLen = 0;
    }

    setRegexp(regExp) {
        if (this.regExp+"" == regExp+"")
            return;
        this.regExp = regExp;
        this.cache = [];
    }

    /**
     * @param {any} html
     * @param {Marker} markerLayer
     * @param {EditSession} session
     * @param {Partial<import("../ace-internal").Ace.LayerConfig>} config
     */
    update(html, markerLayer, session, config) {
        if (!this.regExp)
            return;
        var start = config.firstRow;
        var end = config.lastRow;
        var renderedMarkerRanges = {};
        var _search = session.$editor && session.$editor.$search;
        var mtSearch = _search && _search.$isMultilineSearch(session.$editor.getLastSearchOptions());

        for (var i = start; i <= end; i++) {
            var ranges = this.cache[i];
            if (ranges == null || session.getValue().length != this.docLen) {
                if (mtSearch) {
                    ranges = [];
                    var match = _search.$multiLineForward(session, this.regExp, i, end);
                    if (match) {
                        var end_row = match.endRow <= end ? match.endRow - 1 : end;
                        if (end_row > i)
                            i = end_row;
                        ranges.push(new Range(match.startRow, match.startCol, match.endRow, match.endCol));
                    }
                    if (ranges.length > this.MAX_RANGES)
                        ranges = ranges.slice(0, this.MAX_RANGES);
                }
                else {
                    ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                    if (ranges.length > this.MAX_RANGES)
                        ranges = ranges.slice(0, this.MAX_RANGES);
                    ranges = ranges.map(function(match) {
                        return new Range(i, match.offset, i, match.offset + match.length);
                    });
                }
                this.cache[i] = ranges.length ? ranges : "";
            }

            if (ranges.length === 0) continue;

            for (var j = ranges.length; j --; ) {
                var rangeToAddMarkerTo = ranges[j].toScreenRange(session);
                var rangeAsString = rangeToAddMarkerTo.toString();
                if (renderedMarkerRanges[rangeAsString]) continue;

                renderedMarkerRanges[rangeAsString] = true;
                markerLayer.drawSingleLineMarker(
                    html, rangeToAddMarkerTo, this.clazz, config);
            }
        }
        this.docLen = session.getValue().length;
    }
}

// needed to prevent long lines from freezing the browser
SearchHighlight.prototype.MAX_RANGES = 500;

exports.V = SearchHighlight;


/***/ }),

/***/ 10694:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("../../ace-internal").Ace.LayerConfig} LayerConfig
 * @typedef {import("../edit_session").EditSession} EditSession
 */
var oop = __webpack_require__(2645);
var dom = __webpack_require__(71435);
var lang = __webpack_require__(39955);
var Lines = (__webpack_require__(6406)/* .Lines */ .q);
var EventEmitter = (__webpack_require__(87366).EventEmitter);
var nls = (__webpack_require__(76321).nls);
const isTextToken = (__webpack_require__(41109)/* .isTextToken */ .t);

class Text {
    /**
     * @param {HTMLElement} parentEl
     */
    constructor(parentEl) {
        this.dom = dom;
        this.element = this.dom.createElement("div");
        this.element.className = "ace_layer ace_text-layer";
        parentEl.appendChild(this.element);
        this.$updateEolChar = this.$updateEolChar.bind(this);
        this.$lines = new Lines(this.element);
    }
    
    $updateEolChar() {
        var doc = this.session.doc;
        var unixMode = doc.getNewLineCharacter() == "\n" && doc.getNewLineMode() != "windows";
        var EOL_CHAR = unixMode ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
        if (this.EOL_CHAR != EOL_CHAR) {
            this.EOL_CHAR = EOL_CHAR;
            return true;
        }
    }

    /**
     * @param {number} padding
     */
    setPadding(padding) {
        this.$padding = padding;
        this.element.style.margin = "0 " + padding + "px";
    }
    
    /**
     * @returns {number}
     */
    getLineHeight() {
        return this.$fontMetrics.$characterSize.height || 0;
    }

    /**
     * @returns {number}
     */
    getCharacterWidth() {
        return this.$fontMetrics.$characterSize.width || 0;
    }

    /**
     * @param {any} measure
     */
    $setFontMetrics(measure) {
        this.$fontMetrics = measure;
        this.$fontMetrics.on("changeCharacterSize",
            /**
             * @this {Text}
             */
            function (e) {
                this._signal("changeCharacterSize", e);
        }.bind(this));
        this.$pollSizeChanges();
    }

    checkForSizeChanges() {
        this.$fontMetrics.checkForSizeChanges();
    }
    $pollSizeChanges() {
        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
    }

    /**
     * @param {EditSession} session
     */
    setSession(session) {
        /**@type {EditSession}*/
        this.session = session;
        if (session)
            this.$computeTabString();
    }

    /**
     * @param {string} showInvisibles
     */
    setShowInvisibles(showInvisibles) {
        if (this.showInvisibles == showInvisibles)
            return false;

        this.showInvisibles = showInvisibles;
        if (typeof showInvisibles == "string") {
            this.showSpaces = /tab/i.test(showInvisibles);
            this.showTabs = /space/i.test(showInvisibles);
            this.showEOL = /eol/i.test(showInvisibles);
        } else {
            this.showSpaces = this.showTabs = this.showEOL = showInvisibles;
        }
        this.$computeTabString();
        return true;
    }

    /**
     * @param {boolean} display
     */
    setDisplayIndentGuides(display) {
        if (this.displayIndentGuides == display)
            return false;

        this.displayIndentGuides = display;
        this.$computeTabString();
        return true;
    }

    /**
     * @param {boolean} highlight
     */
    setHighlightIndentGuides(highlight) {
        if (this.$highlightIndentGuides === highlight) return false;

        this.$highlightIndentGuides = highlight;
        return highlight;
    }
    
    $computeTabString() {
        var tabSize = this.session.getTabSize();
        this.tabSize = tabSize;
        /**@type{any}*/var tabStr = this.$tabStrings = [0];
        for (var i = 1; i < tabSize + 1; i++) {
            if (this.showTabs) {
                var span = this.dom.createElement("span");
                span.className = "ace_invisible ace_invisible_tab";
                span.textContent = lang.stringRepeat(this.TAB_CHAR, i);
                tabStr.push(span);
            } else {
                tabStr.push(this.dom.createTextNode(lang.stringRepeat(" ", i), this.element));
            }
        }
        if (this.displayIndentGuides) {
            this.$indentGuideRe =  /\s\S| \t|\t |\s$/;
            var className = "ace_indent-guide";
            var spaceClass = this.showSpaces ? " ace_invisible ace_invisible_space" : "";
            var spaceContent = this.showSpaces
                ? lang.stringRepeat(this.SPACE_CHAR, this.tabSize)
                : lang.stringRepeat(" ", this.tabSize);

            var tabClass = this.showTabs ? " ace_invisible ace_invisible_tab" : "";
            var tabContent = this.showTabs
                ? lang.stringRepeat(this.TAB_CHAR, this.tabSize)
                : spaceContent;

            var span = this.dom.createElement("span");
            span.className = className + spaceClass;
            span.textContent = spaceContent;
            this.$tabStrings[" "] = span;

            var span = this.dom.createElement("span");
            span.className = className + tabClass;
            span.textContent = tabContent;
            this.$tabStrings["\t"] = span;
        }
    }

    /**
     * @param {LayerConfig} config
     * @param {number} firstRow
     * @param {number} lastRow
     */
    updateLines(config, firstRow, lastRow) {
        // Due to wrap line changes there can be new lines if e.g.
        // the line to updated wrapped in the meantime.
        if (this.config.lastRow != config.lastRow ||
            this.config.firstRow != config.firstRow) {
            return this.update(config);
        }

        this.config = config;

        var first = Math.max(firstRow, config.firstRow);
        var last = Math.min(lastRow, config.lastRow);

        var lineElements = this.element.childNodes;
        var lineElementsIdx = 0;

        for (var row = config.firstRow; row < first; row++) {
            var foldLine = this.session.getFoldLine(row);
            if (foldLine) {
                if (foldLine.containsRow(first)) {
                    first = foldLine.start.row;
                    break;
                } else {
                    row = foldLine.end.row;
                }
            }
            lineElementsIdx ++;
        }

        var heightChanged = false;
        var row = first;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row :Infinity;
            }
            if (row > last)
                break;

            /**@type{any}*/var lineElement = lineElements[lineElementsIdx++];
            if (lineElement) {
                this.dom.removeChildren(lineElement);
                this.$renderLine(
                    lineElement, row, row == foldStart ? foldLine : false
                );

                if (heightChanged)
                    lineElement.style.top = this.$lines.computeLineTop(row, config, this.session) + "px";

                var height = (config.lineHeight * this.session.getRowLength(row)) + "px";
                if (lineElement.style.height != height) {
                    heightChanged = true;
                    lineElement.style.height = height;
                }
            }
            row++;
        }
        if (heightChanged) {
            while (lineElementsIdx < this.$lines.cells.length) {
                var cell = this.$lines.cells[lineElementsIdx++];
                cell.element.style.top = this.$lines.computeLineTop(cell.row, config, this.session) + "px";
            }
        }
    }

    /**
     * @param {LayerConfig} config
     */
    scrollLines(config) {
        var oldConfig = this.config;
        this.config = config;

        if (this.$lines.pageChanged(oldConfig, config))
            return this.update(config);

        this.$lines.moveContainer(config);

        var lastRow = config.lastRow;
        var oldLastRow = oldConfig ? oldConfig.lastRow : -1;

        if (!oldConfig || oldLastRow < config.firstRow)
            return this.update(config);

        if (lastRow < oldConfig.firstRow)
            return this.update(config);

        if (!oldConfig || oldConfig.lastRow < config.firstRow)
            return this.update(config);

        if (config.lastRow < oldConfig.firstRow)
            return this.update(config);

        if (oldConfig.firstRow < config.firstRow)
            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)
                this.$lines.shift();

        if (oldConfig.lastRow > config.lastRow)
            for (var row=this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row>0; row--)
                this.$lines.pop();

        if (config.firstRow < oldConfig.firstRow) {
            this.$lines.unshift(this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1));
        }

        if (config.lastRow > oldConfig.lastRow) {
            this.$lines.push(this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow));
        }
        this.$highlightIndentGuide();
    }

    /**
     * @param {LayerConfig} config
     * @param {number} firstRow
     * @param {number} lastRow
     */
    $renderLinesFragment(config, firstRow, lastRow) {
        var fragment = [];
        var row = firstRow;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > lastRow)
                break;

            var line = this.$lines.createCell(row, config, this.session);

            var lineEl = line.element;
            this.dom.removeChildren(lineEl);
            dom.setStyle(lineEl.style, "height", this.$lines.computeLineHeight(row, config, this.session) + "px");
            dom.setStyle(lineEl.style, "top", this.$lines.computeLineTop(row, config, this.session) + "px");

            // Get the tokens per line as there might be some lines in between
            // beeing folded.
            this.$renderLine(lineEl, row, row == foldStart ? foldLine : false);

            if (this.$useLineGroups()) {
                lineEl.className = "ace_line_group";
            } else {
                lineEl.className = "ace_line";
            }
            fragment.push(line);

            row++;
        }
        return fragment;
    }

    /**
     * @param {LayerConfig} config
     */
    update(config) {
        this.$lines.moveContainer(config);

        this.config = config;

        var firstRow = config.firstRow;
        var lastRow = config.lastRow;

        var lines = this.$lines;
        while (lines.getLength())
            lines.pop();

        lines.push(this.$renderLinesFragment(config, firstRow, lastRow));
    }

    $renderToken(parent, screenColumn, token, value) {
        var self = this;
        var re = /(\t)|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\uFEFF\uFFF9-\uFFFC\u2066\u2067\u2068\u202A\u202B\u202D\u202E\u202C\u2069\u2060\u2061\u2062\u2063\u2064\u206A\u206B\u206B\u206C\u206D\u206E\u206F]+)|(\u3000)|([\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g;

        var valueFragment = this.dom.createFragment(this.element);

        var m;
        var i = 0;
        while (m = re.exec(value)) {
            var tab = m[1];
            var simpleSpace = m[2];
            var controlCharacter = m[3];
            var cjkSpace = m[4];
            var cjk = m[5];

            if (!self.showSpaces && simpleSpace)
                continue;

            var before = i != m.index ? value.slice(i, m.index) : "";

            i = m.index + m[0].length;

            if (before) {
                valueFragment.appendChild(this.dom.createTextNode(before, this.element));
            }

            if (tab) {
                var tabSize = self.session.getScreenTabSize(screenColumn + m.index);
                var text = self.$tabStrings[tabSize].cloneNode(true);
                text["charCount"] = 1;
                valueFragment.appendChild(text);
                screenColumn += tabSize - 1;
            } else if (simpleSpace) {
                if (self.showSpaces) {
                    var span = this.dom.createElement("span");
                    span.className = "ace_invisible ace_invisible_space";
                    span.textContent = lang.stringRepeat(self.SPACE_CHAR, simpleSpace.length);
                    valueFragment.appendChild(span);
                } else {
                    valueFragment.appendChild(this.dom.createTextNode(simpleSpace, this.element));
                }
            } else if (controlCharacter) {
                var span = this.dom.createElement("span");
                span.className = "ace_invisible ace_invisible_space ace_invalid";
                span.textContent = lang.stringRepeat(self.SPACE_CHAR, controlCharacter.length);
                valueFragment.appendChild(span);
            } else if (cjkSpace) {
                // U+3000 is both invisible AND full-width, so must be handled uniquely
                screenColumn += 1;

                var span = this.dom.createElement("span");
                span.style.width = (self.config.characterWidth * 2) + "px";
                span.className = self.showSpaces ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                span.textContent = self.showSpaces ? self.SPACE_CHAR : cjkSpace;
                valueFragment.appendChild(span);
            } else if (cjk) {
                screenColumn += 1;
                var span = this.dom.createElement("span");
                span.style.width = (self.config.characterWidth * 2) + "px";
                span.className = "ace_cjk";
                span.textContent = cjk;
                valueFragment.appendChild(span);
            }
        }

        valueFragment.appendChild(this.dom.createTextNode(i ? value.slice(i) : value, this.element));

        if (!isTextToken(token.type)) {
            var classes = "ace_" + token.type.replace(/\./g, " ace_");
            var span = this.dom.createElement("span");
            if (token.type == "fold"){
                span.style.width = (token.value.length * this.config.characterWidth) + "px";
                span.setAttribute("title", nls("inline-fold.closed.title", "Unfold code"));
            }

            span.className = classes;
            span.appendChild(valueFragment);

            parent.appendChild(span);
        }
        else {
            parent.appendChild(valueFragment);
        }

        return screenColumn + value.length;
    }

    renderIndentGuide(parent, value, max) {
        var cols = value.search(this.$indentGuideRe);
        if (cols <= 0 || cols >= max)
            return value;
        if (value[0] == " ") {
            cols -= cols % this.tabSize;
            var count = cols/this.tabSize;
            for (var i=0; i<count; i++) {
                parent.appendChild(this.$tabStrings[" "].cloneNode(true));
            }
            this.$highlightIndentGuide();
            return value.substr(cols);
        } else if (value[0] == "\t") {
            for (var i=0; i<cols; i++) {
                parent.appendChild(this.$tabStrings["\t"].cloneNode(true));
            }
            this.$highlightIndentGuide();
            return value.substr(cols);
        }
        this.$highlightIndentGuide();
        return value;
    }

    $highlightIndentGuide() {
        if (!this.$highlightIndentGuides || !this.displayIndentGuides) return;
        /**@type {{ indentLevel?: number; start?: number; end?: number; dir?: number; }}*/
        this.$highlightIndentGuideMarker = {
            indentLevel: undefined,
            start: undefined,
            end: undefined,
            dir: undefined
        };
        var lines = this.session.doc.$lines;
        if (!lines) return;

        var cursor = this.session.selection.getCursor();
        var initialIndent = /^\s*/.exec(this.session.doc.getLine(cursor.row))[0].length;
        var elementIndentLevel = Math.floor(initialIndent / this.tabSize);
        this.$highlightIndentGuideMarker = {
            indentLevel: elementIndentLevel,
            start: cursor.row
        };

        var bracketHighlight = this.session.$bracketHighlight;
        if (bracketHighlight) {
            var ranges = this.session.$bracketHighlight.ranges;
            for (var i = 0; i < ranges.length; i++) {
                if (cursor.row !== ranges[i].start.row) {
                    this.$highlightIndentGuideMarker.end = ranges[i].start.row + 1;
                    if (cursor.row > ranges[i].start.row) {
                        this.$highlightIndentGuideMarker.dir = -1;
                    }
                    else {
                        this.$highlightIndentGuideMarker.dir = 1;
                    }
                    break;
                }
            }
        }

        if (!this.$highlightIndentGuideMarker.end) {
            if (lines[cursor.row] !== '' && cursor.column === lines[cursor.row].length) {
                this.$highlightIndentGuideMarker.dir = 1;
                for (var i = cursor.row + 1; i < lines.length; i++) {
                    var line = lines[i];
                    var currentIndent = /^\s*/.exec(line)[0].length;
                    if (line !== '') {
                        this.$highlightIndentGuideMarker.end = i;
                        if (currentIndent <= initialIndent) break;
                    }
                }
            }
        }

        this.$renderHighlightIndentGuide();
    }

    $clearActiveIndentGuide() {
        var activeIndentGuides = this.element.querySelectorAll(".ace_indent-guide-active");
        for (var i = 0; i < activeIndentGuides.length; i++) {
            activeIndentGuides[i].classList.remove("ace_indent-guide-active");
        }
    }

    $setIndentGuideActive(cell, indentLevel) {
        var line = this.session.doc.getLine(cell.row);
        if (line !== "") {
            let element = cell.element;
            if (cell.element.classList && cell.element.classList.contains("ace_line_group")) {
                if (cell.element.childNodes.length > 0) {
                    element = cell.element.childNodes[0];
                }
                else {
                    return;
                }
            }
            var childNodes = element.childNodes;
            if (childNodes) {
                let node = childNodes[indentLevel - 1];
                if (node && node.classList && node.classList.contains("ace_indent-guide")) node.classList.add(
                    "ace_indent-guide-active");
            }
        }
    }

    $renderHighlightIndentGuide() {
        if (!this.$lines) return;
        var cells = this.$lines.cells;
        this.$clearActiveIndentGuide();
        var indentLevel = this.$highlightIndentGuideMarker.indentLevel;
        if (indentLevel !== 0) {
            if (this.$highlightIndentGuideMarker.dir === 1) {
                for (var i = 0; i < cells.length; i++) {
                    var cell = cells[i];
                    if (this.$highlightIndentGuideMarker.end && cell.row >= this.$highlightIndentGuideMarker.start
                        + 1) {
                        if (cell.row >= this.$highlightIndentGuideMarker.end) break;
                        this.$setIndentGuideActive(cell, indentLevel);
                    }
                }
            }
            else {
                for (var i = cells.length - 1; i >= 0; i--) {
                    var cell = cells[i];
                    if (this.$highlightIndentGuideMarker.end && cell.row < this.$highlightIndentGuideMarker.start) {
                        if (cell.row < this.$highlightIndentGuideMarker.end) break;
                        this.$setIndentGuideActive(cell, indentLevel);
                    }
                }
            }
        }
    }

    $createLineElement(parent) {
        var lineEl = this.dom.createElement("div");
        lineEl.className = "ace_line";
        lineEl.style.height = this.config.lineHeight + "px";

        return lineEl;
    }

    $renderWrappedLine(parent, tokens, splits) {
        var chars = 0;
        var split = 0;
        var splitChars = splits[0];
        var screenColumn = 0;

        var lineEl = this.$createLineElement();
        parent.appendChild(lineEl);

        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            var value = token.value;
            if (i == 0 && this.displayIndentGuides) {
                chars = value.length;
                value = this.renderIndentGuide(lineEl, value, splitChars);
                if (!value)
                    continue;
                chars -= value.length;
            }

            if (chars + value.length < splitChars) {
                screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
                chars += value.length;
            } else {
                while (chars + value.length >= splitChars) {
                    screenColumn = this.$renderToken(
                        lineEl, screenColumn,
                        token, value.substring(0, splitChars - chars)
                    );
                    value = value.substring(splitChars - chars);
                    chars = splitChars;

                    lineEl = this.$createLineElement();
                    parent.appendChild(lineEl);

                    var text = this.dom.createTextNode(lang.stringRepeat("\xa0", splits.indent), this.element);
                    text["charCount"] = 0; // not to take into account when we are counting columns
                    lineEl.appendChild(text);

                    split ++;
                    screenColumn = 0;
                    splitChars = splits[split] || Number.MAX_VALUE;
                }
                if (value.length != 0) {
                    chars += value.length;
                    screenColumn = this.$renderToken(
                        lineEl, screenColumn, token, value
                    );
                }
            }
        }

        if (splits[splits.length - 1] > this.MAX_LINE_LENGTH)
            this.$renderOverflowMessage(lineEl, screenColumn, null, "", true);
    }

    $renderSimpleLine(parent, tokens) {
        var screenColumn = 0;

        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            var value = token.value;
            if (i == 0 && this.displayIndentGuides) {
                value = this.renderIndentGuide(parent, value);
                if (!value)
                    continue;
            }
            if (screenColumn + value.length > this.MAX_LINE_LENGTH)
                return this.$renderOverflowMessage(parent, screenColumn, token, value);
            screenColumn = this.$renderToken(parent, screenColumn, token, value);
        }
    }

    $renderOverflowMessage(parent, screenColumn, token, value, hide) {
        token && this.$renderToken(parent, screenColumn, token,
            value.slice(0, this.MAX_LINE_LENGTH - screenColumn));

        var overflowEl = this.dom.createElement("span");
        overflowEl.className = "ace_inline_button ace_keyword ace_toggle_wrap";
        overflowEl.textContent = hide ? "<hide>" : "<click to see more...>";

        parent.appendChild(overflowEl);
    }

    // row is either first row of foldline or not in fold
    $renderLine(parent, row, foldLine) {
        if (!foldLine && foldLine != false)
            foldLine = this.session.getFoldLine(row);

        if (foldLine)
            var tokens = this.$getFoldLineTokens(row, foldLine);
        else
            var tokens = this.session.getTokens(row);

        var lastLineEl = parent;
        if (tokens.length) {
            var splits = this.session.getRowSplitData(row);
            if (splits && splits.length) {
                this.$renderWrappedLine(parent, tokens, splits);
                var lastLineEl = parent.lastChild;
            } else {
                var lastLineEl = parent;
                if (this.$useLineGroups()) {
                    lastLineEl = this.$createLineElement();
                    parent.appendChild(lastLineEl);
                }
                this.$renderSimpleLine(lastLineEl, tokens);
            }
        } else if (this.$useLineGroups()) {
            lastLineEl = this.$createLineElement();
            parent.appendChild(lastLineEl);
        }

        if (this.showEOL && lastLineEl) {
            if (foldLine)
                row = foldLine.end.row;

            var invisibleEl = this.dom.createElement("span");
            invisibleEl.className = "ace_invisible ace_invisible_eol";
            invisibleEl.textContent = row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR;

            lastLineEl.appendChild(invisibleEl);
        }
    }

    /**
     * @param {number} row
     * @param {import("../../ace-internal").Ace.FoldLine} foldLine
     * @return {import("../../ace-internal").Ace.Token[]}
     */
    $getFoldLineTokens(row, foldLine) {
        var session = this.session;
        var renderTokens = [];

        function addTokens(tokens, from, to) {
            var idx = 0, col = 0;
            while ((col + tokens[idx].value.length) < from) {
                col += tokens[idx].value.length;
                idx++;

                if (idx == tokens.length)
                    return;
            }
            if (col != from) {
                var value = tokens[idx].value.substring(from - col);
                // Check if the token value is longer then the from...to spacing.
                if (value.length > (to - from))
                    value = value.substring(0, to - from);

                renderTokens.push({
                    type: tokens[idx].type,
                    value: value
                });

                col = from + value.length;
                idx += 1;
            }

            while (col < to && idx < tokens.length) {
                var value = tokens[idx].value;
                if (value.length + col > to) {
                    renderTokens.push({
                        type: tokens[idx].type,
                        value: value.substring(0, to - col)
                    });
                } else
                    renderTokens.push(tokens[idx]);
                col += value.length;
                idx += 1;
            }
        }

        var tokens = session.getTokens(row);
        foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {
            if (placeholder != null) {
                renderTokens.push({
                    type: "fold",
                    value: placeholder
                });
            } else {
                if (isNewRow)
                    tokens = session.getTokens(row);

                if (tokens.length)
                    addTokens(tokens, lastColumn, column);
            }
        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);

        return renderTokens;
    }

    $useLineGroups() {
        // For the updateLines function to work correctly, it's important that the
        // child nodes of this.element correspond on a 1-to-1 basis to rows in the
        // document (as distinct from lines on the screen). For sessions that are
        // wrapped, this means we need to add a layer to the node hierarchy (tagged
        // with the class name ace_line_group).
        return this.session.getUseWrapMode();
    }
}

Text.prototype.EOF_CHAR = "\xB6";
Text.prototype.EOL_CHAR_LF = "\xAC";
Text.prototype.EOL_CHAR_CRLF = "\xa4";
Text.prototype.EOL_CHAR = Text.prototype.EOL_CHAR_LF;
Text.prototype.TAB_CHAR = "\u2014"; //"\u21E5";
Text.prototype.SPACE_CHAR = "\xB7";
Text.prototype.$padding = 0;
Text.prototype.MAX_LINE_LENGTH = 10000;
Text.prototype.showInvisibles = false;
Text.prototype.showSpaces = false;
Text.prototype.showTabs = false;
Text.prototype.showEOL = false;
Text.prototype.displayIndentGuides = true;
Text.prototype.$highlightIndentGuides = true;
Text.prototype.$tabStrings = [];
Text.prototype.destroy = {};
Text.prototype.onChangeTabSize = Text.prototype.$computeTabString;

oop.implement(Text.prototype, EventEmitter);

exports.E = Text;


/***/ }),

/***/ 10776:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var _src_ace__WEBPACK_IMPORTED_MODULE_0___namespace_cache;
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport fake namespace object from non-harmony */ _src_ace__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_src_ace__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_src_ace__WEBPACK_IMPORTED_MODULE_0__, 2)))
/* harmony export */ });
/* harmony import */ var _src_ace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80820);

_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/abap', () => __webpack_require__.e(/* import() */ 7161).then(__webpack_require__.t.bind(__webpack_require__, 67161, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/abc', () => __webpack_require__.e(/* import() */ 4723).then(__webpack_require__.t.bind(__webpack_require__, 44723, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/actionscript', () => __webpack_require__.e(/* import() */ 9950).then(__webpack_require__.t.bind(__webpack_require__, 69950, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/ada', () => __webpack_require__.e(/* import() */ 6199).then(__webpack_require__.t.bind(__webpack_require__, 76199, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/alda', () => __webpack_require__.e(/* import() */ 8653).then(__webpack_require__.t.bind(__webpack_require__, 68653, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/apache_conf', () => __webpack_require__.e(/* import() */ 6014).then(__webpack_require__.t.bind(__webpack_require__, 46014, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/apex', () => __webpack_require__.e(/* import() */ 4255).then(__webpack_require__.t.bind(__webpack_require__, 54255, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/applescript', () => __webpack_require__.e(/* import() */ 1276).then(__webpack_require__.t.bind(__webpack_require__, 21276, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/aql', () => __webpack_require__.e(/* import() */ 5917).then(__webpack_require__.t.bind(__webpack_require__, 85917, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/asciidoc', () => __webpack_require__.e(/* import() */ 7488).then(__webpack_require__.t.bind(__webpack_require__, 87488, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/asl', () => __webpack_require__.e(/* import() */ 7023).then(__webpack_require__.t.bind(__webpack_require__, 37023, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/assembly_arm32', () => __webpack_require__.e(/* import() */ 4583).then(__webpack_require__.t.bind(__webpack_require__, 64583, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/assembly_x86', () => __webpack_require__.e(/* import() */ 1746).then(__webpack_require__.t.bind(__webpack_require__, 11746, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/astro', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(5120)]).then(__webpack_require__.t.bind(__webpack_require__, 15120, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/autohotkey', () => __webpack_require__.e(/* import() */ 2674).then(__webpack_require__.t.bind(__webpack_require__, 32674, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/basic', () => __webpack_require__.e(/* import() */ 8389).then(__webpack_require__.t.bind(__webpack_require__, 38389, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/batchfile', () => __webpack_require__.e(/* import() */ 8253).then(__webpack_require__.t.bind(__webpack_require__, 18253, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/bibtex', () => __webpack_require__.e(/* import() */ 3989).then(__webpack_require__.t.bind(__webpack_require__, 93989, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/c9search', () => __webpack_require__.e(/* import() */ 6679).then(__webpack_require__.t.bind(__webpack_require__, 66679, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/c_cpp', () => __webpack_require__.e(/* import() */ 7668).then(__webpack_require__.t.bind(__webpack_require__, 97668, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/cirru', () => __webpack_require__.e(/* import() */ 2295).then(__webpack_require__.t.bind(__webpack_require__, 74676, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/clojure', () => __webpack_require__.e(/* import() */ 4335).then(__webpack_require__.t.bind(__webpack_require__, 4335, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/clue', () => __webpack_require__.e(/* import() */ 6638).then(__webpack_require__.t.bind(__webpack_require__, 26638, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/cobol', () => __webpack_require__.e(/* import() */ 3436).then(__webpack_require__.t.bind(__webpack_require__, 83436, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/coffee', () => __webpack_require__.e(/* import() */ 1079).then(__webpack_require__.t.bind(__webpack_require__, 61079, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/coldfusion', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(4341)]).then(__webpack_require__.t.bind(__webpack_require__, 54341, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/crystal', () => __webpack_require__.e(/* import() */ 7465).then(__webpack_require__.t.bind(__webpack_require__, 7465, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/csharp', () => __webpack_require__.e(/* import() */ 4764).then(__webpack_require__.t.bind(__webpack_require__, 54764, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/csound_document', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(413), __webpack_require__.e(3928), __webpack_require__.e(215)]).then(__webpack_require__.t.bind(__webpack_require__, 40215, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/csound_orchestra', () => Promise.all(/* import() */[__webpack_require__.e(3928), __webpack_require__.e(1763)]).then(__webpack_require__.t.bind(__webpack_require__, 11763, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/csound_score', () => __webpack_require__.e(/* import() */ 9858).then(__webpack_require__.t.bind(__webpack_require__, 79858, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/csp', () => __webpack_require__.e(/* import() */ 5409).then(__webpack_require__.t.bind(__webpack_require__, 55409, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/css', () => __webpack_require__.e(/* import() */ 1080).then(__webpack_require__.t.bind(__webpack_require__, 41080, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/csv', () => __webpack_require__.e(/* import() */ 955).then(__webpack_require__.t.bind(__webpack_require__, 30955, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/curly', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(9430)]).then(__webpack_require__.t.bind(__webpack_require__, 39430, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/cuttlefish', () => __webpack_require__.e(/* import() */ 4186).then(__webpack_require__.t.bind(__webpack_require__, 64186, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/d', () => __webpack_require__.e(/* import() */ 343).then(__webpack_require__.t.bind(__webpack_require__, 343, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/dart', () => __webpack_require__.e(/* import() */ 3006).then(__webpack_require__.t.bind(__webpack_require__, 83006, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/diff', () => __webpack_require__.e(/* import() */ 6104).then(__webpack_require__.t.bind(__webpack_require__, 56104, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/django', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(3332)]).then(__webpack_require__.t.bind(__webpack_require__, 43332, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/dockerfile', () => __webpack_require__.e(/* import() */ 1257).then(__webpack_require__.t.bind(__webpack_require__, 31257, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/dot', () => __webpack_require__.e(/* import() */ 1304).then(__webpack_require__.t.bind(__webpack_require__, 51304, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/drools', () => __webpack_require__.e(/* import() */ 4554).then(__webpack_require__.t.bind(__webpack_require__, 34554, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/edifact', () => __webpack_require__.e(/* import() */ 261).then(__webpack_require__.t.bind(__webpack_require__, 50261, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/eiffel', () => __webpack_require__.e(/* import() */ 2920).then(__webpack_require__.t.bind(__webpack_require__, 2920, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/ejs', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(4848), __webpack_require__.e(31)]).then(__webpack_require__.t.bind(__webpack_require__, 30031, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/elixir', () => __webpack_require__.e(/* import() */ 7692).then(__webpack_require__.t.bind(__webpack_require__, 37692, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/elm', () => __webpack_require__.e(/* import() */ 6135).then(__webpack_require__.t.bind(__webpack_require__, 6135, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/erlang', () => __webpack_require__.e(/* import() */ 3544).then(__webpack_require__.t.bind(__webpack_require__, 33544, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/flix', () => __webpack_require__.e(/* import() */ 4140).then(__webpack_require__.t.bind(__webpack_require__, 34140, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/forth', () => __webpack_require__.e(/* import() */ 7076).then(__webpack_require__.t.bind(__webpack_require__, 27076, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/fortran', () => __webpack_require__.e(/* import() */ 553).then(__webpack_require__.t.bind(__webpack_require__, 80553, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/fsharp', () => __webpack_require__.e(/* import() */ 7657).then(__webpack_require__.t.bind(__webpack_require__, 17657, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/fsl', () => __webpack_require__.e(/* import() */ 3698).then(__webpack_require__.t.bind(__webpack_require__, 33698, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/ftl', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(413), __webpack_require__.e(769)]).then(__webpack_require__.t.bind(__webpack_require__, 50769, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/gcode', () => __webpack_require__.e(/* import() */ 3695).then(__webpack_require__.t.bind(__webpack_require__, 83695, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/gherkin', () => __webpack_require__.e(/* import() */ 5005).then(__webpack_require__.t.bind(__webpack_require__, 25005, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/gitignore', () => __webpack_require__.e(/* import() */ 297).then(__webpack_require__.t.bind(__webpack_require__, 297, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/glsl', () => __webpack_require__.e(/* import() */ 903).then(__webpack_require__.t.bind(__webpack_require__, 80903, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/gobstones', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(3845)]).then(__webpack_require__.t.bind(__webpack_require__, 93845, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/golang', () => __webpack_require__.e(/* import() */ 8009).then(__webpack_require__.t.bind(__webpack_require__, 38009, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/graphqlschema', () => __webpack_require__.e(/* import() */ 3105).then(__webpack_require__.t.bind(__webpack_require__, 63105, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/groovy', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(2025)]).then(__webpack_require__.t.bind(__webpack_require__, 32025, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/haml', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(413), __webpack_require__.e(4848), __webpack_require__.e(2545)]).then(__webpack_require__.t.bind(__webpack_require__, 42545, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/handlebars', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(2527)]).then(__webpack_require__.t.bind(__webpack_require__, 52527, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/haskell', () => __webpack_require__.e(/* import() */ 2119).then(__webpack_require__.t.bind(__webpack_require__, 82119, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/haskell_cabal', () => __webpack_require__.e(/* import() */ 5611).then(__webpack_require__.t.bind(__webpack_require__, 85611, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/haxe', () => __webpack_require__.e(/* import() */ 1151).then(__webpack_require__.t.bind(__webpack_require__, 91151, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/hjson', () => __webpack_require__.e(/* import() */ 6929).then(__webpack_require__.t.bind(__webpack_require__, 56929, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/html', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234)]).then(__webpack_require__.t.bind(__webpack_require__, 32234, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/html_elixir', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(562)]).then(__webpack_require__.t.bind(__webpack_require__, 562, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/html_ruby', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(4848), __webpack_require__.e(9261)]).then(__webpack_require__.t.bind(__webpack_require__, 9261, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/ini', () => __webpack_require__.e(/* import() */ 5481).then(__webpack_require__.t.bind(__webpack_require__, 95481, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/io', () => __webpack_require__.e(/* import() */ 247).then(__webpack_require__.t.bind(__webpack_require__, 70247, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/ion', () => __webpack_require__.e(/* import() */ 2613).then(__webpack_require__.t.bind(__webpack_require__, 92613, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/jack', () => __webpack_require__.e(/* import() */ 1820).then(__webpack_require__.t.bind(__webpack_require__, 81820, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/jade', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(413), __webpack_require__.e(9681)]).then(__webpack_require__.t.bind(__webpack_require__, 29681, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/java', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(8259)]).then(__webpack_require__.t.bind(__webpack_require__, 38259, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/javascript', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388)]).then(__webpack_require__.t.bind(__webpack_require__, 93388, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/jexl', () => __webpack_require__.e(/* import() */ 1770).then(__webpack_require__.t.bind(__webpack_require__, 91770, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/json', () => __webpack_require__.e(/* import() */ 5081).then(__webpack_require__.t.bind(__webpack_require__, 45081, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/json5', () => __webpack_require__.e(/* import() */ 8314).then(__webpack_require__.t.bind(__webpack_require__, 88314, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/jsp', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(413), __webpack_require__.e(9706)]).then(__webpack_require__.t.bind(__webpack_require__, 99706, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/jssm', () => __webpack_require__.e(/* import() */ 5660).then(__webpack_require__.t.bind(__webpack_require__, 65660, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/jsx', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(3442)]).then(__webpack_require__.t.bind(__webpack_require__, 93442, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/julia', () => __webpack_require__.e(/* import() */ 8270).then(__webpack_require__.t.bind(__webpack_require__, 18270, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/kotlin', () => __webpack_require__.e(/* import() */ 3682).then(__webpack_require__.t.bind(__webpack_require__, 63682, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/latex', () => __webpack_require__.e(/* import() */ 8311).then(__webpack_require__.t.bind(__webpack_require__, 88311, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/latte', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(3629)]).then(__webpack_require__.t.bind(__webpack_require__, 43629, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/less', () => __webpack_require__.e(/* import() */ 9686).then(__webpack_require__.t.bind(__webpack_require__, 79686, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/liquid', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(307)]).then(__webpack_require__.t.bind(__webpack_require__, 20307, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/lisp', () => __webpack_require__.e(/* import() */ 111).then(__webpack_require__.t.bind(__webpack_require__, 20111, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/livescript', () => __webpack_require__.e(/* import() */ 4854).then(__webpack_require__.t.bind(__webpack_require__, 34854, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/logiql', () => __webpack_require__.e(/* import() */ 3983).then(__webpack_require__.t.bind(__webpack_require__, 13983, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/logtalk', () => __webpack_require__.e(/* import() */ 5527).then(__webpack_require__.t.bind(__webpack_require__, 65527, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/lsl', () => __webpack_require__.e(/* import() */ 3476).then(__webpack_require__.t.bind(__webpack_require__, 83476, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/lua', () => __webpack_require__.e(/* import() */ 9781).then(__webpack_require__.t.bind(__webpack_require__, 39781, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/luapage', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(8130)]).then(__webpack_require__.t.bind(__webpack_require__, 88130, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/lucene', () => __webpack_require__.e(/* import() */ 313).then(__webpack_require__.t.bind(__webpack_require__, 10313, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/makefile', () => __webpack_require__.e(/* import() */ 5383).then(__webpack_require__.t.bind(__webpack_require__, 5383, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/markdown', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(5390)]).then(__webpack_require__.t.bind(__webpack_require__, 75390, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/mask', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(413), __webpack_require__.e(2699)]).then(__webpack_require__.t.bind(__webpack_require__, 92699, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/matlab', () => __webpack_require__.e(/* import() */ 4406).then(__webpack_require__.t.bind(__webpack_require__, 84406, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/maze', () => __webpack_require__.e(/* import() */ 2328).then(__webpack_require__.t.bind(__webpack_require__, 92328, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/mediawiki', () => __webpack_require__.e(/* import() */ 9723).then(__webpack_require__.t.bind(__webpack_require__, 59723, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/mel', () => __webpack_require__.e(/* import() */ 365).then(__webpack_require__.t.bind(__webpack_require__, 30365, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/mips', () => __webpack_require__.e(/* import() */ 7240).then(__webpack_require__.t.bind(__webpack_require__, 47240, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/mixal', () => __webpack_require__.e(/* import() */ 9156).then(__webpack_require__.t.bind(__webpack_require__, 9156, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/mushcode', () => __webpack_require__.e(/* import() */ 4223).then(__webpack_require__.t.bind(__webpack_require__, 44223, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/mysql', () => __webpack_require__.e(/* import() */ 3221).then(__webpack_require__.t.bind(__webpack_require__, 43221, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/nasal', () => __webpack_require__.e(/* import() */ 8855).then(__webpack_require__.t.bind(__webpack_require__, 71236, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/nginx', () => __webpack_require__.e(/* import() */ 6535).then(__webpack_require__.t.bind(__webpack_require__, 96535, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/nim', () => __webpack_require__.e(/* import() */ 5799).then(__webpack_require__.t.bind(__webpack_require__, 15799, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/nix', () => __webpack_require__.e(/* import() */ 4348).then(__webpack_require__.t.bind(__webpack_require__, 64348, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/nsis', () => __webpack_require__.e(/* import() */ 1312).then(__webpack_require__.t.bind(__webpack_require__, 31312, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/nunjucks', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(1236)]).then(__webpack_require__.t.bind(__webpack_require__, 1236, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/objectivec', () => __webpack_require__.e(/* import() */ 5507).then(__webpack_require__.t.bind(__webpack_require__, 85507, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/ocaml', () => __webpack_require__.e(/* import() */ 4875).then(__webpack_require__.t.bind(__webpack_require__, 54875, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/odin', () => __webpack_require__.e(/* import() */ 1675).then(__webpack_require__.t.bind(__webpack_require__, 91675, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/partiql', () => __webpack_require__.e(/* import() */ 1078).then(__webpack_require__.t.bind(__webpack_require__, 51078, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/pascal', () => __webpack_require__.e(/* import() */ 5143).then(__webpack_require__.t.bind(__webpack_require__, 75143, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/perl', () => __webpack_require__.e(/* import() */ 1934).then(__webpack_require__.t.bind(__webpack_require__, 21934, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/pgsql', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(5440)]).then(__webpack_require__.t.bind(__webpack_require__, 65440, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/php', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(9883)]).then(__webpack_require__.t.bind(__webpack_require__, 99883, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/php_laravel_blade', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(9883), __webpack_require__.e(3212)]).then(__webpack_require__.t.bind(__webpack_require__, 33212, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/pig', () => __webpack_require__.e(/* import() */ 1951).then(__webpack_require__.t.bind(__webpack_require__, 71951, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/plain_text', () => __webpack_require__.e(/* import() */ 7001).then(__webpack_require__.t.bind(__webpack_require__, 57001, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/plsql', () => __webpack_require__.e(/* import() */ 3219).then(__webpack_require__.t.bind(__webpack_require__, 73219, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/powershell', () => __webpack_require__.e(/* import() */ 5818).then(__webpack_require__.t.bind(__webpack_require__, 5818, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/praat', () => __webpack_require__.e(/* import() */ 5227).then(__webpack_require__.t.bind(__webpack_require__, 35227, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/prisma', () => __webpack_require__.e(/* import() */ 5159).then(__webpack_require__.t.bind(__webpack_require__, 25159, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/prolog', () => __webpack_require__.e(/* import() */ 9492).then(__webpack_require__.t.bind(__webpack_require__, 29492, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/properties', () => __webpack_require__.e(/* import() */ 1994).then(__webpack_require__.t.bind(__webpack_require__, 31994, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/protobuf', () => __webpack_require__.e(/* import() */ 4712).then(__webpack_require__.t.bind(__webpack_require__, 54712, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/prql', () => __webpack_require__.e(/* import() */ 2260).then(__webpack_require__.t.bind(__webpack_require__, 22260, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/puppet', () => __webpack_require__.e(/* import() */ 661).then(__webpack_require__.t.bind(__webpack_require__, 10661, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/python', () => __webpack_require__.e(/* import() */ 5313).then(__webpack_require__.t.bind(__webpack_require__, 35313, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/qml', () => __webpack_require__.e(/* import() */ 2857).then(__webpack_require__.t.bind(__webpack_require__, 32857, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/r', () => __webpack_require__.e(/* import() */ 3317).then(__webpack_require__.t.bind(__webpack_require__, 13317, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/raku', () => __webpack_require__.e(/* import() */ 9042).then(__webpack_require__.t.bind(__webpack_require__, 39042, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/razor', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(8871)]).then(__webpack_require__.t.bind(__webpack_require__, 78871, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/rdoc', () => __webpack_require__.e(/* import() */ 7787).then(__webpack_require__.t.bind(__webpack_require__, 17787, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/red', () => __webpack_require__.e(/* import() */ 6328).then(__webpack_require__.t.bind(__webpack_require__, 66328, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/redshift', () => __webpack_require__.e(/* import() */ 5074).then(__webpack_require__.t.bind(__webpack_require__, 25074, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/rhtml', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(9748)]).then(__webpack_require__.t.bind(__webpack_require__, 9748, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/robot', () => __webpack_require__.e(/* import() */ 571).then(__webpack_require__.t.bind(__webpack_require__, 50571, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/rst', () => __webpack_require__.e(/* import() */ 5262).then(__webpack_require__.t.bind(__webpack_require__, 25262, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/ruby', () => Promise.all(/* import() */[__webpack_require__.e(4848), __webpack_require__.e(1067)]).then(__webpack_require__.t.bind(__webpack_require__, 11067, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/rust', () => __webpack_require__.e(/* import() */ 7149).then(__webpack_require__.t.bind(__webpack_require__, 17149, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/sac', () => __webpack_require__.e(/* import() */ 4350).then(__webpack_require__.t.bind(__webpack_require__, 64350, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/sass', () => __webpack_require__.e(/* import() */ 1525).then(__webpack_require__.t.bind(__webpack_require__, 31525, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/scad', () => __webpack_require__.e(/* import() */ 1092).then(__webpack_require__.t.bind(__webpack_require__, 91092, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/scala', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(8789)]).then(__webpack_require__.t.bind(__webpack_require__, 68789, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/scheme', () => __webpack_require__.e(/* import() */ 3656).then(__webpack_require__.t.bind(__webpack_require__, 53656, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/scrypt', () => __webpack_require__.e(/* import() */ 9660).then(__webpack_require__.t.bind(__webpack_require__, 79660, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/scss', () => __webpack_require__.e(/* import() */ 2007).then(__webpack_require__.t.bind(__webpack_require__, 72007, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/sh', () => __webpack_require__.e(/* import() */ 5052).then(__webpack_require__.t.bind(__webpack_require__, 95052, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/sjs', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(461)]).then(__webpack_require__.t.bind(__webpack_require__, 30461, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/slim', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(4848), __webpack_require__.e(2561), __webpack_require__.e(1026)]).then(__webpack_require__.t.bind(__webpack_require__, 41026, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/smarty', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(4939)]).then(__webpack_require__.t.bind(__webpack_require__, 14939, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/smithy', () => __webpack_require__.e(/* import() */ 2213).then(__webpack_require__.t.bind(__webpack_require__, 22213, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/snippets', () => __webpack_require__.e(/* import() */ 6473).then(__webpack_require__.t.bind(__webpack_require__, 96473, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/soy_template', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(8180)]).then(__webpack_require__.t.bind(__webpack_require__, 95799, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/space', () => __webpack_require__.e(/* import() */ 245).then(__webpack_require__.t.bind(__webpack_require__, 10245, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/sparql', () => __webpack_require__.e(/* import() */ 8886).then(__webpack_require__.t.bind(__webpack_require__, 38886, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/sql', () => __webpack_require__.e(/* import() */ 7447).then(__webpack_require__.t.bind(__webpack_require__, 17447, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/sqlserver', () => __webpack_require__.e(/* import() */ 80).then(__webpack_require__.t.bind(__webpack_require__, 70080, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/stylus', () => __webpack_require__.e(/* import() */ 5241).then(__webpack_require__.t.bind(__webpack_require__, 55241, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/svg', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(4445)]).then(__webpack_require__.t.bind(__webpack_require__, 14445, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/swift', () => __webpack_require__.e(/* import() */ 468).then(__webpack_require__.t.bind(__webpack_require__, 40468, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/tcl', () => __webpack_require__.e(/* import() */ 7228).then(__webpack_require__.t.bind(__webpack_require__, 47228, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/terraform', () => __webpack_require__.e(/* import() */ 5131).then(__webpack_require__.t.bind(__webpack_require__, 25131, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/tex', () => __webpack_require__.e(/* import() */ 3190).then(__webpack_require__.t.bind(__webpack_require__, 13190, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/text', () => Promise.resolve(/* import() */).then(__webpack_require__.t.bind(__webpack_require__, 49432, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/textile', () => __webpack_require__.e(/* import() */ 6314).then(__webpack_require__.t.bind(__webpack_require__, 56314, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/toml', () => __webpack_require__.e(/* import() */ 3571).then(__webpack_require__.t.bind(__webpack_require__, 63571, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/tsv', () => __webpack_require__.e(/* import() */ 5934).then(__webpack_require__.t.bind(__webpack_require__, 45934, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/tsx', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(2656)]).then(__webpack_require__.t.bind(__webpack_require__, 72656, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/turtle', () => __webpack_require__.e(/* import() */ 9433).then(__webpack_require__.t.bind(__webpack_require__, 89433, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/twig', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(5858)]).then(__webpack_require__.t.bind(__webpack_require__, 45858, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/typescript', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(532)]).then(__webpack_require__.t.bind(__webpack_require__, 50532, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/vala', () => __webpack_require__.e(/* import() */ 1905).then(__webpack_require__.t.bind(__webpack_require__, 41905, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/vbscript', () => __webpack_require__.e(/* import() */ 2956).then(__webpack_require__.t.bind(__webpack_require__, 92956, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/velocity', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(540)]).then(__webpack_require__.t.bind(__webpack_require__, 540, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/verilog', () => __webpack_require__.e(/* import() */ 4741).then(__webpack_require__.t.bind(__webpack_require__, 84741, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/vhdl', () => __webpack_require__.e(/* import() */ 5941).then(__webpack_require__.t.bind(__webpack_require__, 95941, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/visualforce', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(5392)]).then(__webpack_require__.t.bind(__webpack_require__, 95392, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/vue', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(413), __webpack_require__.e(2234), __webpack_require__.e(2561), __webpack_require__.e(7171)]).then(__webpack_require__.t.bind(__webpack_require__, 47171, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/wollok', () => Promise.all(/* import() */[__webpack_require__.e(5903), __webpack_require__.e(3388), __webpack_require__.e(843)]).then(__webpack_require__.t.bind(__webpack_require__, 843, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/xml', () => __webpack_require__.e(/* import() */ 9846).then(__webpack_require__.t.bind(__webpack_require__, 49846, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/yaml', () => __webpack_require__.e(/* import() */ 8176).then(__webpack_require__.t.bind(__webpack_require__, 48176, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/zeek', () => __webpack_require__.e(/* import() */ 5178).then(__webpack_require__.t.bind(__webpack_require__, 15178, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/mode/zig', () => __webpack_require__.e(/* import() */ 2181).then(__webpack_require__.t.bind(__webpack_require__, 52181, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/abc', () => __webpack_require__.e(/* import() */ 3450).then(__webpack_require__.t.bind(__webpack_require__, 93450, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/abc.snippets', () => __webpack_require__.e(/* import() */ 7396).then(__webpack_require__.t.bind(__webpack_require__, 97396, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/actionscript', () => __webpack_require__.e(/* import() */ 8770).then(__webpack_require__.t.bind(__webpack_require__, 46389, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/actionscript.snippets', () => __webpack_require__.e(/* import() */ 4257).then(__webpack_require__.t.bind(__webpack_require__, 64257, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/c_cpp', () => __webpack_require__.e(/* import() */ 4249).then(__webpack_require__.t.bind(__webpack_require__, 94249, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/c_cpp.snippets', () => __webpack_require__.e(/* import() */ 9037).then(__webpack_require__.t.bind(__webpack_require__, 79037, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/clojure', () => __webpack_require__.e(/* import() */ 2010).then(__webpack_require__.t.bind(__webpack_require__, 72010, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/clojure.snippets', () => __webpack_require__.e(/* import() */ 8980).then(__webpack_require__.t.bind(__webpack_require__, 48980, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/coffee', () => __webpack_require__.e(/* import() */ 7896).then(__webpack_require__.t.bind(__webpack_require__, 37896, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/coffee.snippets', () => __webpack_require__.e(/* import() */ 9590).then(__webpack_require__.t.bind(__webpack_require__, 69590, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/csound_document', () => __webpack_require__.e(/* import() */ 3630).then(__webpack_require__.t.bind(__webpack_require__, 73630, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/csound_document.snippets', () => __webpack_require__.e(/* import() */ 9552).then(__webpack_require__.t.bind(__webpack_require__, 69552, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/csound_orchestra', () => __webpack_require__.e(/* import() */ 2120).then(__webpack_require__.t.bind(__webpack_require__, 62120, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/csound_orchestra.snippets', () => __webpack_require__.e(/* import() */ 4998).then(__webpack_require__.t.bind(__webpack_require__, 14998, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/css', () => __webpack_require__.e(/* import() */ 6389).then(__webpack_require__.t.bind(__webpack_require__, 16389, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/css.snippets', () => __webpack_require__.e(/* import() */ 1329).then(__webpack_require__.t.bind(__webpack_require__, 81329, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/dart', () => __webpack_require__.e(/* import() */ 8137).then(__webpack_require__.t.bind(__webpack_require__, 20518, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/dart.snippets', () => __webpack_require__.e(/* import() */ 8829).then(__webpack_require__.t.bind(__webpack_require__, 18829, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/diff', () => __webpack_require__.e(/* import() */ 8043).then(__webpack_require__.t.bind(__webpack_require__, 18043, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/diff.snippets', () => __webpack_require__.e(/* import() */ 1019).then(__webpack_require__.t.bind(__webpack_require__, 91019, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/django', () => __webpack_require__.e(/* import() */ 4095).then(__webpack_require__.t.bind(__webpack_require__, 64095, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/django.snippets', () => __webpack_require__.e(/* import() */ 6775).then(__webpack_require__.t.bind(__webpack_require__, 16775, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/drools', () => __webpack_require__.e(/* import() */ 7113).then(__webpack_require__.t.bind(__webpack_require__, 87113, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/drools.snippets', () => __webpack_require__.e(/* import() */ 4541).then(__webpack_require__.t.bind(__webpack_require__, 84541, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/edifact', () => __webpack_require__.e(/* import() */ 796).then(__webpack_require__.t.bind(__webpack_require__, 60796, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/edifact.snippets', () => __webpack_require__.e(/* import() */ 1362).then(__webpack_require__.t.bind(__webpack_require__, 11362, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/erlang', () => __webpack_require__.e(/* import() */ 4879).then(__webpack_require__.t.bind(__webpack_require__, 14879, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/erlang.snippets', () => __webpack_require__.e(/* import() */ 5511).then(__webpack_require__.t.bind(__webpack_require__, 45511, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/fsl', () => __webpack_require__.e(/* import() */ 9491).then(__webpack_require__.t.bind(__webpack_require__, 29491, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/fsl.snippets', () => __webpack_require__.e(/* import() */ 4291).then(__webpack_require__.t.bind(__webpack_require__, 44291, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/gobstones', () => __webpack_require__.e(/* import() */ 1296).then(__webpack_require__.t.bind(__webpack_require__, 81296, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/gobstones.snippets', () => __webpack_require__.e(/* import() */ 5454).then(__webpack_require__.t.bind(__webpack_require__, 35454, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/graphqlschema', () => __webpack_require__.e(/* import() */ 3976).then(__webpack_require__.t.bind(__webpack_require__, 63976, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/graphqlschema.snippets', () => __webpack_require__.e(/* import() */ 8582).then(__webpack_require__.t.bind(__webpack_require__, 38582, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/haml', () => __webpack_require__.e(/* import() */ 1398).then(__webpack_require__.t.bind(__webpack_require__, 1398, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/haml.snippets', () => __webpack_require__.e(/* import() */ 9736).then(__webpack_require__.t.bind(__webpack_require__, 49736, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/haskell', () => __webpack_require__.e(/* import() */ 6286).then(__webpack_require__.t.bind(__webpack_require__, 66286, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/haskell.snippets', () => __webpack_require__.e(/* import() */ 3056).then(__webpack_require__.t.bind(__webpack_require__, 13056, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/html', () => __webpack_require__.e(/* import() */ 2853).then(__webpack_require__.t.bind(__webpack_require__, 42853, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/html.snippets', () => __webpack_require__.e(/* import() */ 7921).then(__webpack_require__.t.bind(__webpack_require__, 27921, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/io', () => __webpack_require__.e(/* import() */ 4612).then(__webpack_require__.t.bind(__webpack_require__, 64612, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/java', () => __webpack_require__.e(/* import() */ 5884).then(__webpack_require__.t.bind(__webpack_require__, 45884, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/java.snippets', () => __webpack_require__.e(/* import() */ 2178).then(__webpack_require__.t.bind(__webpack_require__, 42178, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/javascript', () => __webpack_require__.e(/* import() */ 207).then(__webpack_require__.t.bind(__webpack_require__, 70207, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/javascript.snippets', () => __webpack_require__.e(/* import() */ 3575).then(__webpack_require__.t.bind(__webpack_require__, 93575, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/jsp', () => __webpack_require__.e(/* import() */ 8371).then(__webpack_require__.t.bind(__webpack_require__, 58371, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/jsp.snippets', () => __webpack_require__.e(/* import() */ 4787).then(__webpack_require__.t.bind(__webpack_require__, 44787, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/liquid', () => __webpack_require__.e(/* import() */ 3916).then(__webpack_require__.t.bind(__webpack_require__, 93916, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/liquid.snippets', () => __webpack_require__.e(/* import() */ 5058).then(__webpack_require__.t.bind(__webpack_require__, 45058, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/lsl', () => __webpack_require__.e(/* import() */ 3121).then(__webpack_require__.t.bind(__webpack_require__, 53121, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/lsl.snippets', () => __webpack_require__.e(/* import() */ 3797).then(__webpack_require__.t.bind(__webpack_require__, 43797, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/lua', () => __webpack_require__.e(/* import() */ 4876).then(__webpack_require__.t.bind(__webpack_require__, 74876, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/lua.snippets', () => __webpack_require__.e(/* import() */ 3650).then(__webpack_require__.t.bind(__webpack_require__, 63650, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/makefile', () => __webpack_require__.e(/* import() */ 2640).then(__webpack_require__.t.bind(__webpack_require__, 52640, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/makefile.snippets', () => __webpack_require__.e(/* import() */ 2398).then(__webpack_require__.t.bind(__webpack_require__, 72398, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/markdown', () => __webpack_require__.e(/* import() */ 9253).then(__webpack_require__.t.bind(__webpack_require__, 99253, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/markdown.snippets', () => __webpack_require__.e(/* import() */ 2177).then(__webpack_require__.t.bind(__webpack_require__, 2177, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/maze', () => __webpack_require__.e(/* import() */ 2335).then(__webpack_require__.t.bind(__webpack_require__, 12335, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/maze.snippets', () => __webpack_require__.e(/* import() */ 4487).then(__webpack_require__.t.bind(__webpack_require__, 74487, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/perl', () => __webpack_require__.e(/* import() */ 6185).then(__webpack_require__.t.bind(__webpack_require__, 76185, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/perl.snippets', () => __webpack_require__.e(/* import() */ 2989).then(__webpack_require__.t.bind(__webpack_require__, 62989, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/php', () => __webpack_require__.e(/* import() */ 6302).then(__webpack_require__.t.bind(__webpack_require__, 6302, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/php.snippets', () => __webpack_require__.e(/* import() */ 4880).then(__webpack_require__.t.bind(__webpack_require__, 64880, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/python', () => __webpack_require__.e(/* import() */ 8066).then(__webpack_require__.t.bind(__webpack_require__, 48066, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/python.snippets', () => __webpack_require__.e(/* import() */ 1884).then(__webpack_require__.t.bind(__webpack_require__, 31884, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/r', () => __webpack_require__.e(/* import() */ 4676).then(__webpack_require__.t.bind(__webpack_require__, 4676, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/r.snippets', () => __webpack_require__.e(/* import() */ 1738).then(__webpack_require__.t.bind(__webpack_require__, 21738, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/razor', () => __webpack_require__.e(/* import() */ 1598).then(__webpack_require__.t.bind(__webpack_require__, 11598, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/razor.snippets', () => __webpack_require__.e(/* import() */ 6848).then(__webpack_require__.t.bind(__webpack_require__, 6848, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/robot', () => __webpack_require__.e(/* import() */ 334).then(__webpack_require__.t.bind(__webpack_require__, 80334, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/robot.snippets', () => __webpack_require__.e(/* import() */ 8320).then(__webpack_require__.t.bind(__webpack_require__, 48320, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/rst', () => __webpack_require__.e(/* import() */ 767).then(__webpack_require__.t.bind(__webpack_require__, 20767, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/rst.snippets', () => __webpack_require__.e(/* import() */ 1975).then(__webpack_require__.t.bind(__webpack_require__, 51975, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/ruby', () => __webpack_require__.e(/* import() */ 8780).then(__webpack_require__.t.bind(__webpack_require__, 98780, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/ruby.snippets', () => __webpack_require__.e(/* import() */ 914).then(__webpack_require__.t.bind(__webpack_require__, 90914, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/sh', () => __webpack_require__.e(/* import() */ 723).then(__webpack_require__.t.bind(__webpack_require__, 70723, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/sh.snippets', () => __webpack_require__.e(/* import() */ 5795).then(__webpack_require__.t.bind(__webpack_require__, 75795, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/snippets', () => __webpack_require__.e(/* import() */ 7318).then(__webpack_require__.t.bind(__webpack_require__, 27318, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/snippets.snippets', () => __webpack_require__.e(/* import() */ 9688).then(__webpack_require__.t.bind(__webpack_require__, 59688, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/sql', () => __webpack_require__.e(/* import() */ 3690).then(__webpack_require__.t.bind(__webpack_require__, 53690, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/sql.snippets', () => __webpack_require__.e(/* import() */ 7316).then(__webpack_require__.t.bind(__webpack_require__, 57316, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/sqlserver', () => __webpack_require__.e(/* import() */ 1529).then(__webpack_require__.t.bind(__webpack_require__, 71529, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/sqlserver.snippets', () => __webpack_require__.e(/* import() */ 3181).then(__webpack_require__.t.bind(__webpack_require__, 93181, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/tcl', () => __webpack_require__.e(/* import() */ 585).then(__webpack_require__.t.bind(__webpack_require__, 90585, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/tcl.snippets', () => __webpack_require__.e(/* import() */ 8173).then(__webpack_require__.t.bind(__webpack_require__, 8173, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/tex', () => __webpack_require__.e(/* import() */ 275).then(__webpack_require__.t.bind(__webpack_require__, 80275, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/tex.snippets', () => __webpack_require__.e(/* import() */ 7715).then(__webpack_require__.t.bind(__webpack_require__, 47715, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/textile', () => __webpack_require__.e(/* import() */ 8671).then(__webpack_require__.t.bind(__webpack_require__, 88671, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/textile.snippets', () => __webpack_require__.e(/* import() */ 2039).then(__webpack_require__.t.bind(__webpack_require__, 32039, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/vala', () => __webpack_require__.e(/* import() */ 4782).then(__webpack_require__.t.bind(__webpack_require__, 44782, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/velocity', () => __webpack_require__.e(/* import() */ 2327).then(__webpack_require__.t.bind(__webpack_require__, 72327, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/velocity.snippets', () => __webpack_require__.e(/* import() */ 3871).then(__webpack_require__.t.bind(__webpack_require__, 53871, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/wollok', () => __webpack_require__.e(/* import() */ 1020).then(__webpack_require__.t.bind(__webpack_require__, 81020, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/snippets/wollok.snippets', () => __webpack_require__.e(/* import() */ 3634).then(__webpack_require__.t.bind(__webpack_require__, 73634, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/ambiance', () => __webpack_require__.e(/* import() */ 697).then(__webpack_require__.t.bind(__webpack_require__, 70697, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/chaos', () => __webpack_require__.e(/* import() */ 3201).then(__webpack_require__.t.bind(__webpack_require__, 33201, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/chrome', () => __webpack_require__.e(/* import() */ 5403).then(__webpack_require__.t.bind(__webpack_require__, 75403, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/cloud9_day', () => __webpack_require__.e(/* import() */ 1652).then(__webpack_require__.t.bind(__webpack_require__, 51652, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/cloud9_night', () => __webpack_require__.e(/* import() */ 8440).then(__webpack_require__.t.bind(__webpack_require__, 68440, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/cloud9_night_low_color', () => __webpack_require__.e(/* import() */ 189).then(__webpack_require__.t.bind(__webpack_require__, 30189, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/cloud_editor', () => __webpack_require__.e(/* import() */ 9486).then(__webpack_require__.t.bind(__webpack_require__, 89486, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/cloud_editor_dark', () => __webpack_require__.e(/* import() */ 7029).then(__webpack_require__.t.bind(__webpack_require__, 27029, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/clouds', () => __webpack_require__.e(/* import() */ 983).then(__webpack_require__.t.bind(__webpack_require__, 30983, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/clouds_midnight', () => __webpack_require__.e(/* import() */ 3474).then(__webpack_require__.t.bind(__webpack_require__, 3474, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/cobalt', () => __webpack_require__.e(/* import() */ 4718).then(__webpack_require__.t.bind(__webpack_require__, 42337, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/crimson_editor', () => __webpack_require__.e(/* import() */ 5006).then(__webpack_require__.t.bind(__webpack_require__, 65006, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/dawn', () => __webpack_require__.e(/* import() */ 6919).then(__webpack_require__.t.bind(__webpack_require__, 66919, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/dracula', () => __webpack_require__.e(/* import() */ 7931).then(__webpack_require__.t.bind(__webpack_require__, 67931, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/dreamweaver', () => __webpack_require__.e(/* import() */ 9426).then(__webpack_require__.t.bind(__webpack_require__, 99426, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/eclipse', () => __webpack_require__.e(/* import() */ 9912).then(__webpack_require__.t.bind(__webpack_require__, 39912, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/github', () => __webpack_require__.e(/* import() */ 4214).then(__webpack_require__.t.bind(__webpack_require__, 24214, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/github_dark', () => __webpack_require__.e(/* import() */ 650).then(__webpack_require__.t.bind(__webpack_require__, 68269, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/github_light_default', () => __webpack_require__.e(/* import() */ 1767).then(__webpack_require__.t.bind(__webpack_require__, 81767, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/gob', () => __webpack_require__.e(/* import() */ 4773).then(__webpack_require__.t.bind(__webpack_require__, 94773, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/gruvbox', () => __webpack_require__.e(/* import() */ 294).then(__webpack_require__.t.bind(__webpack_require__, 90294, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/gruvbox_dark_hard', () => __webpack_require__.e(/* import() */ 3701).then(__webpack_require__.t.bind(__webpack_require__, 43701, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/gruvbox_light_hard', () => __webpack_require__.e(/* import() */ 8429).then(__webpack_require__.t.bind(__webpack_require__, 18429, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/idle_fingers', () => __webpack_require__.e(/* import() */ 3902).then(__webpack_require__.t.bind(__webpack_require__, 63902, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/iplastic', () => __webpack_require__.e(/* import() */ 5496).then(__webpack_require__.t.bind(__webpack_require__, 65496, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/katzenmilch', () => __webpack_require__.e(/* import() */ 5195).then(__webpack_require__.t.bind(__webpack_require__, 25195, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/kr_theme', () => __webpack_require__.e(/* import() */ 7750).then(__webpack_require__.t.bind(__webpack_require__, 97750, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/kuroir', () => __webpack_require__.e(/* import() */ 5993).then(__webpack_require__.t.bind(__webpack_require__, 35993, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/merbivore', () => __webpack_require__.e(/* import() */ 42).then(__webpack_require__.t.bind(__webpack_require__, 40042, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/merbivore_soft', () => __webpack_require__.e(/* import() */ 5649).then(__webpack_require__.t.bind(__webpack_require__, 35649, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/mono_industrial', () => __webpack_require__.e(/* import() */ 9322).then(__webpack_require__.t.bind(__webpack_require__, 29322, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/monokai', () => __webpack_require__.e(/* import() */ 507).then(__webpack_require__.t.bind(__webpack_require__, 507, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/nord_dark', () => __webpack_require__.e(/* import() */ 3823).then(__webpack_require__.t.bind(__webpack_require__, 53823, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/one_dark', () => __webpack_require__.e(/* import() */ 8792).then(__webpack_require__.t.bind(__webpack_require__, 28792, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/pastel_on_dark', () => __webpack_require__.e(/* import() */ 2633).then(__webpack_require__.t.bind(__webpack_require__, 72633, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/solarized_dark', () => __webpack_require__.e(/* import() */ 8793).then(__webpack_require__.t.bind(__webpack_require__, 58793, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/solarized_light', () => __webpack_require__.e(/* import() */ 1897).then(__webpack_require__.t.bind(__webpack_require__, 51897, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/sqlserver', () => __webpack_require__.e(/* import() */ 2038).then(__webpack_require__.t.bind(__webpack_require__, 2038, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/terminal', () => __webpack_require__.e(/* import() */ 8097).then(__webpack_require__.t.bind(__webpack_require__, 78097, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/textmate', () => Promise.resolve(/* import() */).then(__webpack_require__.t.bind(__webpack_require__, 87983, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/tomorrow', () => __webpack_require__.e(/* import() */ 5494).then(__webpack_require__.t.bind(__webpack_require__, 35494, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/tomorrow_night', () => __webpack_require__.e(/* import() */ 1007).then(__webpack_require__.t.bind(__webpack_require__, 11007, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/tomorrow_night_blue', () => __webpack_require__.e(/* import() */ 6094).then(__webpack_require__.t.bind(__webpack_require__, 6094, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/tomorrow_night_bright', () => __webpack_require__.e(/* import() */ 6910).then(__webpack_require__.t.bind(__webpack_require__, 36910, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/tomorrow_night_eighties', () => __webpack_require__.e(/* import() */ 4200).then(__webpack_require__.t.bind(__webpack_require__, 74200, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/twilight', () => __webpack_require__.e(/* import() */ 693).then(__webpack_require__.t.bind(__webpack_require__, 40693, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/vibrant_ink', () => __webpack_require__.e(/* import() */ 2144).then(__webpack_require__.t.bind(__webpack_require__, 12144, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/theme/xcode', () => __webpack_require__.e(/* import() */ 1292).then(__webpack_require__.t.bind(__webpack_require__, 21292, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/keyboard/vim', () => __webpack_require__.e(/* import() */ 2829).then(__webpack_require__.t.bind(__webpack_require__, 2829, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/keyboard/emacs', () => __webpack_require__.e(/* import() */ 8534).then(__webpack_require__.t.bind(__webpack_require__, 48534, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/keyboard/sublime', () => __webpack_require__.e(/* import() */ 8390).then(__webpack_require__.t.bind(__webpack_require__, 48390, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/keyboard/vscode', () => __webpack_require__.e(/* import() */ 3087).then(__webpack_require__.t.bind(__webpack_require__, 13087, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/beautify', () => __webpack_require__.e(/* import() */ 4166).then(__webpack_require__.t.bind(__webpack_require__, 34166, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/code_lens', () => __webpack_require__.e(/* import() */ 1377).then(__webpack_require__.t.bind(__webpack_require__, 91377, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/command_bar', () => __webpack_require__.e(/* import() */ 7700).then(__webpack_require__.t.bind(__webpack_require__, 47700, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/diff', () => __webpack_require__.e(/* import() */ 7760).then(__webpack_require__.t.bind(__webpack_require__, 87760, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/elastic_tabstops_lite', () => __webpack_require__.e(/* import() */ 958).then(__webpack_require__.t.bind(__webpack_require__, 10958, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/emmet', () => __webpack_require__.e(/* import() */ 9395).then(__webpack_require__.t.bind(__webpack_require__, 79395, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/error_marker', () => Promise.resolve(/* import() */).then(__webpack_require__.t.bind(__webpack_require__, 4126, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/hardwrap', () => __webpack_require__.e(/* import() */ 7674).then(__webpack_require__.t.bind(__webpack_require__, 57674, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/inline_autocomplete', () => __webpack_require__.e(/* import() */ 9885).then(__webpack_require__.t.bind(__webpack_require__, 29885, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/keybinding_menu', () => __webpack_require__.e(/* import() */ 3281).then(__webpack_require__.t.bind(__webpack_require__, 73281, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/language_tools', () => Promise.resolve(/* import() */).then(__webpack_require__.t.bind(__webpack_require__, 61893, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/linking', () => __webpack_require__.e(/* import() */ 4323).then(__webpack_require__.t.bind(__webpack_require__, 94323, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/modelist', () => Promise.resolve(/* import() */).then(__webpack_require__.t.bind(__webpack_require__, 91772, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/options', () => __webpack_require__.e(/* import() */ 6613).then(__webpack_require__.t.bind(__webpack_require__, 86613, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/prompt', () => __webpack_require__.e(/* import() */ 1085).then(__webpack_require__.t.bind(__webpack_require__, 71085, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/rtl', () => __webpack_require__.e(/* import() */ 7413).then(__webpack_require__.t.bind(__webpack_require__, 87413, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/searchbox', () => __webpack_require__.e(/* import() */ 1570).then(__webpack_require__.t.bind(__webpack_require__, 41570, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/settings_menu', () => __webpack_require__.e(/* import() */ 1214).then(__webpack_require__.t.bind(__webpack_require__, 11214, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/simple_tokenizer', () => __webpack_require__.e(/* import() */ 3199).then(__webpack_require__.t.bind(__webpack_require__, 23199, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/spellcheck', () => __webpack_require__.e(/* import() */ 3641).then(__webpack_require__.t.bind(__webpack_require__, 53641, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/split', () => __webpack_require__.e(/* import() */ 8939).then(__webpack_require__.t.bind(__webpack_require__, 58939, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/static_highlight', () => __webpack_require__.e(/* import() */ 7254).then(__webpack_require__.t.bind(__webpack_require__, 47254, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/statusbar', () => __webpack_require__.e(/* import() */ 5044).then(__webpack_require__.t.bind(__webpack_require__, 5044, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/textarea', () => __webpack_require__.e(/* import() */ 2697).then(__webpack_require__.t.bind(__webpack_require__, 92697, 23)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/themelist', () => __webpack_require__.e(/* import() */ 1494).then(__webpack_require__.t.bind(__webpack_require__, 91494, 19)));
_src_ace__WEBPACK_IMPORTED_MODULE_0__.config.setModuleLoader('ace/ext/whitespace', () => __webpack_require__.e(/* import() */ 1482).then(__webpack_require__.t.bind(__webpack_require__, 21482, 19)));



/***/ }),

/***/ 12187:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("../edit_session").EditSession} EditSession
 * @typedef {import("../../ace-internal").Ace.LayerConfig} LayerConfig
 */
var Range = (__webpack_require__(91902)/* .Range */ .Q);
var dom = __webpack_require__(71435);


class Marker {
    /**
     * @param {HTMLElement} parentEl
     */
    constructor(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_marker-layer";
        parentEl.appendChild(this.element);
    }

    /**
     * @param {number} padding
     */
    setPadding(padding) {
        this.$padding = padding;
    }

    /**
     * @param {EditSession} session
     */
    setSession(session) {
        this.session = session;
    }

    /**
     * @param {{ [x: number]: import("../../ace-internal").Ace.MarkerLike; }} markers
     */
    setMarkers(markers) {
        this.markers = markers;
    }

    /**
     * @param {string} className
     * @param {string} css
     */
    elt(className, css) {
        /**@type {any}*/
        var x = this.i != -1 && this.element.childNodes[this.i];
        if (!x) {
            x = document.createElement("div");
            this.element.appendChild(x);
            this.i = -1;
        } else {
            this.i++;
        }
        x.style.cssText = css;
        x.className = className;
    }

    /**
     * @param {LayerConfig} config
     */
    update(config) {
        if (!config) return;

        this.config = config;

        this.i = 0;
        var html;
        for (var key in this.markers) {
            var marker = this.markers[key];

            if (!marker.range) {
                marker.update(html, this, this.session, config);
                continue;
            }

            var range = marker.range.clipRows(config.firstRow, config.lastRow);
            if (range.isEmpty()) continue;

            range = range.toScreenRange(this.session);
            if (marker.renderer) {
                var top = this.$getTop(range.start.row, config);
                var left = this.$padding + range.start.column * config.characterWidth;
                marker.renderer(html, range, left, top, config);
            } else if (marker.type == "fullLine") {
                this.drawFullLineMarker(html, range, marker.clazz, config);
            } else if (marker.type == "screenLine") {
                this.drawScreenLineMarker(html, range, marker.clazz, config);
            } else if (range.isMultiLine()) {
                if (marker.type == "text")
                    this.drawTextMarker(html, range, marker.clazz, config);
                else
                    this.drawMultiLineMarker(html, range, marker.clazz, config);
            } else {
                this.drawSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
            }
        }
        if (this.i !=-1) {
            while (this.i < this.element.childElementCount)
                this.element.removeChild(this.element.lastChild);
        }
    }

    /**
     * @param {number} row
     * @param {Partial<LayerConfig>} layerConfig
     */
    $getTop(row, layerConfig) {
        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
    }


    // Draws a marker, which spans a range of text on multiple lines 
    /**
     * @param {undefined} stringBuilder
     * @param {Range} range
     * @param {string} clazz
     * @param {Partial<LayerConfig>} layerConfig
     * @param {string} [extraStyle]
     */
    drawTextMarker(stringBuilder, range, clazz, layerConfig, extraStyle) {
        var session = this.session;
        var start = range.start.row;
        var end = range.end.row;
        var row = start;
        var prev = 0; 
        var curr = 0;
        var next = session.getScreenLastRowColumn(row);
        var lineRange = new Range(row, range.start.column, row, curr);
        for (; row <= end; row++) {
            lineRange.start.row = lineRange.end.row = row;
            lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
            lineRange.end.column = next;
            prev = curr;
            curr = next;
            next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
            this.drawSingleLineMarker(stringBuilder, lineRange, 
                clazz + (row == start  ? " ace_start" : "") + " ace_br"
                    + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end),
                layerConfig, row == end ? 0 : 1, extraStyle);
        }
    }

    // Draws a multi line marker, where lines span the full width
    /**
     * @param {undefined} stringBuilder
     * @param {Range} range
     * @param {string} clazz
     * @param {LayerConfig} config
     * @param {string} [extraStyle]
     */
    drawMultiLineMarker(stringBuilder, range, clazz, config, extraStyle) {
        // from selection start to the end of the line
        var padding = this.$padding;
        var height = config.lineHeight;
        var top = this.$getTop(range.start.row, config);
        var left = padding + range.start.column * config.characterWidth;
        extraStyle = extraStyle || "";

        if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
           var range1 = range.clone();
           range1.end.row = range1.start.row;
           range1.end.column = this.session.getLine(range1.start.row).length;
           this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br1 ace_start", config, null, extraStyle);
        } else {
            this.elt(
                clazz + " ace_br1 ace_start",
                "height:"+ height+ "px;"+ "right:" + padding + "px;"+ "top:"+top+ "px;left:"+ left+ "px;" + (extraStyle || "")
            );
        }
        // from start of the last line to the selection end
        if (this.session.$bidiHandler.isBidiRow(range.end.row)) {
           var range1 = range.clone();
           range1.start.row = range1.end.row;
           range1.start.column = 0;
           this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br12", config, null, extraStyle);
        } else {
            top = this.$getTop(range.end.row, config);
            var width = range.end.column * config.characterWidth;

            this.elt(
                clazz + " ace_br12",
                "height:"+ height+ "px;"+
                "width:"+ width+ "px;"+
                "top:"+ top+ "px;"+
                "left:"+ padding+ "px;"+ (extraStyle || "")
            );
        }
        // all the complete lines
        height = (range.end.row - range.start.row - 1) * config.lineHeight;
        if (height <= 0)
            return;
        top = this.$getTop(range.start.row + 1, config);
        
        var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);

        this.elt(
            clazz + (radiusClass ? " ace_br" + radiusClass : ""),
            "height:"+ height+ "px;"+
            "right:" + padding + "px;"+
            "top:"+ top+ "px;"+
            "left:"+ padding+ "px;"+ (extraStyle || "")
        );
    }

    // Draws a marker which covers part or whole width of a single screen line
    /**
     * @param {undefined} stringBuilder
     * @param {Range} range
     * @param {string} clazz
     * @param {Partial<LayerConfig>} config
     * @param {number} [extraLength]
     * @param {string} [extraStyle]
     */
    drawSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle) {
        if (this.session.$bidiHandler.isBidiRow(range.start.row))
            return this.drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle);
        var height = config.lineHeight;
        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;

        var top = this.$getTop(range.start.row, config);
        var left = this.$padding + range.start.column * config.characterWidth;

        this.elt(
            clazz,
            "height:"+ height+ "px;"+
            "width:"+ width+ "px;"+
            "top:"+ top+ "px;"+
            "left:"+ left+ "px;"+ (extraStyle || "")
        );
    }

    // Draws Bidi marker which covers part or whole width of a single screen line
    /**
     * @param {undefined} stringBuilder
     * @param {Range} range
     * @param {string} clazz
     * @param {Partial<LayerConfig>} config
     * @param {number} extraLength
     * @param {string} extraStyle
     */
    drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle) {
        var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;
        var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);

        selections.forEach(function(selection) {
            this.elt(
                clazz,
                "height:" + height + "px;" +
                "width:" + (selection.width + (extraLength || 0)) + "px;" +
                "top:" + top + "px;" +
                "left:" + (padding + selection.left) + "px;" + (extraStyle || "")
            );
        }, this);
    }

    /**
     * @param {undefined} stringBuilder
     * @param {Range} range
     * @param {string} clazz
     * @param {Partial<LayerConfig>} config
     * @param {undefined} [extraStyle]
     */
    drawFullLineMarker(stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;
        if (range.start.row != range.end.row)
            height += this.$getTop(range.end.row, config) - top;

        this.elt(
            clazz,
            "height:"+ height+ "px;"+
            "top:"+ top+ "px;"+
            "left:0;right:0;"+ (extraStyle || "")
        );
    }

    /**
     * @param {undefined} stringBuilder
     * @param {Range} range
     * @param {string} clazz
     * @param {Partial<LayerConfig>} config
     * @param {undefined} [extraStyle]
     */
    drawScreenLineMarker(stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;

        this.elt(
            clazz,
            "height:"+ height+ "px;"+
            "top:"+ top+ "px;"+
            "left:0;right:0;"+ (extraStyle || "")
        );
    }

}

Marker.prototype.$padding = 0;

function getBorderClass(tl, tr, br, bl) {
    return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
}

exports.p = Marker;


/***/ }),

/***/ 16387:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const deepCopy = (__webpack_require__(77893).deepCopy);

/**@type {(new() => Partial<import("../../ace-internal").Ace.HighlightRules>) & {prototype: import("../../ace-internal").Ace.HighlightRules}}*/
var TextHighlightRules;
TextHighlightRules = function() {

    // regexp must not have capturing parentheses
    // regexps are ordered -> the first match is used

    this.$rules = {
        "start" : [{
            token : "empty_line",
            regex : '^$'
        }, {
            defaultToken : "text"
        }]
    };
};

(function() {

    /**
     * @param {import("../../ace-internal").Ace.HighlightRulesMap} rules
     * @param {string} [prefix]
     * @this {import("../../ace-internal").Ace.HighlightRules}
     */
    this.addRules = function(rules, prefix) {
        if (!prefix) {
            for (var key in rules)
                this.$rules[key] = rules[key];
            return;
        }
        for (var key in rules) {
            var state = rules[key];
            for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                if (rule.next || rule.onMatch) {
                    if (typeof rule.next == "string") {
                        if (rule.next.indexOf(prefix) !== 0)
                            rule.next = prefix + rule.next;
                    }
                    if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
                        rule.nextState = prefix + rule.nextState;
                }
            }
            this.$rules[prefix + key] = state;
        }
    };

    /**
     * @returns {import("../../ace-internal").Ace.HighlightRulesMap}
     * @this {import("../../ace-internal").Ace.HighlightRules}
     */
    this.getRules = function() {
        return this.$rules;
    };

    /**
     * @param HighlightRules
     * @param prefix
     * @param escapeRules
     * @param states
     * @param append
     * @this {import("../../ace-internal").Ace.HighlightRules}
     */
    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
        var embedRules = typeof HighlightRules == "function"
            ? new HighlightRules().getRules()
            : HighlightRules;
        if (states) {
            for (var i = 0; i < states.length; i++)
                states[i] = prefix + states[i];
        } else {
            states = [];
            for (var key in embedRules)
                states.push(prefix + key);
        }

        this.addRules(embedRules, prefix);

        if (escapeRules) {
            var addRules = Array.prototype[append ? "push" : "unshift"];
            for (var i = 0; i < states.length; i++)
                addRules.apply(this.$rules[states[i]], deepCopy(escapeRules));
        }

        if (!this.$embeds)
            this.$embeds = [];
        this.$embeds.push(prefix);
    };

    /**
     * @this {import("../../ace-internal").Ace.HighlightRules}
     */
    this.getEmbeds = function() {
        return this.$embeds;
    };

    var pushState = function(currentState, stack) {
        if (currentState != "start" || stack.length)
            stack.unshift(this.nextState, currentState);
        return this.nextState;
    };
    var popState = function(currentState, stack) {
        // if (stack[0] === currentState)
        stack.shift();
        return stack.shift() || "start";
    };

    /**
     * @this {import("../../ace-internal").Ace.HighlightRules}
     */
    this.normalizeRules = function() {
        var id = 0;
        var rules = this.$rules;
        function processState(key) {
            var state = rules[key];
            state["processed"] = true;
            for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                var toInsert = null;
                if (Array.isArray(rule)) {
                    toInsert = rule;
                    // @ts-ignore
                    rule = {};
                }
                if (!rule.regex && rule.start) {
                    rule.regex = rule.start;
                    if (!rule.next)
                        rule.next = [];
                    rule.next.push({
                        defaultToken: rule.token
                    }, {
                        token: rule.token + ".end",
                        regex: rule.end || rule.start,
                        next: "pop"
                    });
                    rule.token = rule.token + ".start";
                    rule.push = true;
                }
                var next = rule.next || rule.push;
                if (next && Array.isArray(next)) {
                    var stateName = rule.stateName;
                    if (!stateName)  {
                        stateName = rule.token;
                        if (typeof stateName != "string")
                            stateName = stateName[0] || "";
                        if (rules[stateName])
                            stateName += id++;
                    }
                    rules[stateName] = next;
                    rule.next = stateName;
                    processState(stateName);
                } else if (next == "pop") {
                    rule.next = popState;
                }

                if (rule.push) {
                    rule.nextState = rule.next || rule.push;
                    rule.next = pushState;
                    delete rule.push;
                }

                if (rule.rules) {
                    for (var r in rule.rules) {
                        if (rules[r]) {
                            if (rules[r].push)
                                rules[r].push.apply(rules[r], rule.rules[r]);
                        } else {
                            rules[r] = rule.rules[r];
                        }
                    }
                }
                var includeName = typeof rule == "string" ? rule : rule.include;
                if (includeName) {
                    if (includeName === "$self")
                        includeName = "start";
                    if (Array.isArray(includeName))
                        toInsert = includeName.map(function(x) { return rules[x]; });
                    else
                        toInsert = rules[includeName];
                }

                if (toInsert) {
                    /**
                     * @type{any[]}
                     */
                    // @ts-ignore
                    var args = [i, 1].concat(toInsert);
                    if (rule.noEscape)
                        args = args.filter(function(x) {return !x.next;});
                    state.splice.apply(state, args);
                    // skip included rules since they are already processed
                    //i += args.length - 3;
                    i--;
                }
                
                if (rule.keywordMap) {
                    rule.token = this.createKeywordMapper(
                        rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive
                    );
                    delete rule.defaultToken;
                }
            }
        }
        Object.keys(rules).forEach(processState, this);
    };

    this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
        var keywords = Object.create(null);
        this.$keywordList = [];
        Object.keys(map).forEach(function(className) {
            var a = map[className];
            var list = a.split(splitChar || "|");
            for (var i = list.length; i--; ) {
                var word = list[i];
                this.$keywordList.push(word);
                if (ignoreCase)
                    word = word.toLowerCase(); 
                keywords[word] = className;
            }
        }, this);
        map = null;
        return ignoreCase
            ? function(value) {return keywords[value.toLowerCase()] || defaultToken; }
            : function(value) {return keywords[value] || defaultToken; };
    };

    /**
     * @this {import("../../ace-internal").Ace.HighlightRules}
     */
    this.getKeywords = function() {
        return this.$keywords;
    };

}).call(TextHighlightRules.prototype);

exports.r = TextHighlightRules;


/***/ }),

/***/ 16585:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./edit_session").EditSession} EditSession
 */

var bidiUtil = __webpack_require__(50973);
var lang = __webpack_require__(39955);
var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\u202B]/;

/**
 * This object is used to ensure Bi-Directional support (for languages with text flowing from right to left, like Arabic or Hebrew)
 * including correct caret positioning, text selection mouse and keyboard arrows functioning
 **/
class BidiHandler {
    /**
     * Creates a new `BidiHandler` object
     * @param {EditSession} session The session to use
     **/
    constructor(session) {
        this.session = session;
        this.bidiMap = {};
        /* current screen row */
        this.currentRow = null;
        this.bidiUtil = bidiUtil;
        /* Arabic/Hebrew character width differs from regular character width */
        this.charWidths = [];
        this.EOL = "\xAC";
        this.showInvisibles = true;
        this.isRtlDir = false;
        this.$isRtl = false;
        this.line = "";
        this.wrapIndent = 0;
        this.EOF = "\xB6";
        this.RLE = "\u202B";
        this.contentWidth = 0;
        this.fontMetrics = null;
        this.rtlLineOffset = 0;
        this.wrapOffset = 0;
        this.isMoveLeftOperation = false;
        this.seenBidi = bidiRE.test(session.getValue());
    }

    /**
     * Returns 'true' if row contains Bidi characters, in such case
     * creates Bidi map to be used in operations related to selection
     * (keyboard arrays, mouse click, select)
     * @param {Number} screenRow the screen row to be checked
     * @param {Number} [docRow] the document row to be checked [optional]
     * @param {Number} [splitIndex] the wrapped screen line index [ optional]
    **/
    isBidiRow(screenRow, docRow, splitIndex) {
        if (!this.seenBidi)
            return false;
        if (screenRow !== this.currentRow) {
            this.currentRow = screenRow;
            this.updateRowLine(docRow, splitIndex);
            this.updateBidiMap();
        }
        return this.bidiMap.bidiLevels;
    }

    /**
     * @param {import("../ace-internal").Ace.Delta} delta
     * @internal
     */
    onChange(delta) {
        if (!this.seenBidi) {
            if (delta.action == "insert" && bidiRE.test(delta.lines.join("\n"))) {
                this.seenBidi = true;
                this.currentRow = null;
            }
        }
        else {
            this.currentRow = null;
        }
    }

    getDocumentRow() {
        var docRow = 0;
        var rowCache = this.session.$screenRowCache;
        if (rowCache.length) {
            var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);
            if (index >= 0)
                docRow = this.session.$docRowCache[index];
        }

        return docRow;
    }

    getSplitIndex() {
        var splitIndex = 0;
        var rowCache = this.session.$screenRowCache;
        if (rowCache.length) {
            var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);
            while (this.currentRow - splitIndex > 0) {
                currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);
                if (currentIndex !== prevIndex)
                    break;

                prevIndex = currentIndex;
                splitIndex++;
            }
        } else {
            splitIndex = this.currentRow;
        }

        return splitIndex;
    }

    updateRowLine(docRow, splitIndex) {
        if (docRow === undefined)
            docRow = this.getDocumentRow();

        var isLastRow = (docRow === this.session.getLength() - 1),
            endOfLine = isLastRow ? this.EOF : this.EOL;

        this.wrapIndent = 0;
        this.line = this.session.getLine(docRow);
        this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;
        if (this.session.$useWrapMode) {
            var splits = this.session.$wrapData[docRow];
            if (splits) {
                if (splitIndex === undefined)
                    splitIndex = this.getSplitIndex();

                if(splitIndex > 0 && splits.length) {
                    this.wrapIndent = splits.indent;
                    this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];
                    this.line = (splitIndex < splits.length) ?
                        this.line.substring(splits[splitIndex - 1], splits[splitIndex]) :
                            this.line.substring(splits[splits.length - 1]);
                } else {
                    this.line = this.line.substring(0, splits[splitIndex]);
                }

                if (splitIndex == splits.length) {
                    this.line += (this.showInvisibles) ? endOfLine : bidiUtil.DOT;
                }
            }
        } else {
            this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
        }

        /* replace tab and wide characters by commensurate spaces */
        var session = this.session, shift = 0, size;
        this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function(ch, i){
            if (ch === '\t' || session.isFullWidth(ch.charCodeAt(0))) {
                size = (ch === '\t') ? session.getScreenTabSize(i + shift) : 2;
                shift += size - 1;
                return lang.stringRepeat(bidiUtil.DOT, size);
            }
            return ch;
        });

        if (this.isRtlDir) {
            this.fontMetrics.$main.textContent = (this.line.charAt(this.line.length - 1) == bidiUtil.DOT) ? this.line.substr(0, this.line.length - 1) : this.line;
            this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;
        }
    }

    updateBidiMap() {
        var textCharTypes = [];
        if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) {
             this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);
        } else {
            this.bidiMap = {};
        }
    }

    /**
     * Resets stored info related to current screen row
    **/
    markAsDirty() {
        this.currentRow = null;
    }

    /**
     * Updates array of character widths
     * @param {Object} fontMetrics metrics
     *
    **/
    updateCharacterWidths(fontMetrics) {
        if (this.characterWidth === fontMetrics.$characterSize.width)
            return;

        this.fontMetrics = fontMetrics;
        var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;
        var bidiCharWidth = fontMetrics.$measureCharWidth("\u05d4");

        this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;
        this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;
        this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;
        this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;

        this.currentRow = null;
    }

    setShowInvisibles(showInvisibles) {
        this.showInvisibles = showInvisibles;
        this.currentRow = null;
    }

    setEolChar(eolChar) {
        this.EOL = eolChar;
    }

    setContentWidth(width) {
        this.contentWidth = width;
    }

    isRtlLine(row) {
        if (this.$isRtl) return true;
        if (row != undefined)
            return (this.session.getLine(row).charAt(0) == this.RLE);
        else
            return this.isRtlDir;
    }

    setRtlDirection(editor, isRtlDir) {
        var cursor = editor.getCursorPosition();
        for (var row = editor.selection.getSelectionAnchor().row; row <= cursor.row; row++) {
            if (!isRtlDir && editor.session.getLine(row).charAt(0) === editor.session.$bidiHandler.RLE)
                editor.session.doc.removeInLine(row, 0, 1);
            else if (isRtlDir && editor.session.getLine(row).charAt(0) !== editor.session.$bidiHandler.RLE)
                editor.session.doc.insert({column: 0, row: row}, editor.session.$bidiHandler.RLE);
        }
    }


    /**
     * Returns offset of character at position defined by column.
     * @param {Number} col the screen column position
     *
     * @return {Number} horizontal pixel offset of given screen column
     **/
    getPosLeft(col) {
        col -= this.wrapIndent;
        var leftBoundary = (this.line.charAt(0) === this.RLE) ? 1 : 0;
        var logicalIdx = (col > leftBoundary) ? (this.session.getOverwrite() ? col : col - 1) : leftBoundary;
        var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap),
            levels = this.bidiMap.bidiLevels, left = 0;

        if (!this.session.getOverwrite() && col <= leftBoundary && levels[visualIdx] % 2 !== 0)
            visualIdx++;

        for (var i = 0; i < visualIdx; i++) {
            left += this.charWidths[levels[i]];
        }

        if (!this.session.getOverwrite() && (col > leftBoundary) && (levels[visualIdx] % 2 === 0))
            left += this.charWidths[levels[visualIdx]];

        if (this.wrapIndent)
            left += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;

        if (this.isRtlDir)
            left += this.rtlLineOffset;

        return left;
    }

    /**
     * Returns 'selections' - array of objects defining set of selection rectangles
     * @param {Number} startCol the start column position
     * @param {Number} endCol the end column position
     *
     * @return {Object[]} Each object contains 'left' and 'width' values defining selection rectangle.
    **/
    getSelections(startCol, endCol) {
        var map = this.bidiMap, levels = map.bidiLevels, level, selections = [], offset = 0,
            selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent,
                isSelected = false, isSelectedPrev = false, selectionStart = 0;

        if (this.wrapIndent)
            offset += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;

        for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {
            logIdx = map.logicalFromVisual[visIdx];
            level = levels[visIdx];
            isSelected = (logIdx >= selColMin) && (logIdx < selColMax);
            if (isSelected && !isSelectedPrev) {
                selectionStart = offset;
            } else if (!isSelected && isSelectedPrev) {
                selections.push({left: selectionStart, width: offset - selectionStart});
            }
            offset += this.charWidths[level];
            isSelectedPrev = isSelected;
        }

        if (isSelected && (visIdx === levels.length)) {
            selections.push({left: selectionStart, width: offset - selectionStart});
        }

        if(this.isRtlDir) {
            for (var i = 0; i < selections.length; i++) {
                selections[i].left += this.rtlLineOffset;
            }
        }
        return selections;
    }

    /**
     * Converts character coordinates on the screen to respective document column number
     * @param {Number} posX character horizontal offset
     *
     * @return {Number} screen column number corresponding to given pixel offset
    **/
    offsetToCol(posX) {
        if(this.isRtlDir)
            posX -= this.rtlLineOffset;

        var logicalIdx = 0, posX = Math.max(posX, 0),
            offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels,
                charWidth = this.charWidths[levels[visualIdx]];

        if (this.wrapIndent)
           posX -= this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;

        while(posX > offset + charWidth/2) {
            offset += charWidth;
            if(visualIdx === levels.length - 1) {
                /* quit when we on the right of the last character, flag this by charWidth = 0 */
                charWidth = 0;
                break;
            }
            charWidth = this.charWidths[levels[++visualIdx]];
        }

        if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && (levels[visualIdx] % 2 === 0)){
        /* Bidi character on the left and None Bidi character on the right */
            if(posX < offset)
                visualIdx--;
            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];

        } else if (visualIdx > 0 && (levels[visualIdx - 1] % 2 === 0) && (levels[visualIdx] % 2 !== 0)){
        /* None Bidi character on the left and Bidi character on the right */
            logicalIdx = 1 + ((posX > offset) ? this.bidiMap.logicalFromVisual[visualIdx]
                    : this.bidiMap.logicalFromVisual[visualIdx - 1]);

        } else if ((this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && (levels[visualIdx - 1] % 2 === 0))
                || (!this.isRtlDir && visualIdx === 0 && (levels[visualIdx] % 2 !== 0))){
        /* To the right of last character, which is None Bidi, in RTL direction or */
        /* to the left of first Bidi character, in LTR direction */
            logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];
        } else {
            /* Tweak visual position when Bidi character on the left in order to map it to corresponding logical position */
            if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && charWidth !== 0)
                visualIdx--;

            /* Regular case */
            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
        }

        if (logicalIdx === 0 && this.isRtlDir)
            logicalIdx++;

        return (logicalIdx + this.wrapIndent);
    }

}

exports.t = BidiHandler;


/***/ }),

/***/ 17745:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


var oop = __webpack_require__(2645);
var dom = __webpack_require__(71435);
var event = __webpack_require__(19631);
var EventEmitter = (__webpack_require__(87366).EventEmitter);
// on ie maximal element height is smaller than what we get from 4-5K line document
// so scrollbar doesn't work, as a workaround we do not set height higher than MAX_SCROLL_H
// and rescale scrolltop
var MAX_SCROLL_H = 0x8000;

/**
 * An abstract class representing a native scrollbar control.
 **/
class Scrollbar {
    /**
     * Creates a new `ScrollBar`. `parent` is the owner of the scroll bar.
     * @param {Element} parent A DOM element
     * @param {string} classSuffix
     **/
    constructor(parent, classSuffix) {
        this.element = dom.createElement("div");
        this.element.className = "ace_scrollbar ace_scrollbar" + classSuffix;

        this.inner = dom.createElement("div");
        this.inner.className = "ace_scrollbar-inner";
        // on safari scrollbar is not shown for empty elements
        this.inner.textContent = "\xa0";
        this.element.appendChild(this.inner);

        parent.appendChild(this.element);

        this.setVisible(false);
        this.skipEvent = false;

        // @ts-expect-error
        event.addListener(this.element, "scroll", this.onScroll.bind(this));
        event.addListener(this.element, "mousedown", event.preventDefault);
    }

    setVisible(isVisible) {
        this.element.style.display = isVisible ? "" : "none";
        this.isVisible = isVisible;
        this.coeff = 1;
    }
}
oop.implement(Scrollbar.prototype, EventEmitter);

/**
 * Represents a vertical scroll bar.
 **/
class VScrollBar extends Scrollbar {
    /**
     * Creates a new `VScrollBar`. `parent` is the owner of the scroll bar.
     * @param {Element} parent A DOM element
     * @param {Object} renderer An editor renderer
     **/
    constructor(parent, renderer) {
        super(parent, '-v');
        this.scrollTop = 0;
        this.scrollHeight = 0;

        // in OSX lion the scrollbars appear to have no width. In this case resize the
        // element to show the scrollbar but still pretend that the scrollbar has a width
        // of 0px
        // in Firefox 6+ scrollbar is hidden if element has the same width as scrollbar
        // make element a little bit wider to retain scrollbar when page is zoomed
        renderer.$scrollbarWidth =
            this.width = dom.scrollbarWidth(parent.ownerDocument);
        this.inner.style.width =
            this.element.style.width = (this.width || 15) + 5 + "px";
        this.$minWidth = 0;
    }


    /**
     * Emitted when the scroll bar, well, scrolls.
     * @event scroll
     * @internal
     **/

    onScroll() {
        if (!this.skipEvent) {
            this.scrollTop = this.element.scrollTop;
            if (this.coeff != 1) {
                var h = this.element.clientHeight / this.scrollHeight;
                this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
            }
            this._emit("scroll", {data: this.scrollTop});
        }
        this.skipEvent = false;
    }

    /**
     * Returns the width of the scroll bar.
     * @returns {Number}
     **/
    getWidth() {
        return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
    }

    /**
     * Sets the height of the scroll bar, in pixels.
     * @param {Number} height The new height
     **/
    setHeight(height) {
        this.element.style.height = height + "px";
    }

    /**
     * Sets the scroll height of the scroll bar, in pixels.
     * @param {Number} height The new scroll height
     **/
    setScrollHeight(height) {
        this.scrollHeight = height;
        if (height > MAX_SCROLL_H) {
            this.coeff = MAX_SCROLL_H / height;
            height = MAX_SCROLL_H;
        } else if (this.coeff != 1) {
            this.coeff = 1;
        }
        this.inner.style.height = height + "px";
    }


    /**
     * Sets the scroll top of the scroll bar.
     * @param {Number} scrollTop The new scroll top
     **/
    setScrollTop(scrollTop) {
        // on chrome 17+ for small zoom levels after calling this function
        // this.element.scrollTop != scrollTop which makes page to scroll up.
        if (this.scrollTop != scrollTop) {
            this.skipEvent = true;
            this.scrollTop = scrollTop;
            this.element.scrollTop = scrollTop * this.coeff;
        }
    }

}

/**
 * Sets the inner height of the scroll bar, in pixels.
 * @param {Number} height The new inner height
 * @deprecated Use setScrollHeight instead
 **/
VScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;

/**
 * Represents a horisontal scroll bar.
 **/
class HScrollBar extends Scrollbar {
    /**
     * Creates a new `HScrollBar`. `parent` is the owner of the scroll bar.
     * @param {Element} parent A DOM element
     * @param {Object} renderer An editor renderer
     **/
    constructor(parent, renderer) {
        super(parent, '-h');
        this.scrollLeft = 0;

        // in OSX lion the scrollbars appear to have no width. In this case resize the
        // element to show the scrollbar but still pretend that the scrollbar has a width
        // of 0px
        // in Firefox 6+ scrollbar is hidden if element has the same width as scrollbar
        // make element a little bit wider to retain scrollbar when page is zoomed
        this.height = renderer.$scrollbarWidth;
        this.inner.style.height =
            this.element.style.height = (this.height || 15) + 5 + "px";
    }

    /**
     * Emitted when the scroll bar, well, scrolls.
     * @event scroll
     * @internal
     **/
    onScroll() {
        if (!this.skipEvent) {
            this.scrollLeft = this.element.scrollLeft;
            this._emit("scroll", {data: this.scrollLeft});
        }
        this.skipEvent = false;
    }

    /**
     * Returns the height of the scroll bar.
     * @returns {Number}
     **/
    getHeight() {
        return this.isVisible ? this.height : 0;
    }

    /**
     * Sets the width of the scroll bar, in pixels.
     * @param {Number} width The new width
     **/
    setWidth(width) {
        this.element.style.width = width + "px";
    }

    /**
     * Sets the inner width of the scroll bar, in pixels.
     * @param {Number} width The new inner width
     * @deprecated Use setScrollWidth instead
     **/
    setInnerWidth(width) {
        this.inner.style.width = width + "px";
    }

    /**
     * Sets the scroll width of the scroll bar, in pixels.
     * @param {Number} width The new scroll width
     **/
    setScrollWidth(width) {
        this.inner.style.width = width + "px";
    }

    /**
     * Sets the scroll left of the scroll bar.
     * @param {Number} scrollLeft The new scroll left
     **/
    setScrollLeft(scrollLeft) {
        // on chrome 17+ for small zoom levels after calling this function
        // this.element.scrollTop != scrollTop which makes page to scroll up.
        if (this.scrollLeft != scrollLeft) {
            this.skipEvent = true;
            this.scrollLeft = this.element.scrollLeft = scrollLeft;
        }
    }

}


__webpack_unused_export__ = VScrollBar; // backward compatibility
__webpack_unused_export__ = VScrollBar; // backward compatibility
__webpack_unused_export__ = HScrollBar; // backward compatibility

exports.vB = VScrollBar;
exports.V1 = HScrollBar;


/***/ }),

/***/ 19564:
/***/ (function(__unused_webpack_module, exports) {

(function(global, factory) {
   true ? factory(exports) : 0;
})(this, (function(exports2) {
  "use strict";var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

  function getDefaultExportFromCjs$1(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  function getAugmentedNamespace(n) {
    if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
    var f = n.default;
    if (typeof f == "function") {
      var a = function a2() {
        var isInstance = false;
        try {
          isInstance = this instanceof a2;
        } catch {
        }
        if (isInstance) {
          return Reflect.construct(f, arguments, this.constructor);
        }
        return f.apply(this, arguments);
      };
      a.prototype = f.prototype;
    } else a = {};
    Object.defineProperty(a, "__esModule", { value: true });
    Object.keys(n).forEach(function(k) {
      var d = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(a, k, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k];
        }
      });
    });
    return a;
  }
  var main$2 = {};
  var main$1 = {};
  var ril = {};
  var api$1 = {};
  var messages$1 = {};
  var is$1 = {};
  var hasRequiredIs$1;
  function requireIs$1() {
    if (hasRequiredIs$1) return is$1;
    hasRequiredIs$1 = 1;
    Object.defineProperty(is$1, "__esModule", { value: true });
    is$1.stringArray = is$1.array = is$1.func = is$1.error = is$1.number = is$1.string = is$1.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    is$1.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    is$1.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    is$1.number = number;
    function error(value) {
      return value instanceof Error;
    }
    is$1.error = error;
    function func(value) {
      return typeof value === "function";
    }
    is$1.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    is$1.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    is$1.stringArray = stringArray;
    return is$1;
  }
  var hasRequiredMessages$1;
  function requireMessages$1() {
    if (hasRequiredMessages$1) return messages$1;
    hasRequiredMessages$1 = 1;
    Object.defineProperty(messages$1, "__esModule", { value: true });
    messages$1.Message = messages$1.NotificationType9 = messages$1.NotificationType8 = messages$1.NotificationType7 = messages$1.NotificationType6 = messages$1.NotificationType5 = messages$1.NotificationType4 = messages$1.NotificationType3 = messages$1.NotificationType2 = messages$1.NotificationType1 = messages$1.NotificationType0 = messages$1.NotificationType = messages$1.RequestType9 = messages$1.RequestType8 = messages$1.RequestType7 = messages$1.RequestType6 = messages$1.RequestType5 = messages$1.RequestType4 = messages$1.RequestType3 = messages$1.RequestType2 = messages$1.RequestType1 = messages$1.RequestType = messages$1.RequestType0 = messages$1.AbstractMessageSignature = messages$1.ParameterStructures = messages$1.ResponseError = messages$1.ErrorCodes = void 0;
    const is2 = requireIs$1();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = -32099;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.PendingResponseRejected = -32097;
      ErrorCodes2.ConnectionInactive = -32096;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = -32e3;
    })(ErrorCodes || (messages$1.ErrorCodes = ErrorCodes = {}));
    class ResponseError extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is2.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    }
    messages$1.ResponseError = ResponseError;
    class ParameterStructures {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    }
    messages$1.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    class AbstractMessageSignature {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    }
    messages$1.AbstractMessageSignature = AbstractMessageSignature;
    class RequestType0 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    }
    messages$1.RequestType0 = RequestType0;
    class RequestType extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    }
    messages$1.RequestType = RequestType;
    class RequestType1 extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    }
    messages$1.RequestType1 = RequestType1;
    class RequestType2 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    }
    messages$1.RequestType2 = RequestType2;
    class RequestType3 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    }
    messages$1.RequestType3 = RequestType3;
    class RequestType4 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    }
    messages$1.RequestType4 = RequestType4;
    class RequestType5 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    }
    messages$1.RequestType5 = RequestType5;
    class RequestType6 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    }
    messages$1.RequestType6 = RequestType6;
    class RequestType7 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    }
    messages$1.RequestType7 = RequestType7;
    class RequestType8 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    }
    messages$1.RequestType8 = RequestType8;
    class RequestType9 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    }
    messages$1.RequestType9 = RequestType9;
    class NotificationType extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    }
    messages$1.NotificationType = NotificationType;
    class NotificationType0 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    }
    messages$1.NotificationType0 = NotificationType0;
    class NotificationType1 extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    }
    messages$1.NotificationType1 = NotificationType1;
    class NotificationType2 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    }
    messages$1.NotificationType2 = NotificationType2;
    class NotificationType3 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    }
    messages$1.NotificationType3 = NotificationType3;
    class NotificationType4 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    }
    messages$1.NotificationType4 = NotificationType4;
    class NotificationType5 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    }
    messages$1.NotificationType5 = NotificationType5;
    class NotificationType6 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    }
    messages$1.NotificationType6 = NotificationType6;
    class NotificationType7 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    }
    messages$1.NotificationType7 = NotificationType7;
    class NotificationType8 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    }
    messages$1.NotificationType8 = NotificationType8;
    class NotificationType9 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    }
    messages$1.NotificationType9 = NotificationType9;
    var Message;
    (function(Message2) {
      function isRequest(message) {
        const candidate = message;
        return candidate && is2.string(candidate.method) && (is2.string(candidate.id) || is2.number(candidate.id));
      }
      Message2.isRequest = isRequest;
      function isNotification(message) {
        const candidate = message;
        return candidate && is2.string(candidate.method) && message.id === void 0;
      }
      Message2.isNotification = isNotification;
      function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is2.string(candidate.id) || is2.number(candidate.id) || candidate.id === null);
      }
      Message2.isResponse = isResponse;
    })(Message || (messages$1.Message = Message = {}));
    return messages$1;
  }
  var linkedMap = {};
  var hasRequiredLinkedMap;
  function requireLinkedMap() {
    if (hasRequiredLinkedMap) return linkedMap;
    hasRequiredLinkedMap = 1;
    var _a;
    Object.defineProperty(linkedMap, "__esModule", { value: true });
    linkedMap.LRUCache = linkedMap.LinkedMap = linkedMap.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch || (linkedMap.Touch = Touch = {}));
    class LinkedMap {
      constructor() {
        this[_a] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        var _a2;
        return (_a2 = this._head) == null ? void 0 : _a2.value;
      }
      get last() {
        var _a2;
        return (_a2 = this._tail) == null ? void 0 : _a2.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    }
    linkedMap.LinkedMap = LinkedMap;
    class LRUCache extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    }
    linkedMap.LRUCache = LRUCache;
    return linkedMap;
  }
  var disposable = {};
  var hasRequiredDisposable;
  function requireDisposable() {
    if (hasRequiredDisposable) return disposable;
    hasRequiredDisposable = 1;
    Object.defineProperty(disposable, "__esModule", { value: true });
    disposable.Disposable = void 0;
    var Disposable;
    (function(Disposable2) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create;
    })(Disposable || (disposable.Disposable = Disposable = {}));
    return disposable;
  }
  var events = {};
  var ral = {};
  var hasRequiredRal;
  function requireRal() {
    if (hasRequiredRal) return ral;
    hasRequiredRal = 1;
    Object.defineProperty(ral, "__esModule", { value: true });
    let _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral2) {
        if (ral2 === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral2;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    ral.default = RAL;
    return ral;
  }
  var hasRequiredEvents;
  function requireEvents() {
    if (hasRequiredEvents) return events;
    hasRequiredEvents = 1;
    Object.defineProperty(events, "__esModule", { value: true });
    events.Emitter = events.Event = void 0;
    const ral_1 = requireRal();
    var Event;
    (function(Event2) {
      const _disposable = { dispose() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(Event || (events.Event = Event = {}));
    class CallbackList {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    }
    class Emitter {
      constructor(_options) {
        this._options = _options;
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    }
    events.Emitter = Emitter;
    Emitter._noop = function() {
    };
    return events;
  }
  var cancellation = {};
  var hasRequiredCancellation;
  function requireCancellation() {
    if (hasRequiredCancellation) return cancellation;
    hasRequiredCancellation = 1;
    Object.defineProperty(cancellation, "__esModule", { value: true });
    cancellation.CancellationTokenSource = cancellation.CancellationToken = void 0;
    const ral_1 = requireRal();
    const Is2 = requireIs$1();
    const events_1 = requireEvents();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is2(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is2.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is2;
    })(CancellationToken || (cancellation.CancellationToken = CancellationToken = {}));
    const shortcutEvent = Object.freeze(function(callback, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        handle.dispose();
      } };
    });
    class MutableToken {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    }
    class CancellationTokenSource {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    }
    cancellation.CancellationTokenSource = CancellationTokenSource;
    return cancellation;
  }
  var sharedArrayCancellation = {};
  var hasRequiredSharedArrayCancellation;
  function requireSharedArrayCancellation() {
    if (hasRequiredSharedArrayCancellation) return sharedArrayCancellation;
    hasRequiredSharedArrayCancellation = 1;
    Object.defineProperty(sharedArrayCancellation, "__esModule", { value: true });
    sharedArrayCancellation.SharedArrayReceiverStrategy = sharedArrayCancellation.SharedArraySenderStrategy = void 0;
    const cancellation_1 = requireCancellation();
    var CancellationState;
    (function(CancellationState2) {
      CancellationState2.Continue = 0;
      CancellationState2.Cancelled = 1;
    })(CancellationState || (CancellationState = {}));
    class SharedArraySenderStrategy {
      constructor() {
        this.buffers = /* @__PURE__ */ new Map();
      }
      enableCancellation(request) {
        if (request.id === null) {
          return;
        }
        const buffer = new SharedArrayBuffer(4);
        const data = new Int32Array(buffer, 0, 1);
        data[0] = CancellationState.Continue;
        this.buffers.set(request.id, buffer);
        request.$cancellationData = buffer;
      }
      async sendCancellation(_conn, id) {
        const buffer = this.buffers.get(id);
        if (buffer === void 0) {
          return;
        }
        const data = new Int32Array(buffer, 0, 1);
        Atomics.store(data, 0, CancellationState.Cancelled);
      }
      cleanup(id) {
        this.buffers.delete(id);
      }
      dispose() {
        this.buffers.clear();
      }
    }
    sharedArrayCancellation.SharedArraySenderStrategy = SharedArraySenderStrategy;
    class SharedArrayBufferCancellationToken {
      constructor(buffer) {
        this.data = new Int32Array(buffer, 0, 1);
      }
      get isCancellationRequested() {
        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
      }
      get onCancellationRequested() {
        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
      }
    }
    class SharedArrayBufferCancellationTokenSource {
      constructor(buffer) {
        this.token = new SharedArrayBufferCancellationToken(buffer);
      }
      cancel() {
      }
      dispose() {
      }
    }
    class SharedArrayReceiverStrategy {
      constructor() {
        this.kind = "request";
      }
      createCancellationTokenSource(request) {
        const buffer = request.$cancellationData;
        if (buffer === void 0) {
          return new cancellation_1.CancellationTokenSource();
        }
        return new SharedArrayBufferCancellationTokenSource(buffer);
      }
    }
    sharedArrayCancellation.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
    return sharedArrayCancellation;
  }
  var messageReader = {};
  var semaphore = {};
  var hasRequiredSemaphore;
  function requireSemaphore() {
    if (hasRequiredSemaphore) return semaphore;
    hasRequiredSemaphore = 1;
    Object.defineProperty(semaphore, "__esModule", { value: true });
    semaphore.Semaphore = void 0;
    const ral_1 = requireRal();
    class Semaphore {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve, reject) => {
          this._waiting.push({ thunk, resolve, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    }
    semaphore.Semaphore = Semaphore;
    return semaphore;
  }
  var hasRequiredMessageReader;
  function requireMessageReader() {
    if (hasRequiredMessageReader) return messageReader;
    hasRequiredMessageReader = 1;
    Object.defineProperty(messageReader, "__esModule", { value: true });
    messageReader.ReadableStreamMessageReader = messageReader.AbstractMessageReader = messageReader.MessageReader = void 0;
    const ral_1 = requireRal();
    const Is2 = requireIs$1();
    const events_1 = requireEvents();
    const semaphore_1 = requireSemaphore();
    var MessageReader;
    (function(MessageReader2) {
      function is2(value) {
        let candidate = value;
        return candidate && Is2.func(candidate.listen) && Is2.func(candidate.dispose) && Is2.func(candidate.onError) && Is2.func(candidate.onClose) && Is2.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is2;
    })(MessageReader || (messageReader.MessageReader = MessageReader = {}));
    class AbstractMessageReader {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
        }
      }
    }
    messageReader.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        let charset;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options ?? "utf-8";
        } else {
          charset = options.charset ?? "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    class ReadableStreamMessageReader extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.readSemaphore = new semaphore_1.Semaphore(1);
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        try {
          this.buffer.append(data);
          while (true) {
            if (this.nextMessageLength === -1) {
              const headers = this.buffer.tryReadHeaders(true);
              if (!headers) {
                return;
              }
              const contentLength = headers.get("content-length");
              if (!contentLength) {
                this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
                return;
              }
              const length = parseInt(contentLength);
              if (isNaN(length)) {
                this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                return;
              }
              this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === void 0) {
              this.setPartialMessageTimer();
              return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            this.readSemaphore.lock(async () => {
              const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
              const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
              this.callback(message);
            }).catch((error) => {
              this.fireError(error);
            });
          }
        } catch (error) {
          this.fireError(error);
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    }
    messageReader.ReadableStreamMessageReader = ReadableStreamMessageReader;
    return messageReader;
  }
  var messageWriter = {};
  var hasRequiredMessageWriter;
  function requireMessageWriter() {
    if (hasRequiredMessageWriter) return messageWriter;
    hasRequiredMessageWriter = 1;
    Object.defineProperty(messageWriter, "__esModule", { value: true });
    messageWriter.WriteableStreamMessageWriter = messageWriter.AbstractMessageWriter = messageWriter.MessageWriter = void 0;
    const ral_1 = requireRal();
    const Is2 = requireIs$1();
    const semaphore_1 = requireSemaphore();
    const events_1 = requireEvents();
    const ContentLength = "Content-Length: ";
    const CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is2(value) {
        let candidate = value;
        return candidate && Is2.func(candidate.dispose) && Is2.func(candidate.onClose) && Is2.func(candidate.onError) && Is2.func(candidate.write);
      }
      MessageWriter2.is = is2;
    })(MessageWriter || (messageWriter.MessageWriter = MessageWriter = {}));
    class AbstractMessageWriter {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
        }
      }
    }
    messageWriter.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        if (options === void 0 || typeof options === "string") {
          return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    class WriteableStreamMessageWriter extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    }
    messageWriter.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
    return messageWriter;
  }
  var messageBuffer = {};
  var hasRequiredMessageBuffer;
  function requireMessageBuffer() {
    if (hasRequiredMessageBuffer) return messageBuffer;
    hasRequiredMessageBuffer = 1;
    Object.defineProperty(messageBuffer, "__esModule", { value: true });
    messageBuffer.AbstractMessageBuffer = void 0;
    const CR = 13;
    const LF = 10;
    const CRLF = "\r\n";
    class AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders(lowerCaseKeys = false) {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
          const chunk = this._chunks[chunkIndex];
          offset = 0;
          while (offset < chunk.length) {
            const value = chunk[offset];
            switch (value) {
              case CR:
                switch (state) {
                  case 0:
                    state = 1;
                    break;
                  case 2:
                    state = 3;
                    break;
                  default:
                    state = 0;
                }
                break;
              case LF:
                switch (state) {
                  case 1:
                    state = 2;
                    break;
                  case 3:
                    state = 4;
                    offset++;
                    break row;
                  default:
                    state = 0;
                }
                break;
              default:
                state = 0;
            }
            offset++;
          }
          chunkBytesRead += chunk.byteLength;
          chunkIndex++;
        }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error(`Message header must separate key and value using ':'
${header}`);
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    }
    messageBuffer.AbstractMessageBuffer = AbstractMessageBuffer;
    return messageBuffer;
  }
  var connection$1 = {};
  var hasRequiredConnection$1;
  function requireConnection$1() {
    if (hasRequiredConnection$1) return connection$1;
    hasRequiredConnection$1 = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.createMessageConnection = exports$1.ConnectionOptions = exports$1.MessageStrategy = exports$1.CancellationStrategy = exports$1.CancellationSenderStrategy = exports$1.CancellationReceiverStrategy = exports$1.RequestCancellationReceiverStrategy = exports$1.IdCancellationReceiverStrategy = exports$1.ConnectionStrategy = exports$1.ConnectionError = exports$1.ConnectionErrors = exports$1.LogTraceNotification = exports$1.SetTraceNotification = exports$1.TraceFormat = exports$1.TraceValues = exports$1.Trace = exports$1.NullLogger = exports$1.ProgressType = exports$1.ProgressToken = void 0;
      const ral_1 = requireRal();
      const Is2 = requireIs$1();
      const messages_1 = requireMessages$1();
      const linkedMap_1 = requireLinkedMap();
      const events_1 = requireEvents();
      const cancellation_1 = requireCancellation();
      var CancelNotification;
      (function(CancelNotification2) {
        CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
      })(CancelNotification || (CancelNotification = {}));
      var ProgressToken;
      (function(ProgressToken2) {
        function is2(value) {
          return typeof value === "string" || typeof value === "number";
        }
        ProgressToken2.is = is2;
      })(ProgressToken || (exports$1.ProgressToken = ProgressToken = {}));
      var ProgressNotification;
      (function(ProgressNotification2) {
        ProgressNotification2.type = new messages_1.NotificationType("$/progress");
      })(ProgressNotification || (ProgressNotification = {}));
      class ProgressType {
        constructor() {
        }
      }
      exports$1.ProgressType = ProgressType;
      var StarRequestHandler;
      (function(StarRequestHandler2) {
        function is2(value) {
          return Is2.func(value);
        }
        StarRequestHandler2.is = is2;
      })(StarRequestHandler || (StarRequestHandler = {}));
      exports$1.NullLogger = Object.freeze({
        error: () => {
        },
        warn: () => {
        },
        info: () => {
        },
        log: () => {
        }
      });
      var Trace;
      (function(Trace2) {
        Trace2[Trace2["Off"] = 0] = "Off";
        Trace2[Trace2["Messages"] = 1] = "Messages";
        Trace2[Trace2["Compact"] = 2] = "Compact";
        Trace2[Trace2["Verbose"] = 3] = "Verbose";
      })(Trace || (exports$1.Trace = Trace = {}));
      var TraceValues;
      (function(TraceValues2) {
        TraceValues2.Off = "off";
        TraceValues2.Messages = "messages";
        TraceValues2.Compact = "compact";
        TraceValues2.Verbose = "verbose";
      })(TraceValues || (exports$1.TraceValues = TraceValues = {}));
      (function(Trace2) {
        function fromString(value) {
          if (!Is2.string(value)) {
            return Trace2.Off;
          }
          value = value.toLowerCase();
          switch (value) {
            case "off":
              return Trace2.Off;
            case "messages":
              return Trace2.Messages;
            case "compact":
              return Trace2.Compact;
            case "verbose":
              return Trace2.Verbose;
            default:
              return Trace2.Off;
          }
        }
        Trace2.fromString = fromString;
        function toString(value) {
          switch (value) {
            case Trace2.Off:
              return "off";
            case Trace2.Messages:
              return "messages";
            case Trace2.Compact:
              return "compact";
            case Trace2.Verbose:
              return "verbose";
            default:
              return "off";
          }
        }
        Trace2.toString = toString;
      })(Trace || (exports$1.Trace = Trace = {}));
      var TraceFormat;
      (function(TraceFormat2) {
        TraceFormat2["Text"] = "text";
        TraceFormat2["JSON"] = "json";
      })(TraceFormat || (exports$1.TraceFormat = TraceFormat = {}));
      (function(TraceFormat2) {
        function fromString(value) {
          if (!Is2.string(value)) {
            return TraceFormat2.Text;
          }
          value = value.toLowerCase();
          if (value === "json") {
            return TraceFormat2.JSON;
          } else {
            return TraceFormat2.Text;
          }
        }
        TraceFormat2.fromString = fromString;
      })(TraceFormat || (exports$1.TraceFormat = TraceFormat = {}));
      var SetTraceNotification;
      (function(SetTraceNotification2) {
        SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
      })(SetTraceNotification || (exports$1.SetTraceNotification = SetTraceNotification = {}));
      var LogTraceNotification;
      (function(LogTraceNotification2) {
        LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
      })(LogTraceNotification || (exports$1.LogTraceNotification = LogTraceNotification = {}));
      var ConnectionErrors;
      (function(ConnectionErrors2) {
        ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
        ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
        ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
      })(ConnectionErrors || (exports$1.ConnectionErrors = ConnectionErrors = {}));
      class ConnectionError extends Error {
        constructor(code, message) {
          super(message);
          this.code = code;
          Object.setPrototypeOf(this, ConnectionError.prototype);
        }
      }
      exports$1.ConnectionError = ConnectionError;
      var ConnectionStrategy;
      (function(ConnectionStrategy2) {
        function is2(value) {
          const candidate = value;
          return candidate && Is2.func(candidate.cancelUndispatched);
        }
        ConnectionStrategy2.is = is2;
      })(ConnectionStrategy || (exports$1.ConnectionStrategy = ConnectionStrategy = {}));
      var IdCancellationReceiverStrategy;
      (function(IdCancellationReceiverStrategy2) {
        function is2(value) {
          const candidate = value;
          return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is2.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is2.func(candidate.dispose));
        }
        IdCancellationReceiverStrategy2.is = is2;
      })(IdCancellationReceiverStrategy || (exports$1.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
      var RequestCancellationReceiverStrategy;
      (function(RequestCancellationReceiverStrategy2) {
        function is2(value) {
          const candidate = value;
          return candidate && candidate.kind === "request" && Is2.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is2.func(candidate.dispose));
        }
        RequestCancellationReceiverStrategy2.is = is2;
      })(RequestCancellationReceiverStrategy || (exports$1.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
      var CancellationReceiverStrategy;
      (function(CancellationReceiverStrategy2) {
        CancellationReceiverStrategy2.Message = Object.freeze({
          createCancellationTokenSource(_) {
            return new cancellation_1.CancellationTokenSource();
          }
        });
        function is2(value) {
          return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
        }
        CancellationReceiverStrategy2.is = is2;
      })(CancellationReceiverStrategy || (exports$1.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
      var CancellationSenderStrategy;
      (function(CancellationSenderStrategy2) {
        CancellationSenderStrategy2.Message = Object.freeze({
          sendCancellation(conn, id) {
            return conn.sendNotification(CancelNotification.type, { id });
          },
          cleanup(_) {
          }
        });
        function is2(value) {
          const candidate = value;
          return candidate && Is2.func(candidate.sendCancellation) && Is2.func(candidate.cleanup);
        }
        CancellationSenderStrategy2.is = is2;
      })(CancellationSenderStrategy || (exports$1.CancellationSenderStrategy = CancellationSenderStrategy = {}));
      var CancellationStrategy;
      (function(CancellationStrategy2) {
        CancellationStrategy2.Message = Object.freeze({
          receiver: CancellationReceiverStrategy.Message,
          sender: CancellationSenderStrategy.Message
        });
        function is2(value) {
          const candidate = value;
          return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
        }
        CancellationStrategy2.is = is2;
      })(CancellationStrategy || (exports$1.CancellationStrategy = CancellationStrategy = {}));
      var MessageStrategy;
      (function(MessageStrategy2) {
        function is2(value) {
          const candidate = value;
          return candidate && Is2.func(candidate.handleMessage);
        }
        MessageStrategy2.is = is2;
      })(MessageStrategy || (exports$1.MessageStrategy = MessageStrategy = {}));
      var ConnectionOptions;
      (function(ConnectionOptions2) {
        function is2(value) {
          const candidate = value;
          return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
        }
        ConnectionOptions2.is = is2;
      })(ConnectionOptions || (exports$1.ConnectionOptions = ConnectionOptions = {}));
      var ConnectionState;
      (function(ConnectionState2) {
        ConnectionState2[ConnectionState2["New"] = 1] = "New";
        ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
        ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
        ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
      })(ConnectionState || (ConnectionState = {}));
      function createMessageConnection(messageReader2, messageWriter2, _logger, options) {
        const logger = _logger !== void 0 ? _logger : exports$1.NullLogger;
        let sequenceNumber = 0;
        let notificationSequenceNumber = 0;
        let unknownResponseSequenceNumber = 0;
        const version = "2.0";
        let starRequestHandler = void 0;
        const requestHandlers = /* @__PURE__ */ new Map();
        let starNotificationHandler = void 0;
        const notificationHandlers = /* @__PURE__ */ new Map();
        const progressHandlers = /* @__PURE__ */ new Map();
        let timer;
        let messageQueue = new linkedMap_1.LinkedMap();
        let responsePromises = /* @__PURE__ */ new Map();
        let knownCanceledRequests = /* @__PURE__ */ new Set();
        let requestTokens = /* @__PURE__ */ new Map();
        let trace = Trace.Off;
        let traceFormat = TraceFormat.Text;
        let tracer;
        let state = ConnectionState.New;
        const errorEmitter = new events_1.Emitter();
        const closeEmitter = new events_1.Emitter();
        const unhandledNotificationEmitter = new events_1.Emitter();
        const unhandledProgressEmitter = new events_1.Emitter();
        const disposeEmitter = new events_1.Emitter();
        const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
        function createRequestQueueKey(id) {
          if (id === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
          }
          return "req-" + id.toString();
        }
        function createResponseQueueKey(id) {
          if (id === null) {
            return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
          } else {
            return "res-" + id.toString();
          }
        }
        function createNotificationQueueKey() {
          return "not-" + (++notificationSequenceNumber).toString();
        }
        function addMessageToQueue(queue2, message) {
          if (messages_1.Message.isRequest(message)) {
            queue2.set(createRequestQueueKey(message.id), message);
          } else if (messages_1.Message.isResponse(message)) {
            queue2.set(createResponseQueueKey(message.id), message);
          } else {
            queue2.set(createNotificationQueueKey(), message);
          }
        }
        function cancelUndispatched(_message) {
          return void 0;
        }
        function isListening() {
          return state === ConnectionState.Listening;
        }
        function isClosed() {
          return state === ConnectionState.Closed;
        }
        function isDisposed() {
          return state === ConnectionState.Disposed;
        }
        function closeHandler() {
          if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(void 0);
          }
        }
        function readErrorHandler(error) {
          errorEmitter.fire([error, void 0, void 0]);
        }
        function writeErrorHandler(data) {
          errorEmitter.fire(data);
        }
        messageReader2.onClose(closeHandler);
        messageReader2.onError(readErrorHandler);
        messageWriter2.onClose(closeHandler);
        messageWriter2.onError(writeErrorHandler);
        function triggerMessageQueue() {
          if (timer || messageQueue.size === 0) {
            return;
          }
          timer = (0, ral_1.default)().timer.setImmediate(() => {
            timer = void 0;
            processMessageQueue();
          });
        }
        function handleMessage(message) {
          if (messages_1.Message.isRequest(message)) {
            handleRequest(message);
          } else if (messages_1.Message.isNotification(message)) {
            handleNotification(message);
          } else if (messages_1.Message.isResponse(message)) {
            handleResponse(message);
          } else {
            handleInvalidMessage(message);
          }
        }
        function processMessageQueue() {
          if (messageQueue.size === 0) {
            return;
          }
          const message = messageQueue.shift();
          try {
            const messageStrategy = options == null ? void 0 : options.messageStrategy;
            if (MessageStrategy.is(messageStrategy)) {
              messageStrategy.handleMessage(message, handleMessage);
            } else {
              handleMessage(message);
            }
          } finally {
            triggerMessageQueue();
          }
        }
        const callback = (message) => {
          try {
            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
              const cancelId = message.params.id;
              const key = createRequestQueueKey(cancelId);
              const toCancel = messageQueue.get(key);
              if (messages_1.Message.isRequest(toCancel)) {
                const strategy = options == null ? void 0 : options.connectionStrategy;
                const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                if (response && (response.error !== void 0 || response.result !== void 0)) {
                  messageQueue.delete(key);
                  requestTokens.delete(cancelId);
                  response.id = toCancel.id;
                  traceSendingResponse(response, message.method, Date.now());
                  messageWriter2.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                  return;
                }
              }
              const cancellationToken = requestTokens.get(cancelId);
              if (cancellationToken !== void 0) {
                cancellationToken.cancel();
                traceReceivedNotification(message);
                return;
              } else {
                knownCanceledRequests.add(cancelId);
              }
            }
            addMessageToQueue(messageQueue, message);
          } finally {
            triggerMessageQueue();
          }
        };
        function handleRequest(requestMessage) {
          if (isDisposed()) {
            return;
          }
          function reply(resultOrError, method, startTime2) {
            const message = {
              jsonrpc: version,
              id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
              message.error = resultOrError.toJson();
            } else {
              message.result = resultOrError === void 0 ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime2);
            messageWriter2.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          function replyError(error, method, startTime2) {
            const message = {
              jsonrpc: version,
              id: requestMessage.id,
              error: error.toJson()
            };
            traceSendingResponse(message, method, startTime2);
            messageWriter2.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          function replySuccess(result, method, startTime2) {
            if (result === void 0) {
              result = null;
            }
            const message = {
              jsonrpc: version,
              id: requestMessage.id,
              result
            };
            traceSendingResponse(message, method, startTime2);
            messageWriter2.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          traceReceivedRequest(requestMessage);
          const element = requestHandlers.get(requestMessage.method);
          let type;
          let requestHandler;
          if (element) {
            type = element.type;
            requestHandler = element.handler;
          }
          const startTime = Date.now();
          if (requestHandler || starRequestHandler) {
            const tokenKey = requestMessage.id ?? String(Date.now());
            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
              cancellationSource.cancel();
            }
            if (requestMessage.id !== null) {
              requestTokens.set(tokenKey, cancellationSource);
            }
            try {
              let handlerResult;
              if (requestHandler) {
                if (requestMessage.params === void 0) {
                  if (type !== void 0 && type.numberOfParams !== 0) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(cancellationSource.token);
                } else if (Array.isArray(requestMessage.params)) {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                } else {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                }
              } else if (starRequestHandler) {
                handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
              }
              const promise = handlerResult;
              if (!handlerResult) {
                requestTokens.delete(tokenKey);
                replySuccess(handlerResult, requestMessage.method, startTime);
              } else if (promise.then) {
                promise.then((resultOrError) => {
                  requestTokens.delete(tokenKey);
                  reply(resultOrError, requestMessage.method, startTime);
                }, (error) => {
                  requestTokens.delete(tokenKey);
                  if (error instanceof messages_1.ResponseError) {
                    replyError(error, requestMessage.method, startTime);
                  } else if (error && Is2.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                  } else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                  }
                });
              } else {
                requestTokens.delete(tokenKey);
                reply(handlerResult, requestMessage.method, startTime);
              }
            } catch (error) {
              requestTokens.delete(tokenKey);
              if (error instanceof messages_1.ResponseError) {
                reply(error, requestMessage.method, startTime);
              } else if (error && Is2.string(error.message)) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
              } else {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
              }
            }
          } else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
          }
        }
        function handleResponse(responseMessage) {
          if (isDisposed()) {
            return;
          }
          if (responseMessage.id === null) {
            if (responseMessage.error) {
              logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
            } else {
              logger.error(`Received response message without id. No further error information provided.`);
            }
          } else {
            const key = responseMessage.id;
            const responsePromise = responsePromises.get(key);
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise !== void 0) {
              responsePromises.delete(key);
              try {
                if (responseMessage.error) {
                  const error = responseMessage.error;
                  responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                } else if (responseMessage.result !== void 0) {
                  responsePromise.resolve(responseMessage.result);
                } else {
                  throw new Error("Should never happen.");
                }
              } catch (error) {
                if (error.message) {
                  logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                } else {
                  logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                }
              }
            }
          }
        }
        function handleNotification(message) {
          if (isDisposed()) {
            return;
          }
          let type = void 0;
          let notificationHandler;
          if (message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            knownCanceledRequests.delete(cancelId);
            traceReceivedNotification(message);
            return;
          } else {
            const element = notificationHandlers.get(message.method);
            if (element) {
              notificationHandler = element.handler;
              type = element.type;
            }
          }
          if (notificationHandler || starNotificationHandler) {
            try {
              traceReceivedNotification(message);
              if (notificationHandler) {
                if (message.params === void 0) {
                  if (type !== void 0) {
                    if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                    }
                  }
                  notificationHandler();
                } else if (Array.isArray(message.params)) {
                  const params = message.params;
                  if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                    notificationHandler({ token: params[0], value: params[1] });
                  } else {
                    if (type !== void 0) {
                      if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                        logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                      }
                      if (type.numberOfParams !== message.params.length) {
                        logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                      }
                    }
                    notificationHandler(...params);
                  }
                } else {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                    logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                  }
                  notificationHandler(message.params);
                }
              } else if (starNotificationHandler) {
                starNotificationHandler(message.method, message.params);
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
              }
            }
          } else {
            unhandledNotificationEmitter.fire(message);
          }
        }
        function handleInvalidMessage(message) {
          if (!message) {
            logger.error("Received empty message.");
            return;
          }
          logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
          const responseMessage = message;
          if (Is2.string(responseMessage.id) || Is2.number(responseMessage.id)) {
            const key = responseMessage.id;
            const responseHandler = responsePromises.get(key);
            if (responseHandler) {
              responseHandler.reject(new Error("The received response has neither a result nor an error property."));
            }
          }
        }
        function stringifyTrace(params) {
          if (params === void 0 || params === null) {
            return void 0;
          }
          switch (trace) {
            case Trace.Verbose:
              return JSON.stringify(params, null, 4);
            case Trace.Compact:
              return JSON.stringify(params);
            default:
              return void 0;
          }
        }
        function traceSendingRequest(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
          } else {
            logLSPMessage("send-request", message);
          }
        }
        function traceSendingNotification(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.params) {
                data = `Params: ${stringifyTrace(message.params)}

`;
              } else {
                data = "No parameters provided.\n\n";
              }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
          } else {
            logLSPMessage("send-notification", message);
          }
        }
        function traceSendingResponse(message, method, startTime) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.error && message.error.data) {
                data = `Error data: ${stringifyTrace(message.error.data)}

`;
              } else {
                if (message.result) {
                  data = `Result: ${stringifyTrace(message.result)}

`;
                } else if (message.error === void 0) {
                  data = "No result returned.\n\n";
                }
              }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
          } else {
            logLSPMessage("send-response", message);
          }
        }
        function traceReceivedRequest(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
          } else {
            logLSPMessage("receive-request", message);
          }
        }
        function traceReceivedNotification(message) {
          if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.params) {
                data = `Params: ${stringifyTrace(message.params)}

`;
              } else {
                data = "No parameters provided.\n\n";
              }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
          } else {
            logLSPMessage("receive-notification", message);
          }
        }
        function traceReceivedResponse(message, responsePromise) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.error && message.error.data) {
                data = `Error data: ${stringifyTrace(message.error.data)}

`;
              } else {
                if (message.result) {
                  data = `Result: ${stringifyTrace(message.result)}

`;
                } else if (message.error === void 0) {
                  data = "No result returned.\n\n";
                }
              }
            }
            if (responsePromise) {
              const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
              tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            } else {
              tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
          } else {
            logLSPMessage("receive-response", message);
          }
        }
        function logLSPMessage(type, message) {
          if (!tracer || trace === Trace.Off) {
            return;
          }
          const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
          };
          tracer.log(lspMessage);
        }
        function throwIfClosedOrDisposed() {
          if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
          }
          if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
          }
        }
        function throwIfListening() {
          if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
          }
        }
        function throwIfNotListening() {
          if (!isListening()) {
            throw new Error("Call listen() first.");
          }
        }
        function undefinedToNull(param) {
          if (param === void 0) {
            return null;
          } else {
            return param;
          }
        }
        function nullToUndefined(param) {
          if (param === null) {
            return void 0;
          } else {
            return param;
          }
        }
        function isNamedParam(param) {
          return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
        }
        function computeSingleParam(parameterStructures, param) {
          switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
              if (isNamedParam(param)) {
                return nullToUndefined(param);
              } else {
                return [undefinedToNull(param)];
              }
            case messages_1.ParameterStructures.byName:
              if (!isNamedParam(param)) {
                throw new Error(`Received parameters by name but param is not an object literal.`);
              }
              return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
              return [undefinedToNull(param)];
            default:
              throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
          }
        }
        function computeMessageParams(type, params) {
          let result;
          const numberOfParams = type.numberOfParams;
          switch (numberOfParams) {
            case 0:
              result = void 0;
              break;
            case 1:
              result = computeSingleParam(type.parameterStructures, params[0]);
              break;
            default:
              result = [];
              for (let i = 0; i < params.length && i < numberOfParams; i++) {
                result.push(undefinedToNull(params[i]));
              }
              if (params.length < numberOfParams) {
                for (let i = params.length; i < numberOfParams; i++) {
                  result.push(null);
                }
              }
              break;
          }
          return result;
        }
        const connection2 = {
          sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is2.string(type)) {
              method = type;
              const first = args[0];
              let paramStart = 0;
              let parameterStructures = messages_1.ParameterStructures.auto;
              if (messages_1.ParameterStructures.is(first)) {
                paramStart = 1;
                parameterStructures = first;
              }
              let paramEnd = args.length;
              const numberOfParams = paramEnd - paramStart;
              switch (numberOfParams) {
                case 0:
                  messageParams = void 0;
                  break;
                case 1:
                  messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                  break;
                default:
                  if (parameterStructures === messages_1.ParameterStructures.byName) {
                    throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                  }
                  messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                  break;
              }
            } else {
              const params = args;
              method = type.method;
              messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
              jsonrpc: version,
              method,
              params: messageParams
            };
            traceSendingNotification(notificationMessage);
            return messageWriter2.write(notificationMessage).catch((error) => {
              logger.error(`Sending notification failed.`);
              throw error;
            });
          },
          onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is2.func(type)) {
              starNotificationHandler = type;
            } else if (handler) {
              if (Is2.string(type)) {
                method = type;
                notificationHandlers.set(type, { type: void 0, handler });
              } else {
                method = type.method;
                notificationHandlers.set(type.method, { type, handler });
              }
            }
            return {
              dispose: () => {
                if (method !== void 0) {
                  notificationHandlers.delete(method);
                } else {
                  starNotificationHandler = void 0;
                }
              }
            };
          },
          onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
              throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
              dispose: () => {
                progressHandlers.delete(token);
              }
            };
          },
          sendProgress: (_type, token, value) => {
            return connection2.sendNotification(ProgressNotification.type, { token, value });
          },
          onUnhandledProgress: unhandledProgressEmitter.event,
          sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = void 0;
            if (Is2.string(type)) {
              method = type;
              const first = args[0];
              const last = args[args.length - 1];
              let paramStart = 0;
              let parameterStructures = messages_1.ParameterStructures.auto;
              if (messages_1.ParameterStructures.is(first)) {
                paramStart = 1;
                parameterStructures = first;
              }
              let paramEnd = args.length;
              if (cancellation_1.CancellationToken.is(last)) {
                paramEnd = paramEnd - 1;
                token = last;
              }
              const numberOfParams = paramEnd - paramStart;
              switch (numberOfParams) {
                case 0:
                  messageParams = void 0;
                  break;
                case 1:
                  messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                  break;
                default:
                  if (parameterStructures === messages_1.ParameterStructures.byName) {
                    throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                  }
                  messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                  break;
              }
            } else {
              const params = args;
              method = type.method;
              messageParams = computeMessageParams(type, params);
              const numberOfParams = type.numberOfParams;
              token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
            }
            const id = sequenceNumber++;
            let disposable2;
            if (token) {
              disposable2 = token.onCancellationRequested(() => {
                const p = cancellationStrategy.sender.sendCancellation(connection2, id);
                if (p === void 0) {
                  logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                  return Promise.resolve();
                } else {
                  return p.catch(() => {
                    logger.log(`Sending cancellation messages for id ${id} failed`);
                  });
                }
              });
            }
            const requestMessage = {
              jsonrpc: version,
              id,
              method,
              params: messageParams
            };
            traceSendingRequest(requestMessage);
            if (typeof cancellationStrategy.sender.enableCancellation === "function") {
              cancellationStrategy.sender.enableCancellation(requestMessage);
            }
            return new Promise(async (resolve, reject) => {
              const resolveWithCleanup = (r) => {
                resolve(r);
                cancellationStrategy.sender.cleanup(id);
                disposable2 == null ? void 0 : disposable2.dispose();
              };
              const rejectWithCleanup = (r) => {
                reject(r);
                cancellationStrategy.sender.cleanup(id);
                disposable2 == null ? void 0 : disposable2.dispose();
              };
              const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
              try {
                await messageWriter2.write(requestMessage);
                responsePromises.set(id, responsePromise);
              } catch (error) {
                logger.error(`Sending request failed.`);
                responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
                throw error;
              }
            });
          },
          onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
              method = void 0;
              starRequestHandler = type;
            } else if (Is2.string(type)) {
              method = null;
              if (handler !== void 0) {
                method = type;
                requestHandlers.set(type, { handler, type: void 0 });
              }
            } else {
              if (handler !== void 0) {
                method = type.method;
                requestHandlers.set(type.method, { type, handler });
              }
            }
            return {
              dispose: () => {
                if (method === null) {
                  return;
                }
                if (method !== void 0) {
                  requestHandlers.delete(method);
                } else {
                  starRequestHandler = void 0;
                }
              }
            };
          },
          hasPendingResponse: () => {
            return responsePromises.size > 0;
          },
          trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== void 0) {
              if (Is2.boolean(sendNotificationOrTraceOptions)) {
                _sendNotification = sendNotificationOrTraceOptions;
              } else {
                _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
              }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
              tracer = void 0;
            } else {
              tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
              await connection2.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
          },
          onError: errorEmitter.event,
          onClose: closeEmitter.event,
          onUnhandledNotification: unhandledNotificationEmitter.event,
          onDispose: disposeEmitter.event,
          end: () => {
            messageWriter2.end();
          },
          dispose: () => {
            if (isDisposed()) {
              return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(void 0);
            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
            for (const promise of responsePromises.values()) {
              promise.reject(error);
            }
            responsePromises = /* @__PURE__ */ new Map();
            requestTokens = /* @__PURE__ */ new Map();
            knownCanceledRequests = /* @__PURE__ */ new Set();
            messageQueue = new linkedMap_1.LinkedMap();
            if (Is2.func(messageWriter2.dispose)) {
              messageWriter2.dispose();
            }
            if (Is2.func(messageReader2.dispose)) {
              messageReader2.dispose();
            }
          },
          listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader2.listen(callback);
          },
          inspect: () => {
            (0, ral_1.default)().console.log("inspect");
          }
        };
        connection2.onNotification(LogTraceNotification.type, (params) => {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          const verbose = trace === Trace.Verbose || trace === Trace.Compact;
          tracer.log(params.message, verbose ? params.verbose : void 0);
        });
        connection2.onNotification(ProgressNotification.type, (params) => {
          const handler = progressHandlers.get(params.token);
          if (handler) {
            handler(params.value);
          } else {
            unhandledProgressEmitter.fire(params);
          }
        });
        return connection2;
      }
      exports$1.createMessageConnection = createMessageConnection;
    })(connection$1);
    return connection$1;
  }
  var hasRequiredApi$1;
  function requireApi$1() {
    if (hasRequiredApi$1) return api$1;
    hasRequiredApi$1 = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.ProgressType = exports$1.ProgressToken = exports$1.createMessageConnection = exports$1.NullLogger = exports$1.ConnectionOptions = exports$1.ConnectionStrategy = exports$1.AbstractMessageBuffer = exports$1.WriteableStreamMessageWriter = exports$1.AbstractMessageWriter = exports$1.MessageWriter = exports$1.ReadableStreamMessageReader = exports$1.AbstractMessageReader = exports$1.MessageReader = exports$1.SharedArrayReceiverStrategy = exports$1.SharedArraySenderStrategy = exports$1.CancellationToken = exports$1.CancellationTokenSource = exports$1.Emitter = exports$1.Event = exports$1.Disposable = exports$1.LRUCache = exports$1.Touch = exports$1.LinkedMap = exports$1.ParameterStructures = exports$1.NotificationType9 = exports$1.NotificationType8 = exports$1.NotificationType7 = exports$1.NotificationType6 = exports$1.NotificationType5 = exports$1.NotificationType4 = exports$1.NotificationType3 = exports$1.NotificationType2 = exports$1.NotificationType1 = exports$1.NotificationType0 = exports$1.NotificationType = exports$1.ErrorCodes = exports$1.ResponseError = exports$1.RequestType9 = exports$1.RequestType8 = exports$1.RequestType7 = exports$1.RequestType6 = exports$1.RequestType5 = exports$1.RequestType4 = exports$1.RequestType3 = exports$1.RequestType2 = exports$1.RequestType1 = exports$1.RequestType0 = exports$1.RequestType = exports$1.Message = exports$1.RAL = void 0;
      exports$1.MessageStrategy = exports$1.CancellationStrategy = exports$1.CancellationSenderStrategy = exports$1.CancellationReceiverStrategy = exports$1.ConnectionError = exports$1.ConnectionErrors = exports$1.LogTraceNotification = exports$1.SetTraceNotification = exports$1.TraceFormat = exports$1.TraceValues = exports$1.Trace = void 0;
      const messages_1 = requireMessages$1();
      Object.defineProperty(exports$1, "Message", { enumerable: true, get: function() {
        return messages_1.Message;
      } });
      Object.defineProperty(exports$1, "RequestType", { enumerable: true, get: function() {
        return messages_1.RequestType;
      } });
      Object.defineProperty(exports$1, "RequestType0", { enumerable: true, get: function() {
        return messages_1.RequestType0;
      } });
      Object.defineProperty(exports$1, "RequestType1", { enumerable: true, get: function() {
        return messages_1.RequestType1;
      } });
      Object.defineProperty(exports$1, "RequestType2", { enumerable: true, get: function() {
        return messages_1.RequestType2;
      } });
      Object.defineProperty(exports$1, "RequestType3", { enumerable: true, get: function() {
        return messages_1.RequestType3;
      } });
      Object.defineProperty(exports$1, "RequestType4", { enumerable: true, get: function() {
        return messages_1.RequestType4;
      } });
      Object.defineProperty(exports$1, "RequestType5", { enumerable: true, get: function() {
        return messages_1.RequestType5;
      } });
      Object.defineProperty(exports$1, "RequestType6", { enumerable: true, get: function() {
        return messages_1.RequestType6;
      } });
      Object.defineProperty(exports$1, "RequestType7", { enumerable: true, get: function() {
        return messages_1.RequestType7;
      } });
      Object.defineProperty(exports$1, "RequestType8", { enumerable: true, get: function() {
        return messages_1.RequestType8;
      } });
      Object.defineProperty(exports$1, "RequestType9", { enumerable: true, get: function() {
        return messages_1.RequestType9;
      } });
      Object.defineProperty(exports$1, "ResponseError", { enumerable: true, get: function() {
        return messages_1.ResponseError;
      } });
      Object.defineProperty(exports$1, "ErrorCodes", { enumerable: true, get: function() {
        return messages_1.ErrorCodes;
      } });
      Object.defineProperty(exports$1, "NotificationType", { enumerable: true, get: function() {
        return messages_1.NotificationType;
      } });
      Object.defineProperty(exports$1, "NotificationType0", { enumerable: true, get: function() {
        return messages_1.NotificationType0;
      } });
      Object.defineProperty(exports$1, "NotificationType1", { enumerable: true, get: function() {
        return messages_1.NotificationType1;
      } });
      Object.defineProperty(exports$1, "NotificationType2", { enumerable: true, get: function() {
        return messages_1.NotificationType2;
      } });
      Object.defineProperty(exports$1, "NotificationType3", { enumerable: true, get: function() {
        return messages_1.NotificationType3;
      } });
      Object.defineProperty(exports$1, "NotificationType4", { enumerable: true, get: function() {
        return messages_1.NotificationType4;
      } });
      Object.defineProperty(exports$1, "NotificationType5", { enumerable: true, get: function() {
        return messages_1.NotificationType5;
      } });
      Object.defineProperty(exports$1, "NotificationType6", { enumerable: true, get: function() {
        return messages_1.NotificationType6;
      } });
      Object.defineProperty(exports$1, "NotificationType7", { enumerable: true, get: function() {
        return messages_1.NotificationType7;
      } });
      Object.defineProperty(exports$1, "NotificationType8", { enumerable: true, get: function() {
        return messages_1.NotificationType8;
      } });
      Object.defineProperty(exports$1, "NotificationType9", { enumerable: true, get: function() {
        return messages_1.NotificationType9;
      } });
      Object.defineProperty(exports$1, "ParameterStructures", { enumerable: true, get: function() {
        return messages_1.ParameterStructures;
      } });
      const linkedMap_1 = requireLinkedMap();
      Object.defineProperty(exports$1, "LinkedMap", { enumerable: true, get: function() {
        return linkedMap_1.LinkedMap;
      } });
      Object.defineProperty(exports$1, "LRUCache", { enumerable: true, get: function() {
        return linkedMap_1.LRUCache;
      } });
      Object.defineProperty(exports$1, "Touch", { enumerable: true, get: function() {
        return linkedMap_1.Touch;
      } });
      const disposable_1 = requireDisposable();
      Object.defineProperty(exports$1, "Disposable", { enumerable: true, get: function() {
        return disposable_1.Disposable;
      } });
      const events_1 = requireEvents();
      Object.defineProperty(exports$1, "Event", { enumerable: true, get: function() {
        return events_1.Event;
      } });
      Object.defineProperty(exports$1, "Emitter", { enumerable: true, get: function() {
        return events_1.Emitter;
      } });
      const cancellation_1 = requireCancellation();
      Object.defineProperty(exports$1, "CancellationTokenSource", { enumerable: true, get: function() {
        return cancellation_1.CancellationTokenSource;
      } });
      Object.defineProperty(exports$1, "CancellationToken", { enumerable: true, get: function() {
        return cancellation_1.CancellationToken;
      } });
      const sharedArrayCancellation_1 = requireSharedArrayCancellation();
      Object.defineProperty(exports$1, "SharedArraySenderStrategy", { enumerable: true, get: function() {
        return sharedArrayCancellation_1.SharedArraySenderStrategy;
      } });
      Object.defineProperty(exports$1, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
        return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
      } });
      const messageReader_1 = requireMessageReader();
      Object.defineProperty(exports$1, "MessageReader", { enumerable: true, get: function() {
        return messageReader_1.MessageReader;
      } });
      Object.defineProperty(exports$1, "AbstractMessageReader", { enumerable: true, get: function() {
        return messageReader_1.AbstractMessageReader;
      } });
      Object.defineProperty(exports$1, "ReadableStreamMessageReader", { enumerable: true, get: function() {
        return messageReader_1.ReadableStreamMessageReader;
      } });
      const messageWriter_1 = requireMessageWriter();
      Object.defineProperty(exports$1, "MessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.MessageWriter;
      } });
      Object.defineProperty(exports$1, "AbstractMessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.AbstractMessageWriter;
      } });
      Object.defineProperty(exports$1, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.WriteableStreamMessageWriter;
      } });
      const messageBuffer_1 = requireMessageBuffer();
      Object.defineProperty(exports$1, "AbstractMessageBuffer", { enumerable: true, get: function() {
        return messageBuffer_1.AbstractMessageBuffer;
      } });
      const connection_1 = requireConnection$1();
      Object.defineProperty(exports$1, "ConnectionStrategy", { enumerable: true, get: function() {
        return connection_1.ConnectionStrategy;
      } });
      Object.defineProperty(exports$1, "ConnectionOptions", { enumerable: true, get: function() {
        return connection_1.ConnectionOptions;
      } });
      Object.defineProperty(exports$1, "NullLogger", { enumerable: true, get: function() {
        return connection_1.NullLogger;
      } });
      Object.defineProperty(exports$1, "createMessageConnection", { enumerable: true, get: function() {
        return connection_1.createMessageConnection;
      } });
      Object.defineProperty(exports$1, "ProgressToken", { enumerable: true, get: function() {
        return connection_1.ProgressToken;
      } });
      Object.defineProperty(exports$1, "ProgressType", { enumerable: true, get: function() {
        return connection_1.ProgressType;
      } });
      Object.defineProperty(exports$1, "Trace", { enumerable: true, get: function() {
        return connection_1.Trace;
      } });
      Object.defineProperty(exports$1, "TraceValues", { enumerable: true, get: function() {
        return connection_1.TraceValues;
      } });
      Object.defineProperty(exports$1, "TraceFormat", { enumerable: true, get: function() {
        return connection_1.TraceFormat;
      } });
      Object.defineProperty(exports$1, "SetTraceNotification", { enumerable: true, get: function() {
        return connection_1.SetTraceNotification;
      } });
      Object.defineProperty(exports$1, "LogTraceNotification", { enumerable: true, get: function() {
        return connection_1.LogTraceNotification;
      } });
      Object.defineProperty(exports$1, "ConnectionErrors", { enumerable: true, get: function() {
        return connection_1.ConnectionErrors;
      } });
      Object.defineProperty(exports$1, "ConnectionError", { enumerable: true, get: function() {
        return connection_1.ConnectionError;
      } });
      Object.defineProperty(exports$1, "CancellationReceiverStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationReceiverStrategy;
      } });
      Object.defineProperty(exports$1, "CancellationSenderStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationSenderStrategy;
      } });
      Object.defineProperty(exports$1, "CancellationStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationStrategy;
      } });
      Object.defineProperty(exports$1, "MessageStrategy", { enumerable: true, get: function() {
        return connection_1.MessageStrategy;
      } });
      const ral_1 = requireRal();
      exports$1.RAL = ral_1.default;
    })(api$1);
    return api$1;
  }
  var hasRequiredRil;
  function requireRil() {
    if (hasRequiredRil) return ril;
    hasRequiredRil = 1;
    Object.defineProperty(ril, "__esModule", { value: true });
    const api_1 = requireApi$1();
    class MessageBuffer extends api_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
        this.asciiDecoder = new TextDecoder("ascii");
      }
      emptyBuffer() {
        return MessageBuffer.emptyBuffer;
      }
      fromString(value, _encoding) {
        return new TextEncoder().encode(value);
      }
      toString(value, encoding) {
        if (encoding === "ascii") {
          return this.asciiDecoder.decode(value);
        } else {
          return new TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer;
        } else {
          return buffer.slice(0, length);
        }
      }
      allocNative(length) {
        return new Uint8Array(length);
      }
    }
    MessageBuffer.emptyBuffer = new Uint8Array(0);
    class ReadableStreamWrapper {
      constructor(socket) {
        this.socket = socket;
        this._onData = new api_1.Emitter();
        this._messageListener = (event) => {
          const blob = event.data;
          blob.arrayBuffer().then((buffer) => {
            this._onData.fire(new Uint8Array(buffer));
          }, () => {
            (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);
          });
        };
        this.socket.addEventListener("message", this._messageListener);
      }
      onClose(listener) {
        this.socket.addEventListener("close", listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
      }
      onError(listener) {
        this.socket.addEventListener("error", listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
      }
      onEnd(listener) {
        this.socket.addEventListener("end", listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
      }
      onData(listener) {
        return this._onData.event(listener);
      }
    }
    class WritableStreamWrapper {
      constructor(socket) {
        this.socket = socket;
      }
      onClose(listener) {
        this.socket.addEventListener("close", listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
      }
      onError(listener) {
        this.socket.addEventListener("error", listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
      }
      onEnd(listener) {
        this.socket.addEventListener("end", listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
      }
      write(data, encoding) {
        if (typeof data === "string") {
          if (encoding !== void 0 && encoding !== "utf-8") {
            throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
          }
          this.socket.send(data);
        } else {
          this.socket.send(data);
        }
        return Promise.resolve();
      }
      end() {
        this.socket.close();
      }
    }
    const _textEncoder = new TextEncoder();
    const _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            if (options.charset !== "utf-8") {
              throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
            }
            return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, void 0, 0)));
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            if (!(buffer instanceof Uint8Array)) {
              throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
            }
            return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (socket) => new ReadableStreamWrapper(socket),
        asWritableStream: (socket) => new WritableStreamWrapper(socket)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          const handle = setTimeout(callback, ms, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
          const handle = setTimeout(callback, 0, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setInterval(callback, ms, ...args) {
          const handle = setInterval(callback, ms, ...args);
          return { dispose: () => clearInterval(handle) };
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        api_1.RAL.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    ril.default = RIL;
    return ril;
  }
  var hasRequiredMain$1;
  function requireMain$1() {
    if (hasRequiredMain$1) return main$1;
    hasRequiredMain$1 = 1;
    (function(exports$1) {
      var __createBinding = main$1 && main$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = main$1 && main$1.__exportStar || function(m, exports$12) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
      };
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.createMessageConnection = exports$1.BrowserMessageWriter = exports$1.BrowserMessageReader = void 0;
      const ril_1 = requireRil();
      ril_1.default.install();
      const api_1 = requireApi$1();
      __exportStar(requireApi$1(), exports$1);
      class BrowserMessageReader extends api_1.AbstractMessageReader {
        constructor(port) {
          super();
          this._onData = new api_1.Emitter();
          this._messageListener = (event) => {
            this._onData.fire(event.data);
          };
          port.addEventListener("error", (event) => this.fireError(event));
          port.onmessage = this._messageListener;
        }
        listen(callback) {
          return this._onData.event(callback);
        }
      }
      exports$1.BrowserMessageReader = BrowserMessageReader;
      class BrowserMessageWriter extends api_1.AbstractMessageWriter {
        constructor(port) {
          super();
          this.port = port;
          this.errorCount = 0;
          port.addEventListener("error", (event) => this.fireError(event));
        }
        write(msg) {
          try {
            this.port.postMessage(msg);
            return Promise.resolve();
          } catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
          }
        }
        handleError(error, msg) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
        end() {
        }
      }
      exports$1.BrowserMessageWriter = BrowserMessageWriter;
      function createMessageConnection(reader, writer, logger, options) {
        if (logger === void 0) {
          logger = api_1.NullLogger;
        }
        if (api_1.ConnectionStrategy.is(options)) {
          options = { connectionStrategy: options };
        }
        return (0, api_1.createMessageConnection)(reader, writer, logger, options);
      }
      exports$1.createMessageConnection = createMessageConnection;
    })(main$1);
    return main$1;
  }
  var browser$1;
  var hasRequiredBrowser;
  function requireBrowser() {
    if (hasRequiredBrowser) return browser$1;
    hasRequiredBrowser = 1;
    browser$1 = requireMain$1();
    return browser$1;
  }
  var api = {};
  var DocumentUri;
  (function(DocumentUri2) {
    function is2(value) {
      return typeof value === "string";
    }
    DocumentUri2.is = is2;
  })(DocumentUri || (DocumentUri = {}));
  var URI$1;
  (function(URI2) {
    function is2(value) {
      return typeof value === "string";
    }
    URI2.is = is2;
  })(URI$1 || (URI$1 = {}));
  var integer;
  (function(integer2) {
    integer2.MIN_VALUE = -2147483648;
    integer2.MAX_VALUE = 2147483647;
    function is2(value) {
      return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
    }
    integer2.is = is2;
  })(integer || (integer = {}));
  var uinteger;
  (function(uinteger2) {
    uinteger2.MIN_VALUE = 0;
    uinteger2.MAX_VALUE = 2147483647;
    function is2(value) {
      return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
    }
    uinteger2.is = is2;
  })(uinteger || (uinteger = {}));
  var Position;
  (function(Position2) {
    function create(line, character) {
      if (line === Number.MAX_VALUE) {
        line = uinteger.MAX_VALUE;
      }
      if (character === Number.MAX_VALUE) {
        character = uinteger.MAX_VALUE;
      }
      return { line, character };
    }
    Position2.create = create;
    function is2(value) {
      let candidate = value;
      return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
    }
    Position2.is = is2;
  })(Position || (Position = {}));
  var Range;
  (function(Range2) {
    function create(one, two, three, four) {
      if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
        return { start: Position.create(one, two), end: Position.create(three, four) };
      } else if (Position.is(one) && Position.is(two)) {
        return { start: one, end: two };
      } else {
        throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);
      }
    }
    Range2.create = create;
    function is2(value) {
      let candidate = value;
      return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
    }
    Range2.is = is2;
  })(Range || (Range = {}));
  var Location;
  (function(Location2) {
    function create(uri, range) {
      return { uri, range };
    }
    Location2.create = create;
    function is2(value) {
      let candidate = value;
      return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location2.is = is2;
  })(Location || (Location = {}));
  var LocationLink;
  (function(LocationLink2) {
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
      return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
    }
    LocationLink2.create = create;
    function is2(value) {
      let candidate = value;
      return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink2.is = is2;
  })(LocationLink || (LocationLink = {}));
  var Color;
  (function(Color2) {
    function create(red, green, blue, alpha) {
      return {
        red,
        green,
        blue,
        alpha
      };
    }
    Color2.create = create;
    function is2(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
    }
    Color2.is = is2;
  })(Color || (Color = {}));
  var ColorInformation;
  (function(ColorInformation2) {
    function create(range, color) {
      return {
        range,
        color
      };
    }
    ColorInformation2.create = create;
    function is2(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation2.is = is2;
  })(ColorInformation || (ColorInformation = {}));
  var ColorPresentation;
  (function(ColorPresentation2) {
    function create(label, textEdit, additionalTextEdits) {
      return {
        label,
        textEdit,
        additionalTextEdits
      };
    }
    ColorPresentation2.create = create;
    function is2(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation2.is = is2;
  })(ColorPresentation || (ColorPresentation = {}));
  var FoldingRangeKind;
  (function(FoldingRangeKind2) {
    FoldingRangeKind2.Comment = "comment";
    FoldingRangeKind2.Imports = "imports";
    FoldingRangeKind2.Region = "region";
  })(FoldingRangeKind || (FoldingRangeKind = {}));
  var FoldingRange;
  (function(FoldingRange2) {
    function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
      const result = {
        startLine,
        endLine
      };
      if (Is.defined(startCharacter)) {
        result.startCharacter = startCharacter;
      }
      if (Is.defined(endCharacter)) {
        result.endCharacter = endCharacter;
      }
      if (Is.defined(kind)) {
        result.kind = kind;
      }
      if (Is.defined(collapsedText)) {
        result.collapsedText = collapsedText;
      }
      return result;
    }
    FoldingRange2.create = create;
    function is2(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange2.is = is2;
  })(FoldingRange || (FoldingRange = {}));
  var DiagnosticRelatedInformation;
  (function(DiagnosticRelatedInformation2) {
    function create(location, message) {
      return {
        location,
        message
      };
    }
    DiagnosticRelatedInformation2.create = create;
    function is2(value) {
      let candidate = value;
      return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation2.is = is2;
  })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
  var DiagnosticSeverity;
  (function(DiagnosticSeverity2) {
    DiagnosticSeverity2.Error = 1;
    DiagnosticSeverity2.Warning = 2;
    DiagnosticSeverity2.Information = 3;
    DiagnosticSeverity2.Hint = 4;
  })(DiagnosticSeverity || (DiagnosticSeverity = {}));
  var DiagnosticTag;
  (function(DiagnosticTag2) {
    DiagnosticTag2.Unnecessary = 1;
    DiagnosticTag2.Deprecated = 2;
  })(DiagnosticTag || (DiagnosticTag = {}));
  var CodeDescription;
  (function(CodeDescription2) {
    function is2(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && Is.string(candidate.href);
    }
    CodeDescription2.is = is2;
  })(CodeDescription || (CodeDescription = {}));
  var Diagnostic;
  (function(Diagnostic2) {
    function create(range, message, severity, code, source, relatedInformation) {
      let result = { range, message };
      if (Is.defined(severity)) {
        result.severity = severity;
      }
      if (Is.defined(code)) {
        result.code = code;
      }
      if (Is.defined(source)) {
        result.source = source;
      }
      if (Is.defined(relatedInformation)) {
        result.relatedInformation = relatedInformation;
      }
      return result;
    }
    Diagnostic2.create = create;
    function is2(value) {
      var _a;
      let candidate = value;
      return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic2.is = is2;
  })(Diagnostic || (Diagnostic = {}));
  var Command;
  (function(Command2) {
    function create(title, command, ...args) {
      let result = { title, command };
      if (Is.defined(args) && args.length > 0) {
        result.arguments = args;
      }
      return result;
    }
    Command2.create = create;
    function is2(value) {
      let candidate = value;
      return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command2.is = is2;
  })(Command || (Command = {}));
  var TextEdit;
  (function(TextEdit2) {
    function replace(range, newText) {
      return { range, newText };
    }
    TextEdit2.replace = replace;
    function insert(position, newText) {
      return { range: { start: position, end: position }, newText };
    }
    TextEdit2.insert = insert;
    function del(range) {
      return { range, newText: "" };
    }
    TextEdit2.del = del;
    function is2(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
    }
    TextEdit2.is = is2;
  })(TextEdit || (TextEdit = {}));
  var ChangeAnnotation;
  (function(ChangeAnnotation2) {
    function create(label, needsConfirmation, description) {
      const result = { label };
      if (needsConfirmation !== void 0) {
        result.needsConfirmation = needsConfirmation;
      }
      if (description !== void 0) {
        result.description = description;
      }
      return result;
    }
    ChangeAnnotation2.create = create;
    function is2(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
    }
    ChangeAnnotation2.is = is2;
  })(ChangeAnnotation || (ChangeAnnotation = {}));
  var ChangeAnnotationIdentifier;
  (function(ChangeAnnotationIdentifier2) {
    function is2(value) {
      const candidate = value;
      return Is.string(candidate);
    }
    ChangeAnnotationIdentifier2.is = is2;
  })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
  var AnnotatedTextEdit;
  (function(AnnotatedTextEdit2) {
    function replace(range, newText, annotation) {
      return { range, newText, annotationId: annotation };
    }
    AnnotatedTextEdit2.replace = replace;
    function insert(position, newText, annotation) {
      return { range: { start: position, end: position }, newText, annotationId: annotation };
    }
    AnnotatedTextEdit2.insert = insert;
    function del(range, annotation) {
      return { range, newText: "", annotationId: annotation };
    }
    AnnotatedTextEdit2.del = del;
    function is2(value) {
      const candidate = value;
      return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    AnnotatedTextEdit2.is = is2;
  })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
  var TextDocumentEdit;
  (function(TextDocumentEdit2) {
    function create(textDocument, edits) {
      return { textDocument, edits };
    }
    TextDocumentEdit2.create = create;
    function is2(value) {
      let candidate = value;
      return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
    }
    TextDocumentEdit2.is = is2;
  })(TextDocumentEdit || (TextDocumentEdit = {}));
  var CreateFile;
  (function(CreateFile2) {
    function create(uri, options, annotation) {
      let result = {
        kind: "create",
        uri
      };
      if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
        result.options = options;
      }
      if (annotation !== void 0) {
        result.annotationId = annotation;
      }
      return result;
    }
    CreateFile2.create = create;
    function is2(value) {
      let candidate = value;
      return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    CreateFile2.is = is2;
  })(CreateFile || (CreateFile = {}));
  var RenameFile;
  (function(RenameFile2) {
    function create(oldUri, newUri, options, annotation) {
      let result = {
        kind: "rename",
        oldUri,
        newUri
      };
      if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
        result.options = options;
      }
      if (annotation !== void 0) {
        result.annotationId = annotation;
      }
      return result;
    }
    RenameFile2.create = create;
    function is2(value) {
      let candidate = value;
      return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    RenameFile2.is = is2;
  })(RenameFile || (RenameFile = {}));
  var DeleteFile;
  (function(DeleteFile2) {
    function create(uri, options, annotation) {
      let result = {
        kind: "delete",
        uri
      };
      if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
        result.options = options;
      }
      if (annotation !== void 0) {
        result.annotationId = annotation;
      }
      return result;
    }
    DeleteFile2.create = create;
    function is2(value) {
      let candidate = value;
      return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    DeleteFile2.is = is2;
  })(DeleteFile || (DeleteFile = {}));
  var WorkspaceEdit;
  (function(WorkspaceEdit2) {
    function is2(value) {
      let candidate = value;
      return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every((change) => {
        if (Is.string(change.kind)) {
          return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
        } else {
          return TextDocumentEdit.is(change);
        }
      }));
    }
    WorkspaceEdit2.is = is2;
  })(WorkspaceEdit || (WorkspaceEdit = {}));
  class TextEditChangeImpl {
    constructor(edits, changeAnnotations) {
      this.edits = edits;
      this.changeAnnotations = changeAnnotations;
    }
    insert(position, newText, annotation) {
      let edit;
      let id;
      if (annotation === void 0) {
        edit = TextEdit.insert(position, newText);
      } else if (ChangeAnnotationIdentifier.is(annotation)) {
        id = annotation;
        edit = AnnotatedTextEdit.insert(position, newText, annotation);
      } else {
        this.assertChangeAnnotations(this.changeAnnotations);
        id = this.changeAnnotations.manage(annotation);
        edit = AnnotatedTextEdit.insert(position, newText, id);
      }
      this.edits.push(edit);
      if (id !== void 0) {
        return id;
      }
    }
    replace(range, newText, annotation) {
      let edit;
      let id;
      if (annotation === void 0) {
        edit = TextEdit.replace(range, newText);
      } else if (ChangeAnnotationIdentifier.is(annotation)) {
        id = annotation;
        edit = AnnotatedTextEdit.replace(range, newText, annotation);
      } else {
        this.assertChangeAnnotations(this.changeAnnotations);
        id = this.changeAnnotations.manage(annotation);
        edit = AnnotatedTextEdit.replace(range, newText, id);
      }
      this.edits.push(edit);
      if (id !== void 0) {
        return id;
      }
    }
    delete(range, annotation) {
      let edit;
      let id;
      if (annotation === void 0) {
        edit = TextEdit.del(range);
      } else if (ChangeAnnotationIdentifier.is(annotation)) {
        id = annotation;
        edit = AnnotatedTextEdit.del(range, annotation);
      } else {
        this.assertChangeAnnotations(this.changeAnnotations);
        id = this.changeAnnotations.manage(annotation);
        edit = AnnotatedTextEdit.del(range, id);
      }
      this.edits.push(edit);
      if (id !== void 0) {
        return id;
      }
    }
    add(edit) {
      this.edits.push(edit);
    }
    all() {
      return this.edits;
    }
    clear() {
      this.edits.splice(0, this.edits.length);
    }
    assertChangeAnnotations(value) {
      if (value === void 0) {
        throw new Error(`Text edit change is not configured to manage change annotations.`);
      }
    }
  }
  class ChangeAnnotations {
    constructor(annotations) {
      this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
      this._counter = 0;
      this._size = 0;
    }
    all() {
      return this._annotations;
    }
    get size() {
      return this._size;
    }
    manage(idOrAnnotation, annotation) {
      let id;
      if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
        id = idOrAnnotation;
      } else {
        id = this.nextId();
        annotation = idOrAnnotation;
      }
      if (this._annotations[id] !== void 0) {
        throw new Error(`Id ${id} is already in use.`);
      }
      if (annotation === void 0) {
        throw new Error(`No annotation provided for id ${id}`);
      }
      this._annotations[id] = annotation;
      this._size++;
      return id;
    }
    nextId() {
      this._counter++;
      return this._counter.toString();
    }
  }
  class WorkspaceChange {
    constructor(workspaceEdit) {
      this._textEditChanges = /* @__PURE__ */ Object.create(null);
      if (workspaceEdit !== void 0) {
        this._workspaceEdit = workspaceEdit;
        if (workspaceEdit.documentChanges) {
          this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
          workspaceEdit.changeAnnotations = this._changeAnnotations.all();
          workspaceEdit.documentChanges.forEach((change) => {
            if (TextDocumentEdit.is(change)) {
              const textEditChange = new TextEditChangeImpl(change.edits, this._changeAnnotations);
              this._textEditChanges[change.textDocument.uri] = textEditChange;
            }
          });
        } else if (workspaceEdit.changes) {
          Object.keys(workspaceEdit.changes).forEach((key) => {
            const textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
            this._textEditChanges[key] = textEditChange;
          });
        }
      } else {
        this._workspaceEdit = {};
      }
    }
    /**
     * Returns the underlying {@link WorkspaceEdit} literal
     * use to be returned from a workspace edit operation like rename.
     */
    get edit() {
      this.initDocumentChanges();
      if (this._changeAnnotations !== void 0) {
        if (this._changeAnnotations.size === 0) {
          this._workspaceEdit.changeAnnotations = void 0;
        } else {
          this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
      }
      return this._workspaceEdit;
    }
    getTextEditChange(key) {
      if (OptionalVersionedTextDocumentIdentifier.is(key)) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        const textDocument = { uri: key.uri, version: key.version };
        let result = this._textEditChanges[textDocument.uri];
        if (!result) {
          const edits = [];
          const textDocumentEdit = {
            textDocument,
            edits
          };
          this._workspaceEdit.documentChanges.push(textDocumentEdit);
          result = new TextEditChangeImpl(edits, this._changeAnnotations);
          this._textEditChanges[textDocument.uri] = result;
        }
        return result;
      } else {
        this.initChanges();
        if (this._workspaceEdit.changes === void 0) {
          throw new Error("Workspace edit is not configured for normal text edit changes.");
        }
        let result = this._textEditChanges[key];
        if (!result) {
          let edits = [];
          this._workspaceEdit.changes[key] = edits;
          result = new TextEditChangeImpl(edits);
          this._textEditChanges[key] = result;
        }
        return result;
      }
    }
    initDocumentChanges() {
      if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
        this._changeAnnotations = new ChangeAnnotations();
        this._workspaceEdit.documentChanges = [];
        this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
      }
    }
    initChanges() {
      if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
        this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
      }
    }
    createFile(uri, optionsOrAnnotation, options) {
      this.initDocumentChanges();
      if (this._workspaceEdit.documentChanges === void 0) {
        throw new Error("Workspace edit is not configured for document changes.");
      }
      let annotation;
      if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
        annotation = optionsOrAnnotation;
      } else {
        options = optionsOrAnnotation;
      }
      let operation;
      let id;
      if (annotation === void 0) {
        operation = CreateFile.create(uri, options);
      } else {
        id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
        operation = CreateFile.create(uri, options, id);
      }
      this._workspaceEdit.documentChanges.push(operation);
      if (id !== void 0) {
        return id;
      }
    }
    renameFile(oldUri, newUri, optionsOrAnnotation, options) {
      this.initDocumentChanges();
      if (this._workspaceEdit.documentChanges === void 0) {
        throw new Error("Workspace edit is not configured for document changes.");
      }
      let annotation;
      if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
        annotation = optionsOrAnnotation;
      } else {
        options = optionsOrAnnotation;
      }
      let operation;
      let id;
      if (annotation === void 0) {
        operation = RenameFile.create(oldUri, newUri, options);
      } else {
        id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
        operation = RenameFile.create(oldUri, newUri, options, id);
      }
      this._workspaceEdit.documentChanges.push(operation);
      if (id !== void 0) {
        return id;
      }
    }
    deleteFile(uri, optionsOrAnnotation, options) {
      this.initDocumentChanges();
      if (this._workspaceEdit.documentChanges === void 0) {
        throw new Error("Workspace edit is not configured for document changes.");
      }
      let annotation;
      if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
        annotation = optionsOrAnnotation;
      } else {
        options = optionsOrAnnotation;
      }
      let operation;
      let id;
      if (annotation === void 0) {
        operation = DeleteFile.create(uri, options);
      } else {
        id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
        operation = DeleteFile.create(uri, options, id);
      }
      this._workspaceEdit.documentChanges.push(operation);
      if (id !== void 0) {
        return id;
      }
    }
  }
  var TextDocumentIdentifier;
  (function(TextDocumentIdentifier2) {
    function create(uri) {
      return { uri };
    }
    TextDocumentIdentifier2.create = create;
    function is2(value) {
      let candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier2.is = is2;
  })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
  var VersionedTextDocumentIdentifier;
  (function(VersionedTextDocumentIdentifier2) {
    function create(uri, version) {
      return { uri, version };
    }
    VersionedTextDocumentIdentifier2.create = create;
    function is2(value) {
      let candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
    }
    VersionedTextDocumentIdentifier2.is = is2;
  })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
  var OptionalVersionedTextDocumentIdentifier;
  (function(OptionalVersionedTextDocumentIdentifier2) {
    function create(uri, version) {
      return { uri, version };
    }
    OptionalVersionedTextDocumentIdentifier2.create = create;
    function is2(value) {
      let candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
    }
    OptionalVersionedTextDocumentIdentifier2.is = is2;
  })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
  var TextDocumentItem;
  (function(TextDocumentItem2) {
    function create(uri, languageId, version, text) {
      return { uri, languageId, version, text };
    }
    TextDocumentItem2.create = create;
    function is2(value) {
      let candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem2.is = is2;
  })(TextDocumentItem || (TextDocumentItem = {}));
  var MarkupKind;
  (function(MarkupKind2) {
    MarkupKind2.PlainText = "plaintext";
    MarkupKind2.Markdown = "markdown";
    function is2(value) {
      const candidate = value;
      return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
    }
    MarkupKind2.is = is2;
  })(MarkupKind || (MarkupKind = {}));
  var MarkupContent;
  (function(MarkupContent2) {
    function is2(value) {
      const candidate = value;
      return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent2.is = is2;
  })(MarkupContent || (MarkupContent = {}));
  var CompletionItemKind;
  (function(CompletionItemKind2) {
    CompletionItemKind2.Text = 1;
    CompletionItemKind2.Method = 2;
    CompletionItemKind2.Function = 3;
    CompletionItemKind2.Constructor = 4;
    CompletionItemKind2.Field = 5;
    CompletionItemKind2.Variable = 6;
    CompletionItemKind2.Class = 7;
    CompletionItemKind2.Interface = 8;
    CompletionItemKind2.Module = 9;
    CompletionItemKind2.Property = 10;
    CompletionItemKind2.Unit = 11;
    CompletionItemKind2.Value = 12;
    CompletionItemKind2.Enum = 13;
    CompletionItemKind2.Keyword = 14;
    CompletionItemKind2.Snippet = 15;
    CompletionItemKind2.Color = 16;
    CompletionItemKind2.File = 17;
    CompletionItemKind2.Reference = 18;
    CompletionItemKind2.Folder = 19;
    CompletionItemKind2.EnumMember = 20;
    CompletionItemKind2.Constant = 21;
    CompletionItemKind2.Struct = 22;
    CompletionItemKind2.Event = 23;
    CompletionItemKind2.Operator = 24;
    CompletionItemKind2.TypeParameter = 25;
  })(CompletionItemKind || (CompletionItemKind = {}));
  var InsertTextFormat;
  (function(InsertTextFormat2) {
    InsertTextFormat2.PlainText = 1;
    InsertTextFormat2.Snippet = 2;
  })(InsertTextFormat || (InsertTextFormat = {}));
  var CompletionItemTag;
  (function(CompletionItemTag2) {
    CompletionItemTag2.Deprecated = 1;
  })(CompletionItemTag || (CompletionItemTag = {}));
  var InsertReplaceEdit;
  (function(InsertReplaceEdit2) {
    function create(newText, insert, replace) {
      return { newText, insert, replace };
    }
    InsertReplaceEdit2.create = create;
    function is2(value) {
      const candidate = value;
      return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
    }
    InsertReplaceEdit2.is = is2;
  })(InsertReplaceEdit || (InsertReplaceEdit = {}));
  var InsertTextMode;
  (function(InsertTextMode2) {
    InsertTextMode2.asIs = 1;
    InsertTextMode2.adjustIndentation = 2;
  })(InsertTextMode || (InsertTextMode = {}));
  var CompletionItemLabelDetails;
  (function(CompletionItemLabelDetails2) {
    function is2(value) {
      const candidate = value;
      return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
    }
    CompletionItemLabelDetails2.is = is2;
  })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
  var CompletionItem;
  (function(CompletionItem2) {
    function create(label) {
      return { label };
    }
    CompletionItem2.create = create;
  })(CompletionItem || (CompletionItem = {}));
  var CompletionList;
  (function(CompletionList2) {
    function create(items, isIncomplete) {
      return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList2.create = create;
  })(CompletionList || (CompletionList = {}));
  var MarkedString;
  (function(MarkedString2) {
    function fromPlainText(plainText) {
      return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
    }
    MarkedString2.fromPlainText = fromPlainText;
    function is2(value) {
      const candidate = value;
      return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
    }
    MarkedString2.is = is2;
  })(MarkedString || (MarkedString = {}));
  var Hover;
  (function(Hover2) {
    function is2(value) {
      let candidate = value;
      return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
    }
    Hover2.is = is2;
  })(Hover || (Hover = {}));
  var ParameterInformation;
  (function(ParameterInformation2) {
    function create(label, documentation) {
      return documentation ? { label, documentation } : { label };
    }
    ParameterInformation2.create = create;
  })(ParameterInformation || (ParameterInformation = {}));
  var SignatureInformation;
  (function(SignatureInformation2) {
    function create(label, documentation, ...parameters) {
      let result = { label };
      if (Is.defined(documentation)) {
        result.documentation = documentation;
      }
      if (Is.defined(parameters)) {
        result.parameters = parameters;
      } else {
        result.parameters = [];
      }
      return result;
    }
    SignatureInformation2.create = create;
  })(SignatureInformation || (SignatureInformation = {}));
  var DocumentHighlightKind;
  (function(DocumentHighlightKind2) {
    DocumentHighlightKind2.Text = 1;
    DocumentHighlightKind2.Read = 2;
    DocumentHighlightKind2.Write = 3;
  })(DocumentHighlightKind || (DocumentHighlightKind = {}));
  var DocumentHighlight;
  (function(DocumentHighlight2) {
    function create(range, kind) {
      let result = { range };
      if (Is.number(kind)) {
        result.kind = kind;
      }
      return result;
    }
    DocumentHighlight2.create = create;
  })(DocumentHighlight || (DocumentHighlight = {}));
  var SymbolKind;
  (function(SymbolKind2) {
    SymbolKind2.File = 1;
    SymbolKind2.Module = 2;
    SymbolKind2.Namespace = 3;
    SymbolKind2.Package = 4;
    SymbolKind2.Class = 5;
    SymbolKind2.Method = 6;
    SymbolKind2.Property = 7;
    SymbolKind2.Field = 8;
    SymbolKind2.Constructor = 9;
    SymbolKind2.Enum = 10;
    SymbolKind2.Interface = 11;
    SymbolKind2.Function = 12;
    SymbolKind2.Variable = 13;
    SymbolKind2.Constant = 14;
    SymbolKind2.String = 15;
    SymbolKind2.Number = 16;
    SymbolKind2.Boolean = 17;
    SymbolKind2.Array = 18;
    SymbolKind2.Object = 19;
    SymbolKind2.Key = 20;
    SymbolKind2.Null = 21;
    SymbolKind2.EnumMember = 22;
    SymbolKind2.Struct = 23;
    SymbolKind2.Event = 24;
    SymbolKind2.Operator = 25;
    SymbolKind2.TypeParameter = 26;
  })(SymbolKind || (SymbolKind = {}));
  var SymbolTag;
  (function(SymbolTag2) {
    SymbolTag2.Deprecated = 1;
  })(SymbolTag || (SymbolTag = {}));
  var SymbolInformation;
  (function(SymbolInformation2) {
    function create(name, kind, range, uri, containerName) {
      let result = {
        name,
        kind,
        location: { uri, range }
      };
      if (containerName) {
        result.containerName = containerName;
      }
      return result;
    }
    SymbolInformation2.create = create;
  })(SymbolInformation || (SymbolInformation = {}));
  var WorkspaceSymbol;
  (function(WorkspaceSymbol2) {
    function create(name, kind, uri, range) {
      return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
    }
    WorkspaceSymbol2.create = create;
  })(WorkspaceSymbol || (WorkspaceSymbol = {}));
  var DocumentSymbol;
  (function(DocumentSymbol2) {
    function create(name, detail, kind, range, selectionRange, children) {
      let result = {
        name,
        detail,
        kind,
        range,
        selectionRange
      };
      if (children !== void 0) {
        result.children = children;
      }
      return result;
    }
    DocumentSymbol2.create = create;
    function is2(value) {
      let candidate = value;
      return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
    }
    DocumentSymbol2.is = is2;
  })(DocumentSymbol || (DocumentSymbol = {}));
  var CodeActionKind;
  (function(CodeActionKind2) {
    CodeActionKind2.Empty = "";
    CodeActionKind2.QuickFix = "quickfix";
    CodeActionKind2.Refactor = "refactor";
    CodeActionKind2.RefactorExtract = "refactor.extract";
    CodeActionKind2.RefactorInline = "refactor.inline";
    CodeActionKind2.RefactorRewrite = "refactor.rewrite";
    CodeActionKind2.Source = "source";
    CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
    CodeActionKind2.SourceFixAll = "source.fixAll";
  })(CodeActionKind || (CodeActionKind = {}));
  var CodeActionTriggerKind;
  (function(CodeActionTriggerKind2) {
    CodeActionTriggerKind2.Invoked = 1;
    CodeActionTriggerKind2.Automatic = 2;
  })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
  var CodeActionContext;
  (function(CodeActionContext2) {
    function create(diagnostics, only, triggerKind) {
      let result = { diagnostics };
      if (only !== void 0 && only !== null) {
        result.only = only;
      }
      if (triggerKind !== void 0 && triggerKind !== null) {
        result.triggerKind = triggerKind;
      }
      return result;
    }
    CodeActionContext2.create = create;
    function is2(value) {
      let candidate = value;
      return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
    }
    CodeActionContext2.is = is2;
  })(CodeActionContext || (CodeActionContext = {}));
  var CodeAction;
  (function(CodeAction2) {
    function create(title, kindOrCommandOrEdit, kind) {
      let result = { title };
      let checkKind = true;
      if (typeof kindOrCommandOrEdit === "string") {
        checkKind = false;
        result.kind = kindOrCommandOrEdit;
      } else if (Command.is(kindOrCommandOrEdit)) {
        result.command = kindOrCommandOrEdit;
      } else {
        result.edit = kindOrCommandOrEdit;
      }
      if (checkKind && kind !== void 0) {
        result.kind = kind;
      }
      return result;
    }
    CodeAction2.create = create;
    function is2(value) {
      let candidate = value;
      return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction2.is = is2;
  })(CodeAction || (CodeAction = {}));
  var CodeLens;
  (function(CodeLens2) {
    function create(range, data) {
      let result = { range };
      if (Is.defined(data)) {
        result.data = data;
      }
      return result;
    }
    CodeLens2.create = create;
    function is2(value) {
      let candidate = value;
      return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens2.is = is2;
  })(CodeLens || (CodeLens = {}));
  var FormattingOptions;
  (function(FormattingOptions2) {
    function create(tabSize, insertSpaces) {
      return { tabSize, insertSpaces };
    }
    FormattingOptions2.create = create;
    function is2(value) {
      let candidate = value;
      return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions2.is = is2;
  })(FormattingOptions || (FormattingOptions = {}));
  var DocumentLink;
  (function(DocumentLink2) {
    function create(range, target, data) {
      return { range, target, data };
    }
    DocumentLink2.create = create;
    function is2(value) {
      let candidate = value;
      return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink2.is = is2;
  })(DocumentLink || (DocumentLink = {}));
  var SelectionRange;
  (function(SelectionRange2) {
    function create(range, parent) {
      return { range, parent };
    }
    SelectionRange2.create = create;
    function is2(value) {
      let candidate = value;
      return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
    }
    SelectionRange2.is = is2;
  })(SelectionRange || (SelectionRange = {}));
  var SemanticTokenTypes;
  (function(SemanticTokenTypes2) {
    SemanticTokenTypes2["namespace"] = "namespace";
    SemanticTokenTypes2["type"] = "type";
    SemanticTokenTypes2["class"] = "class";
    SemanticTokenTypes2["enum"] = "enum";
    SemanticTokenTypes2["interface"] = "interface";
    SemanticTokenTypes2["struct"] = "struct";
    SemanticTokenTypes2["typeParameter"] = "typeParameter";
    SemanticTokenTypes2["parameter"] = "parameter";
    SemanticTokenTypes2["variable"] = "variable";
    SemanticTokenTypes2["property"] = "property";
    SemanticTokenTypes2["enumMember"] = "enumMember";
    SemanticTokenTypes2["event"] = "event";
    SemanticTokenTypes2["function"] = "function";
    SemanticTokenTypes2["method"] = "method";
    SemanticTokenTypes2["macro"] = "macro";
    SemanticTokenTypes2["keyword"] = "keyword";
    SemanticTokenTypes2["modifier"] = "modifier";
    SemanticTokenTypes2["comment"] = "comment";
    SemanticTokenTypes2["string"] = "string";
    SemanticTokenTypes2["number"] = "number";
    SemanticTokenTypes2["regexp"] = "regexp";
    SemanticTokenTypes2["operator"] = "operator";
    SemanticTokenTypes2["decorator"] = "decorator";
  })(SemanticTokenTypes || (SemanticTokenTypes = {}));
  var SemanticTokenModifiers;
  (function(SemanticTokenModifiers2) {
    SemanticTokenModifiers2["declaration"] = "declaration";
    SemanticTokenModifiers2["definition"] = "definition";
    SemanticTokenModifiers2["readonly"] = "readonly";
    SemanticTokenModifiers2["static"] = "static";
    SemanticTokenModifiers2["deprecated"] = "deprecated";
    SemanticTokenModifiers2["abstract"] = "abstract";
    SemanticTokenModifiers2["async"] = "async";
    SemanticTokenModifiers2["modification"] = "modification";
    SemanticTokenModifiers2["documentation"] = "documentation";
    SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
  })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
  var SemanticTokens;
  (function(SemanticTokens2) {
    function is2(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
    }
    SemanticTokens2.is = is2;
  })(SemanticTokens || (SemanticTokens = {}));
  var InlineValueText;
  (function(InlineValueText2) {
    function create(range, text) {
      return { range, text };
    }
    InlineValueText2.create = create;
    function is2(value) {
      const candidate = value;
      return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
    }
    InlineValueText2.is = is2;
  })(InlineValueText || (InlineValueText = {}));
  var InlineValueVariableLookup;
  (function(InlineValueVariableLookup2) {
    function create(range, variableName, caseSensitiveLookup) {
      return { range, variableName, caseSensitiveLookup };
    }
    InlineValueVariableLookup2.create = create;
    function is2(value) {
      const candidate = value;
      return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
    }
    InlineValueVariableLookup2.is = is2;
  })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
  var InlineValueEvaluatableExpression;
  (function(InlineValueEvaluatableExpression2) {
    function create(range, expression) {
      return { range, expression };
    }
    InlineValueEvaluatableExpression2.create = create;
    function is2(value) {
      const candidate = value;
      return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
    }
    InlineValueEvaluatableExpression2.is = is2;
  })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
  var InlineValueContext;
  (function(InlineValueContext2) {
    function create(frameId, stoppedLocation) {
      return { frameId, stoppedLocation };
    }
    InlineValueContext2.create = create;
    function is2(value) {
      const candidate = value;
      return Is.defined(candidate) && Range.is(value.stoppedLocation);
    }
    InlineValueContext2.is = is2;
  })(InlineValueContext || (InlineValueContext = {}));
  var InlayHintKind;
  (function(InlayHintKind2) {
    InlayHintKind2.Type = 1;
    InlayHintKind2.Parameter = 2;
    function is2(value) {
      return value === 1 || value === 2;
    }
    InlayHintKind2.is = is2;
  })(InlayHintKind || (InlayHintKind = {}));
  var InlayHintLabelPart;
  (function(InlayHintLabelPart2) {
    function create(value) {
      return { value };
    }
    InlayHintLabelPart2.create = create;
    function is2(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));
    }
    InlayHintLabelPart2.is = is2;
  })(InlayHintLabelPart || (InlayHintLabelPart = {}));
  var InlayHint;
  (function(InlayHint2) {
    function create(position, label, kind) {
      const result = { position, label };
      if (kind !== void 0) {
        result.kind = kind;
      }
      return result;
    }
    InlayHint2.create = create;
    function is2(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
    }
    InlayHint2.is = is2;
  })(InlayHint || (InlayHint = {}));
  var StringValue;
  (function(StringValue2) {
    function createSnippet(value) {
      return { kind: "snippet", value };
    }
    StringValue2.createSnippet = createSnippet;
  })(StringValue || (StringValue = {}));
  var InlineCompletionItem;
  (function(InlineCompletionItem2) {
    function create(insertText, filterText, range, command) {
      return { insertText, filterText, range, command };
    }
    InlineCompletionItem2.create = create;
  })(InlineCompletionItem || (InlineCompletionItem = {}));
  var InlineCompletionList;
  (function(InlineCompletionList2) {
    function create(items) {
      return { items };
    }
    InlineCompletionList2.create = create;
  })(InlineCompletionList || (InlineCompletionList = {}));
  var InlineCompletionTriggerKind;
  (function(InlineCompletionTriggerKind2) {
    InlineCompletionTriggerKind2.Invoked = 0;
    InlineCompletionTriggerKind2.Automatic = 1;
  })(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
  var SelectedCompletionInfo;
  (function(SelectedCompletionInfo2) {
    function create(range, text) {
      return { range, text };
    }
    SelectedCompletionInfo2.create = create;
  })(SelectedCompletionInfo || (SelectedCompletionInfo = {}));
  var InlineCompletionContext;
  (function(InlineCompletionContext2) {
    function create(triggerKind, selectedCompletionInfo) {
      return { triggerKind, selectedCompletionInfo };
    }
    InlineCompletionContext2.create = create;
  })(InlineCompletionContext || (InlineCompletionContext = {}));
  var WorkspaceFolder;
  (function(WorkspaceFolder2) {
    function is2(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && URI$1.is(candidate.uri) && Is.string(candidate.name);
    }
    WorkspaceFolder2.is = is2;
  })(WorkspaceFolder || (WorkspaceFolder = {}));
  const EOL = ["\n", "\r\n", "\r"];
  var TextDocument;
  (function(TextDocument2) {
    function create(uri, languageId, version, content) {
      return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument2.create = create;
    function is2(value) {
      let candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument2.is = is2;
    function applyEdits(document2, edits) {
      let text = document2.getText();
      let sortedEdits = mergeSort(edits, (a, b) => {
        let diff = a.range.start.line - b.range.start.line;
        if (diff === 0) {
          return a.range.start.character - b.range.start.character;
        }
        return diff;
      });
      let lastModifiedOffset = text.length;
      for (let i = sortedEdits.length - 1; i >= 0; i--) {
        let e = sortedEdits[i];
        let startOffset = document2.offsetAt(e.range.start);
        let endOffset = document2.offsetAt(e.range.end);
        if (endOffset <= lastModifiedOffset) {
          text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
        } else {
          throw new Error("Overlapping edit");
        }
        lastModifiedOffset = startOffset;
      }
      return text;
    }
    TextDocument2.applyEdits = applyEdits;
    function mergeSort(data, compare) {
      if (data.length <= 1) {
        return data;
      }
      const p = data.length / 2 | 0;
      const left = data.slice(0, p);
      const right = data.slice(p);
      mergeSort(left, compare);
      mergeSort(right, compare);
      let leftIdx = 0;
      let rightIdx = 0;
      let i = 0;
      while (leftIdx < left.length && rightIdx < right.length) {
        let ret = compare(left[leftIdx], right[rightIdx]);
        if (ret <= 0) {
          data[i++] = left[leftIdx++];
        } else {
          data[i++] = right[rightIdx++];
        }
      }
      while (leftIdx < left.length) {
        data[i++] = left[leftIdx++];
      }
      while (rightIdx < right.length) {
        data[i++] = right[rightIdx++];
      }
      return data;
    }
  })(TextDocument || (TextDocument = {}));
  class FullTextDocument {
    constructor(uri, languageId, version, content) {
      this._uri = uri;
      this._languageId = languageId;
      this._version = version;
      this._content = content;
      this._lineOffsets = void 0;
    }
    get uri() {
      return this._uri;
    }
    get languageId() {
      return this._languageId;
    }
    get version() {
      return this._version;
    }
    getText(range) {
      if (range) {
        let start = this.offsetAt(range.start);
        let end = this.offsetAt(range.end);
        return this._content.substring(start, end);
      }
      return this._content;
    }
    update(event, version) {
      this._content = event.text;
      this._version = version;
      this._lineOffsets = void 0;
    }
    getLineOffsets() {
      if (this._lineOffsets === void 0) {
        let lineOffsets = [];
        let text = this._content;
        let isLineStart = true;
        for (let i = 0; i < text.length; i++) {
          if (isLineStart) {
            lineOffsets.push(i);
            isLineStart = false;
          }
          let ch = text.charAt(i);
          isLineStart = ch === "\r" || ch === "\n";
          if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
            i++;
          }
        }
        if (isLineStart && text.length > 0) {
          lineOffsets.push(text.length);
        }
        this._lineOffsets = lineOffsets;
      }
      return this._lineOffsets;
    }
    positionAt(offset) {
      offset = Math.max(Math.min(offset, this._content.length), 0);
      let lineOffsets = this.getLineOffsets();
      let low = 0, high = lineOffsets.length;
      if (high === 0) {
        return Position.create(0, offset);
      }
      while (low < high) {
        let mid = Math.floor((low + high) / 2);
        if (lineOffsets[mid] > offset) {
          high = mid;
        } else {
          low = mid + 1;
        }
      }
      let line = low - 1;
      return Position.create(line, offset - lineOffsets[line]);
    }
    offsetAt(position) {
      let lineOffsets = this.getLineOffsets();
      if (position.line >= lineOffsets.length) {
        return this._content.length;
      } else if (position.line < 0) {
        return 0;
      }
      let lineOffset = lineOffsets[position.line];
      let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
      return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    }
    get lineCount() {
      return this.getLineOffsets().length;
    }
  }
  var Is;
  (function(Is2) {
    const toString = Object.prototype.toString;
    function defined(value) {
      return typeof value !== "undefined";
    }
    Is2.defined = defined;
    function undefined$1(value) {
      return typeof value === "undefined";
    }
    Is2.undefined = undefined$1;
    function boolean(value) {
      return value === true || value === false;
    }
    Is2.boolean = boolean;
    function string(value) {
      return toString.call(value) === "[object String]";
    }
    Is2.string = string;
    function number(value) {
      return toString.call(value) === "[object Number]";
    }
    Is2.number = number;
    function numberRange(value, min, max) {
      return toString.call(value) === "[object Number]" && min <= value && value <= max;
    }
    Is2.numberRange = numberRange;
    function integer2(value) {
      return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
    }
    Is2.integer = integer2;
    function uinteger2(value) {
      return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
    }
    Is2.uinteger = uinteger2;
    function func(value) {
      return toString.call(value) === "[object Function]";
    }
    Is2.func = func;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    Is2.objectLiteral = objectLiteral;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    Is2.typedArray = typedArray;
  })(Is || (Is = {}));
  const main = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    get AnnotatedTextEdit() {
      return AnnotatedTextEdit;
    },
    get ChangeAnnotation() {
      return ChangeAnnotation;
    },
    get ChangeAnnotationIdentifier() {
      return ChangeAnnotationIdentifier;
    },
    get CodeAction() {
      return CodeAction;
    },
    get CodeActionContext() {
      return CodeActionContext;
    },
    get CodeActionKind() {
      return CodeActionKind;
    },
    get CodeActionTriggerKind() {
      return CodeActionTriggerKind;
    },
    get CodeDescription() {
      return CodeDescription;
    },
    get CodeLens() {
      return CodeLens;
    },
    get Color() {
      return Color;
    },
    get ColorInformation() {
      return ColorInformation;
    },
    get ColorPresentation() {
      return ColorPresentation;
    },
    get Command() {
      return Command;
    },
    get CompletionItem() {
      return CompletionItem;
    },
    get CompletionItemKind() {
      return CompletionItemKind;
    },
    get CompletionItemLabelDetails() {
      return CompletionItemLabelDetails;
    },
    get CompletionItemTag() {
      return CompletionItemTag;
    },
    get CompletionList() {
      return CompletionList;
    },
    get CreateFile() {
      return CreateFile;
    },
    get DeleteFile() {
      return DeleteFile;
    },
    get Diagnostic() {
      return Diagnostic;
    },
    get DiagnosticRelatedInformation() {
      return DiagnosticRelatedInformation;
    },
    get DiagnosticSeverity() {
      return DiagnosticSeverity;
    },
    get DiagnosticTag() {
      return DiagnosticTag;
    },
    get DocumentHighlight() {
      return DocumentHighlight;
    },
    get DocumentHighlightKind() {
      return DocumentHighlightKind;
    },
    get DocumentLink() {
      return DocumentLink;
    },
    get DocumentSymbol() {
      return DocumentSymbol;
    },
    get DocumentUri() {
      return DocumentUri;
    },
    EOL,
    get FoldingRange() {
      return FoldingRange;
    },
    get FoldingRangeKind() {
      return FoldingRangeKind;
    },
    get FormattingOptions() {
      return FormattingOptions;
    },
    get Hover() {
      return Hover;
    },
    get InlayHint() {
      return InlayHint;
    },
    get InlayHintKind() {
      return InlayHintKind;
    },
    get InlayHintLabelPart() {
      return InlayHintLabelPart;
    },
    get InlineCompletionContext() {
      return InlineCompletionContext;
    },
    get InlineCompletionItem() {
      return InlineCompletionItem;
    },
    get InlineCompletionList() {
      return InlineCompletionList;
    },
    get InlineCompletionTriggerKind() {
      return InlineCompletionTriggerKind;
    },
    get InlineValueContext() {
      return InlineValueContext;
    },
    get InlineValueEvaluatableExpression() {
      return InlineValueEvaluatableExpression;
    },
    get InlineValueText() {
      return InlineValueText;
    },
    get InlineValueVariableLookup() {
      return InlineValueVariableLookup;
    },
    get InsertReplaceEdit() {
      return InsertReplaceEdit;
    },
    get InsertTextFormat() {
      return InsertTextFormat;
    },
    get InsertTextMode() {
      return InsertTextMode;
    },
    get Location() {
      return Location;
    },
    get LocationLink() {
      return LocationLink;
    },
    get MarkedString() {
      return MarkedString;
    },
    get MarkupContent() {
      return MarkupContent;
    },
    get MarkupKind() {
      return MarkupKind;
    },
    get OptionalVersionedTextDocumentIdentifier() {
      return OptionalVersionedTextDocumentIdentifier;
    },
    get ParameterInformation() {
      return ParameterInformation;
    },
    get Position() {
      return Position;
    },
    get Range() {
      return Range;
    },
    get RenameFile() {
      return RenameFile;
    },
    get SelectedCompletionInfo() {
      return SelectedCompletionInfo;
    },
    get SelectionRange() {
      return SelectionRange;
    },
    get SemanticTokenModifiers() {
      return SemanticTokenModifiers;
    },
    get SemanticTokenTypes() {
      return SemanticTokenTypes;
    },
    get SemanticTokens() {
      return SemanticTokens;
    },
    get SignatureInformation() {
      return SignatureInformation;
    },
    get StringValue() {
      return StringValue;
    },
    get SymbolInformation() {
      return SymbolInformation;
    },
    get SymbolKind() {
      return SymbolKind;
    },
    get SymbolTag() {
      return SymbolTag;
    },
    get TextDocument() {
      return TextDocument;
    },
    get TextDocumentEdit() {
      return TextDocumentEdit;
    },
    get TextDocumentIdentifier() {
      return TextDocumentIdentifier;
    },
    get TextDocumentItem() {
      return TextDocumentItem;
    },
    get TextEdit() {
      return TextEdit;
    },
    get URI() {
      return URI$1;
    },
    get VersionedTextDocumentIdentifier() {
      return VersionedTextDocumentIdentifier;
    },
    WorkspaceChange,
    get WorkspaceEdit() {
      return WorkspaceEdit;
    },
    get WorkspaceFolder() {
      return WorkspaceFolder;
    },
    get WorkspaceSymbol() {
      return WorkspaceSymbol;
    },
    get integer() {
      return integer;
    },
    get uinteger() {
      return uinteger;
    }
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$1 = /* @__PURE__ */ getAugmentedNamespace(main);
  var messages = {};
  var hasRequiredMessages;
  function requireMessages() {
    if (hasRequiredMessages) return messages;
    hasRequiredMessages = 1;
    Object.defineProperty(messages, "__esModule", { value: true });
    messages.ProtocolNotificationType = messages.ProtocolNotificationType0 = messages.ProtocolRequestType = messages.ProtocolRequestType0 = messages.RegistrationType = messages.MessageDirection = void 0;
    const vscode_jsonrpc_1 = requireMain$1();
    var MessageDirection;
    (function(MessageDirection2) {
      MessageDirection2["clientToServer"] = "clientToServer";
      MessageDirection2["serverToClient"] = "serverToClient";
      MessageDirection2["both"] = "both";
    })(MessageDirection || (messages.MessageDirection = MessageDirection = {}));
    class RegistrationType {
      constructor(method) {
        this.method = method;
      }
    }
    messages.RegistrationType = RegistrationType;
    class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    }
    messages.ProtocolRequestType0 = ProtocolRequestType0;
    class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    }
    messages.ProtocolRequestType = ProtocolRequestType;
    class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    }
    messages.ProtocolNotificationType0 = ProtocolNotificationType0;
    class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    }
    messages.ProtocolNotificationType = ProtocolNotificationType;
    return messages;
  }
  var protocol = {};
  var is = {};
  var hasRequiredIs;
  function requireIs() {
    if (hasRequiredIs) return is;
    hasRequiredIs = 1;
    Object.defineProperty(is, "__esModule", { value: true });
    is.objectLiteral = is.typedArray = is.stringArray = is.array = is.func = is.error = is.number = is.string = is.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    is.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    is.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    is.number = number;
    function error(value) {
      return value instanceof Error;
    }
    is.error = error;
    function func(value) {
      return typeof value === "function";
    }
    is.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    is.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    is.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    is.typedArray = typedArray;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    is.objectLiteral = objectLiteral;
    return is;
  }
  var protocol_implementation = {};
  var hasRequiredProtocol_implementation;
  function requireProtocol_implementation() {
    if (hasRequiredProtocol_implementation) return protocol_implementation;
    hasRequiredProtocol_implementation = 1;
    Object.defineProperty(protocol_implementation, "__esModule", { value: true });
    protocol_implementation.ImplementationRequest = void 0;
    const messages_1 = requireMessages();
    var ImplementationRequest;
    (function(ImplementationRequest2) {
      ImplementationRequest2.method = "textDocument/implementation";
      ImplementationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    })(ImplementationRequest || (protocol_implementation.ImplementationRequest = ImplementationRequest = {}));
    return protocol_implementation;
  }
  var protocol_typeDefinition = {};
  var hasRequiredProtocol_typeDefinition;
  function requireProtocol_typeDefinition() {
    if (hasRequiredProtocol_typeDefinition) return protocol_typeDefinition;
    hasRequiredProtocol_typeDefinition = 1;
    Object.defineProperty(protocol_typeDefinition, "__esModule", { value: true });
    protocol_typeDefinition.TypeDefinitionRequest = void 0;
    const messages_1 = requireMessages();
    var TypeDefinitionRequest;
    (function(TypeDefinitionRequest2) {
      TypeDefinitionRequest2.method = "textDocument/typeDefinition";
      TypeDefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    })(TypeDefinitionRequest || (protocol_typeDefinition.TypeDefinitionRequest = TypeDefinitionRequest = {}));
    return protocol_typeDefinition;
  }
  var protocol_workspaceFolder = {};
  var hasRequiredProtocol_workspaceFolder;
  function requireProtocol_workspaceFolder() {
    if (hasRequiredProtocol_workspaceFolder) return protocol_workspaceFolder;
    hasRequiredProtocol_workspaceFolder = 1;
    Object.defineProperty(protocol_workspaceFolder, "__esModule", { value: true });
    protocol_workspaceFolder.DidChangeWorkspaceFoldersNotification = protocol_workspaceFolder.WorkspaceFoldersRequest = void 0;
    const messages_1 = requireMessages();
    var WorkspaceFoldersRequest;
    (function(WorkspaceFoldersRequest2) {
      WorkspaceFoldersRequest2.method = "workspace/workspaceFolders";
      WorkspaceFoldersRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest2.method);
    })(WorkspaceFoldersRequest || (protocol_workspaceFolder.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification;
    (function(DidChangeWorkspaceFoldersNotification2) {
      DidChangeWorkspaceFoldersNotification2.method = "workspace/didChangeWorkspaceFolders";
      DidChangeWorkspaceFoldersNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification2.method);
    })(DidChangeWorkspaceFoldersNotification || (protocol_workspaceFolder.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));
    return protocol_workspaceFolder;
  }
  var protocol_configuration = {};
  var hasRequiredProtocol_configuration;
  function requireProtocol_configuration() {
    if (hasRequiredProtocol_configuration) return protocol_configuration;
    hasRequiredProtocol_configuration = 1;
    Object.defineProperty(protocol_configuration, "__esModule", { value: true });
    protocol_configuration.ConfigurationRequest = void 0;
    const messages_1 = requireMessages();
    var ConfigurationRequest;
    (function(ConfigurationRequest2) {
      ConfigurationRequest2.method = "workspace/configuration";
      ConfigurationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ConfigurationRequest2.type = new messages_1.ProtocolRequestType(ConfigurationRequest2.method);
    })(ConfigurationRequest || (protocol_configuration.ConfigurationRequest = ConfigurationRequest = {}));
    return protocol_configuration;
  }
  var protocol_colorProvider = {};
  var hasRequiredProtocol_colorProvider;
  function requireProtocol_colorProvider() {
    if (hasRequiredProtocol_colorProvider) return protocol_colorProvider;
    hasRequiredProtocol_colorProvider = 1;
    Object.defineProperty(protocol_colorProvider, "__esModule", { value: true });
    protocol_colorProvider.ColorPresentationRequest = protocol_colorProvider.DocumentColorRequest = void 0;
    const messages_1 = requireMessages();
    var DocumentColorRequest;
    (function(DocumentColorRequest2) {
      DocumentColorRequest2.method = "textDocument/documentColor";
      DocumentColorRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    })(DocumentColorRequest || (protocol_colorProvider.DocumentColorRequest = DocumentColorRequest = {}));
    var ColorPresentationRequest;
    (function(ColorPresentationRequest2) {
      ColorPresentationRequest2.method = "textDocument/colorPresentation";
      ColorPresentationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ColorPresentationRequest2.type = new messages_1.ProtocolRequestType(ColorPresentationRequest2.method);
    })(ColorPresentationRequest || (protocol_colorProvider.ColorPresentationRequest = ColorPresentationRequest = {}));
    return protocol_colorProvider;
  }
  var protocol_foldingRange = {};
  var hasRequiredProtocol_foldingRange;
  function requireProtocol_foldingRange() {
    if (hasRequiredProtocol_foldingRange) return protocol_foldingRange;
    hasRequiredProtocol_foldingRange = 1;
    Object.defineProperty(protocol_foldingRange, "__esModule", { value: true });
    protocol_foldingRange.FoldingRangeRefreshRequest = protocol_foldingRange.FoldingRangeRequest = void 0;
    const messages_1 = requireMessages();
    var FoldingRangeRequest;
    (function(FoldingRangeRequest2) {
      FoldingRangeRequest2.method = "textDocument/foldingRange";
      FoldingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    })(FoldingRangeRequest || (protocol_foldingRange.FoldingRangeRequest = FoldingRangeRequest = {}));
    var FoldingRangeRefreshRequest;
    (function(FoldingRangeRefreshRequest2) {
      FoldingRangeRefreshRequest2.method = `workspace/foldingRange/refresh`;
      FoldingRangeRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      FoldingRangeRefreshRequest2.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest2.method);
    })(FoldingRangeRefreshRequest || (protocol_foldingRange.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
    return protocol_foldingRange;
  }
  var protocol_declaration = {};
  var hasRequiredProtocol_declaration;
  function requireProtocol_declaration() {
    if (hasRequiredProtocol_declaration) return protocol_declaration;
    hasRequiredProtocol_declaration = 1;
    Object.defineProperty(protocol_declaration, "__esModule", { value: true });
    protocol_declaration.DeclarationRequest = void 0;
    const messages_1 = requireMessages();
    var DeclarationRequest;
    (function(DeclarationRequest2) {
      DeclarationRequest2.method = "textDocument/declaration";
      DeclarationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    })(DeclarationRequest || (protocol_declaration.DeclarationRequest = DeclarationRequest = {}));
    return protocol_declaration;
  }
  var protocol_selectionRange = {};
  var hasRequiredProtocol_selectionRange;
  function requireProtocol_selectionRange() {
    if (hasRequiredProtocol_selectionRange) return protocol_selectionRange;
    hasRequiredProtocol_selectionRange = 1;
    Object.defineProperty(protocol_selectionRange, "__esModule", { value: true });
    protocol_selectionRange.SelectionRangeRequest = void 0;
    const messages_1 = requireMessages();
    var SelectionRangeRequest;
    (function(SelectionRangeRequest2) {
      SelectionRangeRequest2.method = "textDocument/selectionRange";
      SelectionRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    })(SelectionRangeRequest || (protocol_selectionRange.SelectionRangeRequest = SelectionRangeRequest = {}));
    return protocol_selectionRange;
  }
  var protocol_progress = {};
  var hasRequiredProtocol_progress;
  function requireProtocol_progress() {
    if (hasRequiredProtocol_progress) return protocol_progress;
    hasRequiredProtocol_progress = 1;
    Object.defineProperty(protocol_progress, "__esModule", { value: true });
    protocol_progress.WorkDoneProgressCancelNotification = protocol_progress.WorkDoneProgressCreateRequest = protocol_progress.WorkDoneProgress = void 0;
    const vscode_jsonrpc_1 = requireMain$1();
    const messages_1 = requireMessages();
    var WorkDoneProgress;
    (function(WorkDoneProgress2) {
      WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
      function is2(value) {
        return value === WorkDoneProgress2.type;
      }
      WorkDoneProgress2.is = is2;
    })(WorkDoneProgress || (protocol_progress.WorkDoneProgress = WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest;
    (function(WorkDoneProgressCreateRequest2) {
      WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
      WorkDoneProgressCreateRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
    })(WorkDoneProgressCreateRequest || (protocol_progress.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function(WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
      WorkDoneProgressCancelNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
    })(WorkDoneProgressCancelNotification || (protocol_progress.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));
    return protocol_progress;
  }
  var protocol_callHierarchy = {};
  var hasRequiredProtocol_callHierarchy;
  function requireProtocol_callHierarchy() {
    if (hasRequiredProtocol_callHierarchy) return protocol_callHierarchy;
    hasRequiredProtocol_callHierarchy = 1;
    Object.defineProperty(protocol_callHierarchy, "__esModule", { value: true });
    protocol_callHierarchy.CallHierarchyOutgoingCallsRequest = protocol_callHierarchy.CallHierarchyIncomingCallsRequest = protocol_callHierarchy.CallHierarchyPrepareRequest = void 0;
    const messages_1 = requireMessages();
    var CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
    })(CallHierarchyPrepareRequest || (protocol_callHierarchy.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
    })(CallHierarchyIncomingCallsRequest || (protocol_callHierarchy.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
    })(CallHierarchyOutgoingCallsRequest || (protocol_callHierarchy.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));
    return protocol_callHierarchy;
  }
  var protocol_semanticTokens = {};
  var hasRequiredProtocol_semanticTokens;
  function requireProtocol_semanticTokens() {
    if (hasRequiredProtocol_semanticTokens) return protocol_semanticTokens;
    hasRequiredProtocol_semanticTokens = 1;
    Object.defineProperty(protocol_semanticTokens, "__esModule", { value: true });
    protocol_semanticTokens.SemanticTokensRefreshRequest = protocol_semanticTokens.SemanticTokensRangeRequest = protocol_semanticTokens.SemanticTokensDeltaRequest = protocol_semanticTokens.SemanticTokensRequest = protocol_semanticTokens.SemanticTokensRegistrationType = protocol_semanticTokens.TokenFormat = void 0;
    const messages_1 = requireMessages();
    var TokenFormat;
    (function(TokenFormat2) {
      TokenFormat2.Relative = "relative";
    })(TokenFormat || (protocol_semanticTokens.TokenFormat = TokenFormat = {}));
    var SemanticTokensRegistrationType;
    (function(SemanticTokensRegistrationType2) {
      SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
    })(SemanticTokensRegistrationType || (protocol_semanticTokens.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
      SemanticTokensRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRequest || (protocol_semanticTokens.SemanticTokensRequest = SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest;
    (function(SemanticTokensDeltaRequest2) {
      SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
      SemanticTokensDeltaRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensDeltaRequest || (protocol_semanticTokens.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
      SemanticTokensRangeRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRangeRequest || (protocol_semanticTokens.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest;
    (function(SemanticTokensRefreshRequest2) {
      SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
    })(SemanticTokensRefreshRequest || (protocol_semanticTokens.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));
    return protocol_semanticTokens;
  }
  var protocol_showDocument = {};
  var hasRequiredProtocol_showDocument;
  function requireProtocol_showDocument() {
    if (hasRequiredProtocol_showDocument) return protocol_showDocument;
    hasRequiredProtocol_showDocument = 1;
    Object.defineProperty(protocol_showDocument, "__esModule", { value: true });
    protocol_showDocument.ShowDocumentRequest = void 0;
    const messages_1 = requireMessages();
    var ShowDocumentRequest;
    (function(ShowDocumentRequest2) {
      ShowDocumentRequest2.method = "window/showDocument";
      ShowDocumentRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
    })(ShowDocumentRequest || (protocol_showDocument.ShowDocumentRequest = ShowDocumentRequest = {}));
    return protocol_showDocument;
  }
  var protocol_linkedEditingRange = {};
  var hasRequiredProtocol_linkedEditingRange;
  function requireProtocol_linkedEditingRange() {
    if (hasRequiredProtocol_linkedEditingRange) return protocol_linkedEditingRange;
    hasRequiredProtocol_linkedEditingRange = 1;
    Object.defineProperty(protocol_linkedEditingRange, "__esModule", { value: true });
    protocol_linkedEditingRange.LinkedEditingRangeRequest = void 0;
    const messages_1 = requireMessages();
    var LinkedEditingRangeRequest;
    (function(LinkedEditingRangeRequest2) {
      LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
    })(LinkedEditingRangeRequest || (protocol_linkedEditingRange.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));
    return protocol_linkedEditingRange;
  }
  var protocol_fileOperations = {};
  var hasRequiredProtocol_fileOperations;
  function requireProtocol_fileOperations() {
    if (hasRequiredProtocol_fileOperations) return protocol_fileOperations;
    hasRequiredProtocol_fileOperations = 1;
    Object.defineProperty(protocol_fileOperations, "__esModule", { value: true });
    protocol_fileOperations.WillDeleteFilesRequest = protocol_fileOperations.DidDeleteFilesNotification = protocol_fileOperations.DidRenameFilesNotification = protocol_fileOperations.WillRenameFilesRequest = protocol_fileOperations.DidCreateFilesNotification = protocol_fileOperations.WillCreateFilesRequest = protocol_fileOperations.FileOperationPatternKind = void 0;
    const messages_1 = requireMessages();
    var FileOperationPatternKind;
    (function(FileOperationPatternKind2) {
      FileOperationPatternKind2.file = "file";
      FileOperationPatternKind2.folder = "folder";
    })(FileOperationPatternKind || (protocol_fileOperations.FileOperationPatternKind = FileOperationPatternKind = {}));
    var WillCreateFilesRequest;
    (function(WillCreateFilesRequest2) {
      WillCreateFilesRequest2.method = "workspace/willCreateFiles";
      WillCreateFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
    })(WillCreateFilesRequest || (protocol_fileOperations.WillCreateFilesRequest = WillCreateFilesRequest = {}));
    var DidCreateFilesNotification;
    (function(DidCreateFilesNotification2) {
      DidCreateFilesNotification2.method = "workspace/didCreateFiles";
      DidCreateFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
    })(DidCreateFilesNotification || (protocol_fileOperations.DidCreateFilesNotification = DidCreateFilesNotification = {}));
    var WillRenameFilesRequest;
    (function(WillRenameFilesRequest2) {
      WillRenameFilesRequest2.method = "workspace/willRenameFiles";
      WillRenameFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
    })(WillRenameFilesRequest || (protocol_fileOperations.WillRenameFilesRequest = WillRenameFilesRequest = {}));
    var DidRenameFilesNotification;
    (function(DidRenameFilesNotification2) {
      DidRenameFilesNotification2.method = "workspace/didRenameFiles";
      DidRenameFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
    })(DidRenameFilesNotification || (protocol_fileOperations.DidRenameFilesNotification = DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification;
    (function(DidDeleteFilesNotification2) {
      DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
    })(DidDeleteFilesNotification || (protocol_fileOperations.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest;
    (function(WillDeleteFilesRequest2) {
      WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
    })(WillDeleteFilesRequest || (protocol_fileOperations.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));
    return protocol_fileOperations;
  }
  var protocol_moniker = {};
  var hasRequiredProtocol_moniker;
  function requireProtocol_moniker() {
    if (hasRequiredProtocol_moniker) return protocol_moniker;
    hasRequiredProtocol_moniker = 1;
    Object.defineProperty(protocol_moniker, "__esModule", { value: true });
    protocol_moniker.MonikerRequest = protocol_moniker.MonikerKind = protocol_moniker.UniquenessLevel = void 0;
    const messages_1 = requireMessages();
    var UniquenessLevel;
    (function(UniquenessLevel2) {
      UniquenessLevel2.document = "document";
      UniquenessLevel2.project = "project";
      UniquenessLevel2.group = "group";
      UniquenessLevel2.scheme = "scheme";
      UniquenessLevel2.global = "global";
    })(UniquenessLevel || (protocol_moniker.UniquenessLevel = UniquenessLevel = {}));
    var MonikerKind;
    (function(MonikerKind2) {
      MonikerKind2.$import = "import";
      MonikerKind2.$export = "export";
      MonikerKind2.local = "local";
    })(MonikerKind || (protocol_moniker.MonikerKind = MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest || (protocol_moniker.MonikerRequest = MonikerRequest = {}));
    return protocol_moniker;
  }
  var protocol_typeHierarchy = {};
  var hasRequiredProtocol_typeHierarchy;
  function requireProtocol_typeHierarchy() {
    if (hasRequiredProtocol_typeHierarchy) return protocol_typeHierarchy;
    hasRequiredProtocol_typeHierarchy = 1;
    Object.defineProperty(protocol_typeHierarchy, "__esModule", { value: true });
    protocol_typeHierarchy.TypeHierarchySubtypesRequest = protocol_typeHierarchy.TypeHierarchySupertypesRequest = protocol_typeHierarchy.TypeHierarchyPrepareRequest = void 0;
    const messages_1 = requireMessages();
    var TypeHierarchyPrepareRequest;
    (function(TypeHierarchyPrepareRequest2) {
      TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
      TypeHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
    })(TypeHierarchyPrepareRequest || (protocol_typeHierarchy.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
    var TypeHierarchySupertypesRequest;
    (function(TypeHierarchySupertypesRequest2) {
      TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
      TypeHierarchySupertypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
    })(TypeHierarchySupertypesRequest || (protocol_typeHierarchy.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
    var TypeHierarchySubtypesRequest;
    (function(TypeHierarchySubtypesRequest2) {
      TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
      TypeHierarchySubtypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
    })(TypeHierarchySubtypesRequest || (protocol_typeHierarchy.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));
    return protocol_typeHierarchy;
  }
  var protocol_inlineValue = {};
  var hasRequiredProtocol_inlineValue;
  function requireProtocol_inlineValue() {
    if (hasRequiredProtocol_inlineValue) return protocol_inlineValue;
    hasRequiredProtocol_inlineValue = 1;
    Object.defineProperty(protocol_inlineValue, "__esModule", { value: true });
    protocol_inlineValue.InlineValueRefreshRequest = protocol_inlineValue.InlineValueRequest = void 0;
    const messages_1 = requireMessages();
    var InlineValueRequest;
    (function(InlineValueRequest2) {
      InlineValueRequest2.method = "textDocument/inlineValue";
      InlineValueRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
    })(InlineValueRequest || (protocol_inlineValue.InlineValueRequest = InlineValueRequest = {}));
    var InlineValueRefreshRequest;
    (function(InlineValueRefreshRequest2) {
      InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
      InlineValueRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
    })(InlineValueRefreshRequest || (protocol_inlineValue.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));
    return protocol_inlineValue;
  }
  var protocol_inlayHint = {};
  var hasRequiredProtocol_inlayHint;
  function requireProtocol_inlayHint() {
    if (hasRequiredProtocol_inlayHint) return protocol_inlayHint;
    hasRequiredProtocol_inlayHint = 1;
    Object.defineProperty(protocol_inlayHint, "__esModule", { value: true });
    protocol_inlayHint.InlayHintRefreshRequest = protocol_inlayHint.InlayHintResolveRequest = protocol_inlayHint.InlayHintRequest = void 0;
    const messages_1 = requireMessages();
    var InlayHintRequest;
    (function(InlayHintRequest2) {
      InlayHintRequest2.method = "textDocument/inlayHint";
      InlayHintRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
    })(InlayHintRequest || (protocol_inlayHint.InlayHintRequest = InlayHintRequest = {}));
    var InlayHintResolveRequest;
    (function(InlayHintResolveRequest2) {
      InlayHintResolveRequest2.method = "inlayHint/resolve";
      InlayHintResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
    })(InlayHintResolveRequest || (protocol_inlayHint.InlayHintResolveRequest = InlayHintResolveRequest = {}));
    var InlayHintRefreshRequest;
    (function(InlayHintRefreshRequest2) {
      InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
      InlayHintRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
    })(InlayHintRefreshRequest || (protocol_inlayHint.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));
    return protocol_inlayHint;
  }
  var protocol_diagnostic = {};
  var hasRequiredProtocol_diagnostic;
  function requireProtocol_diagnostic() {
    if (hasRequiredProtocol_diagnostic) return protocol_diagnostic;
    hasRequiredProtocol_diagnostic = 1;
    Object.defineProperty(protocol_diagnostic, "__esModule", { value: true });
    protocol_diagnostic.DiagnosticRefreshRequest = protocol_diagnostic.WorkspaceDiagnosticRequest = protocol_diagnostic.DocumentDiagnosticRequest = protocol_diagnostic.DocumentDiagnosticReportKind = protocol_diagnostic.DiagnosticServerCancellationData = void 0;
    const vscode_jsonrpc_1 = requireMain$1();
    const Is2 = requireIs();
    const messages_1 = requireMessages();
    var DiagnosticServerCancellationData;
    (function(DiagnosticServerCancellationData2) {
      function is2(value) {
        const candidate = value;
        return candidate && Is2.boolean(candidate.retriggerRequest);
      }
      DiagnosticServerCancellationData2.is = is2;
    })(DiagnosticServerCancellationData || (protocol_diagnostic.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
    var DocumentDiagnosticReportKind;
    (function(DocumentDiagnosticReportKind2) {
      DocumentDiagnosticReportKind2.Full = "full";
      DocumentDiagnosticReportKind2.Unchanged = "unchanged";
    })(DocumentDiagnosticReportKind || (protocol_diagnostic.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));
    var DocumentDiagnosticRequest;
    (function(DocumentDiagnosticRequest2) {
      DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
      DocumentDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
      DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(DocumentDiagnosticRequest || (protocol_diagnostic.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
    var WorkspaceDiagnosticRequest;
    (function(WorkspaceDiagnosticRequest2) {
      WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
      WorkspaceDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
      WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(WorkspaceDiagnosticRequest || (protocol_diagnostic.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
    var DiagnosticRefreshRequest;
    (function(DiagnosticRefreshRequest2) {
      DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
      DiagnosticRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
    })(DiagnosticRefreshRequest || (protocol_diagnostic.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));
    return protocol_diagnostic;
  }
  var protocol_notebook = {};
  var hasRequiredProtocol_notebook;
  function requireProtocol_notebook() {
    if (hasRequiredProtocol_notebook) return protocol_notebook;
    hasRequiredProtocol_notebook = 1;
    Object.defineProperty(protocol_notebook, "__esModule", { value: true });
    protocol_notebook.DidCloseNotebookDocumentNotification = protocol_notebook.DidSaveNotebookDocumentNotification = protocol_notebook.DidChangeNotebookDocumentNotification = protocol_notebook.NotebookCellArrayChange = protocol_notebook.DidOpenNotebookDocumentNotification = protocol_notebook.NotebookDocumentSyncRegistrationType = protocol_notebook.NotebookDocument = protocol_notebook.NotebookCell = protocol_notebook.ExecutionSummary = protocol_notebook.NotebookCellKind = void 0;
    const vscode_languageserver_types_1 = require$$1;
    const Is2 = requireIs();
    const messages_1 = requireMessages();
    var NotebookCellKind;
    (function(NotebookCellKind2) {
      NotebookCellKind2.Markup = 1;
      NotebookCellKind2.Code = 2;
      function is2(value) {
        return value === 1 || value === 2;
      }
      NotebookCellKind2.is = is2;
    })(NotebookCellKind || (protocol_notebook.NotebookCellKind = NotebookCellKind = {}));
    var ExecutionSummary;
    (function(ExecutionSummary2) {
      function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
          result.success = success;
        }
        return result;
      }
      ExecutionSummary2.create = create;
      function is2(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is2.boolean(candidate.success));
      }
      ExecutionSummary2.is = is2;
      function equals(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
      }
      ExecutionSummary2.equals = equals;
    })(ExecutionSummary || (protocol_notebook.ExecutionSummary = ExecutionSummary = {}));
    var NotebookCell;
    (function(NotebookCell2) {
      function create(kind, document2) {
        return { kind, document: document2 };
      }
      NotebookCell2.create = create;
      function is2(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is2.objectLiteral(candidate.metadata));
      }
      NotebookCell2.is = is2;
      function diff(one, two) {
        const result = /* @__PURE__ */ new Set();
        if (one.document !== two.document) {
          result.add("document");
        }
        if (one.kind !== two.kind) {
          result.add("kind");
        }
        if (one.executionSummary !== two.executionSummary) {
          result.add("executionSummary");
        }
        if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
          result.add("metadata");
        }
        if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
          result.add("executionSummary");
        }
        return result;
      }
      NotebookCell2.diff = diff;
      function equalsMetadata(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one !== typeof other) {
          return false;
        }
        if (typeof one !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one.length; i++) {
            if (!equalsMetadata(one[i], other[i])) {
              return false;
            }
          }
        }
        if (Is2.objectLiteral(one) && Is2.objectLiteral(other)) {
          const oneKeys = Object.keys(one);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop = oneKeys[i];
            if (!equalsMetadata(one[prop], other[prop])) {
              return false;
            }
          }
        }
        return true;
      }
    })(NotebookCell || (protocol_notebook.NotebookCell = NotebookCell = {}));
    var NotebookDocument;
    (function(NotebookDocument2) {
      function create(uri, notebookType, version, cells) {
        return { uri, notebookType, version, cells };
      }
      NotebookDocument2.create = create;
      function is2(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && Is2.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is2.typedArray(candidate.cells, NotebookCell.is);
      }
      NotebookDocument2.is = is2;
    })(NotebookDocument || (protocol_notebook.NotebookDocument = NotebookDocument = {}));
    var NotebookDocumentSyncRegistrationType;
    (function(NotebookDocumentSyncRegistrationType2) {
      NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
      NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
      NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
    })(NotebookDocumentSyncRegistrationType || (protocol_notebook.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
    var DidOpenNotebookDocumentNotification;
    (function(DidOpenNotebookDocumentNotification2) {
      DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
      DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
      DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidOpenNotebookDocumentNotification || (protocol_notebook.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
    var NotebookCellArrayChange;
    (function(NotebookCellArrayChange2) {
      function is2(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is2.typedArray(candidate.cells, NotebookCell.is));
      }
      NotebookCellArrayChange2.is = is2;
      function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== void 0) {
          result.cells = cells;
        }
        return result;
      }
      NotebookCellArrayChange2.create = create;
    })(NotebookCellArrayChange || (protocol_notebook.NotebookCellArrayChange = NotebookCellArrayChange = {}));
    var DidChangeNotebookDocumentNotification;
    (function(DidChangeNotebookDocumentNotification2) {
      DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
      DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
      DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidChangeNotebookDocumentNotification || (protocol_notebook.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
    var DidSaveNotebookDocumentNotification;
    (function(DidSaveNotebookDocumentNotification2) {
      DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
      DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
      DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidSaveNotebookDocumentNotification || (protocol_notebook.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
    var DidCloseNotebookDocumentNotification;
    (function(DidCloseNotebookDocumentNotification2) {
      DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
      DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
      DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidCloseNotebookDocumentNotification || (protocol_notebook.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
    return protocol_notebook;
  }
  var protocol_inlineCompletion = {};
  var hasRequiredProtocol_inlineCompletion;
  function requireProtocol_inlineCompletion() {
    if (hasRequiredProtocol_inlineCompletion) return protocol_inlineCompletion;
    hasRequiredProtocol_inlineCompletion = 1;
    Object.defineProperty(protocol_inlineCompletion, "__esModule", { value: true });
    protocol_inlineCompletion.InlineCompletionRequest = void 0;
    const messages_1 = requireMessages();
    var InlineCompletionRequest;
    (function(InlineCompletionRequest2) {
      InlineCompletionRequest2.method = "textDocument/inlineCompletion";
      InlineCompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineCompletionRequest2.type = new messages_1.ProtocolRequestType(InlineCompletionRequest2.method);
    })(InlineCompletionRequest || (protocol_inlineCompletion.InlineCompletionRequest = InlineCompletionRequest = {}));
    return protocol_inlineCompletion;
  }
  var hasRequiredProtocol;
  function requireProtocol() {
    if (hasRequiredProtocol) return protocol;
    hasRequiredProtocol = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.WorkspaceSymbolRequest = exports$1.CodeActionResolveRequest = exports$1.CodeActionRequest = exports$1.DocumentSymbolRequest = exports$1.DocumentHighlightRequest = exports$1.ReferencesRequest = exports$1.DefinitionRequest = exports$1.SignatureHelpRequest = exports$1.SignatureHelpTriggerKind = exports$1.HoverRequest = exports$1.CompletionResolveRequest = exports$1.CompletionRequest = exports$1.CompletionTriggerKind = exports$1.PublishDiagnosticsNotification = exports$1.WatchKind = exports$1.RelativePattern = exports$1.FileChangeType = exports$1.DidChangeWatchedFilesNotification = exports$1.WillSaveTextDocumentWaitUntilRequest = exports$1.WillSaveTextDocumentNotification = exports$1.TextDocumentSaveReason = exports$1.DidSaveTextDocumentNotification = exports$1.DidCloseTextDocumentNotification = exports$1.DidChangeTextDocumentNotification = exports$1.TextDocumentContentChangeEvent = exports$1.DidOpenTextDocumentNotification = exports$1.TextDocumentSyncKind = exports$1.TelemetryEventNotification = exports$1.LogMessageNotification = exports$1.ShowMessageRequest = exports$1.ShowMessageNotification = exports$1.MessageType = exports$1.DidChangeConfigurationNotification = exports$1.ExitNotification = exports$1.ShutdownRequest = exports$1.InitializedNotification = exports$1.InitializeErrorCodes = exports$1.InitializeRequest = exports$1.WorkDoneProgressOptions = exports$1.TextDocumentRegistrationOptions = exports$1.StaticRegistrationOptions = exports$1.PositionEncodingKind = exports$1.FailureHandlingKind = exports$1.ResourceOperationKind = exports$1.UnregistrationRequest = exports$1.RegistrationRequest = exports$1.DocumentSelector = exports$1.NotebookCellTextDocumentFilter = exports$1.NotebookDocumentFilter = exports$1.TextDocumentFilter = void 0;
      exports$1.MonikerRequest = exports$1.MonikerKind = exports$1.UniquenessLevel = exports$1.WillDeleteFilesRequest = exports$1.DidDeleteFilesNotification = exports$1.WillRenameFilesRequest = exports$1.DidRenameFilesNotification = exports$1.WillCreateFilesRequest = exports$1.DidCreateFilesNotification = exports$1.FileOperationPatternKind = exports$1.LinkedEditingRangeRequest = exports$1.ShowDocumentRequest = exports$1.SemanticTokensRegistrationType = exports$1.SemanticTokensRefreshRequest = exports$1.SemanticTokensRangeRequest = exports$1.SemanticTokensDeltaRequest = exports$1.SemanticTokensRequest = exports$1.TokenFormat = exports$1.CallHierarchyPrepareRequest = exports$1.CallHierarchyOutgoingCallsRequest = exports$1.CallHierarchyIncomingCallsRequest = exports$1.WorkDoneProgressCancelNotification = exports$1.WorkDoneProgressCreateRequest = exports$1.WorkDoneProgress = exports$1.SelectionRangeRequest = exports$1.DeclarationRequest = exports$1.FoldingRangeRefreshRequest = exports$1.FoldingRangeRequest = exports$1.ColorPresentationRequest = exports$1.DocumentColorRequest = exports$1.ConfigurationRequest = exports$1.DidChangeWorkspaceFoldersNotification = exports$1.WorkspaceFoldersRequest = exports$1.TypeDefinitionRequest = exports$1.ImplementationRequest = exports$1.ApplyWorkspaceEditRequest = exports$1.ExecuteCommandRequest = exports$1.PrepareRenameRequest = exports$1.RenameRequest = exports$1.PrepareSupportDefaultBehavior = exports$1.DocumentOnTypeFormattingRequest = exports$1.DocumentRangesFormattingRequest = exports$1.DocumentRangeFormattingRequest = exports$1.DocumentFormattingRequest = exports$1.DocumentLinkResolveRequest = exports$1.DocumentLinkRequest = exports$1.CodeLensRefreshRequest = exports$1.CodeLensResolveRequest = exports$1.CodeLensRequest = exports$1.WorkspaceSymbolResolveRequest = void 0;
      exports$1.InlineCompletionRequest = exports$1.DidCloseNotebookDocumentNotification = exports$1.DidSaveNotebookDocumentNotification = exports$1.DidChangeNotebookDocumentNotification = exports$1.NotebookCellArrayChange = exports$1.DidOpenNotebookDocumentNotification = exports$1.NotebookDocumentSyncRegistrationType = exports$1.NotebookDocument = exports$1.NotebookCell = exports$1.ExecutionSummary = exports$1.NotebookCellKind = exports$1.DiagnosticRefreshRequest = exports$1.WorkspaceDiagnosticRequest = exports$1.DocumentDiagnosticRequest = exports$1.DocumentDiagnosticReportKind = exports$1.DiagnosticServerCancellationData = exports$1.InlayHintRefreshRequest = exports$1.InlayHintResolveRequest = exports$1.InlayHintRequest = exports$1.InlineValueRefreshRequest = exports$1.InlineValueRequest = exports$1.TypeHierarchySupertypesRequest = exports$1.TypeHierarchySubtypesRequest = exports$1.TypeHierarchyPrepareRequest = void 0;
      const messages_1 = requireMessages();
      const vscode_languageserver_types_1 = require$$1;
      const Is2 = requireIs();
      const protocol_implementation_1 = requireProtocol_implementation();
      Object.defineProperty(exports$1, "ImplementationRequest", { enumerable: true, get: function() {
        return protocol_implementation_1.ImplementationRequest;
      } });
      const protocol_typeDefinition_1 = requireProtocol_typeDefinition();
      Object.defineProperty(exports$1, "TypeDefinitionRequest", { enumerable: true, get: function() {
        return protocol_typeDefinition_1.TypeDefinitionRequest;
      } });
      const protocol_workspaceFolder_1 = requireProtocol_workspaceFolder();
      Object.defineProperty(exports$1, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
        return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
      } });
      Object.defineProperty(exports$1, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
        return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
      } });
      const protocol_configuration_1 = requireProtocol_configuration();
      Object.defineProperty(exports$1, "ConfigurationRequest", { enumerable: true, get: function() {
        return protocol_configuration_1.ConfigurationRequest;
      } });
      const protocol_colorProvider_1 = requireProtocol_colorProvider();
      Object.defineProperty(exports$1, "DocumentColorRequest", { enumerable: true, get: function() {
        return protocol_colorProvider_1.DocumentColorRequest;
      } });
      Object.defineProperty(exports$1, "ColorPresentationRequest", { enumerable: true, get: function() {
        return protocol_colorProvider_1.ColorPresentationRequest;
      } });
      const protocol_foldingRange_1 = requireProtocol_foldingRange();
      Object.defineProperty(exports$1, "FoldingRangeRequest", { enumerable: true, get: function() {
        return protocol_foldingRange_1.FoldingRangeRequest;
      } });
      Object.defineProperty(exports$1, "FoldingRangeRefreshRequest", { enumerable: true, get: function() {
        return protocol_foldingRange_1.FoldingRangeRefreshRequest;
      } });
      const protocol_declaration_1 = requireProtocol_declaration();
      Object.defineProperty(exports$1, "DeclarationRequest", { enumerable: true, get: function() {
        return protocol_declaration_1.DeclarationRequest;
      } });
      const protocol_selectionRange_1 = requireProtocol_selectionRange();
      Object.defineProperty(exports$1, "SelectionRangeRequest", { enumerable: true, get: function() {
        return protocol_selectionRange_1.SelectionRangeRequest;
      } });
      const protocol_progress_1 = requireProtocol_progress();
      Object.defineProperty(exports$1, "WorkDoneProgress", { enumerable: true, get: function() {
        return protocol_progress_1.WorkDoneProgress;
      } });
      Object.defineProperty(exports$1, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
        return protocol_progress_1.WorkDoneProgressCreateRequest;
      } });
      Object.defineProperty(exports$1, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
        return protocol_progress_1.WorkDoneProgressCancelNotification;
      } });
      const protocol_callHierarchy_1 = requireProtocol_callHierarchy();
      Object.defineProperty(exports$1, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
        return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
      } });
      Object.defineProperty(exports$1, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
        return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
      } });
      Object.defineProperty(exports$1, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
        return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
      } });
      const protocol_semanticTokens_1 = requireProtocol_semanticTokens();
      Object.defineProperty(exports$1, "TokenFormat", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.TokenFormat;
      } });
      Object.defineProperty(exports$1, "SemanticTokensRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRequest;
      } });
      Object.defineProperty(exports$1, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
      } });
      Object.defineProperty(exports$1, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRangeRequest;
      } });
      Object.defineProperty(exports$1, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
      } });
      Object.defineProperty(exports$1, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRegistrationType;
      } });
      const protocol_showDocument_1 = requireProtocol_showDocument();
      Object.defineProperty(exports$1, "ShowDocumentRequest", { enumerable: true, get: function() {
        return protocol_showDocument_1.ShowDocumentRequest;
      } });
      const protocol_linkedEditingRange_1 = requireProtocol_linkedEditingRange();
      Object.defineProperty(exports$1, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
        return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
      } });
      const protocol_fileOperations_1 = requireProtocol_fileOperations();
      Object.defineProperty(exports$1, "FileOperationPatternKind", { enumerable: true, get: function() {
        return protocol_fileOperations_1.FileOperationPatternKind;
      } });
      Object.defineProperty(exports$1, "DidCreateFilesNotification", { enumerable: true, get: function() {
        return protocol_fileOperations_1.DidCreateFilesNotification;
      } });
      Object.defineProperty(exports$1, "WillCreateFilesRequest", { enumerable: true, get: function() {
        return protocol_fileOperations_1.WillCreateFilesRequest;
      } });
      Object.defineProperty(exports$1, "DidRenameFilesNotification", { enumerable: true, get: function() {
        return protocol_fileOperations_1.DidRenameFilesNotification;
      } });
      Object.defineProperty(exports$1, "WillRenameFilesRequest", { enumerable: true, get: function() {
        return protocol_fileOperations_1.WillRenameFilesRequest;
      } });
      Object.defineProperty(exports$1, "DidDeleteFilesNotification", { enumerable: true, get: function() {
        return protocol_fileOperations_1.DidDeleteFilesNotification;
      } });
      Object.defineProperty(exports$1, "WillDeleteFilesRequest", { enumerable: true, get: function() {
        return protocol_fileOperations_1.WillDeleteFilesRequest;
      } });
      const protocol_moniker_1 = requireProtocol_moniker();
      Object.defineProperty(exports$1, "UniquenessLevel", { enumerable: true, get: function() {
        return protocol_moniker_1.UniquenessLevel;
      } });
      Object.defineProperty(exports$1, "MonikerKind", { enumerable: true, get: function() {
        return protocol_moniker_1.MonikerKind;
      } });
      Object.defineProperty(exports$1, "MonikerRequest", { enumerable: true, get: function() {
        return protocol_moniker_1.MonikerRequest;
      } });
      const protocol_typeHierarchy_1 = requireProtocol_typeHierarchy();
      Object.defineProperty(exports$1, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
        return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
      } });
      Object.defineProperty(exports$1, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
        return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
      } });
      Object.defineProperty(exports$1, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
        return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
      } });
      const protocol_inlineValue_1 = requireProtocol_inlineValue();
      Object.defineProperty(exports$1, "InlineValueRequest", { enumerable: true, get: function() {
        return protocol_inlineValue_1.InlineValueRequest;
      } });
      Object.defineProperty(exports$1, "InlineValueRefreshRequest", { enumerable: true, get: function() {
        return protocol_inlineValue_1.InlineValueRefreshRequest;
      } });
      const protocol_inlayHint_1 = requireProtocol_inlayHint();
      Object.defineProperty(exports$1, "InlayHintRequest", { enumerable: true, get: function() {
        return protocol_inlayHint_1.InlayHintRequest;
      } });
      Object.defineProperty(exports$1, "InlayHintResolveRequest", { enumerable: true, get: function() {
        return protocol_inlayHint_1.InlayHintResolveRequest;
      } });
      Object.defineProperty(exports$1, "InlayHintRefreshRequest", { enumerable: true, get: function() {
        return protocol_inlayHint_1.InlayHintRefreshRequest;
      } });
      const protocol_diagnostic_1 = requireProtocol_diagnostic();
      Object.defineProperty(exports$1, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DiagnosticServerCancellationData;
      } });
      Object.defineProperty(exports$1, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DocumentDiagnosticReportKind;
      } });
      Object.defineProperty(exports$1, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DocumentDiagnosticRequest;
      } });
      Object.defineProperty(exports$1, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
        return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
      } });
      Object.defineProperty(exports$1, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DiagnosticRefreshRequest;
      } });
      const protocol_notebook_1 = requireProtocol_notebook();
      Object.defineProperty(exports$1, "NotebookCellKind", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookCellKind;
      } });
      Object.defineProperty(exports$1, "ExecutionSummary", { enumerable: true, get: function() {
        return protocol_notebook_1.ExecutionSummary;
      } });
      Object.defineProperty(exports$1, "NotebookCell", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookCell;
      } });
      Object.defineProperty(exports$1, "NotebookDocument", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookDocument;
      } });
      Object.defineProperty(exports$1, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
      } });
      Object.defineProperty(exports$1, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidOpenNotebookDocumentNotification;
      } });
      Object.defineProperty(exports$1, "NotebookCellArrayChange", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookCellArrayChange;
      } });
      Object.defineProperty(exports$1, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidChangeNotebookDocumentNotification;
      } });
      Object.defineProperty(exports$1, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidSaveNotebookDocumentNotification;
      } });
      Object.defineProperty(exports$1, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidCloseNotebookDocumentNotification;
      } });
      const protocol_inlineCompletion_1 = requireProtocol_inlineCompletion();
      Object.defineProperty(exports$1, "InlineCompletionRequest", { enumerable: true, get: function() {
        return protocol_inlineCompletion_1.InlineCompletionRequest;
      } });
      var TextDocumentFilter;
      (function(TextDocumentFilter2) {
        function is2(value) {
          const candidate = value;
          return Is2.string(candidate) || (Is2.string(candidate.language) || Is2.string(candidate.scheme) || Is2.string(candidate.pattern));
        }
        TextDocumentFilter2.is = is2;
      })(TextDocumentFilter || (exports$1.TextDocumentFilter = TextDocumentFilter = {}));
      var NotebookDocumentFilter;
      (function(NotebookDocumentFilter2) {
        function is2(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && (Is2.string(candidate.notebookType) || Is2.string(candidate.scheme) || Is2.string(candidate.pattern));
        }
        NotebookDocumentFilter2.is = is2;
      })(NotebookDocumentFilter || (exports$1.NotebookDocumentFilter = NotebookDocumentFilter = {}));
      var NotebookCellTextDocumentFilter;
      (function(NotebookCellTextDocumentFilter2) {
        function is2(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && (Is2.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is2.string(candidate.language));
        }
        NotebookCellTextDocumentFilter2.is = is2;
      })(NotebookCellTextDocumentFilter || (exports$1.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
      var DocumentSelector;
      (function(DocumentSelector2) {
        function is2(value) {
          if (!Array.isArray(value)) {
            return false;
          }
          for (let elem of value) {
            if (!Is2.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
              return false;
            }
          }
          return true;
        }
        DocumentSelector2.is = is2;
      })(DocumentSelector || (exports$1.DocumentSelector = DocumentSelector = {}));
      var RegistrationRequest;
      (function(RegistrationRequest2) {
        RegistrationRequest2.method = "client/registerCapability";
        RegistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        RegistrationRequest2.type = new messages_1.ProtocolRequestType(RegistrationRequest2.method);
      })(RegistrationRequest || (exports$1.RegistrationRequest = RegistrationRequest = {}));
      var UnregistrationRequest;
      (function(UnregistrationRequest2) {
        UnregistrationRequest2.method = "client/unregisterCapability";
        UnregistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        UnregistrationRequest2.type = new messages_1.ProtocolRequestType(UnregistrationRequest2.method);
      })(UnregistrationRequest || (exports$1.UnregistrationRequest = UnregistrationRequest = {}));
      var ResourceOperationKind;
      (function(ResourceOperationKind2) {
        ResourceOperationKind2.Create = "create";
        ResourceOperationKind2.Rename = "rename";
        ResourceOperationKind2.Delete = "delete";
      })(ResourceOperationKind || (exports$1.ResourceOperationKind = ResourceOperationKind = {}));
      var FailureHandlingKind;
      (function(FailureHandlingKind2) {
        FailureHandlingKind2.Abort = "abort";
        FailureHandlingKind2.Transactional = "transactional";
        FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
        FailureHandlingKind2.Undo = "undo";
      })(FailureHandlingKind || (exports$1.FailureHandlingKind = FailureHandlingKind = {}));
      var PositionEncodingKind;
      (function(PositionEncodingKind2) {
        PositionEncodingKind2.UTF8 = "utf-8";
        PositionEncodingKind2.UTF16 = "utf-16";
        PositionEncodingKind2.UTF32 = "utf-32";
      })(PositionEncodingKind || (exports$1.PositionEncodingKind = PositionEncodingKind = {}));
      var StaticRegistrationOptions;
      (function(StaticRegistrationOptions2) {
        function hasId(value) {
          const candidate = value;
          return candidate && Is2.string(candidate.id) && candidate.id.length > 0;
        }
        StaticRegistrationOptions2.hasId = hasId;
      })(StaticRegistrationOptions || (exports$1.StaticRegistrationOptions = StaticRegistrationOptions = {}));
      var TextDocumentRegistrationOptions;
      (function(TextDocumentRegistrationOptions2) {
        function is2(value) {
          const candidate = value;
          return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
        }
        TextDocumentRegistrationOptions2.is = is2;
      })(TextDocumentRegistrationOptions || (exports$1.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
      var WorkDoneProgressOptions;
      (function(WorkDoneProgressOptions2) {
        function is2(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is2.boolean(candidate.workDoneProgress));
        }
        WorkDoneProgressOptions2.is = is2;
        function hasWorkDoneProgress(value) {
          const candidate = value;
          return candidate && Is2.boolean(candidate.workDoneProgress);
        }
        WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
      })(WorkDoneProgressOptions || (exports$1.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
      var InitializeRequest;
      (function(InitializeRequest2) {
        InitializeRequest2.method = "initialize";
        InitializeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InitializeRequest2.type = new messages_1.ProtocolRequestType(InitializeRequest2.method);
      })(InitializeRequest || (exports$1.InitializeRequest = InitializeRequest = {}));
      var InitializeErrorCodes;
      (function(InitializeErrorCodes2) {
        InitializeErrorCodes2.unknownProtocolVersion = 1;
      })(InitializeErrorCodes || (exports$1.InitializeErrorCodes = InitializeErrorCodes = {}));
      var InitializedNotification;
      (function(InitializedNotification2) {
        InitializedNotification2.method = "initialized";
        InitializedNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        InitializedNotification2.type = new messages_1.ProtocolNotificationType(InitializedNotification2.method);
      })(InitializedNotification || (exports$1.InitializedNotification = InitializedNotification = {}));
      var ShutdownRequest;
      (function(ShutdownRequest2) {
        ShutdownRequest2.method = "shutdown";
        ShutdownRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ShutdownRequest2.type = new messages_1.ProtocolRequestType0(ShutdownRequest2.method);
      })(ShutdownRequest || (exports$1.ShutdownRequest = ShutdownRequest = {}));
      var ExitNotification;
      (function(ExitNotification2) {
        ExitNotification2.method = "exit";
        ExitNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        ExitNotification2.type = new messages_1.ProtocolNotificationType0(ExitNotification2.method);
      })(ExitNotification || (exports$1.ExitNotification = ExitNotification = {}));
      var DidChangeConfigurationNotification;
      (function(DidChangeConfigurationNotification2) {
        DidChangeConfigurationNotification2.method = "workspace/didChangeConfiguration";
        DidChangeConfigurationNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification2.method);
      })(DidChangeConfigurationNotification || (exports$1.DidChangeConfigurationNotification = DidChangeConfigurationNotification = {}));
      var MessageType2;
      (function(MessageType3) {
        MessageType3.Error = 1;
        MessageType3.Warning = 2;
        MessageType3.Info = 3;
        MessageType3.Log = 4;
        MessageType3.Debug = 5;
      })(MessageType2 || (exports$1.MessageType = MessageType2 = {}));
      var ShowMessageNotification;
      (function(ShowMessageNotification2) {
        ShowMessageNotification2.method = "window/showMessage";
        ShowMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        ShowMessageNotification2.type = new messages_1.ProtocolNotificationType(ShowMessageNotification2.method);
      })(ShowMessageNotification || (exports$1.ShowMessageNotification = ShowMessageNotification = {}));
      var ShowMessageRequest;
      (function(ShowMessageRequest2) {
        ShowMessageRequest2.method = "window/showMessageRequest";
        ShowMessageRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        ShowMessageRequest2.type = new messages_1.ProtocolRequestType(ShowMessageRequest2.method);
      })(ShowMessageRequest || (exports$1.ShowMessageRequest = ShowMessageRequest = {}));
      var LogMessageNotification;
      (function(LogMessageNotification2) {
        LogMessageNotification2.method = "window/logMessage";
        LogMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        LogMessageNotification2.type = new messages_1.ProtocolNotificationType(LogMessageNotification2.method);
      })(LogMessageNotification || (exports$1.LogMessageNotification = LogMessageNotification = {}));
      var TelemetryEventNotification;
      (function(TelemetryEventNotification2) {
        TelemetryEventNotification2.method = "telemetry/event";
        TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
      })(TelemetryEventNotification || (exports$1.TelemetryEventNotification = TelemetryEventNotification = {}));
      var TextDocumentSyncKind;
      (function(TextDocumentSyncKind2) {
        TextDocumentSyncKind2.None = 0;
        TextDocumentSyncKind2.Full = 1;
        TextDocumentSyncKind2.Incremental = 2;
      })(TextDocumentSyncKind || (exports$1.TextDocumentSyncKind = TextDocumentSyncKind = {}));
      var DidOpenTextDocumentNotification;
      (function(DidOpenTextDocumentNotification2) {
        DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
        DidOpenTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
      })(DidOpenTextDocumentNotification || (exports$1.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
      var TextDocumentContentChangeEvent;
      (function(TextDocumentContentChangeEvent2) {
        function isIncremental(event) {
          let candidate = event;
          return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
        }
        TextDocumentContentChangeEvent2.isIncremental = isIncremental;
        function isFull(event) {
          let candidate = event;
          return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
        }
        TextDocumentContentChangeEvent2.isFull = isFull;
      })(TextDocumentContentChangeEvent || (exports$1.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
      var DidChangeTextDocumentNotification;
      (function(DidChangeTextDocumentNotification2) {
        DidChangeTextDocumentNotification2.method = "textDocument/didChange";
        DidChangeTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
      })(DidChangeTextDocumentNotification || (exports$1.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
      var DidCloseTextDocumentNotification;
      (function(DidCloseTextDocumentNotification2) {
        DidCloseTextDocumentNotification2.method = "textDocument/didClose";
        DidCloseTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
      })(DidCloseTextDocumentNotification || (exports$1.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
      var DidSaveTextDocumentNotification;
      (function(DidSaveTextDocumentNotification2) {
        DidSaveTextDocumentNotification2.method = "textDocument/didSave";
        DidSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
      })(DidSaveTextDocumentNotification || (exports$1.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
      var TextDocumentSaveReason;
      (function(TextDocumentSaveReason2) {
        TextDocumentSaveReason2.Manual = 1;
        TextDocumentSaveReason2.AfterDelay = 2;
        TextDocumentSaveReason2.FocusOut = 3;
      })(TextDocumentSaveReason || (exports$1.TextDocumentSaveReason = TextDocumentSaveReason = {}));
      var WillSaveTextDocumentNotification;
      (function(WillSaveTextDocumentNotification2) {
        WillSaveTextDocumentNotification2.method = "textDocument/willSave";
        WillSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
      })(WillSaveTextDocumentNotification || (exports$1.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
      var WillSaveTextDocumentWaitUntilRequest;
      (function(WillSaveTextDocumentWaitUntilRequest2) {
        WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
        WillSaveTextDocumentWaitUntilRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
      })(WillSaveTextDocumentWaitUntilRequest || (exports$1.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
      var DidChangeWatchedFilesNotification;
      (function(DidChangeWatchedFilesNotification2) {
        DidChangeWatchedFilesNotification2.method = "workspace/didChangeWatchedFiles";
        DidChangeWatchedFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification2.method);
      })(DidChangeWatchedFilesNotification || (exports$1.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));
      var FileChangeType;
      (function(FileChangeType2) {
        FileChangeType2.Created = 1;
        FileChangeType2.Changed = 2;
        FileChangeType2.Deleted = 3;
      })(FileChangeType || (exports$1.FileChangeType = FileChangeType = {}));
      var RelativePattern;
      (function(RelativePattern2) {
        function is2(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is2.string(candidate.pattern);
        }
        RelativePattern2.is = is2;
      })(RelativePattern || (exports$1.RelativePattern = RelativePattern = {}));
      var WatchKind;
      (function(WatchKind2) {
        WatchKind2.Create = 1;
        WatchKind2.Change = 2;
        WatchKind2.Delete = 4;
      })(WatchKind || (exports$1.WatchKind = WatchKind = {}));
      var PublishDiagnosticsNotification;
      (function(PublishDiagnosticsNotification2) {
        PublishDiagnosticsNotification2.method = "textDocument/publishDiagnostics";
        PublishDiagnosticsNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification2.method);
      })(PublishDiagnosticsNotification || (exports$1.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
      var CompletionTriggerKind;
      (function(CompletionTriggerKind2) {
        CompletionTriggerKind2.Invoked = 1;
        CompletionTriggerKind2.TriggerCharacter = 2;
        CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
      })(CompletionTriggerKind || (exports$1.CompletionTriggerKind = CompletionTriggerKind = {}));
      var CompletionRequest;
      (function(CompletionRequest2) {
        CompletionRequest2.method = "textDocument/completion";
        CompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
      })(CompletionRequest || (exports$1.CompletionRequest = CompletionRequest = {}));
      var CompletionResolveRequest;
      (function(CompletionResolveRequest2) {
        CompletionResolveRequest2.method = "completionItem/resolve";
        CompletionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
      })(CompletionResolveRequest || (exports$1.CompletionResolveRequest = CompletionResolveRequest = {}));
      var HoverRequest;
      (function(HoverRequest2) {
        HoverRequest2.method = "textDocument/hover";
        HoverRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
      })(HoverRequest || (exports$1.HoverRequest = HoverRequest = {}));
      var SignatureHelpTriggerKind;
      (function(SignatureHelpTriggerKind2) {
        SignatureHelpTriggerKind2.Invoked = 1;
        SignatureHelpTriggerKind2.TriggerCharacter = 2;
        SignatureHelpTriggerKind2.ContentChange = 3;
      })(SignatureHelpTriggerKind || (exports$1.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
      var SignatureHelpRequest;
      (function(SignatureHelpRequest2) {
        SignatureHelpRequest2.method = "textDocument/signatureHelp";
        SignatureHelpRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
      })(SignatureHelpRequest || (exports$1.SignatureHelpRequest = SignatureHelpRequest = {}));
      var DefinitionRequest;
      (function(DefinitionRequest2) {
        DefinitionRequest2.method = "textDocument/definition";
        DefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
      })(DefinitionRequest || (exports$1.DefinitionRequest = DefinitionRequest = {}));
      var ReferencesRequest;
      (function(ReferencesRequest2) {
        ReferencesRequest2.method = "textDocument/references";
        ReferencesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
      })(ReferencesRequest || (exports$1.ReferencesRequest = ReferencesRequest = {}));
      var DocumentHighlightRequest;
      (function(DocumentHighlightRequest2) {
        DocumentHighlightRequest2.method = "textDocument/documentHighlight";
        DocumentHighlightRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
      })(DocumentHighlightRequest || (exports$1.DocumentHighlightRequest = DocumentHighlightRequest = {}));
      var DocumentSymbolRequest;
      (function(DocumentSymbolRequest2) {
        DocumentSymbolRequest2.method = "textDocument/documentSymbol";
        DocumentSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
      })(DocumentSymbolRequest || (exports$1.DocumentSymbolRequest = DocumentSymbolRequest = {}));
      var CodeActionRequest;
      (function(CodeActionRequest2) {
        CodeActionRequest2.method = "textDocument/codeAction";
        CodeActionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
      })(CodeActionRequest || (exports$1.CodeActionRequest = CodeActionRequest = {}));
      var CodeActionResolveRequest;
      (function(CodeActionResolveRequest2) {
        CodeActionResolveRequest2.method = "codeAction/resolve";
        CodeActionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
      })(CodeActionResolveRequest || (exports$1.CodeActionResolveRequest = CodeActionResolveRequest = {}));
      var WorkspaceSymbolRequest;
      (function(WorkspaceSymbolRequest2) {
        WorkspaceSymbolRequest2.method = "workspace/symbol";
        WorkspaceSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
      })(WorkspaceSymbolRequest || (exports$1.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
      var WorkspaceSymbolResolveRequest;
      (function(WorkspaceSymbolResolveRequest2) {
        WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
        WorkspaceSymbolResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
      })(WorkspaceSymbolResolveRequest || (exports$1.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
      var CodeLensRequest;
      (function(CodeLensRequest2) {
        CodeLensRequest2.method = "textDocument/codeLens";
        CodeLensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
      })(CodeLensRequest || (exports$1.CodeLensRequest = CodeLensRequest = {}));
      var CodeLensResolveRequest;
      (function(CodeLensResolveRequest2) {
        CodeLensResolveRequest2.method = "codeLens/resolve";
        CodeLensResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
      })(CodeLensResolveRequest || (exports$1.CodeLensResolveRequest = CodeLensResolveRequest = {}));
      var CodeLensRefreshRequest;
      (function(CodeLensRefreshRequest2) {
        CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
        CodeLensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
      })(CodeLensRefreshRequest || (exports$1.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
      var DocumentLinkRequest;
      (function(DocumentLinkRequest2) {
        DocumentLinkRequest2.method = "textDocument/documentLink";
        DocumentLinkRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
      })(DocumentLinkRequest || (exports$1.DocumentLinkRequest = DocumentLinkRequest = {}));
      var DocumentLinkResolveRequest;
      (function(DocumentLinkResolveRequest2) {
        DocumentLinkResolveRequest2.method = "documentLink/resolve";
        DocumentLinkResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
      })(DocumentLinkResolveRequest || (exports$1.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
      var DocumentFormattingRequest;
      (function(DocumentFormattingRequest2) {
        DocumentFormattingRequest2.method = "textDocument/formatting";
        DocumentFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
      })(DocumentFormattingRequest || (exports$1.DocumentFormattingRequest = DocumentFormattingRequest = {}));
      var DocumentRangeFormattingRequest;
      (function(DocumentRangeFormattingRequest2) {
        DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
        DocumentRangeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
      })(DocumentRangeFormattingRequest || (exports$1.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
      var DocumentRangesFormattingRequest;
      (function(DocumentRangesFormattingRequest2) {
        DocumentRangesFormattingRequest2.method = "textDocument/rangesFormatting";
        DocumentRangesFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentRangesFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest2.method);
      })(DocumentRangesFormattingRequest || (exports$1.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
      var DocumentOnTypeFormattingRequest;
      (function(DocumentOnTypeFormattingRequest2) {
        DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
        DocumentOnTypeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
      })(DocumentOnTypeFormattingRequest || (exports$1.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
      var PrepareSupportDefaultBehavior;
      (function(PrepareSupportDefaultBehavior2) {
        PrepareSupportDefaultBehavior2.Identifier = 1;
      })(PrepareSupportDefaultBehavior || (exports$1.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
      var RenameRequest;
      (function(RenameRequest2) {
        RenameRequest2.method = "textDocument/rename";
        RenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
      })(RenameRequest || (exports$1.RenameRequest = RenameRequest = {}));
      var PrepareRenameRequest;
      (function(PrepareRenameRequest2) {
        PrepareRenameRequest2.method = "textDocument/prepareRename";
        PrepareRenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
      })(PrepareRenameRequest || (exports$1.PrepareRenameRequest = PrepareRenameRequest = {}));
      var ExecuteCommandRequest;
      (function(ExecuteCommandRequest2) {
        ExecuteCommandRequest2.method = "workspace/executeCommand";
        ExecuteCommandRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest2.method);
      })(ExecuteCommandRequest || (exports$1.ExecuteCommandRequest = ExecuteCommandRequest = {}));
      var ApplyWorkspaceEditRequest;
      (function(ApplyWorkspaceEditRequest2) {
        ApplyWorkspaceEditRequest2.method = "workspace/applyEdit";
        ApplyWorkspaceEditRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
      })(ApplyWorkspaceEditRequest || (exports$1.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));
    })(protocol);
    return protocol;
  }
  var connection = {};
  var hasRequiredConnection;
  function requireConnection() {
    if (hasRequiredConnection) return connection;
    hasRequiredConnection = 1;
    Object.defineProperty(connection, "__esModule", { value: true });
    connection.createProtocolConnection = void 0;
    const vscode_jsonrpc_1 = requireMain$1();
    function createProtocolConnection(input, output, logger, options) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
    }
    connection.createProtocolConnection = createProtocolConnection;
    return connection;
  }
  var hasRequiredApi;
  function requireApi() {
    if (hasRequiredApi) return api;
    hasRequiredApi = 1;
    (function(exports$1) {
      var __createBinding = api && api.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = api && api.__exportStar || function(m, exports$12) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
      };
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.LSPErrorCodes = exports$1.createProtocolConnection = void 0;
      __exportStar(requireMain$1(), exports$1);
      __exportStar(require$$1, exports$1);
      __exportStar(requireMessages(), exports$1);
      __exportStar(requireProtocol(), exports$1);
      var connection_1 = requireConnection();
      Object.defineProperty(exports$1, "createProtocolConnection", { enumerable: true, get: function() {
        return connection_1.createProtocolConnection;
      } });
      var LSPErrorCodes;
      (function(LSPErrorCodes2) {
        LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
        LSPErrorCodes2.RequestFailed = -32803;
        LSPErrorCodes2.ServerCancelled = -32802;
        LSPErrorCodes2.ContentModified = -32801;
        LSPErrorCodes2.RequestCancelled = -32800;
        LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
      })(LSPErrorCodes || (exports$1.LSPErrorCodes = LSPErrorCodes = {}));
    })(api);
    return api;
  }
  var hasRequiredMain;
  function requireMain() {
    if (hasRequiredMain) return main$2;
    hasRequiredMain = 1;
    (function(exports$1) {
      var __createBinding = main$2 && main$2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = main$2 && main$2.__exportStar || function(m, exports$12) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
      };
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.createProtocolConnection = void 0;
      const browser_1 = requireBrowser();
      __exportStar(requireBrowser(), exports$1);
      __exportStar(requireApi(), exports$1);
      function createProtocolConnection(reader, writer, logger, options) {
        return (0, browser_1.createMessageConnection)(reader, writer, logger, options);
      }
      exports$1.createProtocolConnection = createProtocolConnection;
    })(main$2);
    return main$2;
  }
  var mainExports = requireMain();
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var browser = { exports: {} };
  var process = browser.exports = {};
  var cachedSetTimeout;
  var cachedClearTimeout;
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      if (typeof setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      } else {
        cachedSetTimeout = defaultSetTimout;
      }
    } catch (e) {
      cachedSetTimeout = defaultSetTimout;
    }
    try {
      if (typeof clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      } else {
        cachedClearTimeout = defaultClearTimeout;
      }
    } catch (e) {
      cachedClearTimeout = defaultClearTimeout;
    }
  })();
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e2) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e2) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = "browser";
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = "";
  process.versions = {};
  function noop() {
  }
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.prependListener = noop;
  process.prependOnceListener = noop;
  process.listeners = function(name) {
    return [];
  };
  process.binding = function(name) {
    throw new Error("process.binding is not supported");
  };
  process.cwd = function() {
    return "/";
  };
  process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
  };
  process.umask = function() {
    return 0;
  };
  var browserExports = browser.exports;
  const process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
  var LIB;
  (() => {
    var t = { 975: (t2) => {
      function e2(t3) {
        if ("string" != typeof t3) throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
      }
      function r2(t3, e3) {
        for (var r3, n3 = "", i2 = 0, o2 = -1, s2 = 0, h2 = 0; h2 <= t3.length; ++h2) {
          if (h2 < t3.length) r3 = t3.charCodeAt(h2);
          else {
            if (47 === r3) break;
            r3 = 47;
          }
          if (47 === r3) {
            if (o2 === h2 - 1 || 1 === s2) ;
            else if (o2 !== h2 - 1 && 2 === s2) {
              if (n3.length < 2 || 2 !== i2 || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
                if (n3.length > 2) {
                  var a2 = n3.lastIndexOf("/");
                  if (a2 !== n3.length - 1) {
                    -1 === a2 ? (n3 = "", i2 = 0) : i2 = (n3 = n3.slice(0, a2)).length - 1 - n3.lastIndexOf("/"), o2 = h2, s2 = 0;
                    continue;
                  }
                } else if (2 === n3.length || 1 === n3.length) {
                  n3 = "", i2 = 0, o2 = h2, s2 = 0;
                  continue;
                }
              }
              e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", i2 = 2);
            } else n3.length > 0 ? n3 += "/" + t3.slice(o2 + 1, h2) : n3 = t3.slice(o2 + 1, h2), i2 = h2 - o2 - 1;
            o2 = h2, s2 = 0;
          } else 46 === r3 && -1 !== s2 ? ++s2 : s2 = -1;
        }
        return n3;
      }
      var n2 = { resolve: function() {
        for (var t3, n3 = "", i2 = false, o2 = arguments.length - 1; o2 >= -1 && !i2; o2--) {
          var s2;
          o2 >= 0 ? s2 = arguments[o2] : (void 0 === t3 && (t3 = process$1.cwd()), s2 = t3), e2(s2), 0 !== s2.length && (n3 = s2 + "/" + n3, i2 = 47 === s2.charCodeAt(0));
        }
        return n3 = r2(n3, !i2), i2 ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
      }, normalize: function(t3) {
        if (e2(t3), 0 === t3.length) return ".";
        var n3 = 47 === t3.charCodeAt(0), i2 = 47 === t3.charCodeAt(t3.length - 1);
        return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && i2 && (t3 += "/"), n3 ? "/" + t3 : t3;
      }, isAbsolute: function(t3) {
        return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
      }, join: function() {
        if (0 === arguments.length) return ".";
        for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
          var i2 = arguments[r3];
          e2(i2), i2.length > 0 && (void 0 === t3 ? t3 = i2 : t3 += "/" + i2);
        }
        return void 0 === t3 ? "." : n2.normalize(t3);
      }, relative: function(t3, r3) {
        if (e2(t3), e2(r3), t3 === r3) return "";
        if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3))) return "";
        for (var i2 = 1; i2 < t3.length && 47 === t3.charCodeAt(i2); ++i2) ;
        for (var o2 = t3.length, s2 = o2 - i2, h2 = 1; h2 < r3.length && 47 === r3.charCodeAt(h2); ++h2) ;
        for (var a2 = r3.length - h2, c2 = s2 < a2 ? s2 : a2, f2 = -1, u2 = 0; u2 <= c2; ++u2) {
          if (u2 === c2) {
            if (a2 > c2) {
              if (47 === r3.charCodeAt(h2 + u2)) return r3.slice(h2 + u2 + 1);
              if (0 === u2) return r3.slice(h2 + u2);
            } else s2 > c2 && (47 === t3.charCodeAt(i2 + u2) ? f2 = u2 : 0 === u2 && (f2 = 0));
            break;
          }
          var l2 = t3.charCodeAt(i2 + u2);
          if (l2 !== r3.charCodeAt(h2 + u2)) break;
          47 === l2 && (f2 = u2);
        }
        var g2 = "";
        for (u2 = i2 + f2 + 1; u2 <= o2; ++u2) u2 !== o2 && 47 !== t3.charCodeAt(u2) || (0 === g2.length ? g2 += ".." : g2 += "/..");
        return g2.length > 0 ? g2 + r3.slice(h2 + f2) : (h2 += f2, 47 === r3.charCodeAt(h2) && ++h2, r3.slice(h2));
      }, _makeLong: function(t3) {
        return t3;
      }, dirname: function(t3) {
        if (e2(t3), 0 === t3.length) return ".";
        for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, i2 = -1, o2 = true, s2 = t3.length - 1; s2 >= 1; --s2) if (47 === (r3 = t3.charCodeAt(s2))) {
          if (!o2) {
            i2 = s2;
            break;
          }
        } else o2 = false;
        return -1 === i2 ? n3 ? "/" : "." : n3 && 1 === i2 ? "//" : t3.slice(0, i2);
      }, basename: function(t3, r3) {
        if (void 0 !== r3 && "string" != typeof r3) throw new TypeError('"ext" argument must be a string');
        e2(t3);
        var n3, i2 = 0, o2 = -1, s2 = true;
        if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
          if (r3.length === t3.length && r3 === t3) return "";
          var h2 = r3.length - 1, a2 = -1;
          for (n3 = t3.length - 1; n3 >= 0; --n3) {
            var c2 = t3.charCodeAt(n3);
            if (47 === c2) {
              if (!s2) {
                i2 = n3 + 1;
                break;
              }
            } else -1 === a2 && (s2 = false, a2 = n3 + 1), h2 >= 0 && (c2 === r3.charCodeAt(h2) ? -1 == --h2 && (o2 = n3) : (h2 = -1, o2 = a2));
          }
          return i2 === o2 ? o2 = a2 : -1 === o2 && (o2 = t3.length), t3.slice(i2, o2);
        }
        for (n3 = t3.length - 1; n3 >= 0; --n3) if (47 === t3.charCodeAt(n3)) {
          if (!s2) {
            i2 = n3 + 1;
            break;
          }
        } else -1 === o2 && (s2 = false, o2 = n3 + 1);
        return -1 === o2 ? "" : t3.slice(i2, o2);
      }, extname: function(t3) {
        e2(t3);
        for (var r3 = -1, n3 = 0, i2 = -1, o2 = true, s2 = 0, h2 = t3.length - 1; h2 >= 0; --h2) {
          var a2 = t3.charCodeAt(h2);
          if (47 !== a2) -1 === i2 && (o2 = false, i2 = h2 + 1), 46 === a2 ? -1 === r3 ? r3 = h2 : 1 !== s2 && (s2 = 1) : -1 !== r3 && (s2 = -1);
          else if (!o2) {
            n3 = h2 + 1;
            break;
          }
        }
        return -1 === r3 || -1 === i2 || 0 === s2 || 1 === s2 && r3 === i2 - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, i2);
      }, format: function(t3) {
        if (null === t3 || "object" != typeof t3) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
        return (function(t4, e3) {
          var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
          return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
        })(0, t3);
      }, parse: function(t3) {
        e2(t3);
        var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
        if (0 === t3.length) return r3;
        var n3, i2 = t3.charCodeAt(0), o2 = 47 === i2;
        o2 ? (r3.root = "/", n3 = 1) : n3 = 0;
        for (var s2 = -1, h2 = 0, a2 = -1, c2 = true, f2 = t3.length - 1, u2 = 0; f2 >= n3; --f2) if (47 !== (i2 = t3.charCodeAt(f2))) -1 === a2 && (c2 = false, a2 = f2 + 1), 46 === i2 ? -1 === s2 ? s2 = f2 : 1 !== u2 && (u2 = 1) : -1 !== s2 && (u2 = -1);
        else if (!c2) {
          h2 = f2 + 1;
          break;
        }
        return -1 === s2 || -1 === a2 || 0 === u2 || 1 === u2 && s2 === a2 - 1 && s2 === h2 + 1 ? -1 !== a2 && (r3.base = r3.name = 0 === h2 && o2 ? t3.slice(1, a2) : t3.slice(h2, a2)) : (0 === h2 && o2 ? (r3.name = t3.slice(1, s2), r3.base = t3.slice(1, a2)) : (r3.name = t3.slice(h2, s2), r3.base = t3.slice(h2, a2)), r3.ext = t3.slice(s2, a2)), h2 > 0 ? r3.dir = t3.slice(0, h2 - 1) : o2 && (r3.dir = "/"), r3;
      }, sep: "/", delimiter: ":", win32: null, posix: null };
      n2.posix = n2, t2.exports = n2;
    } }, e = {};
    function r(n2) {
      var i2 = e[n2];
      if (void 0 !== i2) return i2.exports;
      var o2 = e[n2] = { exports: {} };
      return t[n2](o2, o2.exports, r), o2.exports;
    }
    r.d = (t2, e2) => {
      for (var n2 in e2) r.o(e2, n2) && !r.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });
    }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
    };
    var n = {};
    let i;
    if (r.r(n), r.d(n, { URI: () => l, Utils: () => I }), "object" == typeof process$1) i = "win32" === process$1.platform;
    else if ("object" == typeof navigator) {
      let t2 = navigator.userAgent;
      i = t2.indexOf("Windows") >= 0;
    }
    const o = /^\w[\w\d+.-]*$/, s = /^\//, h = /^\/\//;
    function a(t2, e2) {
      if (!t2.scheme && e2) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t2.authority}", path: "${t2.path}", query: "${t2.query}", fragment: "${t2.fragment}"}`);
      if (t2.scheme && !o.test(t2.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
      if (t2.path) {
        if (t2.authority) {
          if (!s.test(t2.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
        } else if (h.test(t2.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
      }
    }
    const c = "", f = "/", u = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
    class l {
      constructor(t2, e2, r2, n2, i2, o2 = false) {
        __publicField(this, "scheme");
        __publicField(this, "authority");
        __publicField(this, "path");
        __publicField(this, "query");
        __publicField(this, "fragment");
        "object" == typeof t2 ? (this.scheme = t2.scheme || c, this.authority = t2.authority || c, this.path = t2.path || c, this.query = t2.query || c, this.fragment = t2.fragment || c) : (this.scheme = /* @__PURE__ */ (function(t3, e3) {
          return t3 || e3 ? t3 : "file";
        })(t2, o2), this.authority = e2 || c, this.path = (function(t3, e3) {
          switch (t3) {
            case "https":
            case "http":
            case "file":
              e3 ? e3[0] !== f && (e3 = f + e3) : e3 = f;
          }
          return e3;
        })(this.scheme, r2 || c), this.query = n2 || c, this.fragment = i2 || c, a(this, o2));
      }
      static isUri(t2) {
        return t2 instanceof l || !!t2 && "string" == typeof t2.authority && "string" == typeof t2.fragment && "string" == typeof t2.path && "string" == typeof t2.query && "string" == typeof t2.scheme && "string" == typeof t2.fsPath && "function" == typeof t2.with && "function" == typeof t2.toString;
      }
      get fsPath() {
        return v(this);
      }
      with(t2) {
        if (!t2) return this;
        let { scheme: e2, authority: r2, path: n2, query: i2, fragment: o2 } = t2;
        return void 0 === e2 ? e2 = this.scheme : null === e2 && (e2 = c), void 0 === r2 ? r2 = this.authority : null === r2 && (r2 = c), void 0 === n2 ? n2 = this.path : null === n2 && (n2 = c), void 0 === i2 ? i2 = this.query : null === i2 && (i2 = c), void 0 === o2 ? o2 = this.fragment : null === o2 && (o2 = c), e2 === this.scheme && r2 === this.authority && n2 === this.path && i2 === this.query && o2 === this.fragment ? this : new d(e2, r2, n2, i2, o2);
      }
      static parse(t2, e2 = false) {
        const r2 = u.exec(t2);
        return r2 ? new d(r2[2] || c, w(r2[4] || c), w(r2[5] || c), w(r2[7] || c), w(r2[9] || c), e2) : new d(c, c, c, c, c);
      }
      static file(t2) {
        let e2 = c;
        if (i && (t2 = t2.replace(/\\/g, f)), t2[0] === f && t2[1] === f) {
          const r2 = t2.indexOf(f, 2);
          -1 === r2 ? (e2 = t2.substring(2), t2 = f) : (e2 = t2.substring(2, r2), t2 = t2.substring(r2) || f);
        }
        return new d("file", e2, t2, c, c);
      }
      static from(t2) {
        const e2 = new d(t2.scheme, t2.authority, t2.path, t2.query, t2.fragment);
        return a(e2, true), e2;
      }
      toString(t2 = false) {
        return b(this, t2);
      }
      toJSON() {
        return this;
      }
      static revive(t2) {
        if (t2) {
          if (t2 instanceof l) return t2;
          {
            const e2 = new d(t2);
            return e2._formatted = t2.external, e2._fsPath = t2._sep === g ? t2.fsPath : null, e2;
          }
        }
        return t2;
      }
    }
    const g = i ? 1 : void 0;
    class d extends l {
      constructor() {
        super(...arguments);
        __publicField(this, "_formatted", null);
        __publicField(this, "_fsPath", null);
      }
      get fsPath() {
        return this._fsPath || (this._fsPath = v(this)), this._fsPath;
      }
      toString(t2 = false) {
        return t2 ? b(this, true) : (this._formatted || (this._formatted = b(this, false)), this._formatted);
      }
      toJSON() {
        const t2 = { $mid: 1 };
        return this._fsPath && (t2.fsPath = this._fsPath, t2._sep = g), this._formatted && (t2.external = this._formatted), this.path && (t2.path = this.path), this.scheme && (t2.scheme = this.scheme), this.authority && (t2.authority = this.authority), this.query && (t2.query = this.query), this.fragment && (t2.fragment = this.fragment), t2;
      }
    }
    const p = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
    function m(t2, e2, r2) {
      let n2, i2 = -1;
      for (let o2 = 0; o2 < t2.length; o2++) {
        const s2 = t2.charCodeAt(o2);
        if (s2 >= 97 && s2 <= 122 || s2 >= 65 && s2 <= 90 || s2 >= 48 && s2 <= 57 || 45 === s2 || 46 === s2 || 95 === s2 || 126 === s2 || e2 && 47 === s2 || r2 && 91 === s2 || r2 && 93 === s2 || r2 && 58 === s2) -1 !== i2 && (n2 += encodeURIComponent(t2.substring(i2, o2)), i2 = -1), void 0 !== n2 && (n2 += t2.charAt(o2));
        else {
          void 0 === n2 && (n2 = t2.substr(0, o2));
          const e3 = p[s2];
          void 0 !== e3 ? (-1 !== i2 && (n2 += encodeURIComponent(t2.substring(i2, o2)), i2 = -1), n2 += e3) : -1 === i2 && (i2 = o2);
        }
      }
      return -1 !== i2 && (n2 += encodeURIComponent(t2.substring(i2))), void 0 !== n2 ? n2 : t2;
    }
    function y(t2) {
      let e2;
      for (let r2 = 0; r2 < t2.length; r2++) {
        const n2 = t2.charCodeAt(r2);
        35 === n2 || 63 === n2 ? (void 0 === e2 && (e2 = t2.substr(0, r2)), e2 += p[n2]) : void 0 !== e2 && (e2 += t2[r2]);
      }
      return void 0 !== e2 ? e2 : t2;
    }
    function v(t2, e2) {
      let r2;
      return r2 = t2.authority && t2.path.length > 1 && "file" === t2.scheme ? `//${t2.authority}${t2.path}` : 47 === t2.path.charCodeAt(0) && (t2.path.charCodeAt(1) >= 65 && t2.path.charCodeAt(1) <= 90 || t2.path.charCodeAt(1) >= 97 && t2.path.charCodeAt(1) <= 122) && 58 === t2.path.charCodeAt(2) ? t2.path[1].toLowerCase() + t2.path.substr(2) : t2.path, i && (r2 = r2.replace(/\//g, "\\")), r2;
    }
    function b(t2, e2) {
      const r2 = e2 ? y : m;
      let n2 = "", { scheme: i2, authority: o2, path: s2, query: h2, fragment: a2 } = t2;
      if (i2 && (n2 += i2, n2 += ":"), (o2 || "file" === i2) && (n2 += f, n2 += f), o2) {
        let t3 = o2.indexOf("@");
        if (-1 !== t3) {
          const e3 = o2.substr(0, t3);
          o2 = o2.substr(t3 + 1), t3 = e3.lastIndexOf(":"), -1 === t3 ? n2 += r2(e3, false, false) : (n2 += r2(e3.substr(0, t3), false, false), n2 += ":", n2 += r2(e3.substr(t3 + 1), false, true)), n2 += "@";
        }
        o2 = o2.toLowerCase(), t3 = o2.lastIndexOf(":"), -1 === t3 ? n2 += r2(o2, false, true) : (n2 += r2(o2.substr(0, t3), false, true), n2 += o2.substr(t3));
      }
      if (s2) {
        if (s2.length >= 3 && 47 === s2.charCodeAt(0) && 58 === s2.charCodeAt(2)) {
          const t3 = s2.charCodeAt(1);
          t3 >= 65 && t3 <= 90 && (s2 = `/${String.fromCharCode(t3 + 32)}:${s2.substr(3)}`);
        } else if (s2.length >= 2 && 58 === s2.charCodeAt(1)) {
          const t3 = s2.charCodeAt(0);
          t3 >= 65 && t3 <= 90 && (s2 = `${String.fromCharCode(t3 + 32)}:${s2.substr(2)}`);
        }
        n2 += r2(s2, true, false);
      }
      return h2 && (n2 += "?", n2 += r2(h2, false, false)), a2 && (n2 += "#", n2 += e2 ? a2 : m(a2, false, false)), n2;
    }
    function C(t2) {
      try {
        return decodeURIComponent(t2);
      } catch {
        return t2.length > 3 ? t2.substr(0, 3) + C(t2.substr(3)) : t2;
      }
    }
    const A = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
    function w(t2) {
      return t2.match(A) ? t2.replace(A, ((t3) => C(t3))) : t2;
    }
    var x = r(975);
    const P = x.posix || x, _ = "/";
    var I;
    !(function(t2) {
      t2.joinPath = function(t3, ...e2) {
        return t3.with({ path: P.join(t3.path, ...e2) });
      }, t2.resolvePath = function(t3, ...e2) {
        let r2 = t3.path, n2 = false;
        r2[0] !== _ && (r2 = _ + r2, n2 = true);
        let i2 = P.resolve(r2, ...e2);
        return n2 && i2[0] === _ && !t3.authority && (i2 = i2.substring(1)), t3.with({ path: i2 });
      }, t2.dirname = function(t3) {
        if (0 === t3.path.length || t3.path === _) return t3;
        let e2 = P.dirname(t3.path);
        return 1 === e2.length && 46 === e2.charCodeAt(0) && (e2 = ""), t3.with({ path: e2 });
      }, t2.basename = function(t3) {
        return P.basename(t3.path);
      }, t2.extname = function(t3) {
        return P.extname(t3.path);
      };
    })(I || (I = {})), LIB = n;
  })();
  const { URI, Utils } = LIB;
  function notEmpty(value) {
    return value !== null && value !== void 0;
  }
  function isEmptyRange(range) {
    return range.start.row === range.end.row && range.start.column === range.end.column;
  }
  function mergeRanges(ranges) {
    var list = ranges;
    list = list.sort(function(a, b) {
      return comparePoints(a.start, b.start);
    });
    var next = list[0], range;
    for (var i = 1; i < list.length; i++) {
      range = next;
      next = list[i];
      var cmp = comparePoints(range.end, next.start);
      if (cmp < 0) continue;
      if (cmp == 0 && !isEmptyRange(range) && !isEmptyRange(next)) continue;
      if (comparePoints(range.end, next.end) < 0) {
        range.end.row = next.end.row;
        range.end.column = next.end.column;
      }
      list.splice(i, 1);
      next = range;
      i--;
    }
    return list;
  }
  function comparePoints(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
  }
  function checkValueAgainstRegexpArray(value, regexpArray) {
    if (!regexpArray) {
      return false;
    }
    for (let i = 0; i < regexpArray.length; i++) {
      if (regexpArray[i].test(value)) {
        return true;
      }
    }
    return false;
  }
  function convertToUri(filePath, joinWorkspaceURI = false, workspaceUri) {
    const isFullUri = filePath.startsWith("file://");
    const normalizedPath = filePath.replace(/\\/g, "/");
    let uri;
    if (isFullUri) {
      uri = URI.parse(normalizedPath);
    } else {
      uri = URI.file(normalizedPath);
    }
    if (joinWorkspaceURI && workspaceUri) {
      if (!workspaceUri.startsWith("file://")) {
        throw new Error("workspaceUri must be a file:// URI");
      }
      const workspaceUriParsed = URI.parse(workspaceUri);
      uri = Utils.joinPath(workspaceUriParsed, uri.path);
    }
    return uri.toString();
  }
  class AceRange {
    static getConstructor(editor) {
      if (!AceRange._instance && editor) {
        AceRange._instance = editor.getSelectionRange().constructor;
      }
      return AceRange._instance;
    }
  }
  var CommonConverter;
  ((CommonConverter2) => {
    function normalizeRanges(completions) {
      return completions && completions.map((el) => {
        if (el["range"]) {
          el["range"] = toRange2(el["range"]);
        }
        return el;
      });
    }
    CommonConverter2.normalizeRanges = normalizeRanges;
    function cleanHtml(html) {
      return html.replace(/<a\s/, "<a target='_blank' ");
    }
    CommonConverter2.cleanHtml = cleanHtml;
    function toRange2(range) {
      if (!range || !range.start || !range.end) {
        return;
      }
      let Range2 = AceRange.getConstructor();
      return Range2.fromPoints(range.start, range.end);
    }
    CommonConverter2.toRange = toRange2;
    function convertKind(kind) {
      switch (kind) {
        case "primitiveType":
        case "keyword":
          return mainExports.CompletionItemKind.Keyword;
        case "variable":
        case "localVariable":
          return mainExports.CompletionItemKind.Variable;
        case "memberVariable":
        case "memberGetAccessor":
        case "memberSetAccessor":
          return mainExports.CompletionItemKind.Field;
        case "function":
        case "memberFunction":
        case "constructSignature":
        case "callSignature":
        case "indexSignature":
          return mainExports.CompletionItemKind.Function;
        case "enum":
          return mainExports.CompletionItemKind.Enum;
        case "module":
          return mainExports.CompletionItemKind.Module;
        case "class":
          return mainExports.CompletionItemKind.Class;
        case "interface":
          return mainExports.CompletionItemKind.Interface;
        case "warning":
          return mainExports.CompletionItemKind.File;
      }
      return mainExports.CompletionItemKind.Property;
    }
    CommonConverter2.convertKind = convertKind;
    function excludeByErrorMessage(diagnostics, errorMessagesToIgnore, fieldName = "message") {
      if (!errorMessagesToIgnore)
        return diagnostics;
      return diagnostics.filter((el) => !checkValueAgainstRegexpArray(el[fieldName], errorMessagesToIgnore));
    }
    CommonConverter2.excludeByErrorMessage = excludeByErrorMessage;
  })(CommonConverter || (CommonConverter = {}));
  class BaseMessage {
    constructor(documentIdentifier, callbackId) {
      this.sessionId = documentIdentifier.sessionId;
      this.documentUri = documentIdentifier.documentUri;
      this.callbackId = callbackId;
    }
  }
  class InitMessage extends BaseMessage {
    constructor(documentIdentifier, callbackId, value, version, mode, options) {
      super(documentIdentifier, callbackId);
      this.type = 0;
      this.version = version;
      this.options = options;
      this.mode = mode;
      this.value = value;
    }
  }
  class FormatMessage extends BaseMessage {
    constructor(documentIdentifier, callbackId, value, format) {
      super(documentIdentifier, callbackId);
      this.type = 1;
      this.value = value;
      this.format = format;
    }
  }
  class CompleteMessage extends BaseMessage {
    constructor(documentIdentifier, callbackId, value) {
      super(documentIdentifier, callbackId);
      this.type = 2;
      this.value = value;
    }
  }
  class InlineCompleteMessage extends BaseMessage {
    constructor(documentIdentifier, callbackId, value) {
      super(documentIdentifier, callbackId);
      this.type = 27;
      this.value = value;
    }
  }
  class ResolveCompletionMessage extends BaseMessage {
    constructor(documentIdentifier, callbackId, value) {
      super(documentIdentifier, callbackId);
      this.type = 3;
      this.value = value;
    }
  }
  class HoverMessage extends BaseMessage {
    constructor(documentIdentifier, callbackId, value) {
      super(documentIdentifier, callbackId);
      this.type = 5;
      this.value = value;
    }
  }
  class ValidateMessage extends BaseMessage {
    constructor(documentIdentifier, callbackId) {
      super(documentIdentifier, callbackId);
      this.type = 6;
    }
  }
  class ChangeMessage extends BaseMessage {
    constructor(documentIdentifier, callbackId, value, version) {
      super(documentIdentifier, callbackId);
      this.type = 4;
      this.value = value;
      this.version = version;
    }
  }
  class DeltasMessage extends BaseMessage {
    constructor(documentIdentifier, callbackId, value, version) {
      super(documentIdentifier, callbackId);
      this.type = 7;
      this.value = value;
      this.version = version;
    }
  }
  class ChangeModeMessage extends BaseMessage {
    constructor(documentIdentifier, callbackId, value, version, mode) {
      super(documentIdentifier, callbackId);
      this.type = 8;
      this.value = value;
      this.mode = mode;
      this.version = version;
    }
  }
  class ChangeOptionsMessage extends BaseMessage {
    constructor(documentIdentifier, callbackId, options, merge = false) {
      super(documentIdentifier, callbackId);
      this.type = 9;
      this.options = options;
      this.merge = merge;
    }
  }
  class CloseDocumentMessage extends BaseMessage {
    constructor(documentIdentifier, callbackId) {
      super(documentIdentifier, callbackId);
      this.type = 10;
    }
  }
  class CloseConnectionMessage {
    constructor(callbackId) {
      this.type = 15;
      this.callbackId = callbackId;
    }
  }
  class GlobalOptionsMessage {
    constructor(serviceName, options, merge) {
      this.type = 11;
      this.serviceName = serviceName;
      this.options = options;
      this.merge = merge;
    }
  }
  class ConfigureFeaturesMessage {
    constructor(serviceName, options) {
      this.type = 12;
      this.serviceName = serviceName;
      this.options = options;
    }
  }
  class SignatureHelpMessage extends BaseMessage {
    constructor(documentIdentifier, callbackId, value) {
      super(documentIdentifier, callbackId);
      this.type = 13;
      this.value = value;
    }
  }
  class DocumentHighlightMessage extends BaseMessage {
    constructor(documentIdentifier, callbackId, value) {
      super(documentIdentifier, callbackId);
      this.type = 14;
      this.value = value;
    }
  }
  class GetSemanticTokensMessage extends BaseMessage {
    constructor(documentIdentifier, callbackId, value) {
      super(documentIdentifier, callbackId);
      this.type = 17;
      this.value = value;
    }
  }
  class GetCodeActionsMessage extends BaseMessage {
    constructor(documentIdentifier, callbackId, value, context) {
      super(documentIdentifier, callbackId);
      this.type = 18;
      this.value = value;
      this.context = context;
    }
  }
  class SetWorkspaceMessage {
    constructor(value) {
      this.type = 22;
      this.value = value;
    }
  }
  class ExecuteCommandMessage {
    constructor(serviceName, callbackId, command, args) {
      this.type = 19;
      this.serviceName = serviceName;
      this.callbackId = callbackId;
      this.value = command;
      this.args = args;
    }
  }
  class AppliedEditMessage {
    constructor(value, serviceName, callbackId) {
      this.type = 21;
      this.serviceName = serviceName;
      this.callbackId = callbackId;
      this.value = value;
    }
  }
  class RenameDocumentMessage extends BaseMessage {
    constructor(documentIdentifier, callbackId, value, version) {
      super(documentIdentifier, callbackId);
      this.type = 23;
      this.value = value;
      this.version = version;
    }
  }
  class SendRequestMessage {
    constructor(serviceName, callbackId, requestName, args) {
      this.type = 24;
      this.serviceName = serviceName;
      this.callbackId = callbackId;
      this.value = requestName;
      this.args = args;
    }
  }
  class SendResponseMessage {
    constructor(serviceName, callbackId, args) {
      this.type = 26;
      this.serviceName = serviceName;
      this.callbackId = callbackId;
      this.args = args;
    }
  }
  var MessageType = /* @__PURE__ */ ((MessageType2) => {
    MessageType2[MessageType2["init"] = 0] = "init";
    MessageType2[MessageType2["format"] = 1] = "format";
    MessageType2[MessageType2["complete"] = 2] = "complete";
    MessageType2[MessageType2["resolveCompletion"] = 3] = "resolveCompletion";
    MessageType2[MessageType2["change"] = 4] = "change";
    MessageType2[MessageType2["hover"] = 5] = "hover";
    MessageType2[MessageType2["validate"] = 6] = "validate";
    MessageType2[MessageType2["applyDelta"] = 7] = "applyDelta";
    MessageType2[MessageType2["changeMode"] = 8] = "changeMode";
    MessageType2[MessageType2["changeOptions"] = 9] = "changeOptions";
    MessageType2[MessageType2["closeDocument"] = 10] = "closeDocument";
    MessageType2[MessageType2["globalOptions"] = 11] = "globalOptions";
    MessageType2[MessageType2["configureFeatures"] = 12] = "configureFeatures";
    MessageType2[MessageType2["signatureHelp"] = 13] = "signatureHelp";
    MessageType2[MessageType2["documentHighlight"] = 14] = "documentHighlight";
    MessageType2[MessageType2["closeConnection"] = 15] = "closeConnection";
    MessageType2[MessageType2["capabilitiesChange"] = 16] = "capabilitiesChange";
    MessageType2[MessageType2["getSemanticTokens"] = 17] = "getSemanticTokens";
    MessageType2[MessageType2["getCodeActions"] = 18] = "getCodeActions";
    MessageType2[MessageType2["executeCommand"] = 19] = "executeCommand";
    MessageType2[MessageType2["applyEdit"] = 20] = "applyEdit";
    MessageType2[MessageType2["appliedEdit"] = 21] = "appliedEdit";
    MessageType2[MessageType2["setWorkspace"] = 22] = "setWorkspace";
    MessageType2[MessageType2["renameDocument"] = 23] = "renameDocument";
    MessageType2[MessageType2["sendRequest"] = 24] = "sendRequest";
    MessageType2[MessageType2["showDocument"] = 25] = "showDocument";
    MessageType2[MessageType2["sendResponse"] = 26] = "sendResponse";
    MessageType2[MessageType2["inlineComplete"] = 27] = "inlineComplete";
    return MessageType2;
  })(MessageType || {});
  class MessageController {
    constructor(worker, provider) {
      this.callbacks = {};
      this.callbackId = 1;
      this.$worker = worker;
      this.provider = provider;
      this.$worker.addEventListener("message", (e) => {
        var _a, _b;
        const message = e.data;
        const callbackId = message.callbackId;
        switch (message.type) {
          case MessageType.validate:
          case MessageType.capabilitiesChange:
            const sessionId = this.getSessionIdByUri(message.documentUri);
            if (!sessionId) {
              return;
            }
            if (message.type === MessageType.validate) {
              (_a = this.provider.$sessionLanguageProviders[sessionId]) == null ? void 0 : _a.$showAnnotations(message.value);
            } else {
              (_b = this.provider.$sessionLanguageProviders[sessionId]) == null ? void 0 : _b.setServerCapabilities(message.value);
            }
            break;
          case MessageType.applyEdit:
            const applied = (result, serviceName) => {
              this.$worker.postMessage(new AppliedEditMessage(result, serviceName, message.callbackId));
            };
            this.provider.applyEdit(message.value, message.serviceName, applied);
            break;
          case MessageType.showDocument:
            const sendResponse = (result, serviceName) => {
              this.$worker.postMessage(new SendResponseMessage(serviceName, message.callbackId, result));
            };
            this.provider.showDocument(message, message.serviceName, sendResponse);
            break;
          default:
            if (this.callbacks[callbackId]) {
              this.callbacks[callbackId](message.value);
              delete this.callbacks[callbackId];
            }
            break;
        }
      });
    }
    getSessionIdByUri(documentUri) {
      if (!documentUri) {
        return;
      }
      return this.provider.$urisToSessionsIds[documentUri] || this.provider.$urisToSessionsIds[convertToUri(documentUri)];
    }
    init(documentIdentifier, document2, mode, options, initCallback) {
      this.postMessage(new InitMessage(documentIdentifier, this.callbackId++, document2.getValue(), document2["version"], mode, options), initCallback);
    }
    doValidation(documentIdentifier, callback) {
      this.postMessage(new ValidateMessage(documentIdentifier, this.callbackId++), callback);
    }
    doComplete(documentIdentifier, position, callback) {
      this.postMessage(new CompleteMessage(documentIdentifier, this.callbackId++, position), callback);
    }
    doInlineComplete(documentIdentifier, position, callback) {
      this.postMessage(new InlineCompleteMessage(documentIdentifier, this.callbackId++, position), callback);
    }
    doResolve(documentIdentifier, completion, callback) {
      this.postMessage(new ResolveCompletionMessage(documentIdentifier, this.callbackId++, completion), callback);
    }
    format(documentIdentifier, range, format, callback) {
      this.postMessage(new FormatMessage(documentIdentifier, this.callbackId++, range, format), callback);
    }
    doHover(documentIdentifier, position, callback) {
      this.postMessage(new HoverMessage(documentIdentifier, this.callbackId++, position), callback);
    }
    change(documentIdentifier, deltas, document2, callback) {
      let message;
      if (deltas.length > 50 && deltas.length > document2.getLength() >> 1) {
        message = new ChangeMessage(documentIdentifier, this.callbackId++, document2.getValue(), document2.version);
      } else {
        message = new DeltasMessage(documentIdentifier, this.callbackId++, deltas, document2.version);
      }
      this.postMessage(message, callback);
    }
    changeMode(documentIdentifier, value, version, mode, callback) {
      this.postMessage(new ChangeModeMessage(documentIdentifier, this.callbackId++, value, version, mode), callback);
    }
    changeOptions(documentIdentifier, options, callback, merge = false) {
      this.postMessage(new ChangeOptionsMessage(documentIdentifier, this.callbackId++, options, merge), callback);
    }
    closeDocument(documentIdentifier, callback) {
      this.postMessage(new CloseDocumentMessage(documentIdentifier, this.callbackId++), callback);
    }
    closeConnection(callback) {
      this.postMessage(new CloseConnectionMessage(this.callbackId++), callback);
    }
    setGlobalOptions(serviceName, options, merge = false) {
      this.$worker.postMessage(new GlobalOptionsMessage(serviceName, options, merge));
    }
    provideSignatureHelp(documentIdentifier, position, callback) {
      this.postMessage(new SignatureHelpMessage(documentIdentifier, this.callbackId++, position), callback);
    }
    findDocumentHighlights(documentIdentifier, position, callback) {
      this.postMessage(new DocumentHighlightMessage(documentIdentifier, this.callbackId++, position), callback);
    }
    configureFeatures(serviceName, features) {
      this.$worker.postMessage(new ConfigureFeaturesMessage(serviceName, features));
    }
    getSemanticTokens(documentIdentifier, range, callback) {
      this.postMessage(new GetSemanticTokensMessage(documentIdentifier, this.callbackId++, range), callback);
    }
    getCodeActions(documentIdentifier, range, context, callback) {
      this.postMessage(new GetCodeActionsMessage(documentIdentifier, this.callbackId++, range, context), callback);
    }
    executeCommand(serviceName, command, args, callback) {
      this.postMessage(new ExecuteCommandMessage(serviceName, this.callbackId++, command, args), callback);
    }
    setWorkspace(workspaceUri, callback) {
      this.$worker.postMessage(new SetWorkspaceMessage(workspaceUri));
    }
    renameDocument(documentIdentifier, newDocumentUri, version) {
      this.$worker.postMessage(new RenameDocumentMessage(documentIdentifier, this.callbackId++, newDocumentUri, version));
    }
    sendRequest(serviceName, requestName, args, callback) {
      this.postMessage(new SendRequestMessage(serviceName, this.callbackId++, requestName, args), callback);
    }
    postMessage(message, callback) {
      if (callback) {
        this.callbacks[message.callbackId] = callback;
      }
      this.$worker.postMessage(message);
    }
  }
  function fromRange(range) {
    return {
      start: {
        line: range.start.row,
        character: range.start.column
      },
      end: { line: range.end.row, character: range.end.column }
    };
  }
  function rangeFromPositions(start, end) {
    return {
      start,
      end
    };
  }
  function toRange(range) {
    return {
      start: {
        row: range.start.line,
        column: range.start.character
      },
      end: {
        row: range.end.line,
        column: range.end.character
      }
    };
  }
  function fromPoint(point) {
    return { line: point.row, character: point.column };
  }
  function toAnnotations(diagnostics) {
    return diagnostics == null ? void 0 : diagnostics.map((el) => {
      return {
        row: el.range.start.line,
        column: el.range.start.character,
        text: el.message,
        type: el.severity === 1 ? "error" : el.severity === 2 ? "warning" : "info",
        code: el.code
      };
    });
  }
  function fromAnnotations(annotations) {
    return annotations == null ? void 0 : annotations.map((el) => {
      return {
        range: {
          start: {
            line: el.row,
            character: el.column
          },
          end: {
            line: el.row,
            character: el.column
          }
        },
        message: el.text,
        severity: el.type === "error" ? 1 : el.type === "warning" ? 2 : 3,
        code: el["code"]
      };
    });
  }
  function toCompletion(item) {
    var _a, _b, _c, _d;
    let itemKind = item.kind;
    let kind = itemKind ? Object.keys(mainExports.CompletionItemKind)[Object.values(mainExports.CompletionItemKind).indexOf(itemKind)] : void 0;
    let text = (_c = (_b = (_a = item.textEdit) == null ? void 0 : _a.newText) != null ? _b : item.insertText) != null ? _c : item.label;
    let filterText;
    if (item.filterText) {
      const firstWordMatch = item.filterText.match(/\w+/);
      const firstWord = firstWordMatch ? firstWordMatch[0] : null;
      if (firstWord) {
        const wordRegex = new RegExp(`\\b${firstWord}\\b`, "i");
        if (!wordRegex.test(text)) {
          text = `${item.filterText} ${text}`;
          filterText = item.filterText;
        }
      } else {
        if (!text.includes(item.filterText)) {
          text = `${item.filterText} ${text}`;
          filterText = item.filterText;
        }
      }
    }
    let command = ((_d = item.command) == null ? void 0 : _d.command) == "editor.action.triggerSuggest" ? "startAutocomplete" : void 0;
    let range = item.textEdit ? getTextEditRange(item.textEdit, filterText) : void 0;
    let completion = {
      meta: kind,
      caption: item.label,
      score: void 0
    };
    completion["command"] = command;
    completion["range"] = range;
    completion["item"] = item;
    if (item.insertTextFormat == mainExports.InsertTextFormat.Snippet) {
      completion["snippet"] = text;
    } else {
      completion["value"] = text != null ? text : "";
    }
    completion["documentation"] = item.documentation;
    completion["position"] = item["position"];
    completion["service"] = item["service"];
    return completion;
  }
  function toCompletions(completions) {
    if (completions.length > 0) {
      let combinedCompletions = getCompletionItems(completions);
      return combinedCompletions.map((item) => toCompletion(item));
    }
    return [];
  }
  function getCompletionItems(completions) {
    return completions.map((el) => {
      if (!el.completions) {
        return [];
      }
      let allCompletions;
      if (Array.isArray(el.completions)) {
        allCompletions = el.completions;
      } else {
        allCompletions = el.completions.items;
      }
      return allCompletions.map((item) => {
        item["service"] = el.service;
        return item;
      });
    }).flat();
  }
  function toInlineCompletion(item) {
    var _a;
    let text = typeof item.insertText === "string" ? item.insertText : item.insertText.value;
    let filterText;
    if (item.filterText) {
      const firstWordMatch = item.filterText.match(/\w+/);
      const firstWord = firstWordMatch ? firstWordMatch[0] : null;
      if (firstWord) {
        const wordRegex = new RegExp(`\\b${firstWord}\\b`, "i");
        if (!wordRegex.test(text)) {
          text = `${item.filterText} ${text}`;
          filterText = item.filterText;
        }
      } else {
        if (!text.includes(item.filterText)) {
          text = `${item.filterText} ${text}`;
          filterText = item.filterText;
        }
      }
    }
    let command = ((_a = item.command) == null ? void 0 : _a.command) == "editor.action.triggerSuggest" ? "startAutocomplete" : void 0;
    let range = item.range ? getInlineCompletionRange(item.range, filterText) : void 0;
    let completion = {};
    completion["command"] = command;
    completion["range"] = range;
    completion["item"] = item;
    if (typeof item.insertText !== "string") {
      completion["snippet"] = text;
    } else {
      completion["value"] = text != null ? text : "";
    }
    completion["position"] = item["position"];
    completion["service"] = item["service"];
    return completion;
  }
  function toInlineCompletions(completions) {
    if (completions.length > 0) {
      let combinedCompletions = getCompletionItems(completions);
      return combinedCompletions.map((item) => toInlineCompletion(item));
    }
    return [];
  }
  function toResolvedCompletion(completion, item) {
    completion["docMarkdown"] = fromMarkupContent(item.documentation);
    return completion;
  }
  function toCompletionItem(completion) {
    var _a, _b, _c;
    let command;
    if (completion["command"]) {
      command = {
        title: "triggerSuggest",
        command: completion["command"]
      };
    }
    let completionItem = {
      label: (_a = completion.caption) != null ? _a : "",
      kind: CommonConverter.convertKind(completion.meta),
      command,
      insertTextFormat: completion["snippet"] ? mainExports.InsertTextFormat.Snippet : mainExports.InsertTextFormat.PlainText,
      documentation: completion["documentation"]
    };
    if (completion["range"]) {
      completionItem.textEdit = {
        range: fromRange(completion["range"]),
        newText: (_b = completion["snippet"]) != null ? _b : completion["value"]
      };
    } else {
      completionItem.insertText = (_c = completion["snippet"]) != null ? _c : completion["value"];
    }
    completionItem["fileName"] = completion["fileName"];
    completionItem["position"] = completion["position"];
    completionItem["item"] = completion["item"];
    completionItem["service"] = completion["service"];
    return completionItem;
  }
  function getTextEditRange(textEdit, filterText) {
    const filterLength = filterText ? filterText.length : 0;
    if ("insert" in textEdit && "replace" in textEdit) {
      let mergedRanges = mergeRanges([toRange(textEdit.insert), toRange(textEdit.replace)]);
      return mergedRanges[0];
    } else {
      textEdit.range.start.character -= filterLength;
      return toRange(textEdit.range);
    }
  }
  function getInlineCompletionRange(range, filterText) {
    const filterLength = filterText ? filterText.length : 0;
    range.start.character -= filterLength;
    return toRange(range);
  }
  function toTooltip(hover) {
    var _a;
    if (!hover)
      return;
    let content = hover.map((el) => {
      if (!el || !el.contents)
        return;
      if (mainExports.MarkupContent.is(el.contents)) {
        return fromMarkupContent(el.contents);
      } else if (mainExports.MarkedString.is(el.contents)) {
        if (typeof el.contents === "string") {
          return el.contents;
        }
        return "```" + el.contents.value + "```";
      } else {
        let contents = el.contents.map((el2) => {
          if (typeof el2 !== "string") {
            return `\`\`\`${el2.value}\`\`\``;
          } else {
            return el2;
          }
        });
        return contents.join("\n\n");
      }
    }).filter(notEmpty);
    if (content.length === 0)
      return;
    let lspRange = (_a = hover.find((el) => el == null ? void 0 : el.range)) == null ? void 0 : _a.range;
    let range;
    if (lspRange) range = toRange(lspRange);
    return {
      content: {
        type: "markdown",
        text: content.join("\n\n")
      },
      range
    };
  }
  function fromSignatureHelp(signatureHelp) {
    if (!signatureHelp)
      return;
    let content = signatureHelp.map((el) => {
      if (!el)
        return;
      let signatureIndex = (el == null ? void 0 : el.activeSignature) || 0;
      let activeSignature = el.signatures[signatureIndex];
      if (!activeSignature)
        return;
      let activeParam = el == null ? void 0 : el.activeParameter;
      let contents = activeSignature.label;
      if (activeParam != void 0 && activeSignature.parameters && activeSignature.parameters[activeParam]) {
        let param = activeSignature.parameters[activeParam].label;
        if (typeof param == "string") {
          contents = contents.replace(param, `**${param}**`);
        }
      }
      if (activeSignature.documentation) {
        if (mainExports.MarkupContent.is(activeSignature.documentation)) {
          return contents + "\n\n" + fromMarkupContent(activeSignature.documentation);
        } else {
          contents += "\n\n" + activeSignature.documentation;
          return contents;
        }
      } else {
        return contents;
      }
    }).filter(notEmpty);
    if (content.length === 0)
      return;
    return {
      content: {
        type: "markdown",
        text: content.join("\n\n")
      }
    };
  }
  function fromMarkupContent(content) {
    if (!content)
      return;
    if (typeof content === "string") {
      return content;
    } else {
      return content.value;
    }
  }
  function fromAceDelta(delta, eol) {
    const text = delta.lines.length > 1 ? delta.lines.join(eol) : delta.lines[0];
    return {
      range: delta.action === "insert" ? rangeFromPositions(fromPoint(delta.start), fromPoint(delta.start)) : rangeFromPositions(fromPoint(delta.start), fromPoint(delta.end)),
      text: delta.action === "insert" ? text : ""
    };
  }
  function fromDocumentHighlights(documentHighlights) {
    return documentHighlights.map(function(el) {
      let className = el.kind == 2 ? "language_highlight_read" : el.kind == 3 ? "language_highlight_write" : "language_highlight_text";
      return toMarkerGroupItem(CommonConverter.toRange(toRange(el.range)), className);
    });
  }
  function toMarkerGroupItem(range, className, tooltipText) {
    let markerGroupItem = {
      range,
      className
    };
    if (tooltipText) {
      markerGroupItem["tooltipText"] = tooltipText;
    }
    return markerGroupItem;
  }
  var showdown$2 = { exports: {} };
  var showdown$1 = showdown$2.exports;
  var hasRequiredShowdown;
  function requireShowdown() {
    if (hasRequiredShowdown) return showdown$2.exports;
    hasRequiredShowdown = 1;
    (function(module2) {
      (function() {
        function getDefaultOpts(simple) {
          var defaultOptions = {
            omitExtraWLInCodeBlocks: {
              defaultValue: false,
              describe: "Omit the default extra whiteline added to code blocks",
              type: "boolean"
            },
            noHeaderId: {
              defaultValue: false,
              describe: "Turn on/off generated header id",
              type: "boolean"
            },
            prefixHeaderId: {
              defaultValue: false,
              describe: "Add a prefix to the generated header ids. Passing a string will prefix that string to the header id. Setting to true will add a generic 'section-' prefix",
              type: "string"
            },
            rawPrefixHeaderId: {
              defaultValue: false,
              describe: 'Setting this option to true will prevent showdown from modifying the prefix. This might result in malformed IDs (if, for instance, the " char is used in the prefix)',
              type: "boolean"
            },
            ghCompatibleHeaderId: {
              defaultValue: false,
              describe: "Generate header ids compatible with github style (spaces are replaced with dashes, a bunch of non alphanumeric chars are removed)",
              type: "boolean"
            },
            rawHeaderId: {
              defaultValue: false,
              describe: `Remove only spaces, ' and " from generated header ids (including prefixes), replacing them with dashes (-). WARNING: This might result in malformed ids`,
              type: "boolean"
            },
            headerLevelStart: {
              defaultValue: false,
              describe: "The header blocks level start",
              type: "integer"
            },
            parseImgDimensions: {
              defaultValue: false,
              describe: "Turn on/off image dimension parsing",
              type: "boolean"
            },
            simplifiedAutoLink: {
              defaultValue: false,
              describe: "Turn on/off GFM autolink style",
              type: "boolean"
            },
            excludeTrailingPunctuationFromURLs: {
              defaultValue: false,
              describe: "Excludes trailing punctuation from links generated with autoLinking",
              type: "boolean"
            },
            literalMidWordUnderscores: {
              defaultValue: false,
              describe: "Parse midword underscores as literal underscores",
              type: "boolean"
            },
            literalMidWordAsterisks: {
              defaultValue: false,
              describe: "Parse midword asterisks as literal asterisks",
              type: "boolean"
            },
            strikethrough: {
              defaultValue: false,
              describe: "Turn on/off strikethrough support",
              type: "boolean"
            },
            tables: {
              defaultValue: false,
              describe: "Turn on/off tables support",
              type: "boolean"
            },
            tablesHeaderId: {
              defaultValue: false,
              describe: "Add an id to table headers",
              type: "boolean"
            },
            ghCodeBlocks: {
              defaultValue: true,
              describe: "Turn on/off GFM fenced code blocks support",
              type: "boolean"
            },
            tasklists: {
              defaultValue: false,
              describe: "Turn on/off GFM tasklist support",
              type: "boolean"
            },
            smoothLivePreview: {
              defaultValue: false,
              describe: "Prevents weird effects in live previews due to incomplete input",
              type: "boolean"
            },
            smartIndentationFix: {
              defaultValue: false,
              describe: "Tries to smartly fix indentation in es6 strings",
              type: "boolean"
            },
            disableForced4SpacesIndentedSublists: {
              defaultValue: false,
              describe: "Disables the requirement of indenting nested sublists by 4 spaces",
              type: "boolean"
            },
            simpleLineBreaks: {
              defaultValue: false,
              describe: "Parses simple line breaks as <br> (GFM Style)",
              type: "boolean"
            },
            requireSpaceBeforeHeadingText: {
              defaultValue: false,
              describe: "Makes adding a space between `#` and the header text mandatory (GFM Style)",
              type: "boolean"
            },
            ghMentions: {
              defaultValue: false,
              describe: "Enables github @mentions",
              type: "boolean"
            },
            ghMentionsLink: {
              defaultValue: "https://github.com/{u}",
              describe: "Changes the link generated by @mentions. Only applies if ghMentions option is enabled.",
              type: "string"
            },
            encodeEmails: {
              defaultValue: true,
              describe: "Encode e-mail addresses through the use of Character Entities, transforming ASCII e-mail addresses into its equivalent decimal entities",
              type: "boolean"
            },
            openLinksInNewWindow: {
              defaultValue: false,
              describe: "Open all links in new windows",
              type: "boolean"
            },
            backslashEscapesHTMLTags: {
              defaultValue: false,
              describe: "Support for HTML Tag escaping. ex: <div>foo</div>",
              type: "boolean"
            },
            emoji: {
              defaultValue: false,
              describe: "Enable emoji support. Ex: `this is a :smile: emoji`",
              type: "boolean"
            },
            underline: {
              defaultValue: false,
              describe: "Enable support for underline. Syntax is double or triple underscores: `__underline word__`. With this option enabled, underscores no longer parses into `<em>` and `<strong>`",
              type: "boolean"
            },
            ellipsis: {
              defaultValue: true,
              describe: "Replaces three dots with the ellipsis unicode character",
              type: "boolean"
            },
            completeHTMLDocument: {
              defaultValue: false,
              describe: "Outputs a complete html document, including `<html>`, `<head>` and `<body>` tags",
              type: "boolean"
            },
            metadata: {
              defaultValue: false,
              describe: "Enable support for document metadata (defined at the top of the document between `` and `` or between `---` and `---`).",
              type: "boolean"
            },
            splitAdjacentBlockquotes: {
              defaultValue: false,
              describe: "Split adjacent blockquote blocks",
              type: "boolean"
            }
          };
          if (simple === false) {
            return JSON.parse(JSON.stringify(defaultOptions));
          }
          var ret = {};
          for (var opt in defaultOptions) {
            if (defaultOptions.hasOwnProperty(opt)) {
              ret[opt] = defaultOptions[opt].defaultValue;
            }
          }
          return ret;
        }
        function allOptionsOn() {
          var options = getDefaultOpts(true), ret = {};
          for (var opt in options) {
            if (options.hasOwnProperty(opt)) {
              ret[opt] = true;
            }
          }
          return ret;
        }
        var showdown2 = {}, parsers = {}, extensions = {}, globalOptions = getDefaultOpts(true), setFlavor = "vanilla", flavor = {
          github: {
            omitExtraWLInCodeBlocks: true,
            simplifiedAutoLink: true,
            excludeTrailingPunctuationFromURLs: true,
            literalMidWordUnderscores: true,
            strikethrough: true,
            tables: true,
            tablesHeaderId: true,
            ghCodeBlocks: true,
            tasklists: true,
            disableForced4SpacesIndentedSublists: true,
            simpleLineBreaks: true,
            requireSpaceBeforeHeadingText: true,
            ghCompatibleHeaderId: true,
            ghMentions: true,
            backslashEscapesHTMLTags: true,
            emoji: true,
            splitAdjacentBlockquotes: true
          },
          original: {
            noHeaderId: true,
            ghCodeBlocks: false
          },
          ghost: {
            omitExtraWLInCodeBlocks: true,
            parseImgDimensions: true,
            simplifiedAutoLink: true,
            excludeTrailingPunctuationFromURLs: true,
            literalMidWordUnderscores: true,
            strikethrough: true,
            tables: true,
            tablesHeaderId: true,
            ghCodeBlocks: true,
            tasklists: true,
            smoothLivePreview: true,
            simpleLineBreaks: true,
            requireSpaceBeforeHeadingText: true,
            ghMentions: false,
            encodeEmails: true
          },
          vanilla: getDefaultOpts(true),
          allOn: allOptionsOn()
        };
        showdown2.helper = {};
        showdown2.extensions = {};
        showdown2.setOption = function(key, value) {
          globalOptions[key] = value;
          return this;
        };
        showdown2.getOption = function(key) {
          return globalOptions[key];
        };
        showdown2.getOptions = function() {
          return globalOptions;
        };
        showdown2.resetOptions = function() {
          globalOptions = getDefaultOpts(true);
        };
        showdown2.setFlavor = function(name) {
          if (!flavor.hasOwnProperty(name)) {
            throw Error(name + " flavor was not found");
          }
          showdown2.resetOptions();
          var preset = flavor[name];
          setFlavor = name;
          for (var option in preset) {
            if (preset.hasOwnProperty(option)) {
              globalOptions[option] = preset[option];
            }
          }
        };
        showdown2.getFlavor = function() {
          return setFlavor;
        };
        showdown2.getFlavorOptions = function(name) {
          if (flavor.hasOwnProperty(name)) {
            return flavor[name];
          }
        };
        showdown2.getDefaultOptions = function(simple) {
          return getDefaultOpts(simple);
        };
        showdown2.subParser = function(name, func) {
          if (showdown2.helper.isString(name)) {
            if (typeof func !== "undefined") {
              parsers[name] = func;
            } else {
              if (parsers.hasOwnProperty(name)) {
                return parsers[name];
              } else {
                throw Error("SubParser named " + name + " not registered!");
              }
            }
          }
        };
        showdown2.extension = function(name, ext) {
          if (!showdown2.helper.isString(name)) {
            throw Error("Extension 'name' must be a string");
          }
          name = showdown2.helper.stdExtName(name);
          if (showdown2.helper.isUndefined(ext)) {
            if (!extensions.hasOwnProperty(name)) {
              throw Error("Extension named " + name + " is not registered!");
            }
            return extensions[name];
          } else {
            if (typeof ext === "function") {
              ext = ext();
            }
            if (!showdown2.helper.isArray(ext)) {
              ext = [ext];
            }
            var validExtension = validate(ext, name);
            if (validExtension.valid) {
              extensions[name] = ext;
            } else {
              throw Error(validExtension.error);
            }
          }
        };
        showdown2.getAllExtensions = function() {
          return extensions;
        };
        showdown2.removeExtension = function(name) {
          delete extensions[name];
        };
        showdown2.resetExtensions = function() {
          extensions = {};
        };
        function validate(extension, name) {
          var errMsg = name ? "Error in " + name + " extension->" : "Error in unnamed extension", ret = {
            valid: true,
            error: ""
          };
          if (!showdown2.helper.isArray(extension)) {
            extension = [extension];
          }
          for (var i = 0; i < extension.length; ++i) {
            var baseMsg = errMsg + " sub-extension " + i + ": ", ext = extension[i];
            if (typeof ext !== "object") {
              ret.valid = false;
              ret.error = baseMsg + "must be an object, but " + typeof ext + " given";
              return ret;
            }
            if (!showdown2.helper.isString(ext.type)) {
              ret.valid = false;
              ret.error = baseMsg + 'property "type" must be a string, but ' + typeof ext.type + " given";
              return ret;
            }
            var type = ext.type = ext.type.toLowerCase();
            if (type === "language") {
              type = ext.type = "lang";
            }
            if (type === "html") {
              type = ext.type = "output";
            }
            if (type !== "lang" && type !== "output" && type !== "listener") {
              ret.valid = false;
              ret.error = baseMsg + "type " + type + ' is not recognized. Valid values: "lang/language", "output/html" or "listener"';
              return ret;
            }
            if (type === "listener") {
              if (showdown2.helper.isUndefined(ext.listeners)) {
                ret.valid = false;
                ret.error = baseMsg + '. Extensions of type "listener" must have a property called "listeners"';
                return ret;
              }
            } else {
              if (showdown2.helper.isUndefined(ext.filter) && showdown2.helper.isUndefined(ext.regex)) {
                ret.valid = false;
                ret.error = baseMsg + type + ' extensions must define either a "regex" property or a "filter" method';
                return ret;
              }
            }
            if (ext.listeners) {
              if (typeof ext.listeners !== "object") {
                ret.valid = false;
                ret.error = baseMsg + '"listeners" property must be an object but ' + typeof ext.listeners + " given";
                return ret;
              }
              for (var ln in ext.listeners) {
                if (ext.listeners.hasOwnProperty(ln)) {
                  if (typeof ext.listeners[ln] !== "function") {
                    ret.valid = false;
                    ret.error = baseMsg + '"listeners" property must be an hash of [event name]: [callback]. listeners.' + ln + " must be a function but " + typeof ext.listeners[ln] + " given";
                    return ret;
                  }
                }
              }
            }
            if (ext.filter) {
              if (typeof ext.filter !== "function") {
                ret.valid = false;
                ret.error = baseMsg + '"filter" must be a function, but ' + typeof ext.filter + " given";
                return ret;
              }
            } else if (ext.regex) {
              if (showdown2.helper.isString(ext.regex)) {
                ext.regex = new RegExp(ext.regex, "g");
              }
              if (!(ext.regex instanceof RegExp)) {
                ret.valid = false;
                ret.error = baseMsg + '"regex" property must either be a string or a RegExp object, but ' + typeof ext.regex + " given";
                return ret;
              }
              if (showdown2.helper.isUndefined(ext.replace)) {
                ret.valid = false;
                ret.error = baseMsg + '"regex" extensions must implement a replace string or function';
                return ret;
              }
            }
          }
          return ret;
        }
        showdown2.validateExtension = function(ext) {
          var validateExtension = validate(ext, null);
          if (!validateExtension.valid) {
            console.warn(validateExtension.error);
            return false;
          }
          return true;
        };
        if (!showdown2.hasOwnProperty("helper")) {
          showdown2.helper = {};
        }
        showdown2.helper.isString = function(a) {
          return typeof a === "string" || a instanceof String;
        };
        showdown2.helper.isFunction = function(a) {
          var getType = {};
          return a && getType.toString.call(a) === "[object Function]";
        };
        showdown2.helper.isArray = function(a) {
          return Array.isArray(a);
        };
        showdown2.helper.isUndefined = function(value) {
          return typeof value === "undefined";
        };
        showdown2.helper.forEach = function(obj, callback) {
          if (showdown2.helper.isUndefined(obj)) {
            throw new Error("obj param is required");
          }
          if (showdown2.helper.isUndefined(callback)) {
            throw new Error("callback param is required");
          }
          if (!showdown2.helper.isFunction(callback)) {
            throw new Error("callback param must be a function/closure");
          }
          if (typeof obj.forEach === "function") {
            obj.forEach(callback);
          } else if (showdown2.helper.isArray(obj)) {
            for (var i = 0; i < obj.length; i++) {
              callback(obj[i], i, obj);
            }
          } else if (typeof obj === "object") {
            for (var prop in obj) {
              if (obj.hasOwnProperty(prop)) {
                callback(obj[prop], prop, obj);
              }
            }
          } else {
            throw new Error("obj does not seem to be an array or an iterable object");
          }
        };
        showdown2.helper.stdExtName = function(s) {
          return s.replace(/[_?*+\/\\.^-]/g, "").replace(/\s/g, "").toLowerCase();
        };
        function escapeCharactersCallback(wholeMatch, m1) {
          var charCodeToEscape = m1.charCodeAt(0);
          return "E" + charCodeToEscape + "E";
        }
        showdown2.helper.escapeCharactersCallback = escapeCharactersCallback;
        showdown2.helper.escapeCharacters = function(text, charsToEscape, afterBackslash) {
          var regexString = "([" + charsToEscape.replace(/([\[\]\\])/g, "\\$1") + "])";
          if (afterBackslash) {
            regexString = "\\\\" + regexString;
          }
          var regex = new RegExp(regexString, "g");
          text = text.replace(regex, escapeCharactersCallback);
          return text;
        };
        showdown2.helper.unescapeHTMLEntities = function(txt) {
          return txt.replace(/&quot;/g, '"').replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
        };
        var rgxFindMatchPos = function(str, left, right, flags) {
          var f = flags || "", g = f.indexOf("g") > -1, x = new RegExp(left + "|" + right, "g" + f.replace(/g/g, "")), l = new RegExp(left, f.replace(/g/g, "")), pos = [], t, s, m, start, end;
          do {
            t = 0;
            while (m = x.exec(str)) {
              if (l.test(m[0])) {
                if (!t++) {
                  s = x.lastIndex;
                  start = s - m[0].length;
                }
              } else if (t) {
                if (!--t) {
                  end = m.index + m[0].length;
                  var obj = {
                    left: { start, end: s },
                    match: { start: s, end: m.index },
                    right: { start: m.index, end },
                    wholeMatch: { start, end }
                  };
                  pos.push(obj);
                  if (!g) {
                    return pos;
                  }
                }
              }
            }
          } while (t && (x.lastIndex = s));
          return pos;
        };
        showdown2.helper.matchRecursiveRegExp = function(str, left, right, flags) {
          var matchPos = rgxFindMatchPos(str, left, right, flags), results = [];
          for (var i = 0; i < matchPos.length; ++i) {
            results.push([
              str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),
              str.slice(matchPos[i].match.start, matchPos[i].match.end),
              str.slice(matchPos[i].left.start, matchPos[i].left.end),
              str.slice(matchPos[i].right.start, matchPos[i].right.end)
            ]);
          }
          return results;
        };
        showdown2.helper.replaceRecursiveRegExp = function(str, replacement, left, right, flags) {
          if (!showdown2.helper.isFunction(replacement)) {
            var repStr = replacement;
            replacement = function() {
              return repStr;
            };
          }
          var matchPos = rgxFindMatchPos(str, left, right, flags), finalStr = str, lng = matchPos.length;
          if (lng > 0) {
            var bits = [];
            if (matchPos[0].wholeMatch.start !== 0) {
              bits.push(str.slice(0, matchPos[0].wholeMatch.start));
            }
            for (var i = 0; i < lng; ++i) {
              bits.push(
                replacement(
                  str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),
                  str.slice(matchPos[i].match.start, matchPos[i].match.end),
                  str.slice(matchPos[i].left.start, matchPos[i].left.end),
                  str.slice(matchPos[i].right.start, matchPos[i].right.end)
                )
              );
              if (i < lng - 1) {
                bits.push(str.slice(matchPos[i].wholeMatch.end, matchPos[i + 1].wholeMatch.start));
              }
            }
            if (matchPos[lng - 1].wholeMatch.end < str.length) {
              bits.push(str.slice(matchPos[lng - 1].wholeMatch.end));
            }
            finalStr = bits.join("");
          }
          return finalStr;
        };
        showdown2.helper.regexIndexOf = function(str, regex, fromIndex) {
          if (!showdown2.helper.isString(str)) {
            throw "InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string";
          }
          if (regex instanceof RegExp === false) {
            throw "InvalidArgumentError: second parameter of showdown.helper.regexIndexOf function must be an instance of RegExp";
          }
          var indexOf = str.substring(fromIndex || 0).search(regex);
          return indexOf >= 0 ? indexOf + (fromIndex || 0) : indexOf;
        };
        showdown2.helper.splitAtIndex = function(str, index) {
          if (!showdown2.helper.isString(str)) {
            throw "InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string";
          }
          return [str.substring(0, index), str.substring(index)];
        };
        showdown2.helper.encodeEmailAddress = function(mail) {
          var encode = [
            function(ch) {
              return "&#" + ch.charCodeAt(0) + ";";
            },
            function(ch) {
              return "&#x" + ch.charCodeAt(0).toString(16) + ";";
            },
            function(ch) {
              return ch;
            }
          ];
          mail = mail.replace(/./g, function(ch) {
            if (ch === "@") {
              ch = encode[Math.floor(Math.random() * 2)](ch);
            } else {
              var r = Math.random();
              ch = r > 0.9 ? encode[2](ch) : r > 0.45 ? encode[1](ch) : encode[0](ch);
            }
            return ch;
          });
          return mail;
        };
        showdown2.helper.padEnd = function padEnd(str, targetLength, padString) {
          targetLength = targetLength >> 0;
          padString = String(padString || " ");
          if (str.length > targetLength) {
            return String(str);
          } else {
            targetLength = targetLength - str.length;
            if (targetLength > padString.length) {
              padString += padString.repeat(targetLength / padString.length);
            }
            return String(str) + padString.slice(0, targetLength);
          }
        };
        if (typeof console === "undefined") {
          console = {
            warn: function(msg) {
              alert(msg);
            },
            log: function(msg) {
              alert(msg);
            },
            error: function(msg) {
              throw msg;
            }
          };
        }
        showdown2.helper.regexes = {
          asteriskDashAndColon: /([*_:~])/g
        };
        showdown2.helper.emojis = {
          "+1": "",
          "-1": "",
          "100": "",
          "1234": "",
          "1st_place_medal": "",
          "2nd_place_medal": "",
          "3rd_place_medal": "",
          "8ball": "",
          "a": "",
          "ab": "",
          "abc": "",
          "abcd": "",
          "accept": "",
          "aerial_tramway": "",
          "airplane": "",
          "alarm_clock": "",
          "alembic": "",
          "alien": "",
          "ambulance": "",
          "amphora": "",
          "anchor": "",
          "angel": "",
          "anger": "",
          "angry": "",
          "anguished": "",
          "ant": "",
          "apple": "",
          "aquarius": "",
          "aries": "",
          "arrow_backward": "",
          "arrow_double_down": "",
          "arrow_double_up": "",
          "arrow_down": "",
          "arrow_down_small": "",
          "arrow_forward": "",
          "arrow_heading_down": "",
          "arrow_heading_up": "",
          "arrow_left": "",
          "arrow_lower_left": "",
          "arrow_lower_right": "",
          "arrow_right": "",
          "arrow_right_hook": "",
          "arrow_up": "",
          "arrow_up_down": "",
          "arrow_up_small": "",
          "arrow_upper_left": "",
          "arrow_upper_right": "",
          "arrows_clockwise": "",
          "arrows_counterclockwise": "",
          "art": "",
          "articulated_lorry": "",
          "artificial_satellite": "",
          "astonished": "",
          "athletic_shoe": "",
          "atm": "",
          "atom_symbol": "",
          "avocado": "",
          "b": "",
          "baby": "",
          "baby_bottle": "",
          "baby_chick": "",
          "baby_symbol": "",
          "back": "",
          "bacon": "",
          "badminton": "",
          "baggage_claim": "",
          "baguette_bread": "",
          "balance_scale": "",
          "balloon": "",
          "ballot_box": "",
          "ballot_box_with_check": "",
          "bamboo": "",
          "banana": "",
          "bangbang": "",
          "bank": "",
          "bar_chart": "",
          "barber": "",
          "baseball": "",
          "basketball": "",
          "basketball_man": "",
          "basketball_woman": "&zwj;",
          "bat": "",
          "bath": "",
          "bathtub": "",
          "battery": "",
          "beach_umbrella": "",
          "bear": "",
          "bed": "",
          "bee": "",
          "beer": "",
          "beers": "",
          "beetle": "",
          "beginner": "",
          "bell": "",
          "bellhop_bell": "",
          "bento": "",
          "biking_man": "",
          "bike": "",
          "biking_woman": "&zwj;",
          "bikini": "",
          "biohazard": "",
          "bird": "",
          "birthday": "",
          "black_circle": "",
          "black_flag": "",
          "black_heart": "",
          "black_joker": "",
          "black_large_square": "",
          "black_medium_small_square": "",
          "black_medium_square": "",
          "black_nib": "",
          "black_small_square": "",
          "black_square_button": "",
          "blonde_man": "",
          "blonde_woman": "&zwj;",
          "blossom": "",
          "blowfish": "",
          "blue_book": "",
          "blue_car": "",
          "blue_heart": "",
          "blush": "",
          "boar": "",
          "boat": "",
          "bomb": "",
          "book": "",
          "bookmark": "",
          "bookmark_tabs": "",
          "books": "",
          "boom": "",
          "boot": "",
          "bouquet": "",
          "bowing_man": "",
          "bow_and_arrow": "",
          "bowing_woman": "&zwj;",
          "bowling": "",
          "boxing_glove": "",
          "boy": "",
          "bread": "",
          "bride_with_veil": "",
          "bridge_at_night": "",
          "briefcase": "",
          "broken_heart": "",
          "bug": "",
          "building_construction": "",
          "bulb": "",
          "bullettrain_front": "",
          "bullettrain_side": "",
          "burrito": "",
          "bus": "",
          "business_suit_levitating": "",
          "busstop": "",
          "bust_in_silhouette": "",
          "busts_in_silhouette": "",
          "butterfly": "",
          "cactus": "",
          "cake": "",
          "calendar": "",
          "call_me_hand": "",
          "calling": "",
          "camel": "",
          "camera": "",
          "camera_flash": "",
          "camping": "",
          "cancer": "",
          "candle": "",
          "candy": "",
          "canoe": "",
          "capital_abcd": "",
          "capricorn": "",
          "car": "",
          "card_file_box": "",
          "card_index": "",
          "card_index_dividers": "",
          "carousel_horse": "",
          "carrot": "",
          "cat": "",
          "cat2": "",
          "cd": "",
          "chains": "",
          "champagne": "",
          "chart": "",
          "chart_with_downwards_trend": "",
          "chart_with_upwards_trend": "",
          "checkered_flag": "",
          "cheese": "",
          "cherries": "",
          "cherry_blossom": "",
          "chestnut": "",
          "chicken": "",
          "children_crossing": "",
          "chipmunk": "",
          "chocolate_bar": "",
          "christmas_tree": "",
          "church": "",
          "cinema": "",
          "circus_tent": "",
          "city_sunrise": "",
          "city_sunset": "",
          "cityscape": "",
          "cl": "",
          "clamp": "",
          "clap": "",
          "clapper": "",
          "classical_building": "",
          "clinking_glasses": "",
          "clipboard": "",
          "clock1": "",
          "clock10": "",
          "clock1030": "",
          "clock11": "",
          "clock1130": "",
          "clock12": "",
          "clock1230": "",
          "clock130": "",
          "clock2": "",
          "clock230": "",
          "clock3": "",
          "clock330": "",
          "clock4": "",
          "clock430": "",
          "clock5": "",
          "clock530": "",
          "clock6": "",
          "clock630": "",
          "clock7": "",
          "clock730": "",
          "clock8": "",
          "clock830": "",
          "clock9": "",
          "clock930": "",
          "closed_book": "",
          "closed_lock_with_key": "",
          "closed_umbrella": "",
          "cloud": "",
          "cloud_with_lightning": "",
          "cloud_with_lightning_and_rain": "",
          "cloud_with_rain": "",
          "cloud_with_snow": "",
          "clown_face": "",
          "clubs": "",
          "cocktail": "",
          "coffee": "",
          "coffin": "",
          "cold_sweat": "",
          "comet": "",
          "computer": "",
          "computer_mouse": "",
          "confetti_ball": "",
          "confounded": "",
          "confused": "",
          "congratulations": "",
          "construction": "",
          "construction_worker_man": "",
          "construction_worker_woman": "&zwj;",
          "control_knobs": "",
          "convenience_store": "",
          "cookie": "",
          "cool": "",
          "policeman": "",
          "copyright": "",
          "corn": "",
          "couch_and_lamp": "",
          "couple": "",
          "couple_with_heart_woman_man": "",
          "couple_with_heart_man_man": "&zwj;&zwj;",
          "couple_with_heart_woman_woman": "&zwj;&zwj;",
          "couplekiss_man_man": "&zwj;&zwj;&zwj;",
          "couplekiss_man_woman": "",
          "couplekiss_woman_woman": "&zwj;&zwj;&zwj;",
          "cow": "",
          "cow2": "",
          "cowboy_hat_face": "",
          "crab": "",
          "crayon": "",
          "credit_card": "",
          "crescent_moon": "",
          "cricket": "",
          "crocodile": "",
          "croissant": "",
          "crossed_fingers": "",
          "crossed_flags": "",
          "crossed_swords": "",
          "crown": "",
          "cry": "",
          "crying_cat_face": "",
          "crystal_ball": "",
          "cucumber": "",
          "cupid": "",
          "curly_loop": "",
          "currency_exchange": "",
          "curry": "",
          "custard": "",
          "customs": "",
          "cyclone": "",
          "dagger": "",
          "dancer": "",
          "dancing_women": "",
          "dancing_men": "&zwj;",
          "dango": "",
          "dark_sunglasses": "",
          "dart": "",
          "dash": "",
          "date": "",
          "deciduous_tree": "",
          "deer": "",
          "department_store": "",
          "derelict_house": "",
          "desert": "",
          "desert_island": "",
          "desktop_computer": "",
          "male_detective": "",
          "diamond_shape_with_a_dot_inside": "",
          "diamonds": "",
          "disappointed": "",
          "disappointed_relieved": "",
          "dizzy": "",
          "dizzy_face": "",
          "do_not_litter": "",
          "dog": "",
          "dog2": "",
          "dollar": "",
          "dolls": "",
          "dolphin": "",
          "door": "",
          "doughnut": "",
          "dove": "",
          "dragon": "",
          "dragon_face": "",
          "dress": "",
          "dromedary_camel": "",
          "drooling_face": "",
          "droplet": "",
          "drum": "",
          "duck": "",
          "dvd": "",
          "e-mail": "",
          "eagle": "",
          "ear": "",
          "ear_of_rice": "",
          "earth_africa": "",
          "earth_americas": "",
          "earth_asia": "",
          "egg": "",
          "eggplant": "",
          "eight_pointed_black_star": "",
          "eight_spoked_asterisk": "",
          "electric_plug": "",
          "elephant": "",
          "email": "",
          "end": "",
          "envelope_with_arrow": "",
          "euro": "",
          "european_castle": "",
          "european_post_office": "",
          "evergreen_tree": "",
          "exclamation": "",
          "expressionless": "",
          "eye": "",
          "eye_speech_bubble": "&zwj;",
          "eyeglasses": "",
          "eyes": "",
          "face_with_head_bandage": "",
          "face_with_thermometer": "",
          "fist_oncoming": "",
          "factory": "",
          "fallen_leaf": "",
          "family_man_woman_boy": "",
          "family_man_boy": "&zwj;",
          "family_man_boy_boy": "&zwj;&zwj;",
          "family_man_girl": "&zwj;",
          "family_man_girl_boy": "&zwj;&zwj;",
          "family_man_girl_girl": "&zwj;&zwj;",
          "family_man_man_boy": "&zwj;&zwj;",
          "family_man_man_boy_boy": "&zwj;&zwj;&zwj;",
          "family_man_man_girl": "&zwj;&zwj;",
          "family_man_man_girl_boy": "&zwj;&zwj;&zwj;",
          "family_man_man_girl_girl": "&zwj;&zwj;&zwj;",
          "family_man_woman_boy_boy": "&zwj;&zwj;&zwj;",
          "family_man_woman_girl": "&zwj;&zwj;",
          "family_man_woman_girl_boy": "&zwj;&zwj;&zwj;",
          "family_man_woman_girl_girl": "&zwj;&zwj;&zwj;",
          "family_woman_boy": "&zwj;",
          "family_woman_boy_boy": "&zwj;&zwj;",
          "family_woman_girl": "&zwj;",
          "family_woman_girl_boy": "&zwj;&zwj;",
          "family_woman_girl_girl": "&zwj;&zwj;",
          "family_woman_woman_boy": "&zwj;&zwj;",
          "family_woman_woman_boy_boy": "&zwj;&zwj;&zwj;",
          "family_woman_woman_girl": "&zwj;&zwj;",
          "family_woman_woman_girl_boy": "&zwj;&zwj;&zwj;",
          "family_woman_woman_girl_girl": "&zwj;&zwj;&zwj;",
          "fast_forward": "",
          "fax": "",
          "fearful": "",
          "feet": "",
          "female_detective": "&zwj;",
          "ferris_wheel": "",
          "ferry": "",
          "field_hockey": "",
          "file_cabinet": "",
          "file_folder": "",
          "film_projector": "",
          "film_strip": "",
          "fire": "",
          "fire_engine": "",
          "fireworks": "",
          "first_quarter_moon": "",
          "first_quarter_moon_with_face": "",
          "fish": "",
          "fish_cake": "",
          "fishing_pole_and_fish": "",
          "fist_raised": "",
          "fist_left": "",
          "fist_right": "",
          "flags": "",
          "flashlight": "",
          "fleur_de_lis": "",
          "flight_arrival": "",
          "flight_departure": "",
          "floppy_disk": "",
          "flower_playing_cards": "",
          "flushed": "",
          "fog": "",
          "foggy": "",
          "football": "",
          "footprints": "",
          "fork_and_knife": "",
          "fountain": "",
          "fountain_pen": "",
          "four_leaf_clover": "",
          "fox_face": "",
          "framed_picture": "",
          "free": "",
          "fried_egg": "",
          "fried_shrimp": "",
          "fries": "",
          "frog": "",
          "frowning": "",
          "frowning_face": "",
          "frowning_man": "&zwj;",
          "frowning_woman": "",
          "middle_finger": "",
          "fuelpump": "",
          "full_moon": "",
          "full_moon_with_face": "",
          "funeral_urn": "",
          "game_die": "",
          "gear": "",
          "gem": "",
          "gemini": "",
          "ghost": "",
          "gift": "",
          "gift_heart": "",
          "girl": "",
          "globe_with_meridians": "",
          "goal_net": "",
          "goat": "",
          "golf": "",
          "golfing_man": "",
          "golfing_woman": "&zwj;",
          "gorilla": "",
          "grapes": "",
          "green_apple": "",
          "green_book": "",
          "green_heart": "",
          "green_salad": "",
          "grey_exclamation": "",
          "grey_question": "",
          "grimacing": "",
          "grin": "",
          "grinning": "",
          "guardsman": "",
          "guardswoman": "&zwj;",
          "guitar": "",
          "gun": "",
          "haircut_woman": "",
          "haircut_man": "&zwj;",
          "hamburger": "",
          "hammer": "",
          "hammer_and_pick": "",
          "hammer_and_wrench": "",
          "hamster": "",
          "hand": "",
          "handbag": "",
          "handshake": "",
          "hankey": "",
          "hatched_chick": "",
          "hatching_chick": "",
          "headphones": "",
          "hear_no_evil": "",
          "heart": "",
          "heart_decoration": "",
          "heart_eyes": "",
          "heart_eyes_cat": "",
          "heartbeat": "",
          "heartpulse": "",
          "hearts": "",
          "heavy_check_mark": "",
          "heavy_division_sign": "",
          "heavy_dollar_sign": "",
          "heavy_heart_exclamation": "",
          "heavy_minus_sign": "",
          "heavy_multiplication_x": "",
          "heavy_plus_sign": "",
          "helicopter": "",
          "herb": "",
          "hibiscus": "",
          "high_brightness": "",
          "high_heel": "",
          "hocho": "",
          "hole": "",
          "honey_pot": "",
          "horse": "",
          "horse_racing": "",
          "hospital": "",
          "hot_pepper": "",
          "hotdog": "",
          "hotel": "",
          "hotsprings": "",
          "hourglass": "",
          "hourglass_flowing_sand": "",
          "house": "",
          "house_with_garden": "",
          "houses": "",
          "hugs": "",
          "hushed": "",
          "ice_cream": "",
          "ice_hockey": "",
          "ice_skate": "",
          "icecream": "",
          "id": "",
          "ideograph_advantage": "",
          "imp": "",
          "inbox_tray": "",
          "incoming_envelope": "",
          "tipping_hand_woman": "",
          "information_source": "",
          "innocent": "",
          "interrobang": "",
          "iphone": "",
          "izakaya_lantern": "",
          "jack_o_lantern": "",
          "japan": "",
          "japanese_castle": "",
          "japanese_goblin": "",
          "japanese_ogre": "",
          "jeans": "",
          "joy": "",
          "joy_cat": "",
          "joystick": "",
          "kaaba": "",
          "key": "",
          "keyboard": "",
          "keycap_ten": "",
          "kick_scooter": "",
          "kimono": "",
          "kiss": "",
          "kissing": "",
          "kissing_cat": "",
          "kissing_closed_eyes": "",
          "kissing_heart": "",
          "kissing_smiling_eyes": "",
          "kiwi_fruit": "",
          "koala": "",
          "koko": "",
          "label": "",
          "large_blue_circle": "",
          "large_blue_diamond": "",
          "large_orange_diamond": "",
          "last_quarter_moon": "",
          "last_quarter_moon_with_face": "",
          "latin_cross": "",
          "laughing": "",
          "leaves": "",
          "ledger": "",
          "left_luggage": "",
          "left_right_arrow": "",
          "leftwards_arrow_with_hook": "",
          "lemon": "",
          "leo": "",
          "leopard": "",
          "level_slider": "",
          "libra": "",
          "light_rail": "",
          "link": "",
          "lion": "",
          "lips": "",
          "lipstick": "",
          "lizard": "",
          "lock": "",
          "lock_with_ink_pen": "",
          "lollipop": "",
          "loop": "",
          "loud_sound": "",
          "loudspeaker": "",
          "love_hotel": "",
          "love_letter": "",
          "low_brightness": "",
          "lying_face": "",
          "m": "",
          "mag": "",
          "mag_right": "",
          "mahjong": "",
          "mailbox": "",
          "mailbox_closed": "",
          "mailbox_with_mail": "",
          "mailbox_with_no_mail": "",
          "man": "",
          "man_artist": "&zwj;",
          "man_astronaut": "&zwj;",
          "man_cartwheeling": "&zwj;",
          "man_cook": "&zwj;",
          "man_dancing": "",
          "man_facepalming": "&zwj;",
          "man_factory_worker": "&zwj;",
          "man_farmer": "&zwj;",
          "man_firefighter": "&zwj;",
          "man_health_worker": "&zwj;",
          "man_in_tuxedo": "",
          "man_judge": "&zwj;",
          "man_juggling": "&zwj;",
          "man_mechanic": "&zwj;",
          "man_office_worker": "&zwj;",
          "man_pilot": "&zwj;",
          "man_playing_handball": "&zwj;",
          "man_playing_water_polo": "&zwj;",
          "man_scientist": "&zwj;",
          "man_shrugging": "&zwj;",
          "man_singer": "&zwj;",
          "man_student": "&zwj;",
          "man_teacher": "&zwj;",
          "man_technologist": "&zwj;",
          "man_with_gua_pi_mao": "",
          "man_with_turban": "",
          "tangerine": "",
          "mans_shoe": "",
          "mantelpiece_clock": "",
          "maple_leaf": "",
          "martial_arts_uniform": "",
          "mask": "",
          "massage_woman": "",
          "massage_man": "&zwj;",
          "meat_on_bone": "",
          "medal_military": "",
          "medal_sports": "",
          "mega": "",
          "melon": "",
          "memo": "",
          "men_wrestling": "&zwj;",
          "menorah": "",
          "mens": "",
          "metal": "",
          "metro": "",
          "microphone": "",
          "microscope": "",
          "milk_glass": "",
          "milky_way": "",
          "minibus": "",
          "minidisc": "",
          "mobile_phone_off": "",
          "money_mouth_face": "",
          "money_with_wings": "",
          "moneybag": "",
          "monkey": "",
          "monkey_face": "",
          "monorail": "",
          "moon": "",
          "mortar_board": "",
          "mosque": "",
          "motor_boat": "",
          "motor_scooter": "",
          "motorcycle": "",
          "motorway": "",
          "mount_fuji": "",
          "mountain": "",
          "mountain_biking_man": "",
          "mountain_biking_woman": "&zwj;",
          "mountain_cableway": "",
          "mountain_railway": "",
          "mountain_snow": "",
          "mouse": "",
          "mouse2": "",
          "movie_camera": "",
          "moyai": "",
          "mrs_claus": "",
          "muscle": "",
          "mushroom": "",
          "musical_keyboard": "",
          "musical_note": "",
          "musical_score": "",
          "mute": "",
          "nail_care": "",
          "name_badge": "",
          "national_park": "",
          "nauseated_face": "",
          "necktie": "",
          "negative_squared_cross_mark": "",
          "nerd_face": "",
          "neutral_face": "",
          "new": "",
          "new_moon": "",
          "new_moon_with_face": "",
          "newspaper": "",
          "newspaper_roll": "",
          "next_track_button": "",
          "ng": "",
          "no_good_man": "&zwj;",
          "no_good_woman": "",
          "night_with_stars": "",
          "no_bell": "",
          "no_bicycles": "",
          "no_entry": "",
          "no_entry_sign": "",
          "no_mobile_phones": "",
          "no_mouth": "",
          "no_pedestrians": "",
          "no_smoking": "",
          "non-potable_water": "",
          "nose": "",
          "notebook": "",
          "notebook_with_decorative_cover": "",
          "notes": "",
          "nut_and_bolt": "",
          "o": "",
          "o2": "",
          "ocean": "",
          "octopus": "",
          "oden": "",
          "office": "",
          "oil_drum": "",
          "ok": "",
          "ok_hand": "",
          "ok_man": "&zwj;",
          "ok_woman": "",
          "old_key": "",
          "older_man": "",
          "older_woman": "",
          "om": "",
          "on": "",
          "oncoming_automobile": "",
          "oncoming_bus": "",
          "oncoming_police_car": "",
          "oncoming_taxi": "",
          "open_file_folder": "",
          "open_hands": "",
          "open_mouth": "",
          "open_umbrella": "",
          "ophiuchus": "",
          "orange_book": "",
          "orthodox_cross": "",
          "outbox_tray": "",
          "owl": "",
          "ox": "",
          "package": "",
          "page_facing_up": "",
          "page_with_curl": "",
          "pager": "",
          "paintbrush": "",
          "palm_tree": "",
          "pancakes": "",
          "panda_face": "",
          "paperclip": "",
          "paperclips": "",
          "parasol_on_ground": "",
          "parking": "",
          "part_alternation_mark": "",
          "partly_sunny": "",
          "passenger_ship": "",
          "passport_control": "",
          "pause_button": "",
          "peace_symbol": "",
          "peach": "",
          "peanuts": "",
          "pear": "",
          "pen": "",
          "pencil2": "",
          "penguin": "",
          "pensive": "",
          "performing_arts": "",
          "persevere": "",
          "person_fencing": "",
          "pouting_woman": "",
          "phone": "",
          "pick": "",
          "pig": "",
          "pig2": "",
          "pig_nose": "",
          "pill": "",
          "pineapple": "",
          "ping_pong": "",
          "pisces": "",
          "pizza": "",
          "place_of_worship": "",
          "plate_with_cutlery": "",
          "play_or_pause_button": "",
          "point_down": "",
          "point_left": "",
          "point_right": "",
          "point_up": "",
          "point_up_2": "",
          "police_car": "",
          "policewoman": "&zwj;",
          "poodle": "",
          "popcorn": "",
          "post_office": "",
          "postal_horn": "",
          "postbox": "",
          "potable_water": "",
          "potato": "",
          "pouch": "",
          "poultry_leg": "",
          "pound": "",
          "rage": "",
          "pouting_cat": "",
          "pouting_man": "&zwj;",
          "pray": "",
          "prayer_beads": "",
          "pregnant_woman": "",
          "previous_track_button": "",
          "prince": "",
          "princess": "",
          "printer": "",
          "purple_heart": "",
          "purse": "",
          "pushpin": "",
          "put_litter_in_its_place": "",
          "question": "",
          "rabbit": "",
          "rabbit2": "",
          "racehorse": "",
          "racing_car": "",
          "radio": "",
          "radio_button": "",
          "radioactive": "",
          "railway_car": "",
          "railway_track": "",
          "rainbow": "",
          "rainbow_flag": "&zwj;",
          "raised_back_of_hand": "",
          "raised_hand_with_fingers_splayed": "",
          "raised_hands": "",
          "raising_hand_woman": "",
          "raising_hand_man": "&zwj;",
          "ram": "",
          "ramen": "",
          "rat": "",
          "record_button": "",
          "recycle": "",
          "red_circle": "",
          "registered": "",
          "relaxed": "",
          "relieved": "",
          "reminder_ribbon": "",
          "repeat": "",
          "repeat_one": "",
          "rescue_worker_helmet": "",
          "restroom": "",
          "revolving_hearts": "",
          "rewind": "",
          "rhinoceros": "",
          "ribbon": "",
          "rice": "",
          "rice_ball": "",
          "rice_cracker": "",
          "rice_scene": "",
          "right_anger_bubble": "",
          "ring": "",
          "robot": "",
          "rocket": "",
          "rofl": "",
          "roll_eyes": "",
          "roller_coaster": "",
          "rooster": "",
          "rose": "",
          "rosette": "",
          "rotating_light": "",
          "round_pushpin": "",
          "rowing_man": "",
          "rowing_woman": "&zwj;",
          "rugby_football": "",
          "running_man": "",
          "running_shirt_with_sash": "",
          "running_woman": "&zwj;",
          "sa": "",
          "sagittarius": "",
          "sake": "",
          "sandal": "",
          "santa": "",
          "satellite": "",
          "saxophone": "",
          "school": "",
          "school_satchel": "",
          "scissors": "",
          "scorpion": "",
          "scorpius": "",
          "scream": "",
          "scream_cat": "",
          "scroll": "",
          "seat": "",
          "secret": "",
          "see_no_evil": "",
          "seedling": "",
          "selfie": "",
          "shallow_pan_of_food": "",
          "shamrock": "",
          "shark": "",
          "shaved_ice": "",
          "sheep": "",
          "shell": "",
          "shield": "",
          "shinto_shrine": "",
          "ship": "",
          "shirt": "",
          "shopping": "",
          "shopping_cart": "",
          "shower": "",
          "shrimp": "",
          "signal_strength": "",
          "six_pointed_star": "",
          "ski": "",
          "skier": "",
          "skull": "",
          "skull_and_crossbones": "",
          "sleeping": "",
          "sleeping_bed": "",
          "sleepy": "",
          "slightly_frowning_face": "",
          "slightly_smiling_face": "",
          "slot_machine": "",
          "small_airplane": "",
          "small_blue_diamond": "",
          "small_orange_diamond": "",
          "small_red_triangle": "",
          "small_red_triangle_down": "",
          "smile": "",
          "smile_cat": "",
          "smiley": "",
          "smiley_cat": "",
          "smiling_imp": "",
          "smirk": "",
          "smirk_cat": "",
          "smoking": "",
          "snail": "",
          "snake": "",
          "sneezing_face": "",
          "snowboarder": "",
          "snowflake": "",
          "snowman": "",
          "snowman_with_snow": "",
          "sob": "",
          "soccer": "",
          "soon": "",
          "sos": "",
          "sound": "",
          "space_invader": "",
          "spades": "",
          "spaghetti": "",
          "sparkle": "",
          "sparkler": "",
          "sparkles": "",
          "sparkling_heart": "",
          "speak_no_evil": "",
          "speaker": "",
          "speaking_head": "",
          "speech_balloon": "",
          "speedboat": "",
          "spider": "",
          "spider_web": "",
          "spiral_calendar": "",
          "spiral_notepad": "",
          "spoon": "",
          "squid": "",
          "stadium": "",
          "star": "",
          "star2": "",
          "star_and_crescent": "",
          "star_of_david": "",
          "stars": "",
          "station": "",
          "statue_of_liberty": "",
          "steam_locomotive": "",
          "stew": "",
          "stop_button": "",
          "stop_sign": "",
          "stopwatch": "",
          "straight_ruler": "",
          "strawberry": "",
          "stuck_out_tongue": "",
          "stuck_out_tongue_closed_eyes": "",
          "stuck_out_tongue_winking_eye": "",
          "studio_microphone": "",
          "stuffed_flatbread": "",
          "sun_behind_large_cloud": "",
          "sun_behind_rain_cloud": "",
          "sun_behind_small_cloud": "",
          "sun_with_face": "",
          "sunflower": "",
          "sunglasses": "",
          "sunny": "",
          "sunrise": "",
          "sunrise_over_mountains": "",
          "surfing_man": "",
          "surfing_woman": "&zwj;",
          "sushi": "",
          "suspension_railway": "",
          "sweat": "",
          "sweat_drops": "",
          "sweat_smile": "",
          "sweet_potato": "",
          "swimming_man": "",
          "swimming_woman": "&zwj;",
          "symbols": "",
          "synagogue": "",
          "syringe": "",
          "taco": "",
          "tada": "",
          "tanabata_tree": "",
          "taurus": "",
          "taxi": "",
          "tea": "",
          "telephone_receiver": "",
          "telescope": "",
          "tennis": "",
          "tent": "",
          "thermometer": "",
          "thinking": "",
          "thought_balloon": "",
          "ticket": "",
          "tickets": "",
          "tiger": "",
          "tiger2": "",
          "timer_clock": "",
          "tipping_hand_man": "&zwj;",
          "tired_face": "",
          "tm": "",
          "toilet": "",
          "tokyo_tower": "",
          "tomato": "",
          "tongue": "",
          "top": "",
          "tophat": "",
          "tornado": "",
          "trackball": "",
          "tractor": "",
          "traffic_light": "",
          "train": "",
          "train2": "",
          "tram": "",
          "triangular_flag_on_post": "",
          "triangular_ruler": "",
          "trident": "",
          "triumph": "",
          "trolleybus": "",
          "trophy": "",
          "tropical_drink": "",
          "tropical_fish": "",
          "truck": "",
          "trumpet": "",
          "tulip": "",
          "tumbler_glass": "",
          "turkey": "",
          "turtle": "",
          "tv": "",
          "twisted_rightwards_arrows": "",
          "two_hearts": "",
          "two_men_holding_hands": "",
          "two_women_holding_hands": "",
          "u5272": "",
          "u5408": "",
          "u55b6": "",
          "u6307": "",
          "u6708": "",
          "u6709": "",
          "u6e80": "",
          "u7121": "",
          "u7533": "",
          "u7981": "",
          "u7a7a": "",
          "umbrella": "",
          "unamused": "",
          "underage": "",
          "unicorn": "",
          "unlock": "",
          "up": "",
          "upside_down_face": "",
          "v": "",
          "vertical_traffic_light": "",
          "vhs": "",
          "vibration_mode": "",
          "video_camera": "",
          "video_game": "",
          "violin": "",
          "virgo": "",
          "volcano": "",
          "volleyball": "",
          "vs": "",
          "vulcan_salute": "",
          "walking_man": "",
          "walking_woman": "&zwj;",
          "waning_crescent_moon": "",
          "waning_gibbous_moon": "",
          "warning": "",
          "wastebasket": "",
          "watch": "",
          "water_buffalo": "",
          "watermelon": "",
          "wave": "",
          "wavy_dash": "",
          "waxing_crescent_moon": "",
          "wc": "",
          "weary": "",
          "wedding": "",
          "weight_lifting_man": "",
          "weight_lifting_woman": "&zwj;",
          "whale": "",
          "whale2": "",
          "wheel_of_dharma": "",
          "wheelchair": "",
          "white_check_mark": "",
          "white_circle": "",
          "white_flag": "",
          "white_flower": "",
          "white_large_square": "",
          "white_medium_small_square": "",
          "white_medium_square": "",
          "white_small_square": "",
          "white_square_button": "",
          "wilted_flower": "",
          "wind_chime": "",
          "wind_face": "",
          "wine_glass": "",
          "wink": "",
          "wolf": "",
          "woman": "",
          "woman_artist": "&zwj;",
          "woman_astronaut": "&zwj;",
          "woman_cartwheeling": "&zwj;",
          "woman_cook": "&zwj;",
          "woman_facepalming": "&zwj;",
          "woman_factory_worker": "&zwj;",
          "woman_farmer": "&zwj;",
          "woman_firefighter": "&zwj;",
          "woman_health_worker": "&zwj;",
          "woman_judge": "&zwj;",
          "woman_juggling": "&zwj;",
          "woman_mechanic": "&zwj;",
          "woman_office_worker": "&zwj;",
          "woman_pilot": "&zwj;",
          "woman_playing_handball": "&zwj;",
          "woman_playing_water_polo": "&zwj;",
          "woman_scientist": "&zwj;",
          "woman_shrugging": "&zwj;",
          "woman_singer": "&zwj;",
          "woman_student": "&zwj;",
          "woman_teacher": "&zwj;",
          "woman_technologist": "&zwj;",
          "woman_with_turban": "&zwj;",
          "womans_clothes": "",
          "womans_hat": "",
          "women_wrestling": "&zwj;",
          "womens": "",
          "world_map": "",
          "worried": "",
          "wrench": "",
          "writing_hand": "",
          "x": "",
          "yellow_heart": "",
          "yen": "",
          "yin_yang": "",
          "yum": "",
          "zap": "",
          "zipper_mouth_face": "",
          "zzz": "",
          /* special emojis :P */
          "octocat": '<img alt=":octocat:" height="20" width="20" align="absmiddle" src="https://assets-cdn.github.com/images/icons/emoji/octocat.png">',
          "showdown": `<span style="font-family: 'Anonymous Pro', monospace; text-decoration: underline; text-decoration-style: dashed; text-decoration-color: #3e8b8a;text-underline-position: under;">S</span>`
        };
        showdown2.Converter = function(converterOptions) {
          var options = {}, langExtensions = [], outputModifiers = [], listeners = {}, setConvFlavor = setFlavor, metadata = {
            parsed: {},
            raw: "",
            format: ""
          };
          _constructor();
          function _constructor() {
            converterOptions = converterOptions || {};
            for (var gOpt in globalOptions) {
              if (globalOptions.hasOwnProperty(gOpt)) {
                options[gOpt] = globalOptions[gOpt];
              }
            }
            if (typeof converterOptions === "object") {
              for (var opt in converterOptions) {
                if (converterOptions.hasOwnProperty(opt)) {
                  options[opt] = converterOptions[opt];
                }
              }
            } else {
              throw Error("Converter expects the passed parameter to be an object, but " + typeof converterOptions + " was passed instead.");
            }
            if (options.extensions) {
              showdown2.helper.forEach(options.extensions, _parseExtension);
            }
          }
          function _parseExtension(ext, name) {
            name = name || null;
            if (showdown2.helper.isString(ext)) {
              ext = showdown2.helper.stdExtName(ext);
              name = ext;
              if (showdown2.extensions[ext]) {
                console.warn("DEPRECATION WARNING: " + ext + " is an old extension that uses a deprecated loading method.Please inform the developer that the extension should be updated!");
                legacyExtensionLoading(showdown2.extensions[ext], ext);
                return;
              } else if (!showdown2.helper.isUndefined(extensions[ext])) {
                ext = extensions[ext];
              } else {
                throw Error('Extension "' + ext + '" could not be loaded. It was either not found or is not a valid extension.');
              }
            }
            if (typeof ext === "function") {
              ext = ext();
            }
            if (!showdown2.helper.isArray(ext)) {
              ext = [ext];
            }
            var validExt = validate(ext, name);
            if (!validExt.valid) {
              throw Error(validExt.error);
            }
            for (var i = 0; i < ext.length; ++i) {
              switch (ext[i].type) {
                case "lang":
                  langExtensions.push(ext[i]);
                  break;
                case "output":
                  outputModifiers.push(ext[i]);
                  break;
              }
              if (ext[i].hasOwnProperty("listeners")) {
                for (var ln in ext[i].listeners) {
                  if (ext[i].listeners.hasOwnProperty(ln)) {
                    listen(ln, ext[i].listeners[ln]);
                  }
                }
              }
            }
          }
          function legacyExtensionLoading(ext, name) {
            if (typeof ext === "function") {
              ext = ext(new showdown2.Converter());
            }
            if (!showdown2.helper.isArray(ext)) {
              ext = [ext];
            }
            var valid = validate(ext, name);
            if (!valid.valid) {
              throw Error(valid.error);
            }
            for (var i = 0; i < ext.length; ++i) {
              switch (ext[i].type) {
                case "lang":
                  langExtensions.push(ext[i]);
                  break;
                case "output":
                  outputModifiers.push(ext[i]);
                  break;
                default:
                  throw Error("Extension loader error: Type unrecognized!!!");
              }
            }
          }
          function listen(name, callback) {
            if (!showdown2.helper.isString(name)) {
              throw Error("Invalid argument in converter.listen() method: name must be a string, but " + typeof name + " given");
            }
            if (typeof callback !== "function") {
              throw Error("Invalid argument in converter.listen() method: callback must be a function, but " + typeof callback + " given");
            }
            if (!listeners.hasOwnProperty(name)) {
              listeners[name] = [];
            }
            listeners[name].push(callback);
          }
          function rTrimInputText(text) {
            var rsp = text.match(/^\s*/)[0].length, rgx = new RegExp("^\\s{0," + rsp + "}", "gm");
            return text.replace(rgx, "");
          }
          this._dispatch = function dispatch(evtName, text, options2, globals) {
            if (listeners.hasOwnProperty(evtName)) {
              for (var ei = 0; ei < listeners[evtName].length; ++ei) {
                var nText = listeners[evtName][ei](evtName, text, this, options2, globals);
                if (nText && typeof nText !== "undefined") {
                  text = nText;
                }
              }
            }
            return text;
          };
          this.listen = function(name, callback) {
            listen(name, callback);
            return this;
          };
          this.makeHtml = function(text) {
            if (!text) {
              return text;
            }
            var globals = {
              gHtmlBlocks: [],
              gHtmlMdBlocks: [],
              gHtmlSpans: [],
              gUrls: {},
              gTitles: {},
              gDimensions: {},
              gListLevel: 0,
              hashLinkCounts: {},
              langExtensions,
              outputModifiers,
              converter: this,
              ghCodeBlocks: [],
              metadata: {
                parsed: {},
                raw: "",
                format: ""
              }
            };
            text = text.replace(//g, "T");
            text = text.replace(/\$/g, "D");
            text = text.replace(/\r\n/g, "\n");
            text = text.replace(/\r/g, "\n");
            text = text.replace(/\u00A0/g, "&nbsp;");
            if (options.smartIndentationFix) {
              text = rTrimInputText(text);
            }
            text = "\n\n" + text + "\n\n";
            text = showdown2.subParser("detab")(text, options, globals);
            text = text.replace(/^[ \t]+$/mg, "");
            showdown2.helper.forEach(langExtensions, function(ext) {
              text = showdown2.subParser("runExtension")(ext, text, options, globals);
            });
            text = showdown2.subParser("metadata")(text, options, globals);
            text = showdown2.subParser("hashPreCodeTags")(text, options, globals);
            text = showdown2.subParser("githubCodeBlocks")(text, options, globals);
            text = showdown2.subParser("hashHTMLBlocks")(text, options, globals);
            text = showdown2.subParser("hashCodeTags")(text, options, globals);
            text = showdown2.subParser("stripLinkDefinitions")(text, options, globals);
            text = showdown2.subParser("blockGamut")(text, options, globals);
            text = showdown2.subParser("unhashHTMLSpans")(text, options, globals);
            text = showdown2.subParser("unescapeSpecialChars")(text, options, globals);
            text = text.replace(/D/g, "$$");
            text = text.replace(/T/g, "");
            text = showdown2.subParser("completeHTMLDocument")(text, options, globals);
            showdown2.helper.forEach(outputModifiers, function(ext) {
              text = showdown2.subParser("runExtension")(ext, text, options, globals);
            });
            metadata = globals.metadata;
            return text;
          };
          this.makeMarkdown = this.makeMd = function(src, HTMLParser) {
            src = src.replace(/\r\n/g, "\n");
            src = src.replace(/\r/g, "\n");
            src = src.replace(/>[ \t]+</, ">NBSP;<");
            if (!HTMLParser) {
              if (window && window.document) {
                HTMLParser = window.document;
              } else {
                throw new Error("HTMLParser is undefined. If in a webworker or nodejs environment, you need to provide a WHATWG DOM and HTML such as JSDOM");
              }
            }
            var doc = HTMLParser.createElement("div");
            doc.innerHTML = src;
            var globals = {
              preList: substitutePreCodeTags(doc)
            };
            clean(doc);
            var nodes = doc.childNodes, mdDoc = "";
            for (var i = 0; i < nodes.length; i++) {
              mdDoc += showdown2.subParser("makeMarkdown.node")(nodes[i], globals);
            }
            function clean(node) {
              for (var n = 0; n < node.childNodes.length; ++n) {
                var child = node.childNodes[n];
                if (child.nodeType === 3) {
                  if (!/\S/.test(child.nodeValue) && !/^[ ]+$/.test(child.nodeValue)) {
                    node.removeChild(child);
                    --n;
                  } else {
                    child.nodeValue = child.nodeValue.split("\n").join(" ");
                    child.nodeValue = child.nodeValue.replace(/(\s)+/g, "$1");
                  }
                } else if (child.nodeType === 1) {
                  clean(child);
                }
              }
            }
            function substitutePreCodeTags(doc2) {
              var pres = doc2.querySelectorAll("pre"), presPH = [];
              for (var i2 = 0; i2 < pres.length; ++i2) {
                if (pres[i2].childElementCount === 1 && pres[i2].firstChild.tagName.toLowerCase() === "code") {
                  var content = pres[i2].firstChild.innerHTML.trim(), language = pres[i2].firstChild.getAttribute("data-language") || "";
                  if (language === "") {
                    var classes = pres[i2].firstChild.className.split(" ");
                    for (var c = 0; c < classes.length; ++c) {
                      var matches = classes[c].match(/^language-(.+)$/);
                      if (matches !== null) {
                        language = matches[1];
                        break;
                      }
                    }
                  }
                  content = showdown2.helper.unescapeHTMLEntities(content);
                  presPH.push(content);
                  pres[i2].outerHTML = '<precode language="' + language + '" precodenum="' + i2.toString() + '"></precode>';
                } else {
                  presPH.push(pres[i2].innerHTML);
                  pres[i2].innerHTML = "";
                  pres[i2].setAttribute("prenum", i2.toString());
                }
              }
              return presPH;
            }
            return mdDoc;
          };
          this.setOption = function(key, value) {
            options[key] = value;
          };
          this.getOption = function(key) {
            return options[key];
          };
          this.getOptions = function() {
            return options;
          };
          this.addExtension = function(extension, name) {
            name = name || null;
            _parseExtension(extension, name);
          };
          this.useExtension = function(extensionName) {
            _parseExtension(extensionName);
          };
          this.setFlavor = function(name) {
            if (!flavor.hasOwnProperty(name)) {
              throw Error(name + " flavor was not found");
            }
            var preset = flavor[name];
            setConvFlavor = name;
            for (var option in preset) {
              if (preset.hasOwnProperty(option)) {
                options[option] = preset[option];
              }
            }
          };
          this.getFlavor = function() {
            return setConvFlavor;
          };
          this.removeExtension = function(extension) {
            if (!showdown2.helper.isArray(extension)) {
              extension = [extension];
            }
            for (var a = 0; a < extension.length; ++a) {
              var ext = extension[a];
              for (var i = 0; i < langExtensions.length; ++i) {
                if (langExtensions[i] === ext) {
                  langExtensions.splice(i, 1);
                }
              }
              for (var ii = 0; ii < outputModifiers.length; ++ii) {
                if (outputModifiers[ii] === ext) {
                  outputModifiers.splice(ii, 1);
                }
              }
            }
          };
          this.getAllExtensions = function() {
            return {
              language: langExtensions,
              output: outputModifiers
            };
          };
          this.getMetadata = function(raw) {
            if (raw) {
              return metadata.raw;
            } else {
              return metadata.parsed;
            }
          };
          this.getMetadataFormat = function() {
            return metadata.format;
          };
          this._setMetadataPair = function(key, value) {
            metadata.parsed[key] = value;
          };
          this._setMetadataFormat = function(format) {
            metadata.format = format;
          };
          this._setMetadataRaw = function(raw) {
            metadata.raw = raw;
          };
        };
        showdown2.subParser("anchors", function(text, options, globals) {
          text = globals.converter._dispatch("anchors.before", text, options, globals);
          var writeAnchorTag = function(wholeMatch, linkText, linkId, url, m5, m6, title) {
            if (showdown2.helper.isUndefined(title)) {
              title = "";
            }
            linkId = linkId.toLowerCase();
            if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
              url = "";
            } else if (!url) {
              if (!linkId) {
                linkId = linkText.toLowerCase().replace(/ ?\n/g, " ");
              }
              url = "#" + linkId;
              if (!showdown2.helper.isUndefined(globals.gUrls[linkId])) {
                url = globals.gUrls[linkId];
                if (!showdown2.helper.isUndefined(globals.gTitles[linkId])) {
                  title = globals.gTitles[linkId];
                }
              } else {
                return wholeMatch;
              }
            }
            url = url.replace(showdown2.helper.regexes.asteriskDashAndColon, showdown2.helper.escapeCharactersCallback);
            var result = '<a href="' + url + '"';
            if (title !== "" && title !== null) {
              title = title.replace(/"/g, "&quot;");
              title = title.replace(showdown2.helper.regexes.asteriskDashAndColon, showdown2.helper.escapeCharactersCallback);
              result += ' title="' + title + '"';
            }
            if (options.openLinksInNewWindow && !/^#/.test(url)) {
              result += ' rel="noopener noreferrer" target="E95Eblank"';
            }
            result += ">" + linkText + "</a>";
            return result;
          };
          text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)] ?(?:\n *)?\[(.*?)]()()()()/g, writeAnchorTag);
          text = text.replace(
            /\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<([^>]*)>(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
            writeAnchorTag
          );
          text = text.replace(
            /\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
            writeAnchorTag
          );
          text = text.replace(/\[([^\[\]]+)]()()()()()/g, writeAnchorTag);
          if (options.ghMentions) {
            text = text.replace(/(^|\s)(\\)?(@([a-z\d]+(?:[a-z\d.-]+?[a-z\d]+)*))/gmi, function(wm, st, escape, mentions, username) {
              if (escape === "\\") {
                return st + mentions;
              }
              if (!showdown2.helper.isString(options.ghMentionsLink)) {
                throw new Error("ghMentionsLink option must be a string");
              }
              var lnk = options.ghMentionsLink.replace(/\{u}/g, username), target = "";
              if (options.openLinksInNewWindow) {
                target = ' rel="noopener noreferrer" target="E95Eblank"';
              }
              return st + '<a href="' + lnk + '"' + target + ">" + mentions + "</a>";
            });
          }
          text = globals.converter._dispatch("anchors.after", text, options, globals);
          return text;
        });
        var simpleURLRegex = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+?\.[^'">\s]+?)()(\1)?(?=\s|$)(?!["<>])/gi, simpleURLRegex2 = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+\.[^'">\s]+?)([.!?,()\[\]])?(\1)?(?=\s|$)(?!["<>])/gi, delimUrlRegex = /()<(((https?|ftp|dict):\/\/|www\.)[^'">\s]+)()>()/gi, simpleMailRegex = /(^|\s)(?:mailto:)?([A-Za-z0-9!#$%&'*+-/=?^_`{|}~.]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)(?=$|\s)/gmi, delimMailRegex = /<()(?:mailto:)?([-.\w]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi, replaceLink = function(options) {
          return function(wm, leadingMagicChars, link, m2, m3, trailingPunctuation, trailingMagicChars) {
            link = link.replace(showdown2.helper.regexes.asteriskDashAndColon, showdown2.helper.escapeCharactersCallback);
            var lnkTxt = link, append = "", target = "", lmc = leadingMagicChars || "", tmc = trailingMagicChars || "";
            if (/^www\./i.test(link)) {
              link = link.replace(/^www\./i, "http://www.");
            }
            if (options.excludeTrailingPunctuationFromURLs && trailingPunctuation) {
              append = trailingPunctuation;
            }
            if (options.openLinksInNewWindow) {
              target = ' rel="noopener noreferrer" target="E95Eblank"';
            }
            return lmc + '<a href="' + link + '"' + target + ">" + lnkTxt + "</a>" + append + tmc;
          };
        }, replaceMail = function(options, globals) {
          return function(wholeMatch, b, mail) {
            var href = "mailto:";
            b = b || "";
            mail = showdown2.subParser("unescapeSpecialChars")(mail, options, globals);
            if (options.encodeEmails) {
              href = showdown2.helper.encodeEmailAddress(href + mail);
              mail = showdown2.helper.encodeEmailAddress(mail);
            } else {
              href = href + mail;
            }
            return b + '<a href="' + href + '">' + mail + "</a>";
          };
        };
        showdown2.subParser("autoLinks", function(text, options, globals) {
          text = globals.converter._dispatch("autoLinks.before", text, options, globals);
          text = text.replace(delimUrlRegex, replaceLink(options));
          text = text.replace(delimMailRegex, replaceMail(options, globals));
          text = globals.converter._dispatch("autoLinks.after", text, options, globals);
          return text;
        });
        showdown2.subParser("simplifiedAutoLinks", function(text, options, globals) {
          if (!options.simplifiedAutoLink) {
            return text;
          }
          text = globals.converter._dispatch("simplifiedAutoLinks.before", text, options, globals);
          if (options.excludeTrailingPunctuationFromURLs) {
            text = text.replace(simpleURLRegex2, replaceLink(options));
          } else {
            text = text.replace(simpleURLRegex, replaceLink(options));
          }
          text = text.replace(simpleMailRegex, replaceMail(options, globals));
          text = globals.converter._dispatch("simplifiedAutoLinks.after", text, options, globals);
          return text;
        });
        showdown2.subParser("blockGamut", function(text, options, globals) {
          text = globals.converter._dispatch("blockGamut.before", text, options, globals);
          text = showdown2.subParser("blockQuotes")(text, options, globals);
          text = showdown2.subParser("headers")(text, options, globals);
          text = showdown2.subParser("horizontalRule")(text, options, globals);
          text = showdown2.subParser("lists")(text, options, globals);
          text = showdown2.subParser("codeBlocks")(text, options, globals);
          text = showdown2.subParser("tables")(text, options, globals);
          text = showdown2.subParser("hashHTMLBlocks")(text, options, globals);
          text = showdown2.subParser("paragraphs")(text, options, globals);
          text = globals.converter._dispatch("blockGamut.after", text, options, globals);
          return text;
        });
        showdown2.subParser("blockQuotes", function(text, options, globals) {
          text = globals.converter._dispatch("blockQuotes.before", text, options, globals);
          text = text + "\n\n";
          var rgx = /(^ {0,3}>[ \t]?.+\n(.+\n)*\n*)+/gm;
          if (options.splitAdjacentBlockquotes) {
            rgx = /^ {0,3}>[\s\S]*?(?:\n\n)/gm;
          }
          text = text.replace(rgx, function(bq) {
            bq = bq.replace(/^[ \t]*>[ \t]?/gm, "");
            bq = bq.replace(/0/g, "");
            bq = bq.replace(/^[ \t]+$/gm, "");
            bq = showdown2.subParser("githubCodeBlocks")(bq, options, globals);
            bq = showdown2.subParser("blockGamut")(bq, options, globals);
            bq = bq.replace(/(^|\n)/g, "$1  ");
            bq = bq.replace(/(\s*<pre>[^\r]+?<\/pre>)/gm, function(wholeMatch, m1) {
              var pre = m1;
              pre = pre.replace(/^  /mg, "0");
              pre = pre.replace(/0/g, "");
              return pre;
            });
            return showdown2.subParser("hashBlock")("<blockquote>\n" + bq + "\n</blockquote>", options, globals);
          });
          text = globals.converter._dispatch("blockQuotes.after", text, options, globals);
          return text;
        });
        showdown2.subParser("codeBlocks", function(text, options, globals) {
          text = globals.converter._dispatch("codeBlocks.before", text, options, globals);
          text += "0";
          var pattern = /(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=0))/g;
          text = text.replace(pattern, function(wholeMatch, m1, m2) {
            var codeblock = m1, nextChar = m2, end = "\n";
            codeblock = showdown2.subParser("outdent")(codeblock, options, globals);
            codeblock = showdown2.subParser("encodeCode")(codeblock, options, globals);
            codeblock = showdown2.subParser("detab")(codeblock, options, globals);
            codeblock = codeblock.replace(/^\n+/g, "");
            codeblock = codeblock.replace(/\n+$/g, "");
            if (options.omitExtraWLInCodeBlocks) {
              end = "";
            }
            codeblock = "<pre><code>" + codeblock + end + "</code></pre>";
            return showdown2.subParser("hashBlock")(codeblock, options, globals) + nextChar;
          });
          text = text.replace(/0/, "");
          text = globals.converter._dispatch("codeBlocks.after", text, options, globals);
          return text;
        });
        showdown2.subParser("codeSpans", function(text, options, globals) {
          text = globals.converter._dispatch("codeSpans.before", text, options, globals);
          if (typeof text === "undefined") {
            text = "";
          }
          text = text.replace(
            /(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm,
            function(wholeMatch, m1, m2, m3) {
              var c = m3;
              c = c.replace(/^([ \t]*)/g, "");
              c = c.replace(/[ \t]*$/g, "");
              c = showdown2.subParser("encodeCode")(c, options, globals);
              c = m1 + "<code>" + c + "</code>";
              c = showdown2.subParser("hashHTMLSpans")(c, options, globals);
              return c;
            }
          );
          text = globals.converter._dispatch("codeSpans.after", text, options, globals);
          return text;
        });
        showdown2.subParser("completeHTMLDocument", function(text, options, globals) {
          if (!options.completeHTMLDocument) {
            return text;
          }
          text = globals.converter._dispatch("completeHTMLDocument.before", text, options, globals);
          var doctype = "html", doctypeParsed = "<!DOCTYPE HTML>\n", title = "", charset = '<meta charset="utf-8">\n', lang = "", metadata = "";
          if (typeof globals.metadata.parsed.doctype !== "undefined") {
            doctypeParsed = "<!DOCTYPE " + globals.metadata.parsed.doctype + ">\n";
            doctype = globals.metadata.parsed.doctype.toString().toLowerCase();
            if (doctype === "html" || doctype === "html5") {
              charset = '<meta charset="utf-8">';
            }
          }
          for (var meta in globals.metadata.parsed) {
            if (globals.metadata.parsed.hasOwnProperty(meta)) {
              switch (meta.toLowerCase()) {
                case "doctype":
                  break;
                case "title":
                  title = "<title>" + globals.metadata.parsed.title + "</title>\n";
                  break;
                case "charset":
                  if (doctype === "html" || doctype === "html5") {
                    charset = '<meta charset="' + globals.metadata.parsed.charset + '">\n';
                  } else {
                    charset = '<meta name="charset" content="' + globals.metadata.parsed.charset + '">\n';
                  }
                  break;
                case "language":
                case "lang":
                  lang = ' lang="' + globals.metadata.parsed[meta] + '"';
                  metadata += '<meta name="' + meta + '" content="' + globals.metadata.parsed[meta] + '">\n';
                  break;
                default:
                  metadata += '<meta name="' + meta + '" content="' + globals.metadata.parsed[meta] + '">\n';
              }
            }
          }
          text = doctypeParsed + "<html" + lang + ">\n<head>\n" + title + charset + metadata + "</head>\n<body>\n" + text.trim() + "\n</body>\n</html>";
          text = globals.converter._dispatch("completeHTMLDocument.after", text, options, globals);
          return text;
        });
        showdown2.subParser("detab", function(text, options, globals) {
          text = globals.converter._dispatch("detab.before", text, options, globals);
          text = text.replace(/\t(?=\t)/g, "    ");
          text = text.replace(/\t/g, "AB");
          text = text.replace(/B(.+?)A/g, function(wholeMatch, m1) {
            var leadingText = m1, numSpaces = 4 - leadingText.length % 4;
            for (var i = 0; i < numSpaces; i++) {
              leadingText += " ";
            }
            return leadingText;
          });
          text = text.replace(/A/g, "    ");
          text = text.replace(/B/g, "");
          text = globals.converter._dispatch("detab.after", text, options, globals);
          return text;
        });
        showdown2.subParser("ellipsis", function(text, options, globals) {
          if (!options.ellipsis) {
            return text;
          }
          text = globals.converter._dispatch("ellipsis.before", text, options, globals);
          text = text.replace(/\.\.\./g, "");
          text = globals.converter._dispatch("ellipsis.after", text, options, globals);
          return text;
        });
        showdown2.subParser("emoji", function(text, options, globals) {
          if (!options.emoji) {
            return text;
          }
          text = globals.converter._dispatch("emoji.before", text, options, globals);
          var emojiRgx = /:([\S]+?):/g;
          text = text.replace(emojiRgx, function(wm, emojiCode) {
            if (showdown2.helper.emojis.hasOwnProperty(emojiCode)) {
              return showdown2.helper.emojis[emojiCode];
            }
            return wm;
          });
          text = globals.converter._dispatch("emoji.after", text, options, globals);
          return text;
        });
        showdown2.subParser("encodeAmpsAndAngles", function(text, options, globals) {
          text = globals.converter._dispatch("encodeAmpsAndAngles.before", text, options, globals);
          text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g, "&amp;");
          text = text.replace(/<(?![a-z\/?$!])/gi, "&lt;");
          text = text.replace(/</g, "&lt;");
          text = text.replace(/>/g, "&gt;");
          text = globals.converter._dispatch("encodeAmpsAndAngles.after", text, options, globals);
          return text;
        });
        showdown2.subParser("encodeBackslashEscapes", function(text, options, globals) {
          text = globals.converter._dispatch("encodeBackslashEscapes.before", text, options, globals);
          text = text.replace(/\\(\\)/g, showdown2.helper.escapeCharactersCallback);
          text = text.replace(/\\([`*_{}\[\]()>#+.!~=|:-])/g, showdown2.helper.escapeCharactersCallback);
          text = globals.converter._dispatch("encodeBackslashEscapes.after", text, options, globals);
          return text;
        });
        showdown2.subParser("encodeCode", function(text, options, globals) {
          text = globals.converter._dispatch("encodeCode.before", text, options, globals);
          text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/([*_{}\[\]\\=~-])/g, showdown2.helper.escapeCharactersCallback);
          text = globals.converter._dispatch("encodeCode.after", text, options, globals);
          return text;
        });
        showdown2.subParser("escapeSpecialCharsWithinTagAttributes", function(text, options, globals) {
          text = globals.converter._dispatch("escapeSpecialCharsWithinTagAttributes.before", text, options, globals);
          var tags = /<\/?[a-z\d_:-]+(?:[\s]+[\s\S]+?)?>/gi, comments = /<!(--(?:(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>/gi;
          text = text.replace(tags, function(wholeMatch) {
            return wholeMatch.replace(/(.)<\/?code>(?=.)/g, "$1`").replace(/([\\`*_~=|])/g, showdown2.helper.escapeCharactersCallback);
          });
          text = text.replace(comments, function(wholeMatch) {
            return wholeMatch.replace(/([\\`*_~=|])/g, showdown2.helper.escapeCharactersCallback);
          });
          text = globals.converter._dispatch("escapeSpecialCharsWithinTagAttributes.after", text, options, globals);
          return text;
        });
        showdown2.subParser("githubCodeBlocks", function(text, options, globals) {
          if (!options.ghCodeBlocks) {
            return text;
          }
          text = globals.converter._dispatch("githubCodeBlocks.before", text, options, globals);
          text += "0";
          text = text.replace(/(?:^|\n)(?: {0,3})(```+|~~~+)(?: *)([^\s`~]*)\n([\s\S]*?)\n(?: {0,3})\1/g, function(wholeMatch, delim, language, codeblock) {
            var end = options.omitExtraWLInCodeBlocks ? "" : "\n";
            codeblock = showdown2.subParser("encodeCode")(codeblock, options, globals);
            codeblock = showdown2.subParser("detab")(codeblock, options, globals);
            codeblock = codeblock.replace(/^\n+/g, "");
            codeblock = codeblock.replace(/\n+$/g, "");
            codeblock = "<pre><code" + (language ? ' class="' + language + " language-" + language + '"' : "") + ">" + codeblock + end + "</code></pre>";
            codeblock = showdown2.subParser("hashBlock")(codeblock, options, globals);
            return "\n\nG" + (globals.ghCodeBlocks.push({ text: wholeMatch, codeblock }) - 1) + "G\n\n";
          });
          text = text.replace(/0/, "");
          return globals.converter._dispatch("githubCodeBlocks.after", text, options, globals);
        });
        showdown2.subParser("hashBlock", function(text, options, globals) {
          text = globals.converter._dispatch("hashBlock.before", text, options, globals);
          text = text.replace(/(^\n+|\n+$)/g, "");
          text = "\n\nK" + (globals.gHtmlBlocks.push(text) - 1) + "K\n\n";
          text = globals.converter._dispatch("hashBlock.after", text, options, globals);
          return text;
        });
        showdown2.subParser("hashCodeTags", function(text, options, globals) {
          text = globals.converter._dispatch("hashCodeTags.before", text, options, globals);
          var repFunc = function(wholeMatch, match, left, right) {
            var codeblock = left + showdown2.subParser("encodeCode")(match, options, globals) + right;
            return "C" + (globals.gHtmlSpans.push(codeblock) - 1) + "C";
          };
          text = showdown2.helper.replaceRecursiveRegExp(text, repFunc, "<code\\b[^>]*>", "</code>", "gim");
          text = globals.converter._dispatch("hashCodeTags.after", text, options, globals);
          return text;
        });
        showdown2.subParser("hashElement", function(text, options, globals) {
          return function(wholeMatch, m1) {
            var blockText = m1;
            blockText = blockText.replace(/\n\n/g, "\n");
            blockText = blockText.replace(/^\n/, "");
            blockText = blockText.replace(/\n+$/g, "");
            blockText = "\n\nK" + (globals.gHtmlBlocks.push(blockText) - 1) + "K\n\n";
            return blockText;
          };
        });
        showdown2.subParser("hashHTMLBlocks", function(text, options, globals) {
          text = globals.converter._dispatch("hashHTMLBlocks.before", text, options, globals);
          var blockTags = [
            "pre",
            "div",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "blockquote",
            "table",
            "dl",
            "ol",
            "ul",
            "script",
            "noscript",
            "form",
            "fieldset",
            "iframe",
            "math",
            "style",
            "section",
            "header",
            "footer",
            "nav",
            "article",
            "aside",
            "address",
            "audio",
            "canvas",
            "figure",
            "hgroup",
            "output",
            "video",
            "p"
          ], repFunc = function(wholeMatch, match, left, right) {
            var txt = wholeMatch;
            if (left.search(/\bmarkdown\b/) !== -1) {
              txt = left + globals.converter.makeHtml(match) + right;
            }
            return "\n\nK" + (globals.gHtmlBlocks.push(txt) - 1) + "K\n\n";
          };
          if (options.backslashEscapesHTMLTags) {
            text = text.replace(/\\<(\/?[^>]+?)>/g, function(wm, inside) {
              return "&lt;" + inside + "&gt;";
            });
          }
          for (var i = 0; i < blockTags.length; ++i) {
            var opTagPos, rgx1 = new RegExp("^ {0,3}(<" + blockTags[i] + "\\b[^>]*>)", "im"), patLeft = "<" + blockTags[i] + "\\b[^>]*>", patRight = "</" + blockTags[i] + ">";
            while ((opTagPos = showdown2.helper.regexIndexOf(text, rgx1)) !== -1) {
              var subTexts = showdown2.helper.splitAtIndex(text, opTagPos), newSubText1 = showdown2.helper.replaceRecursiveRegExp(subTexts[1], repFunc, patLeft, patRight, "im");
              if (newSubText1 === subTexts[1]) {
                break;
              }
              text = subTexts[0].concat(newSubText1);
            }
          }
          text = text.replace(
            /(\n {0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g,
            showdown2.subParser("hashElement")(text, options, globals)
          );
          text = showdown2.helper.replaceRecursiveRegExp(text, function(txt) {
            return "\n\nK" + (globals.gHtmlBlocks.push(txt) - 1) + "K\n\n";
          }, "^ {0,3}<!--", "-->", "gm");
          text = text.replace(
            /(?:\n\n)( {0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g,
            showdown2.subParser("hashElement")(text, options, globals)
          );
          text = globals.converter._dispatch("hashHTMLBlocks.after", text, options, globals);
          return text;
        });
        showdown2.subParser("hashHTMLSpans", function(text, options, globals) {
          text = globals.converter._dispatch("hashHTMLSpans.before", text, options, globals);
          function hashHTMLSpan(html) {
            return "C" + (globals.gHtmlSpans.push(html) - 1) + "C";
          }
          text = text.replace(/<[^>]+?\/>/gi, function(wm) {
            return hashHTMLSpan(wm);
          });
          text = text.replace(/<([^>]+?)>[\s\S]*?<\/\1>/g, function(wm) {
            return hashHTMLSpan(wm);
          });
          text = text.replace(/<([^>]+?)\s[^>]+?>[\s\S]*?<\/\1>/g, function(wm) {
            return hashHTMLSpan(wm);
          });
          text = text.replace(/<[^>]+?>/gi, function(wm) {
            return hashHTMLSpan(wm);
          });
          text = globals.converter._dispatch("hashHTMLSpans.after", text, options, globals);
          return text;
        });
        showdown2.subParser("unhashHTMLSpans", function(text, options, globals) {
          text = globals.converter._dispatch("unhashHTMLSpans.before", text, options, globals);
          for (var i = 0; i < globals.gHtmlSpans.length; ++i) {
            var repText = globals.gHtmlSpans[i], limit = 0;
            while (/C(\d+)C/.test(repText)) {
              var num = RegExp.$1;
              repText = repText.replace("C" + num + "C", globals.gHtmlSpans[num]);
              if (limit === 10) {
                console.error("maximum nesting of 10 spans reached!!!");
                break;
              }
              ++limit;
            }
            text = text.replace("C" + i + "C", repText);
          }
          text = globals.converter._dispatch("unhashHTMLSpans.after", text, options, globals);
          return text;
        });
        showdown2.subParser("hashPreCodeTags", function(text, options, globals) {
          text = globals.converter._dispatch("hashPreCodeTags.before", text, options, globals);
          var repFunc = function(wholeMatch, match, left, right) {
            var codeblock = left + showdown2.subParser("encodeCode")(match, options, globals) + right;
            return "\n\nG" + (globals.ghCodeBlocks.push({ text: wholeMatch, codeblock }) - 1) + "G\n\n";
          };
          text = showdown2.helper.replaceRecursiveRegExp(text, repFunc, "^ {0,3}<pre\\b[^>]*>\\s*<code\\b[^>]*>", "^ {0,3}</code>\\s*</pre>", "gim");
          text = globals.converter._dispatch("hashPreCodeTags.after", text, options, globals);
          return text;
        });
        showdown2.subParser("headers", function(text, options, globals) {
          text = globals.converter._dispatch("headers.before", text, options, globals);
          var headerLevelStart = isNaN(parseInt(options.headerLevelStart)) ? 1 : parseInt(options.headerLevelStart), setextRegexH1 = options.smoothLivePreview ? /^(.+)[ \t]*\n={2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n=+[ \t]*\n+/gm, setextRegexH2 = options.smoothLivePreview ? /^(.+)[ \t]*\n-{2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n-+[ \t]*\n+/gm;
          text = text.replace(setextRegexH1, function(wholeMatch, m1) {
            var spanGamut = showdown2.subParser("spanGamut")(m1, options, globals), hID = options.noHeaderId ? "" : ' id="' + headerId(m1) + '"', hLevel = headerLevelStart, hashBlock = "<h" + hLevel + hID + ">" + spanGamut + "</h" + hLevel + ">";
            return showdown2.subParser("hashBlock")(hashBlock, options, globals);
          });
          text = text.replace(setextRegexH2, function(matchFound, m1) {
            var spanGamut = showdown2.subParser("spanGamut")(m1, options, globals), hID = options.noHeaderId ? "" : ' id="' + headerId(m1) + '"', hLevel = headerLevelStart + 1, hashBlock = "<h" + hLevel + hID + ">" + spanGamut + "</h" + hLevel + ">";
            return showdown2.subParser("hashBlock")(hashBlock, options, globals);
          });
          var atxStyle = options.requireSpaceBeforeHeadingText ? /^(#{1,6})[ \t]+(.+?)[ \t]*#*\n+/gm : /^(#{1,6})[ \t]*(.+?)[ \t]*#*\n+/gm;
          text = text.replace(atxStyle, function(wholeMatch, m1, m2) {
            var hText = m2;
            if (options.customizedHeaderId) {
              hText = m2.replace(/\s?\{([^{]+?)}\s*$/, "");
            }
            var span = showdown2.subParser("spanGamut")(hText, options, globals), hID = options.noHeaderId ? "" : ' id="' + headerId(m2) + '"', hLevel = headerLevelStart - 1 + m1.length, header = "<h" + hLevel + hID + ">" + span + "</h" + hLevel + ">";
            return showdown2.subParser("hashBlock")(header, options, globals);
          });
          function headerId(m) {
            var title, prefix;
            if (options.customizedHeaderId) {
              var match = m.match(/\{([^{]+?)}\s*$/);
              if (match && match[1]) {
                m = match[1];
              }
            }
            title = m;
            if (showdown2.helper.isString(options.prefixHeaderId)) {
              prefix = options.prefixHeaderId;
            } else if (options.prefixHeaderId === true) {
              prefix = "section-";
            } else {
              prefix = "";
            }
            if (!options.rawPrefixHeaderId) {
              title = prefix + title;
            }
            if (options.ghCompatibleHeaderId) {
              title = title.replace(/ /g, "-").replace(/&amp;/g, "").replace(/T/g, "").replace(/D/g, "").replace(/[&+$,\/:;=?@"#{}|^~\[\]`\\*)(%.!'<>]/g, "").toLowerCase();
            } else if (options.rawHeaderId) {
              title = title.replace(/ /g, "-").replace(/&amp;/g, "&").replace(/T/g, "").replace(/D/g, "$").replace(/["']/g, "-").toLowerCase();
            } else {
              title = title.replace(/[^\w]/g, "").toLowerCase();
            }
            if (options.rawPrefixHeaderId) {
              title = prefix + title;
            }
            if (globals.hashLinkCounts[title]) {
              title = title + "-" + globals.hashLinkCounts[title]++;
            } else {
              globals.hashLinkCounts[title] = 1;
            }
            return title;
          }
          text = globals.converter._dispatch("headers.after", text, options, globals);
          return text;
        });
        showdown2.subParser("horizontalRule", function(text, options, globals) {
          text = globals.converter._dispatch("horizontalRule.before", text, options, globals);
          var key = showdown2.subParser("hashBlock")("<hr />", options, globals);
          text = text.replace(/^ {0,2}( ?-){3,}[ \t]*$/gm, key);
          text = text.replace(/^ {0,2}( ?\*){3,}[ \t]*$/gm, key);
          text = text.replace(/^ {0,2}( ?_){3,}[ \t]*$/gm, key);
          text = globals.converter._dispatch("horizontalRule.after", text, options, globals);
          return text;
        });
        showdown2.subParser("images", function(text, options, globals) {
          text = globals.converter._dispatch("images.before", text, options, globals);
          var inlineRegExp = /!\[([^\]]*?)][ \t]*()\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g, crazyRegExp = /!\[([^\]]*?)][ \t]*()\([ \t]?<([^>]*)>(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(?:(["'])([^"]*?)\6))?[ \t]?\)/g, base64RegExp = /!\[([^\]]*?)][ \t]*()\([ \t]?<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g, referenceRegExp = /!\[([^\]]*?)] ?(?:\n *)?\[([\s\S]*?)]()()()()()/g, refShortcutRegExp = /!\[([^\[\]]+)]()()()()()/g;
          function writeImageTagBase64(wholeMatch, altText, linkId, url, width, height, m5, title) {
            url = url.replace(/\s/g, "");
            return writeImageTag(wholeMatch, altText, linkId, url, width, height, m5, title);
          }
          function writeImageTag(wholeMatch, altText, linkId, url, width, height, m5, title) {
            var gUrls = globals.gUrls, gTitles = globals.gTitles, gDims = globals.gDimensions;
            linkId = linkId.toLowerCase();
            if (!title) {
              title = "";
            }
            if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
              url = "";
            } else if (url === "" || url === null) {
              if (linkId === "" || linkId === null) {
                linkId = altText.toLowerCase().replace(/ ?\n/g, " ");
              }
              url = "#" + linkId;
              if (!showdown2.helper.isUndefined(gUrls[linkId])) {
                url = gUrls[linkId];
                if (!showdown2.helper.isUndefined(gTitles[linkId])) {
                  title = gTitles[linkId];
                }
                if (!showdown2.helper.isUndefined(gDims[linkId])) {
                  width = gDims[linkId].width;
                  height = gDims[linkId].height;
                }
              } else {
                return wholeMatch;
              }
            }
            altText = altText.replace(/"/g, "&quot;").replace(showdown2.helper.regexes.asteriskDashAndColon, showdown2.helper.escapeCharactersCallback);
            url = url.replace(showdown2.helper.regexes.asteriskDashAndColon, showdown2.helper.escapeCharactersCallback);
            var result = '<img src="' + url + '" alt="' + altText + '"';
            if (title && showdown2.helper.isString(title)) {
              title = title.replace(/"/g, "&quot;").replace(showdown2.helper.regexes.asteriskDashAndColon, showdown2.helper.escapeCharactersCallback);
              result += ' title="' + title + '"';
            }
            if (width && height) {
              width = width === "*" ? "auto" : width;
              height = height === "*" ? "auto" : height;
              result += ' width="' + width + '"';
              result += ' height="' + height + '"';
            }
            result += " />";
            return result;
          }
          text = text.replace(referenceRegExp, writeImageTag);
          text = text.replace(base64RegExp, writeImageTagBase64);
          text = text.replace(crazyRegExp, writeImageTag);
          text = text.replace(inlineRegExp, writeImageTag);
          text = text.replace(refShortcutRegExp, writeImageTag);
          text = globals.converter._dispatch("images.after", text, options, globals);
          return text;
        });
        showdown2.subParser("italicsAndBold", function(text, options, globals) {
          text = globals.converter._dispatch("italicsAndBold.before", text, options, globals);
          function parseInside(txt, left, right) {
            return left + txt + right;
          }
          if (options.literalMidWordUnderscores) {
            text = text.replace(/\b___(\S[\s\S]*?)___\b/g, function(wm, txt) {
              return parseInside(txt, "<strong><em>", "</em></strong>");
            });
            text = text.replace(/\b__(\S[\s\S]*?)__\b/g, function(wm, txt) {
              return parseInside(txt, "<strong>", "</strong>");
            });
            text = text.replace(/\b_(\S[\s\S]*?)_\b/g, function(wm, txt) {
              return parseInside(txt, "<em>", "</em>");
            });
          } else {
            text = text.replace(/___(\S[\s\S]*?)___/g, function(wm, m) {
              return /\S$/.test(m) ? parseInside(m, "<strong><em>", "</em></strong>") : wm;
            });
            text = text.replace(/__(\S[\s\S]*?)__/g, function(wm, m) {
              return /\S$/.test(m) ? parseInside(m, "<strong>", "</strong>") : wm;
            });
            text = text.replace(/_([^\s_][\s\S]*?)_/g, function(wm, m) {
              return /\S$/.test(m) ? parseInside(m, "<em>", "</em>") : wm;
            });
          }
          if (options.literalMidWordAsterisks) {
            text = text.replace(/([^*]|^)\B\*\*\*(\S[\s\S]*?)\*\*\*\B(?!\*)/g, function(wm, lead, txt) {
              return parseInside(txt, lead + "<strong><em>", "</em></strong>");
            });
            text = text.replace(/([^*]|^)\B\*\*(\S[\s\S]*?)\*\*\B(?!\*)/g, function(wm, lead, txt) {
              return parseInside(txt, lead + "<strong>", "</strong>");
            });
            text = text.replace(/([^*]|^)\B\*(\S[\s\S]*?)\*\B(?!\*)/g, function(wm, lead, txt) {
              return parseInside(txt, lead + "<em>", "</em>");
            });
          } else {
            text = text.replace(/\*\*\*(\S[\s\S]*?)\*\*\*/g, function(wm, m) {
              return /\S$/.test(m) ? parseInside(m, "<strong><em>", "</em></strong>") : wm;
            });
            text = text.replace(/\*\*(\S[\s\S]*?)\*\*/g, function(wm, m) {
              return /\S$/.test(m) ? parseInside(m, "<strong>", "</strong>") : wm;
            });
            text = text.replace(/\*([^\s*][\s\S]*?)\*/g, function(wm, m) {
              return /\S$/.test(m) ? parseInside(m, "<em>", "</em>") : wm;
            });
          }
          text = globals.converter._dispatch("italicsAndBold.after", text, options, globals);
          return text;
        });
        showdown2.subParser("lists", function(text, options, globals) {
          function processListItems(listStr, trimTrailing) {
            globals.gListLevel++;
            listStr = listStr.replace(/\n{2,}$/, "\n");
            listStr += "0";
            var rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(0| {0,3}([*+-]|\d+[.])[ \t]+))/gm, isParagraphed = /\n[ \t]*\n(?!0)/.test(listStr);
            if (options.disableForced4SpacesIndentedSublists) {
              rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(0|\2([*+-]|\d+[.])[ \t]+))/gm;
            }
            listStr = listStr.replace(rgx, function(wholeMatch, m1, m2, m3, m4, taskbtn, checked) {
              checked = checked && checked.trim() !== "";
              var item = showdown2.subParser("outdent")(m4, options, globals), bulletStyle = "";
              if (taskbtn && options.tasklists) {
                bulletStyle = ' class="task-list-item" style="list-style-type: none;"';
                item = item.replace(/^[ \t]*\[(x|X| )?]/m, function() {
                  var otp = '<input type="checkbox" disabled style="margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;"';
                  if (checked) {
                    otp += " checked";
                  }
                  otp += ">";
                  return otp;
                });
              }
              item = item.replace(/^([-*+]|\d\.)[ \t]+[\S\n ]*/g, function(wm2) {
                return "A" + wm2;
              });
              if (m1 || item.search(/\n{2,}/) > -1) {
                item = showdown2.subParser("githubCodeBlocks")(item, options, globals);
                item = showdown2.subParser("blockGamut")(item, options, globals);
              } else {
                item = showdown2.subParser("lists")(item, options, globals);
                item = item.replace(/\n$/, "");
                item = showdown2.subParser("hashHTMLBlocks")(item, options, globals);
                item = item.replace(/\n\n+/g, "\n\n");
                if (isParagraphed) {
                  item = showdown2.subParser("paragraphs")(item, options, globals);
                } else {
                  item = showdown2.subParser("spanGamut")(item, options, globals);
                }
              }
              item = item.replace("A", "");
              item = "<li" + bulletStyle + ">" + item + "</li>\n";
              return item;
            });
            listStr = listStr.replace(/0/g, "");
            globals.gListLevel--;
            if (trimTrailing) {
              listStr = listStr.replace(/\s+$/, "");
            }
            return listStr;
          }
          function styleStartNumber(list, listType) {
            if (listType === "ol") {
              var res = list.match(/^ *(\d+)\./);
              if (res && res[1] !== "1") {
                return ' start="' + res[1] + '"';
              }
            }
            return "";
          }
          function parseConsecutiveLists(list, listType, trimTrailing) {
            var olRgx = options.disableForced4SpacesIndentedSublists ? /^ ?\d+\.[ \t]/gm : /^ {0,3}\d+\.[ \t]/gm, ulRgx = options.disableForced4SpacesIndentedSublists ? /^ ?[*+-][ \t]/gm : /^ {0,3}[*+-][ \t]/gm, counterRxg = listType === "ul" ? olRgx : ulRgx, result = "";
            if (list.search(counterRxg) !== -1) {
              (function parseCL(txt) {
                var pos = txt.search(counterRxg), style2 = styleStartNumber(list, listType);
                if (pos !== -1) {
                  result += "\n\n<" + listType + style2 + ">\n" + processListItems(txt.slice(0, pos), !!trimTrailing) + "</" + listType + ">\n";
                  listType = listType === "ul" ? "ol" : "ul";
                  counterRxg = listType === "ul" ? olRgx : ulRgx;
                  parseCL(txt.slice(pos));
                } else {
                  result += "\n\n<" + listType + style2 + ">\n" + processListItems(txt, !!trimTrailing) + "</" + listType + ">\n";
                }
              })(list);
            } else {
              var style = styleStartNumber(list, listType);
              result = "\n\n<" + listType + style + ">\n" + processListItems(list, !!trimTrailing) + "</" + listType + ">\n";
            }
            return result;
          }
          text = globals.converter._dispatch("lists.before", text, options, globals);
          text += "0";
          if (globals.gListLevel) {
            text = text.replace(
              /^(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
              function(wholeMatch, list, m2) {
                var listType = m2.search(/[*+-]/g) > -1 ? "ul" : "ol";
                return parseConsecutiveLists(list, listType, true);
              }
            );
          } else {
            text = text.replace(
              /(\n\n|^\n?)(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
              function(wholeMatch, m1, list, m3) {
                var listType = m3.search(/[*+-]/g) > -1 ? "ul" : "ol";
                return parseConsecutiveLists(list, listType, false);
              }
            );
          }
          text = text.replace(/0/, "");
          text = globals.converter._dispatch("lists.after", text, options, globals);
          return text;
        });
        showdown2.subParser("metadata", function(text, options, globals) {
          if (!options.metadata) {
            return text;
          }
          text = globals.converter._dispatch("metadata.before", text, options, globals);
          function parseMetadataContents(content) {
            globals.metadata.raw = content;
            content = content.replace(/&/g, "&amp;").replace(/"/g, "&quot;");
            content = content.replace(/\n {4}/g, " ");
            content.replace(/^([\S ]+): +([\s\S]+?)$/gm, function(wm, key, value) {
              globals.metadata.parsed[key] = value;
              return "";
            });
          }
          text = text.replace(/^\s*+(\S*?)\n([\s\S]+?)\n+\n/, function(wholematch, format, content) {
            parseMetadataContents(content);
            return "M";
          });
          text = text.replace(/^\s*---+(\S*?)\n([\s\S]+?)\n---+\n/, function(wholematch, format, content) {
            if (format) {
              globals.metadata.format = format;
            }
            parseMetadataContents(content);
            return "M";
          });
          text = text.replace(/M/g, "");
          text = globals.converter._dispatch("metadata.after", text, options, globals);
          return text;
        });
        showdown2.subParser("outdent", function(text, options, globals) {
          text = globals.converter._dispatch("outdent.before", text, options, globals);
          text = text.replace(/^(\t|[ ]{1,4})/gm, "0");
          text = text.replace(/0/g, "");
          text = globals.converter._dispatch("outdent.after", text, options, globals);
          return text;
        });
        showdown2.subParser("paragraphs", function(text, options, globals) {
          text = globals.converter._dispatch("paragraphs.before", text, options, globals);
          text = text.replace(/^\n+/g, "");
          text = text.replace(/\n+$/g, "");
          var grafs = text.split(/\n{2,}/g), grafsOut = [], end = grafs.length;
          for (var i = 0; i < end; i++) {
            var str = grafs[i];
            if (str.search(/(K|G)(\d+)\1/g) >= 0) {
              grafsOut.push(str);
            } else if (str.search(/\S/) >= 0) {
              str = showdown2.subParser("spanGamut")(str, options, globals);
              str = str.replace(/^([ \t]*)/g, "<p>");
              str += "</p>";
              grafsOut.push(str);
            }
          }
          end = grafsOut.length;
          for (i = 0; i < end; i++) {
            var blockText = "", grafsOutIt = grafsOut[i], codeFlag = false;
            while (/(K|G)(\d+)\1/.test(grafsOutIt)) {
              var delim = RegExp.$1, num = RegExp.$2;
              if (delim === "K") {
                blockText = globals.gHtmlBlocks[num];
              } else {
                if (codeFlag) {
                  blockText = showdown2.subParser("encodeCode")(globals.ghCodeBlocks[num].text, options, globals);
                } else {
                  blockText = globals.ghCodeBlocks[num].codeblock;
                }
              }
              blockText = blockText.replace(/\$/g, "$$$$");
              grafsOutIt = grafsOutIt.replace(/(\n\n)?(K|G)\d+\2(\n\n)?/, blockText);
              if (/^<pre\b[^>]*>\s*<code\b[^>]*>/.test(grafsOutIt)) {
                codeFlag = true;
              }
            }
            grafsOut[i] = grafsOutIt;
          }
          text = grafsOut.join("\n");
          text = text.replace(/^\n+/g, "");
          text = text.replace(/\n+$/g, "");
          return globals.converter._dispatch("paragraphs.after", text, options, globals);
        });
        showdown2.subParser("runExtension", function(ext, text, options, globals) {
          if (ext.filter) {
            text = ext.filter(text, globals.converter, options);
          } else if (ext.regex) {
            var re = ext.regex;
            if (!(re instanceof RegExp)) {
              re = new RegExp(re, "g");
            }
            text = text.replace(re, ext.replace);
          }
          return text;
        });
        showdown2.subParser("spanGamut", function(text, options, globals) {
          text = globals.converter._dispatch("spanGamut.before", text, options, globals);
          text = showdown2.subParser("codeSpans")(text, options, globals);
          text = showdown2.subParser("escapeSpecialCharsWithinTagAttributes")(text, options, globals);
          text = showdown2.subParser("encodeBackslashEscapes")(text, options, globals);
          text = showdown2.subParser("images")(text, options, globals);
          text = showdown2.subParser("anchors")(text, options, globals);
          text = showdown2.subParser("autoLinks")(text, options, globals);
          text = showdown2.subParser("simplifiedAutoLinks")(text, options, globals);
          text = showdown2.subParser("emoji")(text, options, globals);
          text = showdown2.subParser("underline")(text, options, globals);
          text = showdown2.subParser("italicsAndBold")(text, options, globals);
          text = showdown2.subParser("strikethrough")(text, options, globals);
          text = showdown2.subParser("ellipsis")(text, options, globals);
          text = showdown2.subParser("hashHTMLSpans")(text, options, globals);
          text = showdown2.subParser("encodeAmpsAndAngles")(text, options, globals);
          if (options.simpleLineBreaks) {
            if (!/\n\nK/.test(text)) {
              text = text.replace(/\n+/g, "<br />\n");
            }
          } else {
            text = text.replace(/  +\n/g, "<br />\n");
          }
          text = globals.converter._dispatch("spanGamut.after", text, options, globals);
          return text;
        });
        showdown2.subParser("strikethrough", function(text, options, globals) {
          function parseInside(txt) {
            if (options.simplifiedAutoLink) {
              txt = showdown2.subParser("simplifiedAutoLinks")(txt, options, globals);
            }
            return "<del>" + txt + "</del>";
          }
          if (options.strikethrough) {
            text = globals.converter._dispatch("strikethrough.before", text, options, globals);
            text = text.replace(/(?:~){2}([\s\S]+?)(?:~){2}/g, function(wm, txt) {
              return parseInside(txt);
            });
            text = globals.converter._dispatch("strikethrough.after", text, options, globals);
          }
          return text;
        });
        showdown2.subParser("stripLinkDefinitions", function(text, options, globals) {
          var regex = /^ {0,3}\[([^\]]+)]:[ \t]*\n?[ \t]*<?([^>\s]+)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n+|(?=0))/gm, base64Regex = /^ {0,3}\[([^\]]+)]:[ \t]*\n?[ \t]*<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n\n|(?=0)|(?=\n\[))/gm;
          text += "0";
          var replaceFunc = function(wholeMatch, linkId, url, width, height, blankLines, title) {
            linkId = linkId.toLowerCase();
            if (text.toLowerCase().split(linkId).length - 1 < 2) {
              return wholeMatch;
            }
            if (url.match(/^data:.+?\/.+?;base64,/)) {
              globals.gUrls[linkId] = url.replace(/\s/g, "");
            } else {
              globals.gUrls[linkId] = showdown2.subParser("encodeAmpsAndAngles")(url, options, globals);
            }
            if (blankLines) {
              return blankLines + title;
            } else {
              if (title) {
                globals.gTitles[linkId] = title.replace(/"|'/g, "&quot;");
              }
              if (options.parseImgDimensions && width && height) {
                globals.gDimensions[linkId] = {
                  width,
                  height
                };
              }
            }
            return "";
          };
          text = text.replace(base64Regex, replaceFunc);
          text = text.replace(regex, replaceFunc);
          text = text.replace(/0/, "");
          return text;
        });
        showdown2.subParser("tables", function(text, options, globals) {
          if (!options.tables) {
            return text;
          }
          var tableRgx = /^ {0,3}\|?.+\|.+\n {0,3}\|?[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*:?[ \t]*(?:[-=]){2,}[\s\S]+?(?:\n\n|0)/gm, singeColTblRgx = /^ {0,3}\|.+\|[ \t]*\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n( {0,3}\|.+\|[ \t]*\n)*(?:\n|0)/gm;
          function parseStyles(sLine) {
            if (/^:[ \t]*--*$/.test(sLine)) {
              return ' style="text-align:left;"';
            } else if (/^--*[ \t]*:[ \t]*$/.test(sLine)) {
              return ' style="text-align:right;"';
            } else if (/^:[ \t]*--*[ \t]*:$/.test(sLine)) {
              return ' style="text-align:center;"';
            } else {
              return "";
            }
          }
          function parseHeaders(header, style) {
            var id = "";
            header = header.trim();
            if (options.tablesHeaderId || options.tableHeaderId) {
              id = ' id="' + header.replace(/ /g, "_").toLowerCase() + '"';
            }
            header = showdown2.subParser("spanGamut")(header, options, globals);
            return "<th" + id + style + ">" + header + "</th>\n";
          }
          function parseCells(cell, style) {
            var subText = showdown2.subParser("spanGamut")(cell, options, globals);
            return "<td" + style + ">" + subText + "</td>\n";
          }
          function buildTable(headers, cells) {
            var tb = "<table>\n<thead>\n<tr>\n", tblLgn = headers.length;
            for (var i = 0; i < tblLgn; ++i) {
              tb += headers[i];
            }
            tb += "</tr>\n</thead>\n<tbody>\n";
            for (i = 0; i < cells.length; ++i) {
              tb += "<tr>\n";
              for (var ii = 0; ii < tblLgn; ++ii) {
                tb += cells[i][ii];
              }
              tb += "</tr>\n";
            }
            tb += "</tbody>\n</table>\n";
            return tb;
          }
          function parseTable(rawTable) {
            var i, tableLines = rawTable.split("\n");
            for (i = 0; i < tableLines.length; ++i) {
              if (/^ {0,3}\|/.test(tableLines[i])) {
                tableLines[i] = tableLines[i].replace(/^ {0,3}\|/, "");
              }
              if (/\|[ \t]*$/.test(tableLines[i])) {
                tableLines[i] = tableLines[i].replace(/\|[ \t]*$/, "");
              }
              tableLines[i] = showdown2.subParser("codeSpans")(tableLines[i], options, globals);
            }
            var rawHeaders = tableLines[0].split("|").map(function(s) {
              return s.trim();
            }), rawStyles = tableLines[1].split("|").map(function(s) {
              return s.trim();
            }), rawCells = [], headers = [], styles = [], cells = [];
            tableLines.shift();
            tableLines.shift();
            for (i = 0; i < tableLines.length; ++i) {
              if (tableLines[i].trim() === "") {
                continue;
              }
              rawCells.push(
                tableLines[i].split("|").map(function(s) {
                  return s.trim();
                })
              );
            }
            if (rawHeaders.length < rawStyles.length) {
              return rawTable;
            }
            for (i = 0; i < rawStyles.length; ++i) {
              styles.push(parseStyles(rawStyles[i]));
            }
            for (i = 0; i < rawHeaders.length; ++i) {
              if (showdown2.helper.isUndefined(styles[i])) {
                styles[i] = "";
              }
              headers.push(parseHeaders(rawHeaders[i], styles[i]));
            }
            for (i = 0; i < rawCells.length; ++i) {
              var row = [];
              for (var ii = 0; ii < headers.length; ++ii) {
                if (showdown2.helper.isUndefined(rawCells[i][ii])) ;
                row.push(parseCells(rawCells[i][ii], styles[ii]));
              }
              cells.push(row);
            }
            return buildTable(headers, cells);
          }
          text = globals.converter._dispatch("tables.before", text, options, globals);
          text = text.replace(/\\(\|)/g, showdown2.helper.escapeCharactersCallback);
          text = text.replace(tableRgx, parseTable);
          text = text.replace(singeColTblRgx, parseTable);
          text = globals.converter._dispatch("tables.after", text, options, globals);
          return text;
        });
        showdown2.subParser("underline", function(text, options, globals) {
          if (!options.underline) {
            return text;
          }
          text = globals.converter._dispatch("underline.before", text, options, globals);
          if (options.literalMidWordUnderscores) {
            text = text.replace(/\b___(\S[\s\S]*?)___\b/g, function(wm, txt) {
              return "<u>" + txt + "</u>";
            });
            text = text.replace(/\b__(\S[\s\S]*?)__\b/g, function(wm, txt) {
              return "<u>" + txt + "</u>";
            });
          } else {
            text = text.replace(/___(\S[\s\S]*?)___/g, function(wm, m) {
              return /\S$/.test(m) ? "<u>" + m + "</u>" : wm;
            });
            text = text.replace(/__(\S[\s\S]*?)__/g, function(wm, m) {
              return /\S$/.test(m) ? "<u>" + m + "</u>" : wm;
            });
          }
          text = text.replace(/(_)/g, showdown2.helper.escapeCharactersCallback);
          text = globals.converter._dispatch("underline.after", text, options, globals);
          return text;
        });
        showdown2.subParser("unescapeSpecialChars", function(text, options, globals) {
          text = globals.converter._dispatch("unescapeSpecialChars.before", text, options, globals);
          text = text.replace(/E(\d+)E/g, function(wholeMatch, m1) {
            var charCodeToReplace = parseInt(m1);
            return String.fromCharCode(charCodeToReplace);
          });
          text = globals.converter._dispatch("unescapeSpecialChars.after", text, options, globals);
          return text;
        });
        showdown2.subParser("makeMarkdown.blockquote", function(node, globals) {
          var txt = "";
          if (node.hasChildNodes()) {
            var children = node.childNodes, childrenLength = children.length;
            for (var i = 0; i < childrenLength; ++i) {
              var innerTxt = showdown2.subParser("makeMarkdown.node")(children[i], globals);
              if (innerTxt === "") {
                continue;
              }
              txt += innerTxt;
            }
          }
          txt = txt.trim();
          txt = "> " + txt.split("\n").join("\n> ");
          return txt;
        });
        showdown2.subParser("makeMarkdown.codeBlock", function(node, globals) {
          var lang = node.getAttribute("language"), num = node.getAttribute("precodenum");
          return "```" + lang + "\n" + globals.preList[num] + "\n```";
        });
        showdown2.subParser("makeMarkdown.codeSpan", function(node) {
          return "`" + node.innerHTML + "`";
        });
        showdown2.subParser("makeMarkdown.emphasis", function(node, globals) {
          var txt = "";
          if (node.hasChildNodes()) {
            txt += "*";
            var children = node.childNodes, childrenLength = children.length;
            for (var i = 0; i < childrenLength; ++i) {
              txt += showdown2.subParser("makeMarkdown.node")(children[i], globals);
            }
            txt += "*";
          }
          return txt;
        });
        showdown2.subParser("makeMarkdown.header", function(node, globals, headerLevel) {
          var headerMark = new Array(headerLevel + 1).join("#"), txt = "";
          if (node.hasChildNodes()) {
            txt = headerMark + " ";
            var children = node.childNodes, childrenLength = children.length;
            for (var i = 0; i < childrenLength; ++i) {
              txt += showdown2.subParser("makeMarkdown.node")(children[i], globals);
            }
          }
          return txt;
        });
        showdown2.subParser("makeMarkdown.hr", function() {
          return "---";
        });
        showdown2.subParser("makeMarkdown.image", function(node) {
          var txt = "";
          if (node.hasAttribute("src")) {
            txt += "![" + node.getAttribute("alt") + "](";
            txt += "<" + node.getAttribute("src") + ">";
            if (node.hasAttribute("width") && node.hasAttribute("height")) {
              txt += " =" + node.getAttribute("width") + "x" + node.getAttribute("height");
            }
            if (node.hasAttribute("title")) {
              txt += ' "' + node.getAttribute("title") + '"';
            }
            txt += ")";
          }
          return txt;
        });
        showdown2.subParser("makeMarkdown.links", function(node, globals) {
          var txt = "";
          if (node.hasChildNodes() && node.hasAttribute("href")) {
            var children = node.childNodes, childrenLength = children.length;
            txt = "[";
            for (var i = 0; i < childrenLength; ++i) {
              txt += showdown2.subParser("makeMarkdown.node")(children[i], globals);
            }
            txt += "](";
            txt += "<" + node.getAttribute("href") + ">";
            if (node.hasAttribute("title")) {
              txt += ' "' + node.getAttribute("title") + '"';
            }
            txt += ")";
          }
          return txt;
        });
        showdown2.subParser("makeMarkdown.list", function(node, globals, type) {
          var txt = "";
          if (!node.hasChildNodes()) {
            return "";
          }
          var listItems = node.childNodes, listItemsLenght = listItems.length, listNum = node.getAttribute("start") || 1;
          for (var i = 0; i < listItemsLenght; ++i) {
            if (typeof listItems[i].tagName === "undefined" || listItems[i].tagName.toLowerCase() !== "li") {
              continue;
            }
            var bullet = "";
            if (type === "ol") {
              bullet = listNum.toString() + ". ";
            } else {
              bullet = "- ";
            }
            txt += bullet + showdown2.subParser("makeMarkdown.listItem")(listItems[i], globals);
            ++listNum;
          }
          txt += "\n<!-- -->\n";
          return txt.trim();
        });
        showdown2.subParser("makeMarkdown.listItem", function(node, globals) {
          var listItemTxt = "";
          var children = node.childNodes, childrenLenght = children.length;
          for (var i = 0; i < childrenLenght; ++i) {
            listItemTxt += showdown2.subParser("makeMarkdown.node")(children[i], globals);
          }
          if (!/\n$/.test(listItemTxt)) {
            listItemTxt += "\n";
          } else {
            listItemTxt = listItemTxt.split("\n").join("\n    ").replace(/^ {4}$/gm, "").replace(/\n\n+/g, "\n\n");
          }
          return listItemTxt;
        });
        showdown2.subParser("makeMarkdown.node", function(node, globals, spansOnly) {
          spansOnly = spansOnly || false;
          var txt = "";
          if (node.nodeType === 3) {
            return showdown2.subParser("makeMarkdown.txt")(node, globals);
          }
          if (node.nodeType === 8) {
            return "<!--" + node.data + "-->\n\n";
          }
          if (node.nodeType !== 1) {
            return "";
          }
          var tagName = node.tagName.toLowerCase();
          switch (tagName) {
            //
            // BLOCKS
            //
            case "h1":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.header")(node, globals, 1) + "\n\n";
              }
              break;
            case "h2":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.header")(node, globals, 2) + "\n\n";
              }
              break;
            case "h3":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.header")(node, globals, 3) + "\n\n";
              }
              break;
            case "h4":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.header")(node, globals, 4) + "\n\n";
              }
              break;
            case "h5":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.header")(node, globals, 5) + "\n\n";
              }
              break;
            case "h6":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.header")(node, globals, 6) + "\n\n";
              }
              break;
            case "p":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.paragraph")(node, globals) + "\n\n";
              }
              break;
            case "blockquote":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.blockquote")(node, globals) + "\n\n";
              }
              break;
            case "hr":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.hr")(node, globals) + "\n\n";
              }
              break;
            case "ol":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.list")(node, globals, "ol") + "\n\n";
              }
              break;
            case "ul":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.list")(node, globals, "ul") + "\n\n";
              }
              break;
            case "precode":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.codeBlock")(node, globals) + "\n\n";
              }
              break;
            case "pre":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.pre")(node, globals) + "\n\n";
              }
              break;
            case "table":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.table")(node, globals) + "\n\n";
              }
              break;
            //
            // SPANS
            //
            case "code":
              txt = showdown2.subParser("makeMarkdown.codeSpan")(node, globals);
              break;
            case "em":
            case "i":
              txt = showdown2.subParser("makeMarkdown.emphasis")(node, globals);
              break;
            case "strong":
            case "b":
              txt = showdown2.subParser("makeMarkdown.strong")(node, globals);
              break;
            case "del":
              txt = showdown2.subParser("makeMarkdown.strikethrough")(node, globals);
              break;
            case "a":
              txt = showdown2.subParser("makeMarkdown.links")(node, globals);
              break;
            case "img":
              txt = showdown2.subParser("makeMarkdown.image")(node, globals);
              break;
            default:
              txt = node.outerHTML + "\n\n";
          }
          return txt;
        });
        showdown2.subParser("makeMarkdown.paragraph", function(node, globals) {
          var txt = "";
          if (node.hasChildNodes()) {
            var children = node.childNodes, childrenLength = children.length;
            for (var i = 0; i < childrenLength; ++i) {
              txt += showdown2.subParser("makeMarkdown.node")(children[i], globals);
            }
          }
          txt = txt.trim();
          return txt;
        });
        showdown2.subParser("makeMarkdown.pre", function(node, globals) {
          var num = node.getAttribute("prenum");
          return "<pre>" + globals.preList[num] + "</pre>";
        });
        showdown2.subParser("makeMarkdown.strikethrough", function(node, globals) {
          var txt = "";
          if (node.hasChildNodes()) {
            txt += "~~";
            var children = node.childNodes, childrenLength = children.length;
            for (var i = 0; i < childrenLength; ++i) {
              txt += showdown2.subParser("makeMarkdown.node")(children[i], globals);
            }
            txt += "~~";
          }
          return txt;
        });
        showdown2.subParser("makeMarkdown.strong", function(node, globals) {
          var txt = "";
          if (node.hasChildNodes()) {
            txt += "**";
            var children = node.childNodes, childrenLength = children.length;
            for (var i = 0; i < childrenLength; ++i) {
              txt += showdown2.subParser("makeMarkdown.node")(children[i], globals);
            }
            txt += "**";
          }
          return txt;
        });
        showdown2.subParser("makeMarkdown.table", function(node, globals) {
          var txt = "", tableArray = [[], []], headings = node.querySelectorAll("thead>tr>th"), rows = node.querySelectorAll("tbody>tr"), i, ii;
          for (i = 0; i < headings.length; ++i) {
            var headContent = showdown2.subParser("makeMarkdown.tableCell")(headings[i], globals), allign = "---";
            if (headings[i].hasAttribute("style")) {
              var style = headings[i].getAttribute("style").toLowerCase().replace(/\s/g, "");
              switch (style) {
                case "text-align:left;":
                  allign = ":---";
                  break;
                case "text-align:right;":
                  allign = "---:";
                  break;
                case "text-align:center;":
                  allign = ":---:";
                  break;
              }
            }
            tableArray[0][i] = headContent.trim();
            tableArray[1][i] = allign;
          }
          for (i = 0; i < rows.length; ++i) {
            var r = tableArray.push([]) - 1, cols = rows[i].getElementsByTagName("td");
            for (ii = 0; ii < headings.length; ++ii) {
              var cellContent = " ";
              if (typeof cols[ii] !== "undefined") {
                cellContent = showdown2.subParser("makeMarkdown.tableCell")(cols[ii], globals);
              }
              tableArray[r].push(cellContent);
            }
          }
          var cellSpacesCount = 3;
          for (i = 0; i < tableArray.length; ++i) {
            for (ii = 0; ii < tableArray[i].length; ++ii) {
              var strLen = tableArray[i][ii].length;
              if (strLen > cellSpacesCount) {
                cellSpacesCount = strLen;
              }
            }
          }
          for (i = 0; i < tableArray.length; ++i) {
            for (ii = 0; ii < tableArray[i].length; ++ii) {
              if (i === 1) {
                if (tableArray[i][ii].slice(-1) === ":") {
                  tableArray[i][ii] = showdown2.helper.padEnd(tableArray[i][ii].slice(-1), cellSpacesCount - 1, "-") + ":";
                } else {
                  tableArray[i][ii] = showdown2.helper.padEnd(tableArray[i][ii], cellSpacesCount, "-");
                }
              } else {
                tableArray[i][ii] = showdown2.helper.padEnd(tableArray[i][ii], cellSpacesCount);
              }
            }
            txt += "| " + tableArray[i].join(" | ") + " |\n";
          }
          return txt.trim();
        });
        showdown2.subParser("makeMarkdown.tableCell", function(node, globals) {
          var txt = "";
          if (!node.hasChildNodes()) {
            return "";
          }
          var children = node.childNodes, childrenLength = children.length;
          for (var i = 0; i < childrenLength; ++i) {
            txt += showdown2.subParser("makeMarkdown.node")(children[i], globals, true);
          }
          return txt.trim();
        });
        showdown2.subParser("makeMarkdown.txt", function(node) {
          var txt = node.nodeValue;
          txt = txt.replace(/ +/g, " ");
          txt = txt.replace(/NBSP;/g, " ");
          txt = showdown2.helper.unescapeHTMLEntities(txt);
          txt = txt.replace(/([*_~|`])/g, "\\$1");
          txt = txt.replace(/^(\s*)>/g, "\\$1>");
          txt = txt.replace(/^#/gm, "\\#");
          txt = txt.replace(/^(\s*)([-=]{3,})(\s*)$/, "$1\\$2$3");
          txt = txt.replace(/^( {0,3}\d+)\./gm, "$1\\.");
          txt = txt.replace(/^( {0,3})([+-])/gm, "$1\\$2");
          txt = txt.replace(/]([\s]*)\(/g, "\\]$1\\(");
          txt = txt.replace(/^ {0,3}\[([\S \t]*?)]:/gm, "\\[$1]:");
          return txt;
        });
        var root = this;
        if (module2.exports) {
          module2.exports = showdown2;
        } else {
          root.showdown = showdown2;
        }
      }).call(showdown$1);
    })(showdown$2);
    return showdown$2.exports;
  }
  var showdownExports = requireShowdown();
  const showdown = /* @__PURE__ */ getDefaultExportFromCjs$1(showdownExports);
  function createWorkerBlob(cdnUrl, services) {
    return new Blob([`
        importScripts("${cdnUrl}/service-manager.js");
        const manager = new ServiceManager(self);

        ${services.map((service) => {
      var _a;
      return `
            manager.registerService("${service.name}", {
                module: () => {
                    importScripts("${(_a = service.cdnUrl) != null ? _a : cdnUrl}/${service.script}");
                    return {${service.className}};
                },
                className: "${service.className}",
                modes: "${service.modes}"
            });
        `;
    }).join("\n")}
    `], { type: "application/javascript" });
  }
  function createWorker(source, includeLinters) {
    if (includeLinters === void 0) {
      includeLinters = true;
    }
    if (typeof Worker == "undefined") return {
      postMessage: function() {
      },
      terminate: function() {
      }
    };
    let blob;
    if (typeof source === "string") {
      const allServices = getServices(includeLinters);
      blob = createWorkerBlob(source, allServices);
    } else {
      const allServices = [...source.services, ...getServices(includeLinters)];
      const cdnUrl = source.serviceManagerCdn;
      blob = createWorkerBlob(cdnUrl, allServices);
    }
    var URL = window.URL || window.webkitURL;
    var blobURL = URL.createObjectURL(blob);
    return new Worker(blobURL);
  }
  function getServices(includeLinters) {
    const allServices = [
      {
        name: "json",
        script: "json-service.js",
        className: "JsonService",
        modes: "json|json5"
      },
      {
        name: "html",
        script: "html-service.js",
        className: "HtmlService",
        modes: "html"
      },
      {
        name: "css",
        script: "css-service.js",
        className: "CssService",
        modes: "css"
      },
      {
        name: "less",
        script: "css-service.js",
        className: "CssService",
        modes: "less"
      },
      {
        name: "scss",
        script: "css-service.js",
        className: "CssService",
        modes: "scss"
      },
      {
        name: "typescript",
        script: "typescript-service.js",
        className: "TypescriptService",
        modes: "typescript|tsx|javascript|jsx"
      },
      {
        name: "lua",
        script: "lua-service.js",
        className: "LuaService",
        modes: "lua"
      },
      {
        name: "yaml",
        script: "yaml-service.js",
        className: "YamlService",
        modes: "yaml"
      },
      {
        name: "xml",
        script: "xml-service.js",
        className: "XmlService",
        modes: "xml"
      },
      {
        name: "php",
        script: "php-service.js",
        className: "PhpService",
        modes: "php"
      },
      {
        name: "eslint",
        script: "javascript-service.js",
        className: "JavascriptService",
        modes: "javascript"
      },
      {
        name: "python",
        script: "python-service.js",
        className: "PythonService",
        modes: "python",
        cdnUrl: "https://www.unpkg.com/ace-python-ruff-linter/build"
      }
    ];
    if (includeLinters === true || includeLinters === void 0) {
      return allServices;
    } else if (includeLinters === false) {
      return [];
    }
    if (includeLinters.javascript) {
      includeLinters.eslint = includeLinters.javascript;
      delete includeLinters.javascript;
    }
    return allServices.filter((service) => {
      return includeLinters[service.name];
    });
  }
  var CLASSNAME = "ace_tooltip";
  class Tooltip {
    /**
     * @param {Element} parentNode
     **/
    constructor(parentNode) {
      this.isOpen = false;
      this.$element = null;
      this.$parentNode = parentNode;
    }
    $init() {
      this.$element = document.createElement("div");
      this.$element.className = CLASSNAME;
      this.$element.style.display = "none";
      this.$parentNode.appendChild(this.$element);
      return this.$element;
    }
    /**
     * @returns {HTMLElement}
     **/
    getElement() {
      return this.$element || this.$init();
    }
    /**
     * @param {String} text
     **/
    setText(text) {
      this.getElement().textContent = text;
    }
    /**
     * @param {String} html
     **/
    setHtml(html) {
      this.getElement().innerHTML = html;
    }
    /**
     * @param {Number} x
     * @param {Number} y
     **/
    setPosition(x, y) {
      this.getElement().style.left = x + "px";
      this.getElement().style.top = y + "px";
    }
    /**
     * @param {String} className
     **/
    setClassName(className) {
      this.getElement().className += " " + className;
    }
    setTheme(theme) {
      this.getElement().className = CLASSNAME + " " + (theme.isDark ? "ace_dark " : "") + (theme.cssClass || "");
    }
    /**
     * @param {String} text
     * @param {Number} x
     * @param {Number} y
     **/
    show(text, x, y) {
      if (text != null)
        this.setText(text);
      if (x != null && y != null)
        this.setPosition(x, y);
      if (!this.isOpen) {
        this.getElement().style.display = "block";
        this.isOpen = true;
      }
    }
    hide() {
      if (this.isOpen) {
        this.getElement().style.display = "none";
        this.getElement().className = CLASSNAME;
        this.isOpen = false;
      }
    }
    /**
     * @returns {Number}
     **/
    getHeight() {
      return this.getElement().offsetHeight;
    }
    /**
     * @returns {Number}
     **/
    getWidth() {
      return this.getElement().offsetWidth;
    }
    destroy() {
      this.isOpen = false;
      if (this.$element && this.$element.parentNode) {
        this.$element.parentNode.removeChild(this.$element);
      }
    }
  }
  class PopupManager {
    constructor() {
      this.popups = /* @__PURE__ */ new Set();
      this.acePopups = /* @__PURE__ */ new Set();
      this.updateScheduled = false;
    }
    addPopup(popup) {
      if (!popup || typeof popup.getElement !== "function") {
        console.warn("Invalid popup object provided to addPopup");
        return;
      }
      this.popups.add(popup);
      this.scheduleUpdate();
    }
    addAcePopup(popup) {
      if (!popup) {
        console.warn("Invalid popup object provided to addAcePopup");
        return;
      }
      this.acePopups.add(popup);
      this.scheduleUpdate();
    }
    removePopup(popup) {
      if (this.popups.has(popup)) {
        this.popups.delete(popup);
        this.scheduleUpdate();
      }
    }
    removeAcePopup(popup) {
      if (this.acePopups.has(popup)) {
        this.acePopups.delete(popup);
        this.scheduleUpdate();
      }
    }
    scheduleUpdate() {
      if (this.updateScheduled) return;
      this.updateScheduled = true;
      requestAnimationFrame(() => {
        this.updateScheduled = false;
        this.updatePopups();
      });
    }
    cleanupStalePopups() {
      for (const popup of this.popups) {
        if (!this.isPopupValid(popup)) {
          this.popups.delete(popup);
        }
      }
      for (const popup of this.acePopups) {
        if (!this.isPopupValid(popup)) {
          this.acePopups.delete(popup);
        }
      }
    }
    isPopupValid(popup) {
      try {
        const element = typeof popup.getElement === "function" ? popup.getElement() : popup.container;
        return element && element.isConnected;
      } catch (e) {
        return false;
      }
    }
    updatePopups() {
      try {
        this.cleanupStalePopups();
        const pupups = Array.from(this.popups).sort((a, b) => (b.priority || 0) - (a.priority || 0));
        const sortedPopups = [...this.acePopups, ...pupups];
        const visiblePopups = [];
        for (const popup of sortedPopups) {
          if (!this.shouldDisplayPopup(popup, visiblePopups)) {
            this.safeHidePopup(popup);
          } else {
            visiblePopups.push(popup);
          }
        }
      } catch (error) {
        console.error("Error updating popups:", error);
      }
    }
    shouldDisplayPopup(popup, visiblePopups) {
      try {
        if (!this.isPopupValid(popup)) {
          return false;
        }
        for (const visiblePopup of visiblePopups) {
          if (this.doPopupsOverlap(visiblePopup, popup)) {
            return false;
          }
        }
        return true;
      } catch (error) {
        console.error("Error checking popup display:", error);
        return false;
      }
    }
    safeHidePopup(popup) {
      try {
        if (popup && typeof popup.hide === "function") {
          popup.hide();
        }
      } catch (error) {
        console.error("Error hiding popup:", error);
      }
    }
    doPopupsOverlap(popupA, popupB) {
      try {
        const elemA = typeof popupA.getElement === "function" ? popupA.getElement() : popupA.container;
        const elemB = typeof popupB.getElement === "function" ? popupB.getElement() : popupB.container;
        if (!elemA || !elemB || !elemA.isConnected || !elemB.isConnected) {
          return false;
        }
        const rectA = elemA.getBoundingClientRect();
        const rectB = elemB.getBoundingClientRect();
        return rectA.left < rectB.right && rectA.right > rectB.left && rectA.top < rectB.bottom && rectA.bottom > rectB.top;
      } catch (error) {
        console.error("Error checking popup overlap:", error);
        return false;
      }
    }
  }
  const popupManager = new PopupManager();
  class BaseTooltip extends Tooltip {
    constructor(provider) {
      super(document.body);
      this.$show = () => {
        if (!this.$activeEditor)
          return;
        let editor = this.$activeEditor;
        var MARGIN = 10;
        var renderer = editor.renderer;
        if (!this.isOpen) {
          this.$registerEditorEvents();
          this.setTheme(renderer.theme);
          this.isOpen = true;
        }
        let position = renderer.textToScreenCoordinates(this.row, this.column);
        var rect = renderer.scroller.getBoundingClientRect();
        if (position.pageX < rect.left)
          position.pageX = rect.left;
        var element = this.getElement();
        element.style.maxHeight = "";
        element.style.display = "block";
        var labelHeight = element.clientHeight;
        var labelWidth = element.clientWidth;
        var spaceBelow = window.innerHeight - position.pageY - renderer.lineHeight;
        let isAbove = true;
        if (position.pageY - labelHeight < 0 && position.pageY < spaceBelow) {
          isAbove = false;
        }
        element.style.maxHeight = (isAbove ? position.pageY : spaceBelow) - MARGIN + "px";
        element.style.top = isAbove ? "" : position.pageY + renderer.lineHeight + "px";
        element.style.bottom = isAbove ? window.innerHeight - position.pageY + "px" : "";
        element.style.left = Math.min(position.pageX, window.innerWidth - labelWidth - MARGIN) + "px";
        popupManager.addPopup(this);
      };
      this.$hide = () => {
        if (this.timeout) {
          clearTimeout(this.timeout);
          this.timeout = null;
        }
        this.lastEvent = null;
        if (this.isOpen) {
          this.$removeEditorEvents();
          this.hide();
        }
        this.$inactivateEditor();
      };
      this.provider = provider;
      try {
        Tooltip.call(this, document.body);
      } catch (e) {
      }
      this.timeout = void 0;
      this.lastT = 0;
      this.idleTime = 500;
      var el = this.getElement();
      el.style.whiteSpace = "pre-wrap";
      el.style.pointerEvents = "auto";
    }
    hide() {
      super.hide();
      popupManager.removePopup(this);
    }
    show(param, pageX, pageY) {
      super.show(param, pageX, pageY);
      this.$registerEditorEvents();
    }
    setHtml(descriptionText) {
      super.setHtml(descriptionText);
    }
    $inactivateEditor() {
      this.$activeEditor = void 0;
    }
    $activateEditor(editor) {
      if (this.$activeEditor == editor)
        return;
      this.$activeEditor = editor;
    }
    destroy() {
      this.$hide();
    }
    $registerEditorEvents() {
    }
    $removeEditorEvents() {
    }
  }
  class SignatureTooltip extends BaseTooltip {
    constructor() {
      super(...arguments);
      this.editorHandlers = /* @__PURE__ */ new Map();
      this.escCommand = {
        exec: this.$hide,
        bindKey: "Esc"
      };
      this.onChangeSelection = (editor) => {
        if (!this.provider.options.functionality.signatureHelp)
          return;
        this.$activateEditor(editor);
        if (this.isOpen) {
          setTimeout(this.provideSignatureHelp, 0);
        } else {
          this.lastT = Date.now();
          this.timeout = setTimeout(this.waitForSignature, this.idleTime);
        }
      };
      this.waitForSignature = () => {
        if (this.timeout) clearTimeout(this.timeout);
        var dt = Date.now() - this.lastT;
        if (this.idleTime - dt > 10) {
          this.timeout = setTimeout(this.waitForSignature, this.idleTime - dt);
          return;
        }
        this.timeout = void 0;
        this.provideSignatureHelp();
      };
      this.provideSignatureHelp = () => {
        if (!this.$activeEditor) {
          return;
        }
        let cursor = this.$activeEditor.getCursorPosition();
        let session = this.$activeEditor.session;
        let docPos = session.screenToDocumentPosition(cursor.row, cursor.column);
        this.provider.provideSignatureHelp(session, docPos, (tooltip) => {
          var _a, _b, _c, _d, _e;
          let descriptionText = tooltip ? this.provider.getTooltipText(tooltip) : null;
          if (!tooltip || !descriptionText) {
            this.hide();
            return;
          }
          let token = session.getTokenAt(docPos.row, docPos.column);
          let row = (_b = (_a = tooltip.range) == null ? void 0 : _a.start.row) != null ? _b : docPos.row;
          let column = (_e = (_d = (_c = tooltip.range) == null ? void 0 : _c.start.column) != null ? _d : token == null ? void 0 : token.start) != null ? _e : 0;
          if (this.descriptionText != descriptionText) {
            this.hide();
            this.setHtml(descriptionText);
            this.descriptionText = descriptionText;
          } else if (this.row == row && this.column == column && this.isOpen) {
            return;
          }
          this.row = row;
          this.column = column;
          this.$show();
        });
      };
      this.$onAfterRender = (e) => {
        if (!this.isOpen) return;
        setTimeout(() => {
          var _a;
          if (!((_a = this.$activeEditor) == null ? void 0 : _a.isRowVisible(this.row))) {
            this.$hide();
          } else {
            this.$show();
          }
        }, 0);
      };
    }
    registerEditor(editor) {
      const handler = () => this.onChangeSelection(editor);
      this.editorHandlers.set(editor, handler);
      editor.on("changeSelection", handler);
      editor.commands.addCommand(this.escCommand);
    }
    unregisterEditor(editor) {
      const handler = this.editorHandlers.get(editor);
      if (handler) {
        editor.off("changeSelection", handler);
        this.editorHandlers.delete(editor);
      }
      if (this.$activeEditor === editor) {
        this.$inactivateEditor();
      }
      editor.commands.removeCommand(this.escCommand);
    }
    $registerEditorEvents() {
      this.$activeEditor.renderer.on("afterRender", this.$onAfterRender);
      this.$activeEditor.on("blur", this.$hide);
    }
    $removeEditorEvents() {
      this.$activeEditor.renderer.off("afterRender", this.$onAfterRender);
      this.$activeEditor.off("blur", this.$hide);
    }
  }
  function preventParentScroll(event) {
    event.stopPropagation();
    var target = event.currentTarget;
    var contentOverflows = target.scrollHeight > target.clientHeight;
    if (!contentOverflows) {
      event.preventDefault();
    }
  }
  class HoverTooltip extends Tooltip {
    constructor(parentNode = document.body) {
      super(parentNode);
      this.timeout = void 0;
      this.lastT = 0;
      this.idleTime = 350;
      this.lastEvent = void 0;
      this.onMouseOut = this.onMouseOut.bind(this);
      this.onMouseMove = this.onMouseMove.bind(this);
      this.waitForHover = this.waitForHover.bind(this);
      this.hide = this.hide.bind(this);
      var el = this.getElement();
      el.style.whiteSpace = "pre-wrap";
      el.style.pointerEvents = "auto";
      el.addEventListener("mouseout", this.onMouseOut);
      el.tabIndex = -1;
      el.addEventListener("blur", (function() {
        if (!el.contains(document.activeElement)) this.hide();
      }).bind(this));
      el.addEventListener("wheel", preventParentScroll);
    }
    /**
     * @param {Editor} editor
     */
    addToEditor(editor) {
      editor.on("mousemove", this.onMouseMove);
      editor.on("mousedown", this.hide);
      editor.renderer.getMouseEventTarget().addEventListener("mouseout", this.onMouseOut, true);
    }
    /**
     * @param {Editor} editor
     */
    removeFromEditor(editor) {
      editor.off("mousemove", this.onMouseMove);
      editor.off("mousedown", this.hide);
      editor.renderer.getMouseEventTarget().removeEventListener("mouseout", this.onMouseOut, true);
      if (this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
      }
    }
    /**
     * @param {MouseEvent} e
     * @param {Editor} editor
     * @internal
     */
    onMouseMove(e, editor) {
      this.lastEvent = e;
      this.lastT = Date.now();
      var isMousePressed = editor.$mouseHandler.isMousePressed;
      if (this.isOpen) {
        var pos = this.lastEvent && this.lastEvent.getDocumentPosition();
        if (!this.range || !this.range.contains(pos.row, pos.column) || isMousePressed || this.isOutsideOfText(this.lastEvent)) {
          this.hide();
        }
      }
      if (this.timeout || isMousePressed) return;
      this.lastEvent = e;
      this.timeout = setTimeout(this.waitForHover, this.idleTime);
    }
    waitForHover() {
      if (this.timeout) clearTimeout(this.timeout);
      var dt = Date.now() - this.lastT;
      if (this.idleTime - dt > 10) {
        this.timeout = setTimeout(this.waitForHover, this.idleTime - dt);
        return;
      }
      this.timeout = null;
      if (this.lastEvent && !this.isOutsideOfText(this.lastEvent)) {
        this.$gatherData(this.lastEvent, this.lastEvent.editor);
      }
    }
    /**
     * @param {MouseEvent} e
     */
    isOutsideOfText(e) {
      var editor = e.editor;
      var docPos = e.getDocumentPosition();
      var line = editor.session.getLine(docPos.row);
      if (docPos.column == line.length) {
        var screenPos = editor.renderer.pixelToScreenCoordinates(e.clientX, e.clientY);
        var clippedPos = editor.session.documentToScreenPosition(docPos.row, docPos.column);
        if (clippedPos.column != screenPos.column || clippedPos.row != screenPos.row) {
          return true;
        }
      }
      return false;
    }
    /**
     * @param {(event: MouseEvent, editor: Editor) => void} value
     */
    setDataProvider(value) {
      this.$gatherData = value;
    }
    /**
     * @param {Editor} editor
     * @param {Range} range
     * @param {HTMLElement} domNode
     * @param {MouseEvent} [startingEvent]
     */
    showForRange(editor, range, domNode, startingEvent) {
      var MARGIN = 10;
      if (startingEvent && startingEvent != this.lastEvent) return;
      if (this.isOpen && document.activeElement == this.getElement()) return;
      var renderer = editor.renderer;
      if (!this.isOpen) {
        this.$registerCloseEvents();
        this.setTheme(renderer.theme);
      }
      this.isOpen = true;
      this.addMarker(range, editor.session);
      const Range2 = editor.getSelectionRange().constructor;
      this.range = Range2.fromPoints(range.start, range.end);
      var position = renderer.textToScreenCoordinates(range.start.row, range.start.column);
      var rect = renderer.scroller.getBoundingClientRect();
      if (position.pageX < rect.left)
        position.pageX = rect.left;
      var element = this.getElement();
      element.innerHTML = "";
      element.appendChild(domNode);
      element.style.maxHeight = "";
      element.style.display = "block";
      var labelHeight = element.clientHeight;
      var labelWidth = element.clientWidth;
      var spaceBelow = window.innerHeight - position.pageY - renderer.lineHeight;
      let isAbove = true;
      if (position.pageY - labelHeight < 0 && position.pageY < spaceBelow) {
        isAbove = false;
      }
      element.style.maxHeight = (isAbove ? position.pageY : spaceBelow) - MARGIN + "px";
      element.style.top = isAbove ? "" : position.pageY + renderer.lineHeight + "px";
      element.style.bottom = isAbove ? window.innerHeight - position.pageY + "px" : "";
      element.style.left = Math.min(position.pageX, window.innerWidth - labelWidth - MARGIN) + "px";
      popupManager.addPopup(this);
    }
    addMarker(range, session) {
      if (this.marker) {
        this.$markerSession.removeMarker(this.marker);
      }
      this.$markerSession = session;
      this.marker = session && session.addMarker(range, "ace_highlight-marker", "text");
    }
    hide(e) {
      var _a;
      if (!e && document.activeElement == this.getElement())
        return;
      if (e && e.target && (e.type != "keydown" || e.ctrlKey || e.metaKey) && ((_a = this.$element) == null ? void 0 : _a.contains(e.target)))
        return;
      this.lastEvent = null;
      if (this.timeout) clearTimeout(this.timeout);
      this.timeout = null;
      this.addMarker(null);
      if (this.isOpen) {
        this.$removeCloseEvents();
        this.getElement().style.display = "none";
        this.isOpen = false;
        popupManager.removePopup(this);
      }
    }
    $registerCloseEvents() {
      window.addEventListener("keydown", this.hide, true);
      window.addEventListener("wheel", this.hide, true);
      window.addEventListener("mousedown", this.hide, true);
    }
    $removeCloseEvents() {
      window.removeEventListener("keydown", this.hide, true);
      window.removeEventListener("wheel", this.hide, true);
      window.removeEventListener("mousedown", this.hide, true);
    }
    /**
     * @internal
     */
    onMouseOut(e) {
      if (this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
      }
      this.lastEvent = null;
      if (!this.isOpen) return;
      if (!e.relatedTarget || this.getElement().contains(e.relatedTarget)) return;
      if (e && e.currentTarget.contains(e.relatedTarget)) return;
      if (!e.relatedTarget.classList.contains("ace_content")) this.hide();
    }
  }
  class AceVirtualRenderer {
    static getConstructor(editor) {
      if (!AceVirtualRenderer._instance && editor) {
        AceVirtualRenderer._instance = editor.renderer.constructor;
      }
      return AceVirtualRenderer._instance;
    }
  }
  class AceEditor {
    static getConstructor(editor) {
      if (!AceEditor._instance && editor) {
        AceEditor._instance = editor.constructor;
      }
      return AceEditor._instance;
    }
  }
  var getAriaId = function(index) {
    return `suggest-aria-id:${index}`;
  };
  var _navigator = typeof navigator == "object" ? navigator : { userAgent: "" };
  var ua = _navigator.userAgent || "";
  var isSafari = parseFloat(ua.split(" Safari/")[1]) || void 0;
  var popupAriaRole = isSafari ? "menu" : "listbox";
  var optionAriaRole = isSafari ? "menuitem" : "option";
  var ariaActiveState = isSafari ? "aria-current" : "aria-selected";
  var $singleLineEditor = function(el) {
    var Renderer = AceVirtualRenderer.getConstructor();
    var Editor = AceEditor.getConstructor();
    var renderer = new Renderer(el);
    renderer.$maxLines = 4;
    var editor = new Editor(renderer);
    editor.setHighlightActiveLine(false);
    editor.setShowPrintMargin(false);
    editor.renderer.setShowGutter(false);
    editor.renderer.setHighlightGutterLine(false);
    editor.$mouseHandler.$focusTimeout = 0;
    editor.$highlightTagPending = true;
    return editor;
  };
  class AcePopup {
    /**
     * Creates and renders single line editor in popup window. If `parentNode` param is isset, then attaching it to this element.
     * @param {Element} [parentNode]
     * @return {Ace.AcePopup}
     */
    constructor(parentNode) {
      var el = document.createElement("div");
      var popup = $singleLineEditor(el);
      var Range2 = AceRange.getConstructor();
      if (parentNode) {
        parentNode.appendChild(el);
      }
      el.style.display = "none";
      popup.renderer.content.style.cursor = "default";
      popup.renderer.setStyle("ace_autocomplete");
      popup.renderer["$textLayer"].element.setAttribute("role", popupAriaRole);
      popup.renderer["textarea"].setAttribute("aria-hidden", "true");
      popup.setOption("displayIndentGuides", false);
      popup.setOption("dragDelay", 150);
      var noop2 = function() {
      };
      popup.focus = noop2;
      popup.$isFocused = true;
      popup.renderer["$cursorLayer"].restartTimer = noop2;
      popup.renderer["$cursorLayer"].element.style.opacity = "0";
      popup.renderer["$maxLines"] = 8;
      popup.renderer["$keepTextAreaAtCursor"] = false;
      popup.setHighlightActiveLine(false);
      popup.session.highlight("");
      popup.session["$searchHighlight"].clazz = "ace_highlight-marker";
      popup.on("mousedown", function(e) {
        var pos = e.getDocumentPosition();
        popup.selection.moveToPosition(pos);
        selectionMarker.start.row = selectionMarker.end.row = pos.row;
        e.stop();
      });
      var lastMouseEvent;
      var hoverMarker = new Range2(-1, 0, -1, Infinity);
      var selectionMarker = new Range2(-1, 0, -1, Infinity);
      selectionMarker.id = popup.session.addMarker(selectionMarker, "ace_active-line", "fullLine");
      popup.setSelectOnHover = function(val) {
        if (!val) {
          hoverMarker.id = popup.session.addMarker(hoverMarker, "ace_line-hover", "fullLine");
        } else if (hoverMarker.id) {
          popup.session.removeMarker(hoverMarker.id);
          hoverMarker.id = void 0;
        }
      };
      popup.setSelectOnHover(false);
      popup.on("mousemove", function(e) {
        if (!lastMouseEvent) {
          lastMouseEvent = e;
          return;
        }
        if (lastMouseEvent.x == e.x && lastMouseEvent.y == e.y) {
          return;
        }
        lastMouseEvent = e;
        lastMouseEvent.scrollTop = popup.renderer.scrollTop;
        popup.isMouseOver = true;
        var row = lastMouseEvent.getDocumentPosition().row;
        if (hoverMarker.start.row != row) {
          if (!hoverMarker.id)
            popup.setRow(row);
          setHoverMarker(row);
        }
      });
      popup.renderer.on("beforeRender", function() {
        if (lastMouseEvent && hoverMarker.start.row != -1) {
          lastMouseEvent.$pos = null;
          var row = lastMouseEvent.getDocumentPosition().row;
          if (!hoverMarker.id)
            popup.setRow(row);
          setHoverMarker(row, true);
        }
      });
      popup.renderer.on("afterRender", function() {
        var row = popup.getRow();
        var t = popup.renderer["$textLayer"];
        var selected = (
          /** @type {HTMLElement|null} */
          t.element.childNodes[row - t.config.firstRow]
        );
        var el2 = document.activeElement;
        if (selected !== popup.selectedNode && popup.selectedNode) {
          popup.renderer["$textLayer"].dom.removeCssClass(popup.selectedNode, "ace_selected");
          el2 == null ? void 0 : el2.removeAttribute("aria-activedescendant");
          popup.selectedNode.removeAttribute(ariaActiveState);
          popup.selectedNode.removeAttribute("id");
        }
        popup.selectedNode = selected;
        if (selected) {
          popup.renderer["$textLayer"].dom.addCssClass(selected, "ace_selected");
          var ariaId = getAriaId(row);
          selected.id = ariaId;
          t.element.setAttribute("aria-activedescendant", ariaId);
          el2 == null ? void 0 : el2.setAttribute("aria-activedescendant", ariaId);
          selected.setAttribute("role", optionAriaRole);
          selected.setAttribute("aria-label", popup.getData(row).caption || popup.getData(row).value);
          selected.setAttribute("aria-setsize", popup.data.length);
          selected.setAttribute("aria-posinset", row + 1);
          selected.setAttribute("aria-describedby", "doc-tooltip");
          selected.setAttribute(ariaActiveState, "true");
        }
      });
      var hideHoverMarker = function() {
        setHoverMarker(-1);
      };
      var setHoverMarker = function(row, suppressRedraw) {
        if (row !== hoverMarker.start.row) {
          hoverMarker.start.row = hoverMarker.end.row = row;
          if (!suppressRedraw) {
            popup.session._emit("changeBackMarker");
          }
          popup._emit("changeHoverMarker");
        }
      };
      popup.getHoveredRow = function() {
        return hoverMarker.start.row;
      };
      popup.container.addEventListener("mouseout", function() {
        popup.isMouseOver = false;
        hideHoverMarker();
      });
      popup.on("hide", hideHoverMarker);
      popup.on("changeSelection", hideHoverMarker);
      popup.session.doc.getLength = function() {
        return popup.data.length;
      };
      popup.session.doc.getLine = function(i) {
        var data = popup.data[i];
        if (typeof data == "string")
          return data;
        return data && data.value || "";
      };
      var bgTokenizer = popup.session.bgTokenizer;
      bgTokenizer.$tokenizeRow = function(row) {
        var data = popup.data[row];
        var tokens = [];
        if (!data)
          return tokens;
        if (typeof data == "string")
          data = { value: data };
        var caption = data.caption || data.value || data.name;
        function addToken(value, className) {
          value && tokens.push({
            type: (data.className || "") + (className || ""),
            value
          });
        }
        var lower = caption.toLowerCase();
        var filterText = (popup.filterText || "").toLowerCase();
        var lastIndex = 0;
        var lastI = 0;
        for (var i = 0; i <= filterText.length; i++) {
          if (i != lastI && (data.matchMask & 1 << i || i == filterText.length)) {
            var sub = filterText.slice(lastI, i);
            lastI = i;
            var index = lower.indexOf(sub, lastIndex);
            if (index == -1) continue;
            addToken(caption.slice(lastIndex, index), "");
            lastIndex = index + sub.length;
            addToken(caption.slice(index, lastIndex), "completion-highlight");
          }
        }
        addToken(caption.slice(lastIndex, caption.length), "");
        tokens.push({ type: "completion-spacer", value: " " });
        if (data.meta)
          tokens.push({ type: "completion-meta", value: data.meta });
        if (data.message)
          tokens.push({ type: "completion-message", value: data.message });
        return tokens;
      };
      bgTokenizer.$updateOnChange = noop2;
      bgTokenizer.start = noop2;
      popup.session["$computeWidth"] = function() {
        return this.screenWidth = 0;
      };
      popup.isOpen = false;
      popup.isTopdown = false;
      popup.autoSelect = true;
      popup.filterText = "";
      popup.isMouseOver = false;
      popup.data = [];
      popup.setData = function(list, filterText) {
        popup.filterText = filterText || "";
        popup.setValue("\n".repeat(list.length), -1);
        popup.data = list || [];
        popup.setRow(0);
      };
      popup.getData = function(row) {
        return popup.data[row];
      };
      popup.getRow = function() {
        return selectionMarker.start.row;
      };
      popup.setRow = function(line) {
        line = Math.max(this.autoSelect ? 0 : -1, Math.min(this.data.length - 1, line));
        if (selectionMarker.start.row != line) {
          popup.selection.clearSelection();
          selectionMarker.start.row = selectionMarker.end.row = line || 0;
          popup.session._emit("changeBackMarker");
          popup.moveCursorTo(line || 0, 0);
          if (popup.isOpen)
            popup._signal("select");
        }
      };
      popup.on("changeSelection", function() {
        if (popup.isOpen) {
          popup.setRow(popup.selection.lead.row);
        }
        popup.renderer.scrollCursorIntoView();
      });
      popup.hide = function() {
        this.container.style.display = "none";
        popup.anchorPos = null;
        popup.anchor = null;
        if (popup.isOpen) {
          popup.isOpen = false;
          this._signal("hide");
        }
      };
      popup.tryShow = function(pos, lineHeight, anchor, forceShow) {
        if (!forceShow && popup.isOpen && popup.anchorPos && popup.anchor && popup.anchorPos.top === pos.top && popup.anchorPos.left === pos.left && popup.anchor === anchor) {
          return true;
        }
        var el2 = this.container;
        var screenHeight = window.innerHeight;
        var screenWidth = window.innerWidth;
        var renderer = this.renderer;
        var maxH = renderer.$maxLines * lineHeight * 1.4;
        var dims = { top: 0, bottom: 0 };
        var spaceBelow = screenHeight - pos.top - 3 * this.$borderSize - lineHeight;
        var spaceAbove = pos.top - 3 * this.$borderSize;
        if (!anchor) {
          if (spaceAbove <= spaceBelow || spaceBelow >= maxH) {
            anchor = "bottom";
          } else {
            anchor = "top";
          }
        }
        if (anchor === "top") {
          dims.bottom = pos.top - this.$borderSize;
          dims.top = dims.bottom - maxH;
        } else if (anchor === "bottom") {
          dims.top = pos.top + lineHeight + this.$borderSize;
          dims.bottom = dims.top + maxH;
        }
        var fitsX = dims.top >= 0 && dims.bottom <= screenHeight;
        if (!forceShow && !fitsX) {
          return false;
        }
        if (!fitsX) {
          if (anchor === "top") {
            renderer.$maxPixelHeight = spaceAbove;
          } else {
            renderer.$maxPixelHeight = spaceBelow;
          }
        } else {
          renderer.$maxPixelHeight = null;
        }
        if (anchor === "top") {
          el2.style.top = "";
          el2.style.bottom = screenHeight - dims.bottom + "px";
          popup.isTopdown = false;
        } else {
          el2.style.top = dims.top + "px";
          el2.style.bottom = "";
          popup.isTopdown = true;
        }
        el2.style.display = "";
        var left = pos.left;
        if (left + el2.offsetWidth > screenWidth)
          left = screenWidth - el2.offsetWidth;
        el2.style.left = left + "px";
        el2.style.right = "";
        if (!popup.isOpen) {
          popup.isOpen = true;
          this._signal("show");
          lastMouseEvent = null;
        }
        popup.anchorPos = pos;
        popup.anchor = anchor;
        return true;
      };
      popup.show = function(pos, lineHeight, topdownOnly) {
        this.tryShow(pos, lineHeight, topdownOnly ? "bottom" : void 0, true);
      };
      popup.goTo = function(where) {
        var row = this.getRow();
        var max = this.session.getLength() - 1;
        switch (where) {
          case "up":
            row = row <= 0 ? max : row - 1;
            break;
          case "down":
            row = row >= max ? -1 : row + 1;
            break;
          case "start":
            row = 0;
            break;
          case "end":
            row = max;
            break;
        }
        this.setRow(row);
      };
      popup.getTextLeftOffset = function() {
        return this.$borderSize + this.renderer.$padding + this.$imageSize;
      };
      popup.$imageSize = 0;
      popup.$borderSize = 1;
      return popup;
    }
  }
  class LightbulbWidget {
    constructor(editor, executeActionCallback) {
      this.lightBulbWidth = 10;
      this.lightBulbHeight = 16;
      this.hideAll = () => {
        this.hideLightbulb();
        this.popup.hide();
      };
      this.setPosition = () => {
        const position = this.calculatePosition();
        this.lightbulb.style.left = `${position.x}px`;
        this.lightbulb.style.top = `${position.y}px`;
      };
      this.editor = editor;
      this.codeActions = [];
      this.executeActionCallback = executeActionCallback;
      this.popup = new AcePopup(editor.container || document.body || document.documentElement);
      this.popup.on("click", (e) => {
        const selectedRow = this.popup.getData(this.popup.getRow());
        this.executeAction(selectedRow["action"], selectedRow["serviceName"]);
        this.popup.hide();
        e.stop();
      });
      this.setEditorListeners(editor);
      this.createLightbulb();
    }
    setEditorListeners(editor) {
      editor.on("changeSelection", this.hideAll);
      editor.on("focus", this.hideAll);
      editor.renderer.on("afterRender", this.setPosition);
    }
    removeListeners() {
      this.editor.off("changeSelection", this.hideAll);
      this.editor.off("focus", this.hideAll);
      this.editor.renderer.off("afterRender", this.setPosition);
      this.editor.session.off("changeScrollTop", this.setPosition);
      this.editor.session.off("changeScrollLeft", this.setPosition);
    }
    setExecuteActionCallback(callback) {
      this.executeActionCallback = callback;
    }
    createLightbulb() {
      this.lightbulb = document.createElement("div");
      this.lightbulb.id = "lightbulb";
      this.lightbulb.style.display = "none";
      this.lightbulb.style.position = "absolute";
      this.lightbulb.style.width = this.lightBulbWidth + "px";
      this.lightbulb.style.height = this.lightBulbHeight + "px";
      this.lightbulb.style.zIndex = "999";
      this.lightbulb.style.background = "url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjxzdmcgdmlld0JveD0iNi4yMTM2IDIuMjk4MSAxMi42OTI0IDE4LjYzMjgiIHdpZHRoPSIxMCIgaGVpZ2h0PSIxNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCiAgPHBhdGggZD0iTSAxNi43ODEgNC4wOCBDIDE1LjQzMyAyLjc1MiAxMy42MiAyLjA5OCAxMS44MSAyLjM1MiBDIDguOTUyIDIuNzU0IDYuNjY4IDUuMjE0IDYuMjc4IDguMzA4IEMgNS45ODYgMTAuNjE2IDYuNjk2IDEyLjg0NSA4LjIyNyAxNC40MjQgQyA5LjE4NyAxNS40MTUgOS43MzkgMTYuNzgzIDkuNzM5IDE4LjE3NSBMIDE1LjM5NiAxOC4xODkgQyAxNS4zOTYgMTYuODc2IDE1LjkxMSAxNS40MTggMTYuODc1IDE0LjQzNSBDIDE4LjE2NSAxMy4xMTYgMTguOTA2IDExLjI0OSAxOC45MDYgOS4zMTQgQyAxOC45MDYgNy4zMTcgMTguMTMzIDUuNDEgMTYuNzgxIDQuMDggWiIgc3R5bGU9ImZpbGw6IHJnYigyNTIsIDE5NSwgODcpOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwgMCwgMCwgMSwgMCwgLTEuNDIxMDg1NDcxNTIwMjAwNGUtMTQpIi8+DQogIDxyZWN0IHg9IjguMzgiIHk9IjIzMy42NzkiIHdpZHRoPSI0LjMxMyIgaGVpZ2h0PSIwLjAxMSIgc3R5bGU9ImZpbGw6IHJnYigyMTYsIDIxNiwgMjE2KTsgc3Ryb2tlOiByZ2IoMCwgMCwgMCk7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLCAwLCAwLCAtMSwgMi4wNzg5ODQxMDcxNjIxODUsIDI1Mi45MzUzNDM1OTU5NDE5NikiLz4NCiAgPHJlY3QgeD0iLTExLjY2NSIgeT0iLTIzLjU5NSIgd2lkdGg9IjMuMDk4IiBzdHlsZT0iZmlsbDogcmdiKDIxNiwgMjE2LCAyMTYpOyBzdHJva2U6IHJnYigwLCAwLCAwKTsiIHRyYW5zZm9ybT0ibWF0cml4KDAuOTk5OTgxOTk5Mzk3Mjc3OSwgLTAuMDA2MDUyOTk5NzU3MjMwMjgxLCAwLCAxLjAwMDAxODAwMDYwMjcyMjIsIDIyLjcyOTA4NDk0NDQxNjMwNywgNDQuNDQ0NjczNDQ4NDU5MDg1KSIgaGVpZ2h0PSIwLjAxMSIvPg0KPC9zdmc+) no-repeat center center";
      this.lightbulb.style.cursor = "pointer";
      this.lightbulb.setAttribute("role", "button");
      this.lightbulb.setAttribute("aria-label", "Show code actions");
      this.editor.container.appendChild(this.lightbulb);
      this.lightbulb.addEventListener("click", (event) => {
        this.showMenu(event.clientX, event.clientY);
      });
    }
    setCodeActions(actions) {
      this.codeActions = actions;
    }
    showMenu(x, y) {
      if (this.codeActions.length === 0) {
        return;
      }
      this.setDataToPopup();
      this.popup.show({ top: y, left: x }, 12, false);
    }
    isEmpty() {
      if (this.codeActions.length === 0) {
        return true;
      }
      for (let actionsByService of this.codeActions) {
        if (actionsByService.codeActions && actionsByService.codeActions.length > 0) {
          return false;
        }
      }
      return true;
    }
    setDataToPopup() {
      let codeActions = [];
      this.codeActions.forEach((codeActionsByService) => {
        var _a;
        (_a = codeActionsByService.codeActions) == null ? void 0 : _a.forEach(
          (action) => {
            codeActions.push({
              value: action.title,
              //@ts-expect-error
              serviceName: codeActionsByService.service,
              action
            });
          }
        );
      });
      this.popup.setData(codeActions, "");
    }
    executeAction(action, serviceName) {
      this.executeActionCallback && this.executeActionCallback(action, serviceName);
      this.hideLightbulb();
    }
    showLightbulb() {
      if (this.isEmpty()) {
        return;
      }
      this.setPosition();
      this.lightbulb.style.display = "block";
    }
    hideLightbulb() {
      this.lightbulb.style.display = "none";
    }
    calculatePosition() {
      const gutterCenter = Math.round(this.editor.renderer["gutterWidth"] / 2 - this.lightBulbWidth);
      const firstRow = this.editor.renderer.getFirstVisibleRow();
      const cursor = this.editor.getCursorPosition();
      const lineHeight = this.editor.renderer.lineHeight;
      return {
        x: gutterCenter,
        y: (cursor.row - firstRow) * lineHeight
      };
    }
    dispose() {
      this.removeListeners();
      if (this.lightbulb && this.lightbulb.parentNode) {
        this.lightbulb.parentNode.removeChild(this.lightbulb);
      }
      this.popup.destroy();
    }
  }
  function setStyles(editor) {
    editor.renderer["$textLayer"].dom.importCssString(`.ace_tooltip * {
    margin: 0;
    font-size: 12px;
}

.ace_tooltip code {
    font-style: italic;
    font-size: 11px;
}

.language_highlight_error {
    position: absolute;
    border-bottom: dotted 1px #e00404;
    z-index: 2000;
    border-radius: 0;
}

.language_highlight_warning {
    position: absolute;
    border-bottom: solid 1px #DDC50F;
    z-index: 2000;
    border-radius: 0;
}

.language_highlight_info {
    position: absolute;
    border-bottom: dotted 1px #999;
    z-index: 2000;
    border-radius: 0;
}

.language_highlight_text, .language_highlight_read, .language_highlight_write {
    position: absolute;
    box-sizing: border-box;
    border: solid 1px #888;
    z-index: 2000;
}

.language_highlight_write {
    border: solid 1px #F88;
}`, "linters.css");
    editor.renderer["$textLayer"].dom.importCssString(`
.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {
    background-color: #CAD6FA;
    z-index: 1;
}
.ace_dark.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {
    background-color: #3a674e;
}
.ace_editor.ace_autocomplete .ace_line-hover {
    border: 1px solid #abbffe;
    margin-top: -1px;
    background: rgba(233,233,253,0.4);
    position: absolute;
    z-index: 2;
}
.ace_dark.ace_editor.ace_autocomplete .ace_line-hover {
    border: 1px solid rgba(109, 150, 13, 0.8);
    background: rgba(58, 103, 78, 0.62);
}
.ace_completion-meta {
    opacity: 0.5;
    margin-left: 0.9em;
}
.ace_completion-message {
    margin-left: 0.9em;
    color: blue;
}
.ace_editor.ace_autocomplete .ace_completion-highlight{
    color: #2d69c7;
}
.ace_dark.ace_editor.ace_autocomplete .ace_completion-highlight{
    color: #93ca12;
}
.ace_editor.ace_autocomplete {
    width: 300px;
    z-index: 200000;
    border: 1px lightgray solid;
    position: fixed;
    box-shadow: 2px 3px 5px rgba(0,0,0,.2);
    line-height: 1.4;
    background: #fefefe;
    color: #111;
}
.ace_dark.ace_editor.ace_autocomplete {
    border: 1px #484747 solid;
    box-shadow: 2px 3px 5px rgba(0, 0, 0, 0.51);
    line-height: 1.4;
    background: #25282c;
    color: #c1c1c1;
}
.ace_autocomplete .ace_text-layer  {
    width: calc(100% - 8px);
}
.ace_autocomplete .ace_line {
    display: flex;
    align-items: center;
}
.ace_autocomplete .ace_line > * {
    min-width: 0;
    flex: 0 0 auto;
}
.ace_autocomplete .ace_line .ace_ {
    flex: 0 1 auto;
    overflow: hidden;
    text-overflow: ellipsis;
}
.ace_autocomplete .ace_completion-spacer {
    flex: 1;
}
.ace_autocomplete.ace_loading:after  {
    content: "";
    position: absolute;
    top: 0px;
    height: 2px;
    width: 8%;
    background: blue;
    z-index: 100;
    animation: ace_progress 3s infinite linear;
    animation-delay: 300ms;
    transform: translateX(-100%) scaleX(1);
}
@keyframes ace_progress {
    0% { transform: translateX(-100%) scaleX(1) }
    50% { transform: translateX(625%) scaleX(2) } 
    100% { transform: translateX(1500%) scaleX(3) } 
}
@media (prefers-reduced-motion) {
    .ace_autocomplete.ace_loading:after {
        transform: translateX(625%) scaleX(2);
        animation: none;
     }
}
`, "autocompletion.css", false);
  }
  function validateAcePrototypes(InlineAutocomplete, CommandBarTooltip, CompletionProvider) {
    const proto = InlineAutocomplete.prototype;
    const required = [
      "detach",
      "destroy",
      "show",
      "getCompletionProvider",
      "getInlineTooltip"
    ];
    for (const method of required) {
      if (typeof proto[method] !== "function") {
        throw new Error(`InlineAutocomplete.prototype missing method: ${method}`);
      }
    }
    const cbProto = CommandBarTooltip.prototype;
    ["registerCommand", "setAlwaysShow", "getAlwaysShow"].forEach((method) => {
      if (typeof cbProto[method] !== "function") {
        throw new Error(`CommandBarTooltip.prototype missing method: ${method}`);
      }
    });
    if (typeof CompletionProvider.prototype.gatherCompletions !== "function") {
      throw new Error("CompletionProvider.prototype missing method: gatherCompletions");
    }
  }
  function createInlineCompleterAdapter(OriginalInlineAutocomplete, OriginalCommandBarTooltip, OriginalCompletionProvider) {
    validateAcePrototypes(OriginalInlineAutocomplete, OriginalCommandBarTooltip, OriginalCompletionProvider);
    var destroyCompleter = function(e, editor) {
      editor.inlineCompleter && editor.inlineCompleter.destroy();
    };
    class InlineCompletionProvider extends OriginalCompletionProvider {
      gatherCompletions(editor, callback) {
        var session = editor.getSession();
        var pos = editor.getCursorPosition();
        var prefix = getCompletionPrefix(editor);
        var matches = [];
        this.completers = editor.inlineCompleters;
        var total = editor.inlineCompleters.length;
        editor.inlineCompleters.forEach(function(completer, i) {
          completer.getCompletions(editor, session, pos, prefix, function(err, results) {
            if (completer.hideInlinePreview)
              results = results.map((result) => {
                return Object.assign(result, { hideInlinePreview: completer.hideInlinePreview });
              });
            if (!err && results)
              matches = matches.concat(results);
            callback(null, {
              prefix: getCompletionPrefix(editor),
              matches,
              finished: --total === 0
            });
          });
        });
        return true;
      }
    }
    class InlineCompleter extends OriginalInlineAutocomplete {
      getCompletionProvider(initialPosition) {
        if (!this.completionProvider)
          this.completionProvider = new InlineCompletionProvider(initialPosition);
        return this.completionProvider;
      }
      show(options) {
        this.activated = true;
        if (this.editor.inlineCompleter !== this) {
          if (this.editor.inlineCompleter) {
            this.editor.inlineCompleter.detach();
          }
          this.editor.inlineCompleter = this;
        }
        this.editor.on("changeSelection", this.changeListener);
        this.editor.on("blur", this.blurListener);
        this.updateCompletions(options);
      }
      destroy() {
        this.detach();
        if (this.inlineRenderer)
          this.inlineRenderer.destroy();
        if (this.inlineTooltip)
          this.inlineTooltip.destroy();
        if (this.editor && this.editor.inlineCompleter == this) {
          this.editor.off("destroy", destroyCompleter);
          this.editor.inlineCompleter = null;
        }
        this.inlineTooltip = this.editor = this.inlineRenderer = null;
      }
      static for(editor) {
        if (editor.inlineCompleter instanceof InlineCompleter) {
          return editor.inlineCompleter;
        }
        if (editor.inlineCompleter) {
          editor.inlineCompleter.destroy();
          editor.inlineCompleter = null;
        }
        editor.inlineCompleter = new InlineCompleter(editor);
        editor.once("destroy", destroyCompleter);
        return editor.inlineCompleter;
      }
      getInlineTooltip() {
        if (!this.inlineTooltip) {
          this.inlineTooltip = InlineCompleter.createInlineTooltip(document.body || document.documentElement);
        }
        return this.inlineTooltip;
      }
      static createInlineTooltip(parentEl) {
        var inlineTooltip = new OriginalCommandBarTooltip(parentEl);
        inlineTooltip.registerCommand(
          "Previous",
          // @ts-expect-error
          Object.assign({}, OriginalInlineAutocomplete.prototype.commands["Previous"], {
            enabled: true,
            type: "button",
            iconCssClass: "ace_arrow_rotated"
          })
        );
        inlineTooltip.registerCommand("Position", {
          enabled: false,
          getValue: function(editor) {
            return editor ? [
              editor.inlineCompleter.getIndex() + 1,
              editor.inlineCompleter.getLength()
            ].join("/") : "";
          },
          type: "text",
          cssClass: "completion_position"
        });
        inlineTooltip.registerCommand(
          "Next",
          // @ts-expect-error
          Object.assign({}, OriginalInlineAutocomplete.prototype.commands["Next"], {
            enabled: true,
            type: "button",
            iconCssClass: "ace_arrow"
          })
        );
        inlineTooltip.registerCommand(
          "Accept",
          // @ts-expect-error
          Object.assign({}, OriginalInlineAutocomplete.prototype.commands["Accept"], {
            enabled: function(editor) {
              return !!editor && editor.inlineCompleter.getIndex() >= 0;
            },
            type: "button"
          })
        );
        inlineTooltip.registerCommand("ShowTooltip", {
          name: "Always Show Tooltip",
          exec: function() {
            inlineTooltip.setAlwaysShow(!inlineTooltip.getAlwaysShow());
          },
          enabled: true,
          getValue: function() {
            return inlineTooltip.getAlwaysShow();
          },
          type: "checkbox"
        });
        return inlineTooltip;
      }
      updateCompletions(options) {
        if (options && options.matches) {
          var pos = this.editor.getSelectionRange().start;
          this.base = this.editor.session.doc.createAnchor(pos.row, pos.column);
          this.base["$insertRight"] = true;
          this.completions = new FilteredList(options.matches);
          return this.$open(this.editor, "");
        }
        if (this.base && this.completions) {
          this.$updatePrefix();
        }
        var session = this.editor.getSession();
        var pos = this.editor.getCursorPosition();
        var prefix = getCompletionPrefix(this.editor);
        this.base = session.doc.createAnchor(pos.row, pos.column - prefix.length);
        this.base.$insertRight = true;
        var options = {
          exactMatch: true,
          ignoreCaption: true
        };
        this.getCompletionProvider({
          prefix,
          base: this.base,
          pos
          // @ts-ignore
        }).provideCompletions(
          this.editor,
          options,
          /**
           * @this {InlineAutocomplete}
           */
          (function(err, completions, finished) {
            var filtered = completions.filtered;
            var prefix2 = getCompletionPrefix(this.editor);
            if (finished) {
              if (!filtered.length)
                return this.detach();
              if (filtered.length == 1 && filtered[0].value == prefix2 && !filtered[0].snippet)
                return this.detach();
            }
            this.completions = completions;
            this.$open(this.editor, prefix2);
          }).bind(this)
        );
      }
    }
    OriginalInlineAutocomplete.prototype.commands["Previous"].exec = (editor) => {
      editor.inlineCompleter.goTo("prev");
    };
    OriginalInlineAutocomplete.prototype.commands["Next"].exec = (editor) => {
      editor.inlineCompleter.goTo("next");
    };
    OriginalInlineAutocomplete.prototype.commands["Accept"].exec = (editor) => {
      return editor.inlineCompleter.insertMatch();
    };
    OriginalInlineAutocomplete.prototype.commands["Close"].exec = (editor) => {
      editor.inlineCompleter.detach();
    };
    var doLiveAutocomplete = function(e) {
      var editor = e.editor;
      var hasCompleter = editor.inlineCompleter && editor.inlineCompleter.activated;
      if (e.command.name === "backspace") {
        if (hasCompleter && !getCompletionPrefix(editor))
          editor.inlineCompleter.detach();
      } else if (e.command.name === "insertstring" && !hasCompleter) {
        lastExecEvent = e;
        var delay = e.editor.$liveAutocompletionDelay;
        if (delay) {
          liveAutocompleteTimer.delay(delay);
        } else {
          showLiveAutocomplete(e);
        }
      }
    };
    var lastExecEvent;
    var liveAutocompleteTimer = new DelayedCall(function() {
      showLiveAutocomplete(lastExecEvent);
    }, 0);
    var showLiveAutocomplete = (e) => {
      var editor = e.editor;
      var prefix = getCompletionPrefix(editor);
      var previousChar = e.args;
      var triggerAutocomplete = triggerAutocompleteFunc(editor, previousChar);
      if (prefix && prefix.length >= editor.$liveAutocompletionThreshold || triggerAutocomplete) {
        var completer = InlineCompleter.for(editor);
        completer.show({
          exactMatch: false,
          ignoreCaption: false
        });
      }
    };
    const validateAceInlineCompleterWithEditor = (editor) => {
      let completer;
      try {
        completer = InlineCompleter.for(editor);
        completer.show({});
        if (typeof completer.activated !== "boolean") throw new Error("activated property missing or not boolean");
        completer.destroy();
      } catch (e) {
        throw new Error(`InlineAutocomplete runtime validation failed: ${e.message}`);
      }
      try {
        const provider = new InlineCompletionProvider();
        if (typeof provider.gatherCompletions !== "function") throw new Error("gatherCompletions missing");
      } catch (e) {
        throw new Error(`CompletionProvider runtime validation failed: ${e.message}`);
      }
    };
    return { InlineCompleter, doLiveAutocomplete, validateAceInlineCompleterWithEditor };
  }
  function getCompletionPrefix(editor) {
    var pos = editor.getCursorPosition();
    var line = editor.session.getLine(pos.row);
    var prefix;
    if (!editor.inlineCompleters) {
      return "";
    }
    editor.inlineCompleters.forEach((function(completer) {
      if (completer.identifierRegexps) {
        completer.identifierRegexps.forEach((function(identifierRegex) {
          if (!prefix && identifierRegex)
            prefix = retrievePrecedingIdentifier(line, pos.column, identifierRegex);
        }).bind(this));
      }
    }).bind(this));
    return prefix || retrievePrecedingIdentifier(line, pos.column);
  }
  var ID_REGEX = /[a-zA-Z_0-9\$\-\u00A2-\u2000\u2070-\uFFFF]/;
  function retrievePrecedingIdentifier(text, pos, regex) {
    regex = regex || ID_REGEX;
    var buf = [];
    for (var i = pos - 1; i >= 0; i--) {
      if (regex.test(text[i]))
        buf.push(text[i]);
      else
        break;
    }
    return buf.reverse().join("");
  }
  function triggerAutocompleteFunc(editor, previousChar) {
    var previousChar = previousChar == null ? editor.session.getPrecedingCharacter() : previousChar;
    return editor.inlineCompleters.some((completer) => {
      if (completer.triggerCharacters && Array.isArray(completer.triggerCharacters)) {
        return completer.triggerCharacters.includes(previousChar);
      }
    });
  }
  class DelayedCall {
    constructor(fcn, defaultTimeout) {
      this.timer = null;
      this.fcn = fcn;
      this.defaultTimeout = defaultTimeout;
      this.callback = () => {
        this.timer = null;
        this.fcn();
      };
    }
    schedule(timeout) {
      if (this.timer == null) {
        this.timer = setTimeout(this.callback, timeout || this.defaultTimeout);
      }
    }
    delay(timeout) {
      this.timer && clearTimeout(this.timer);
      this.timer = setTimeout(this.callback, timeout || this.defaultTimeout);
    }
    call() {
      this.cancel();
      this.fcn();
    }
    cancel() {
      this.timer && clearTimeout(this.timer);
      this.timer = null;
    }
    isPending() {
      return this.timer;
    }
  }
  class FilteredList {
    constructor(array, filterText) {
      this.all = array;
      this.filtered = array;
      this.filterText = filterText || "";
      this.exactMatch = false;
      this.ignoreCaption = false;
    }
    setFilter(str) {
      if (str.length > this.filterText && str.lastIndexOf(this.filterText, 0) === 0)
        var matches = this.filtered;
      else
        var matches = this.all;
      this.filterText = str;
      matches = this.filterCompletions(matches, this.filterText);
      matches = matches.sort(function(a, b) {
        return b.exactMatch - a.exactMatch || b.$score - a.$score || (a.caption || a.value).localeCompare(b.caption || b.value);
      });
      var prev = null;
      matches = matches.filter(function(item) {
        var caption = item.snippet || item.caption || item.value;
        if (caption === prev) return false;
        prev = caption;
        return true;
      });
      this.filtered = matches;
    }
    filterCompletions(items, needle) {
      var results = [];
      var upper = needle.toUpperCase();
      var lower = needle.toLowerCase();
      loop: for (var i = 0, item; item = items[i]; i++) {
        if (item.skipFilter) {
          item.$score = item.score;
          results.push(item);
          continue;
        }
        var caption = !this.ignoreCaption && item.caption || item.value || item.snippet;
        if (!caption) continue;
        var lastIndex = -1;
        var matchMask = 0;
        var penalty = 0;
        var index, distance;
        if (this.exactMatch) {
          if (needle !== caption.substr(0, needle.length))
            continue loop;
        } else {
          var fullMatchIndex = caption.toLowerCase().indexOf(lower);
          if (fullMatchIndex > -1) {
            penalty = fullMatchIndex;
          } else {
            for (var j = 0; j < needle.length; j++) {
              var i1 = caption.indexOf(lower[j], lastIndex + 1);
              var i2 = caption.indexOf(upper[j], lastIndex + 1);
              index = i1 >= 0 ? i2 < 0 || i1 < i2 ? i1 : i2 : i2;
              if (index < 0)
                continue loop;
              distance = index - lastIndex - 1;
              if (distance > 0) {
                if (lastIndex === -1)
                  penalty += 10;
                penalty += distance;
                matchMask = matchMask | 1 << j;
              }
              lastIndex = index;
            }
          }
        }
        item.matchMask = matchMask;
        item.exactMatch = penalty ? 0 : 1;
        item.$score = (item.score || 0) - penalty;
        results.push(item);
      }
      return results;
    }
  }
  class MarkerGroup {
    constructor(session) {
      this.MAX_MARKERS = 1e4;
      this.markers = [];
      this.session = session;
      session.addDynamicMarker(this);
    }
    /**
     * Finds the first marker containing pos
     * @param {Position} pos
     * @returns Ace.MarkerGroupItem
     */
    getMarkerAtPosition(pos) {
      return this.markers.find(function(marker) {
        return marker.range.contains(pos.row, pos.column);
      });
    }
    /**
     * Finds all markers that contain the given position.
     * @param {Position} pos - The position to search for.
     * @returns {Ace.MarkerGroupItem[]} - An array of all markers that contain the given position.
     */
    getMarkersAtPosition(pos) {
      return this.markers.filter(function(marker) {
        return marker.range.contains(pos.row, pos.column);
      });
    }
    /**
     * Comparator for Array.sort function, which sorts marker definitions by their positions
     *
     * @param {Ace.MarkerGroupItem} a first marker.
     * @param {Ace.MarkerGroupItem} b second marker.
     * @returns {number} negative number if a should be before b, positive number if b should be before a, 0 otherwise.
     */
    markersComparator(a, b) {
      return a.range.start.row - b.range.start.row;
    }
    /**
     * Sets marker definitions to be rendered. Limits the number of markers at MAX_MARKERS.
     * @param {Ace.MarkerGroupItem[]} markers an array of marker definitions.
     */
    setMarkers(markers) {
      this.markers = markers.sort(this.markersComparator).slice(0, this.MAX_MARKERS);
      this.session._signal("changeBackMarker");
    }
    update(html, markerLayer, session, config) {
      if (!this.markers || !this.markers.length)
        return;
      var visibleRangeStartRow = config.firstRow, visibleRangeEndRow = config.lastRow;
      var foldLine;
      var markersOnOneLine = 0;
      var lastRow = 0;
      for (var i = 0; i < this.markers.length; i++) {
        var marker = this.markers[i];
        if (marker.range.end.row < visibleRangeStartRow) continue;
        if (marker.range.start.row > visibleRangeEndRow) continue;
        if (marker.range.start.row === lastRow) {
          markersOnOneLine++;
        } else {
          lastRow = marker.range.start.row;
          markersOnOneLine = 0;
        }
        if (markersOnOneLine > 200) {
          continue;
        }
        var markerVisibleRange = marker.range.clipRows(visibleRangeStartRow, visibleRangeEndRow);
        if (markerVisibleRange.start.row === markerVisibleRange.end.row && markerVisibleRange.start.column === markerVisibleRange.end.column) {
          continue;
        }
        var screenRange = markerVisibleRange.toScreenRange(session);
        if (screenRange.isEmpty()) {
          foldLine = session.getNextFoldLine(markerVisibleRange.end.row, foldLine);
          if (foldLine && foldLine.end.row > markerVisibleRange.end.row) {
            visibleRangeStartRow = foldLine.end.row;
          }
          continue;
        }
        if (screenRange.isMultiLine()) {
          markerLayer.drawTextMarker(html, screenRange, marker.className, config);
        } else {
          markerLayer.drawSingleLineMarker(html, screenRange, marker.className, config);
        }
      }
    }
  }
  function decodeModifiers(modifierFlag, tokenModifiersLegend) {
    const modifiers = [];
    for (let i = 0; i < tokenModifiersLegend.length; i++) {
      if (modifierFlag & 1 << i) {
        modifiers.push(tokenModifiersLegend[i]);
      }
    }
    return modifiers;
  }
  function parseSemanticTokens(tokens, tokenTypes, tokenModifiersLegend) {
    if (tokens.length % 5 !== 0) {
      return;
    }
    const decodedTokens = [];
    let line = 0;
    let startColumn = 0;
    for (let i = 0; i < tokens.length; i += 5) {
      line += tokens[i];
      if (tokens[i] === 0) {
        startColumn += tokens[i + 1];
      } else {
        startColumn = tokens[i + 1];
      }
      const length = tokens[i + 2];
      const tokenTypeIndex = tokens[i + 3];
      const tokenModifierFlag = tokens[i + 4];
      const tokenType = tokenTypes[tokenTypeIndex];
      const tokenModifiers = decodeModifiers(tokenModifierFlag, tokenModifiersLegend);
      decodedTokens.push({
        row: line,
        startColumn,
        length,
        type: toAceTokenType(tokenType, tokenModifiers)
      });
    }
    return new DecodedSemanticTokens(decodedTokens);
  }
  function toAceTokenType(tokenType, tokenModifiers) {
    let modifiers = "";
    let type = tokenType;
    if (tokenModifiers.length > 0) {
      modifiers = "." + tokenModifiers.join(".");
    }
    switch (tokenType) {
      case "class":
        type = "entity.name.type.class";
        break;
      case "struct":
        type = "storage.type.struct";
        break;
      case "enum":
        type = "entity.name.type.enum";
        break;
      case "interface":
        type = "entity.name.type.interface";
        break;
      case "namespace":
        type = "entity.name.namespace";
        break;
      case "typeParameter":
        break;
      case "type":
        type = "entity.name.type";
        break;
      case "parameter":
        type = "variable.parameter";
        break;
      case "variable":
        type = "entity.name.variable";
        break;
      case "enumMember":
        type = "variable.other.enummember";
        break;
      case "property":
        type = "variable.other.property";
        break;
      case "function":
        type = "entity.name.function";
        break;
      case "method":
        type = "entity.name.function.member";
        break;
      case "event":
        type = "variable.other.event";
        break;
    }
    return type + modifiers;
  }
  function mergeTokens(aceTokens, decodedTokens) {
    let mergedTokens = [];
    let currentCharIndex = 0;
    let aceTokenIndex = 0;
    decodedTokens.forEach((semanticToken) => {
      let semanticStart = semanticToken.startColumn;
      let semanticEnd = semanticStart + semanticToken.length;
      while (aceTokenIndex < aceTokens.length && currentCharIndex + aceTokens[aceTokenIndex].value.length <= semanticStart) {
        mergedTokens.push(aceTokens[aceTokenIndex]);
        currentCharIndex += aceTokens[aceTokenIndex].value.length;
        aceTokenIndex++;
      }
      while (aceTokenIndex < aceTokens.length && currentCharIndex < semanticEnd) {
        let aceToken = aceTokens[aceTokenIndex];
        let aceTokenEnd = currentCharIndex + aceToken.value.length;
        let overlapStart = Math.max(currentCharIndex, semanticStart);
        let overlapEnd = Math.min(aceTokenEnd, semanticEnd);
        if (currentCharIndex < semanticStart) {
          let beforeSemantic = {
            ...aceToken,
            value: aceToken.value.substring(0, semanticStart - currentCharIndex)
          };
          mergedTokens.push(beforeSemantic);
        }
        let middle = {
          type: semanticToken.type,
          // Use semantic token's type
          value: aceToken.value.substring(overlapStart - currentCharIndex, overlapEnd - currentCharIndex)
        };
        mergedTokens.push(middle);
        if (aceTokenEnd > semanticEnd) {
          let afterSemantic = {
            ...aceToken,
            value: aceToken.value.substring(semanticEnd - currentCharIndex)
          };
          currentCharIndex = semanticEnd;
          aceTokens.splice(aceTokenIndex, 1, afterSemantic);
          break;
        }
        currentCharIndex = aceTokenEnd;
        aceTokenIndex++;
      }
    });
    while (aceTokenIndex < aceTokens.length) {
      mergedTokens.push(aceTokens[aceTokenIndex]);
      aceTokenIndex++;
    }
    return mergedTokens;
  }
  class DecodedSemanticTokens {
    constructor(tokens) {
      this.tokens = this.sortTokens(tokens);
    }
    getByRow(row) {
      return this.tokens.filter((token) => token.row === row);
    }
    sortTokens(tokens) {
      return tokens.sort((a, b) => {
        if (a.row === b.row) {
          return a.startColumn - b.startColumn;
        }
        return a.row - b.row;
      });
    }
  }
  class SessionLanguageProvider {
    /**
     * Constructs a new instance of the `SessionLanguageProvider` class.
     *
     * @param provider - The `LanguageProvider` instance.
     * @param session - The Ace editor session.
     * @param editor - The Ace editor instance.
     * @param messageController - The `IMessageController` instance for handling messages.
     * @param config
     */
    constructor(provider, session, editor, messageController, config) {
      this.$isConnected = false;
      this.$requestsQueue = [];
      this.state = {
        occurrenceMarkers: null,
        diagnosticMarkers: null
      };
      this.extensions = {
        "typescript": "ts",
        "javascript": "js"
      };
      this.$connected = (capabilities) => {
        this.$isConnected = true;
        this.setServerCapabilities(capabilities);
        this.$requestsQueue.forEach((requestCallback) => requestCallback());
        this.$requestsQueue = [];
        if (this.$deltaQueue)
          this.$sendDeltaQueue();
        if (this.$options)
          this.setOptions(this.$options);
      };
      this.$changeMode = () => {
        this.enqueueIfNotConnected(() => {
          this.$deltaQueue = [];
          this.session.clearAnnotations();
          if (this.state.diagnosticMarkers) {
            this.state.diagnosticMarkers.setMarkers([]);
          }
          this.session.setSemanticTokens(void 0);
          let newVersion = this.session.doc.version++;
          this.$messageController.changeMode(this.comboDocumentIdentifier, this.session.getValue(), newVersion, this.$mode, this.setServerCapabilities);
        });
      };
      this.setServerCapabilities = (capabilities) => {
        var _a, _b, _c, _d, _e;
        if (!capabilities)
          return;
        this.$servicesCapabilities = { ...capabilities };
        let hasTriggerChars = Object.values(capabilities).some((capability) => {
          var _a2;
          return (_a2 = capability == null ? void 0 : capability.completionProvider) == null ? void 0 : _a2.triggerCharacters;
        });
        if (hasTriggerChars || ((_a = this.$provider.options.functionality) == null ? void 0 : _a.completion) && ((_c = (_b = this.$provider.options.functionality) == null ? void 0 : _b.completion.lspCompleterOptions) == null ? void 0 : _c.triggerCharacters)) {
          let completer = this.editor.completers.find((completer2) => completer2.id === "lspCompleters");
          if (completer) {
            let allTriggerCharacters = [];
            Object.values(capabilities).forEach((capability) => {
              var _a2;
              if ((_a2 = capability == null ? void 0 : capability.completionProvider) == null ? void 0 : _a2.triggerCharacters) {
                allTriggerCharacters.push(...capability.completionProvider.triggerCharacters);
              }
            });
            allTriggerCharacters = [...new Set(allTriggerCharacters)];
            const triggerCharacterOptions = typeof ((_d = this.$provider.options.functionality) == null ? void 0 : _d.completion) == "object" ? (_e = this.$provider.options.functionality.completion.lspCompleterOptions) == null ? void 0 : _e.triggerCharacters : void 0;
            if (triggerCharacterOptions) {
              const removeChars = Array.isArray(triggerCharacterOptions.remove) ? triggerCharacterOptions.remove : [];
              const addChars = Array.isArray(triggerCharacterOptions.add) ? triggerCharacterOptions.add : [];
              completer.triggerCharacters = allTriggerCharacters.filter(
                (char) => !removeChars.includes(char)
              );
              addChars.forEach((char) => {
                if (!completer.triggerCharacters.includes(char)) {
                  completer.triggerCharacters.push(char);
                }
              });
            } else {
              completer.triggerCharacters = allTriggerCharacters;
            }
          }
        }
        let hasSemanticTokensProvider = Object.values(capabilities).some((capability) => {
          if (capability == null ? void 0 : capability.semanticTokensProvider) {
            this.semanticTokensLegend = capability.semanticTokensProvider.legend;
            return true;
          }
        });
        if (hasSemanticTokensProvider) {
          this.getSemanticTokens();
        }
      };
      this.$changeListener = (delta) => {
        this.session.doc.version++;
        if (!this.$deltaQueue) {
          this.$deltaQueue = [];
          setTimeout(() => this.$sendDeltaQueue(() => {
            this.getSemanticTokens();
          }), 0);
        }
        this.$deltaQueue.push(delta);
      };
      this.$sendDeltaQueue = (callback) => {
        let deltas = this.$deltaQueue;
        if (!deltas) return callback && callback();
        this.$deltaQueue = null;
        if (deltas.length)
          this.$messageController.change(this.comboDocumentIdentifier, deltas.map((delta) => fromAceDelta(delta, this.session.doc.getNewLineCharacter())), this.session.doc, callback);
      };
      this.$showAnnotations = (diagnostics) => {
        if (!diagnostics) {
          return;
        }
        let annotations = toAnnotations(diagnostics);
        this.session.clearAnnotations();
        if (annotations && annotations.length > 0) {
          this.session.setAnnotations(annotations);
        }
        if (!this.state.diagnosticMarkers) {
          this.state.diagnosticMarkers = new MarkerGroup(this.session);
        }
        this.state.diagnosticMarkers.setMarkers(diagnostics == null ? void 0 : diagnostics.map((el) => toMarkerGroupItem(CommonConverter.toRange(toRange(el.range)), "language_highlight_error", el.message)));
      };
      this.validate = () => {
        this.$messageController.doValidation(this.comboDocumentIdentifier, this.$showAnnotations);
      };
      this.format = () => {
        let selectionRanges = this.session.getSelection().getAllRanges();
        let $format = this.$format;
        let aceRangeDatas = selectionRanges;
        if (!selectionRanges || selectionRanges[0].isEmpty()) {
          let row = this.session.getLength();
          let column = this.session.getLine(row).length - 1;
          aceRangeDatas = [{
            start: {
              row: 0,
              column: 0
            },
            end: {
              row,
              column
            }
          }];
        }
        for (let range of aceRangeDatas) {
          this.$messageController.format(this.comboDocumentIdentifier, fromRange(range), $format, this.applyEdits);
        }
      };
      this.applyEdits = (edits) => {
        edits != null ? edits : edits = [];
        for (let edit of edits.reverse()) {
          this.session.replace(toRange(edit.range), edit.newText);
        }
      };
      this.$applyDocumentHighlight = (documentHighlights) => {
        if (!this.state.occurrenceMarkers) {
          this.state.occurrenceMarkers = new MarkerGroup(this.session);
        }
        if (documentHighlights) {
          this.state.occurrenceMarkers.setMarkers(fromDocumentHighlights(documentHighlights));
        }
      };
      this.$provider = provider;
      this.$messageController = messageController;
      this.session = session;
      this.editor = editor;
      session.doc.version = 1;
      session.doc.on("change", this.$changeListener, true);
      this.addSemanticTokenSupport(session);
      session.on("changeMode", this.$changeMode);
      if (this.$provider.options.functionality.semanticTokens) {
        this.$changeScrollTopHandler = () => this.getSemanticTokens();
        session.on("changeScrollTop", this.$changeScrollTopHandler);
      }
      session.setUseWorker(false);
      this.$init(config);
    }
    enqueueIfNotConnected(callback) {
      if (!this.$isConnected) {
        this.$requestsQueue.push(callback);
      } else {
        callback();
      }
    }
    get comboDocumentIdentifier() {
      return {
        documentUri: this.documentUri,
        sessionId: this.session["id"]
      };
    }
    /**
     * Sets the file path for the current document and optionally joins it with the workspace URI.
     * Increments the document version and updates the internal document URI and identifier.
     *
     * @param {string} filePath - The new file path for the document.
     * @param {boolean} [joinWorkspaceURI] - when true the given path is treated as relative and will be joined with
     * the workspaces root URI to form the final canonical URI. When false (or omitted) filePath is just transformed to
     * URI.
     */
    setFilePath(filePath, joinWorkspaceURI) {
      this.enqueueIfNotConnected(() => {
        this.session.doc.version++;
        this.$filePath = filePath;
        const previousComboId = this.comboDocumentIdentifier;
        this.initDocumentUri(true, joinWorkspaceURI);
        if (previousComboId.documentUri === this.comboDocumentIdentifier.documentUri) {
          return;
        }
        this.$messageController.renameDocument(previousComboId, this.comboDocumentIdentifier.documentUri, this.session.doc.version);
      });
    }
    $init(config) {
      if (config == null ? void 0 : config.filePath) {
        this.$filePath = config.filePath;
      }
      this.initDocumentUri(false, config == null ? void 0 : config.joinWorkspaceURI);
      this.$messageController.init(this.comboDocumentIdentifier, this.session.doc, this.$mode, this.$options, this.$connected);
    }
    addSemanticTokenSupport(session) {
      let bgTokenizer = session.bgTokenizer;
      session.setSemanticTokens = (tokens) => {
        bgTokenizer.semanticTokens = tokens;
      };
      bgTokenizer.$tokenizeRow = (row) => {
        var line = bgTokenizer.doc.getLine(row);
        var state = bgTokenizer.states[row - 1];
        var data = bgTokenizer.tokenizer.getLineTokens(line, state, row);
        if (bgTokenizer.states[row] + "" !== data.state + "") {
          bgTokenizer.states[row] = data.state;
          bgTokenizer.lines[row + 1] = null;
          if (bgTokenizer.currentLine > row + 1)
            bgTokenizer.currentLine = row + 1;
        } else if (bgTokenizer.currentLine == row) {
          bgTokenizer.currentLine = row + 1;
        }
        if (bgTokenizer.semanticTokens) {
          let decodedTokens = bgTokenizer.semanticTokens.getByRow(row);
          if (decodedTokens) {
            data.tokens = mergeTokens(data.tokens, decodedTokens);
          }
        }
        return bgTokenizer.lines[row] = data.tokens;
      };
    }
    initDocumentUri(isRename = false, joinWorkspaceURI = false) {
      var _a;
      let filePath = (_a = this.$filePath) != null ? _a : this.session["id"] + "." + this.$extension;
      if (isRename) {
        delete this.$provider.$urisToSessionsIds[this.documentUri];
      }
      this.documentUri = convertToUri(filePath, joinWorkspaceURI, this.$provider.workspaceUri);
      this.$provider.$urisToSessionsIds[this.documentUri] = this.session["id"];
    }
    get $extension() {
      var _a;
      let mode = this.$mode.replace("ace/mode/", "");
      return (_a = this.extensions[mode]) != null ? _a : mode;
    }
    get $mode() {
      return this.session["$modeId"];
    }
    get $format() {
      return {
        tabSize: this.session.getTabSize(),
        insertSpaces: this.session.getUseSoftTabs()
      };
    }
    setOptions(options) {
      if (!this.$isConnected) {
        this.$options = options;
        return;
      }
      this.$messageController.changeOptions(this.comboDocumentIdentifier, options);
    }
    getSemanticTokens() {
      if (!this.$provider.options.functionality.semanticTokens)
        return;
      let lastRow = this.editor.renderer.getLastVisibleRow();
      let visibleRange = {
        start: {
          row: this.editor.renderer.getFirstVisibleRow(),
          column: 0
        },
        end: {
          row: lastRow + 1,
          column: this.session.getLine(lastRow).length
        }
      };
      this.$messageController.getSemanticTokens(
        this.comboDocumentIdentifier,
        fromRange(visibleRange),
        (tokens) => {
          if (!tokens) {
            return;
          }
          let decodedTokens = parseSemanticTokens(tokens.data, this.semanticTokensLegend.tokenTypes, this.semanticTokensLegend.tokenModifiers);
          this.session.setSemanticTokens(decodedTokens);
          let bgTokenizer = this.session.bgTokenizer;
          bgTokenizer.running = setTimeout(() => {
            var _a, _b, _c;
            if (((_a = bgTokenizer == null ? void 0 : bgTokenizer.semanticTokens) == null ? void 0 : _a.tokens) && ((_b = bgTokenizer == null ? void 0 : bgTokenizer.semanticTokens) == null ? void 0 : _b.tokens.length) > 0) {
              let startRow = (_c = bgTokenizer == null ? void 0 : bgTokenizer.semanticTokens) == null ? void 0 : _c.tokens[0].row;
              bgTokenizer.currentLine = startRow;
              bgTokenizer.lines = bgTokenizer.lines.slice(0, startRow - 1);
            } else {
              bgTokenizer.currentLine = 0;
              bgTokenizer.lines = [];
            }
            bgTokenizer.$worker();
          }, 20);
        }
      );
    }
    /**
     * Disposes of the SessionLanguageProvider, cleaning up all event listeners,
     * marker groups, and notifying the server to close the document.
     * This method should be called when the session is no longer needed.
     *
     * @param callback - Optional callback to execute after the document is closed
     */
    dispose(callback) {
      this.session.doc.off("change", this.$changeListener);
      this.session.off("changeMode", this.$changeMode);
      if (this.$changeScrollTopHandler) {
        this.session.off("changeScrollTop", this.$changeScrollTopHandler);
        this.$changeScrollTopHandler = void 0;
      }
      if (this.state.occurrenceMarkers) {
        this.state.occurrenceMarkers.setMarkers([]);
        this.state.occurrenceMarkers = null;
      }
      if (this.state.diagnosticMarkers) {
        this.state.diagnosticMarkers.setMarkers([]);
        this.state.diagnosticMarkers = null;
      }
      this.session.clearAnnotations();
      if (this.session.setSemanticTokens) {
        this.session.setSemanticTokens(void 0);
      }
      this.$deltaQueue = null;
      this.$requestsQueue = [];
      if (this.documentUri) {
        delete this.$provider.$urisToSessionsIds[this.documentUri];
      }
      this.$isConnected = false;
      this.session.setUseWorker(true);
      this.closeDocument(callback);
    }
    closeDocument(callback) {
      this.$messageController.closeDocument(this.comboDocumentIdentifier, callback);
    }
  }
  class LanguageProvider {
    constructor(worker, options) {
      this.$sessionLanguageProviders = {};
      this.editors = [];
      this.$urisToSessionsIds = {};
      this.$lightBulbWidgets = {};
      this.$editorEventHandlers = {};
      this.$editorOriginalState = {};
      this.registerSession = (session, editor, config) => {
        if (!this.$sessionLanguageProviders[session["id"]]) {
          this.$sessionLanguageProviders[session["id"]] = new SessionLanguageProvider(this, session, editor, this.$messageController, config);
        }
        if (config) {
          this.$sessionLanguageProviders[session["id"]].setFilePath(config.filePath, config.joinWorkspaceURI);
        }
      };
      this.format = () => {
        if (!this.options.functionality.format)
          return;
        if (this.activeEditor) {
          let sessionLanguageProvider = this.$getSessionLanguageProvider(this.activeEditor.session);
          sessionLanguageProvider.$sendDeltaQueue(sessionLanguageProvider.format);
        }
      };
      this.$messageController = new MessageController(worker, this);
      this.setProviderOptions(options);
      this.$signatureTooltip = new SignatureTooltip(this);
    }
    /**
     *  Creates LanguageProvider using our transport protocol with the ability to register different services on the same
     *  webworker
     * @param {Worker} worker
     * @param {ProviderOptions} options
     */
    static create(worker, options) {
      return new LanguageProvider(worker, options);
    }
    static fromCdn(source, options, includeDefaultLinters) {
      var _a;
      let worker;
      if (typeof source === "string") {
        if (source == "" || !/^http(s)?:/.test(source)) {
          throw "Url is not valid";
        }
        if (source[source.length - 1] == "/") {
          source = source.substring(0, source.length - 1);
        }
        worker = createWorker(source, includeDefaultLinters);
      } else {
        if (source.includeDefaultLinters == void 0) {
          source.includeDefaultLinters = true;
        }
        worker = createWorker({
          services: source.services,
          serviceManagerCdn: source.serviceManagerCdn
        }, (_a = source.includeDefaultLinters) != null ? _a : includeDefaultLinters);
      }
      return new LanguageProvider(worker, options);
    }
    setProviderOptions(options) {
      var _a;
      const defaultFunctionalities = {
        hover: true,
        completion: { overwriteCompleters: true },
        completionResolve: true,
        format: true,
        documentHighlights: true,
        signatureHelp: true,
        semanticTokens: false,
        //experimental functionality
        codeActions: true,
        inlineCompletion: false
      };
      this.options = options != null ? options : {};
      this.options.functionality = typeof this.options.functionality === "object" ? this.options.functionality : {};
      Object.entries(defaultFunctionalities).forEach(([key, value]) => {
        if (this.options.functionality[key] === void 0) {
          this.options.functionality[key] = value;
        }
      });
      (_a = this.options).markdownConverter || (_a.markdownConverter = new showdown.Converter());
      if (options == null ? void 0 : options.workspacePath) {
        this.workspaceUri = convertToUri(options.workspacePath);
      }
      if (this.options.functionality.inlineCompletion) {
        this.checkInlineCompletionAdapter(() => {
          var _a2, _b, _c;
          if (!((_a2 = this.options.aceComponents) == null ? void 0 : _a2.InlineAutocomplete) || !((_b = this.options.aceComponents) == null ? void 0 : _b.CommandBarTooltip) || !((_c = this.options.aceComponents) == null ? void 0 : _c.CompletionProvider)) {
            throw new Error("Inline completion requires the InlineAutocomplete, CompletionProvider and CommandBarTooltip to be defined");
          }
          this.completerAdapter = createInlineCompleterAdapter(this.options.aceComponents.InlineAutocomplete, this.options.aceComponents.CommandBarTooltip, this.options.aceComponents.CompletionProvider);
        });
      }
    }
    checkInlineCompletionAdapter(method) {
      var _a;
      try {
        method();
      } catch (e) {
        console.error(`Inline completion disabled: Incompatible Ace implementation: ${e.message}`);
        if ((_a = this.options) == null ? void 0 : _a.functionality) {
          this.options.functionality.inlineCompletion = false;
        }
      }
    }
    /**
     * Sets the file path for the given Ace edit session. Optionally allows the file path to
     * be joined with the workspace URI.
     *
     * @param session The Ace edit session to update with the file path.
     * @param config config to set
     */
    setSessionFilePath(session, config) {
      var _a;
      (_a = this.$getSessionLanguageProvider(session)) == null ? void 0 : _a.setFilePath(config.filePath, config.joinWorkspaceURI);
    }
    /**
     * Sets the Language Server Protocol (LSP) configuration for the given session.
     *
     * @param session - The editor session to which the LSP configuration will be applied.
     * @param config - The LSP configuration to set for the session.
     * @return The updated editor session with the applied LSP configuration.
     */
    setSessionLspConfig(session, config) {
      session.lspConfig = config;
      return session;
    }
    $getSessionLanguageProvider(session) {
      return this.$sessionLanguageProviders[session["id"]];
    }
    $getFileName(session) {
      let sessionLanguageProvider = this.$getSessionLanguageProvider(session);
      return sessionLanguageProvider.comboDocumentIdentifier;
    }
    /**
     * Registers an Ace editor instance along with the session's configuration settings.
     *
     * @param editor - The Ace editor instance to be registered.
     * @param [config] - Configuration options for the session.
     */
    registerEditor(editor, config) {
      if (!this.editors.includes(editor))
        this.$registerEditor(editor);
      config = config != null ? config : editor.session.lspConfig;
      this.registerSession(editor.session, editor, config);
    }
    /**
     * Unregisters an Ace editor instance, removing all event listeners, completers, tooltips,
     * and cleaning up associated resources. This is the counterpart to registerEditor.
     *
     * @param editor - The Ace editor instance to be unregistered.
     * @param cleanupSession - Optional flag to also dispose the current session. When true,
     *                         calls closeDocument on the editor's session, cleaning up all
     *                         session-related resources. Default: false.
     */
    unregisterEditor(editor, cleanupSession = false) {
      if (this.editors.includes(editor))
        this.$unregisterEditor(editor, cleanupSession);
    }
    /**
     * Sets a callback function that will be triggered with an array of code actions grouped by service.
     *
     * @param {function} callback - A function that receives an array of code actions, categorized by service, as its argument.
     */
    setCodeActionCallback(callback) {
      this.codeActionCallback = callback;
    }
    executeCommand(command, serviceName, args, callback) {
      this.$messageController.executeCommand(serviceName, command, args, callback);
    }
    applyEdit(workspaceEdit, serviceName, callback) {
      if (workspaceEdit.changes) {
        for (let uri in workspaceEdit.changes) {
          if (!this.$urisToSessionsIds[uri]) {
            callback && callback({
              applied: false,
              failureReason: "No session found for uri " + uri
            }, serviceName);
            return;
          }
        }
        for (let uri in workspaceEdit.changes) {
          let sessionId = this.$urisToSessionsIds[uri];
          let sessionLanguageProvider = this.$sessionLanguageProviders[sessionId];
          sessionLanguageProvider.applyEdits(workspaceEdit.changes[uri]);
        }
        callback && callback({
          applied: true
        }, serviceName);
      }
      if (workspaceEdit.documentChanges) {
        for (let change of workspaceEdit.documentChanges) {
          if ("kind" in change) {
            return;
          }
          if ("textDocument" in change) {
            let uri = change.textDocument.uri;
            if (!this.$urisToSessionsIds[uri]) {
              callback && callback({
                applied: false,
                failureReason: "No session found for uri " + uri
              }, serviceName);
              return;
            }
          }
        }
        for (let change of workspaceEdit.documentChanges) {
          if ("textDocument" in change) {
            let sessionId = this.$urisToSessionsIds[change.textDocument.uri];
            let sessionLanguageProvider = this.$sessionLanguageProviders[sessionId];
            sessionLanguageProvider.applyEdits(change.edits);
          }
        }
        callback && callback({
          applied: true
        }, serviceName);
      }
    }
    $registerEditor(editor) {
      var _a;
      this.editors.push(editor);
      AceRange.getConstructor(editor);
      AceVirtualRenderer.getConstructor(editor);
      AceEditor.getConstructor(editor);
      editor.setOption("useWorker", false);
      this.$editorEventHandlers[editor.id] = {};
      if (!this.options.manualSessionControl) {
        const changeSessionHandler = ({ session }) => this.registerSession(session, editor, session.lspConfig);
        this.$editorEventHandlers[editor.id].changeSession = changeSessionHandler;
        editor.on("changeSession", changeSessionHandler);
      }
      if (this.options.functionality.completion || this.options.functionality.inlineCompletion) {
        this.$registerCompleters(editor);
      }
      (_a = this.activeEditor) != null ? _a : this.activeEditor = editor;
      const focusHandler = () => {
        this.activeEditor = editor;
      };
      this.$editorEventHandlers[editor.id].focus = focusHandler;
      editor.on("focus", focusHandler);
      if (this.options.functionality.documentHighlights) {
        var $timer;
        const changeSelectionForHighlights = () => {
          if (!$timer)
            $timer = setTimeout(() => {
              let sessionLanguageProvider = this.$getSessionLanguageProvider(editor.session);
              if (!sessionLanguageProvider) {
                $timer = void 0;
                return;
              }
              let cursor = editor.getCursorPosition();
              this.$messageController.findDocumentHighlights(this.$getFileName(editor.session), fromPoint(cursor), sessionLanguageProvider.$applyDocumentHighlight);
              $timer = void 0;
            }, 50);
        };
        this.$editorEventHandlers[editor.id].changeSelectionForHighlights = changeSelectionForHighlights;
        editor.on("changeSelection", changeSelectionForHighlights);
      }
      if (this.options.functionality.codeActions) {
        this.$provideCodeActions(editor);
      }
      if (this.options.functionality.hover) {
        if (!this.$hoverTooltip) {
          this.$hoverTooltip = new HoverTooltip();
        }
        this.$initHoverTooltip(editor);
      }
      if (this.options.functionality.signatureHelp) {
        this.$signatureTooltip.registerEditor(editor);
      }
      this.setStyles(editor);
    }
    $unregisterEditor(editor, cleanupSession = false) {
      var _a, _b, _c, _d, _e, _f;
      const editorIndex = this.editors.indexOf(editor);
      if (editorIndex > -1) {
        this.editors.splice(editorIndex, 1);
      }
      const handlers = this.$editorEventHandlers[editor.id];
      if (handlers) {
        if (handlers.changeSession) {
          editor.off("changeSession", handlers.changeSession);
        }
        if (handlers.focus) {
          editor.off("focus", handlers.focus);
        }
        if (handlers.changeSelectionForHighlights) {
          editor.off("changeSelection", handlers.changeSelectionForHighlights);
        }
        if (handlers.changeSelectionForCodeActions) {
          editor.off("changeSelection", handlers.changeSelectionForCodeActions);
        }
        if (handlers.afterExec) {
          editor.commands.off("afterExec", handlers.afterExec);
        }
        delete this.$editorEventHandlers[editor.id];
      }
      const originalState = this.$editorOriginalState[editor.id];
      if (originalState) {
        if (((_a = this.options.functionality) == null ? void 0 : _a.completion) && originalState.completers !== void 0) {
          editor.completers = originalState.completers;
        }
        if (((_b = this.options.functionality) == null ? void 0 : _b.inlineCompletion) && originalState.inlineCompleters !== void 0) {
          editor.inlineCompleters = originalState.inlineCompleters;
        }
        if ((_c = this.options.functionality) == null ? void 0 : _c.inlineCompletion) {
          if (originalState.inlineAutocompleteCommand) {
            editor.commands.addCommand(originalState.inlineAutocompleteCommand);
          } else {
            try {
              editor.commands.removeCommand("startInlineAutocomplete");
            } catch (e) {
            }
          }
        }
        delete this.$editorOriginalState[editor.id];
      }
      if ((_d = this.options.functionality) == null ? void 0 : _d.signatureHelp) {
        this.$signatureTooltip.unregisterEditor(editor);
      }
      if (((_e = this.options.functionality) == null ? void 0 : _e.hover) && this.$hoverTooltip) {
        this.$hoverTooltip.removeFromEditor(editor);
      }
      if ((_f = this.options.functionality) == null ? void 0 : _f.codeActions) {
        const lightBulb = this.$lightBulbWidgets[editor.id];
        if (lightBulb) {
          lightBulb.dispose();
          delete this.$lightBulbWidgets[editor.id];
        }
      }
      editor.setOption("useWorker", true);
      if (this.activeEditor === editor) {
        this.activeEditor = this.editors.length > 0 ? this.editors[0] : null;
      }
      if (cleanupSession && editor.session) {
        this.closeDocument(editor.session);
      }
    }
    $provideCodeActions(editor) {
      const lightBulb = new LightbulbWidget(editor);
      this.$lightBulbWidgets[editor.id] = lightBulb;
      lightBulb.setExecuteActionCallback((action, serviceName) => {
        for (let id in this.$lightBulbWidgets) {
          this.$lightBulbWidgets[id].hideAll();
        }
        if (typeof action.command === "string") {
          this.executeCommand(action.command, serviceName, action["arguments"]);
        } else {
          if (action.command) {
            this.executeCommand(action.command.command, serviceName, action.command.arguments);
          } else if ("edit" in action) {
            this.applyEdit(action.edit, serviceName);
          }
        }
      });
      var actionTimer;
      const changeSelectionForCodeActions = () => {
        if (!actionTimer)
          actionTimer = setTimeout(() => {
            if (!this.$getSessionLanguageProvider(editor.session)) {
              actionTimer = void 0;
              return;
            }
            let selection = editor.getSelection().getRange();
            let cursor = editor.getCursorPosition();
            let diagnostics = fromAnnotations(editor.session.getAnnotations().filter((el) => el.row === cursor.row));
            this.$messageController.getCodeActions(this.$getFileName(editor.session), fromRange(selection), { diagnostics }, (codeActions) => {
              lightBulb.setCodeActions(codeActions);
              lightBulb.showLightbulb();
            });
            actionTimer = void 0;
          }, 500);
      };
      this.$editorEventHandlers[editor.id].changeSelectionForCodeActions = changeSelectionForCodeActions;
      editor.on("changeSelection", changeSelectionForCodeActions);
    }
    $initHoverTooltip(editor) {
      const Range2 = editor.getSelectionRange().constructor;
      this.$hoverTooltip.setDataProvider((e, editor2) => {
        const session = editor2.session;
        const docPos = e.getDocumentPosition();
        this.doHover(session, docPos, (hover) => {
          var _a, _b, _c, _d, _e;
          const errorMarkers = (_c = (_b = (_a = this.$getSessionLanguageProvider(session).state) == null ? void 0 : _a.diagnosticMarkers) == null ? void 0 : _b.getMarkersAtPosition(docPos)) != null ? _c : [];
          const hasHoverContent = hover == null ? void 0 : hover.content;
          if (errorMarkers.length === 0 && !hasHoverContent) return;
          var range = (_e = hover == null ? void 0 : hover.range) != null ? _e : (_d = errorMarkers[0]) == null ? void 0 : _d.range;
          range = range ? Range2.fromPoints(range.start, range.end) : session.getWordRange(docPos.row, docPos.column);
          const hoverNode = hasHoverContent ? this.createHoverNode(hover) : null;
          const errorNode = errorMarkers.length > 0 ? this.createErrorNode(errorMarkers) : null;
          const domNode = document.createElement("div");
          if (errorNode) domNode.appendChild(errorNode);
          if (hoverNode) domNode.appendChild(hoverNode);
          this.$hoverTooltip.showForRange(editor2, range, domNode, e);
        });
      });
      this.$hoverTooltip.addToEditor(editor);
    }
    createHoverNode(hover) {
      const hoverNode = document.createElement("div");
      hoverNode.innerHTML = this.getTooltipText(hover);
      return hoverNode;
    }
    createErrorNode(errorMarkers) {
      const errorDiv = document.createElement("div");
      errorDiv.textContent = errorMarkers.map((el) => el.tooltipText.trim()).join("\n");
      return errorDiv;
    }
    setStyles(editor) {
      if (!this.stylesEmbedded) {
        setStyles(editor);
        this.stylesEmbedded = true;
      }
    }
    /**
     * Configures global options that apply to all documents handled by the specified language service.
     *
     * Global options serve as default settings for all documents processed by a service when no
     * document-specific options are provided. These options affect language service behavior across
     * the entire workspace, including validation rules, formatting preferences, completion settings,
     * and service-specific configurations.
     *
     * @param serviceName - The identifier of the language service to configure. Must be a valid
     *                      service name from the supported services (e.g., 'typescript', 'json', 'html').
     * @param options - The global configuration options specific to the language service. The structure
     *                  varies by service type.
     * @param {boolean} [merge=false] - Indicates whether to merge the provided options with the existing options.
     *                  Defaults to false.
     */
    setGlobalOptions(serviceName, options, merge = false) {
      this.$messageController.setGlobalOptions(serviceName, options, merge);
    }
    /**
     * Sets the workspace URI for the language provider.
     *
     * If the provided URI is the same as the current workspace URI, no action is taken.
     * Otherwise, the workspace URI is updated and the message controller is notified.
     *
     * Not all servers support changing of workspace URI.
     *
     * @param workspaceUri - The new workspace URI. Could be simple path, not URI itself.
     */
    changeWorkspaceFolder(workspaceUri) {
      if (workspaceUri === this.workspaceUri)
        return;
      this.workspaceUri = convertToUri(workspaceUri);
      this.$messageController.setWorkspace(this.workspaceUri);
    }
    /**
     * Sets the options for a specified editor session.
     *
     * @param session - The Ace editor session to configure.
     * @param options - The configuration options to be applied to the session.
     * @deprecated Use `setDocumentOptions` instead. This method will be removed in the future.
     */
    setSessionOptions(session, options) {
      let sessionLanguageProvider = this.$getSessionLanguageProvider(session);
      sessionLanguageProvider.setOptions(options);
    }
    /**
     * Sets configuration options for a document associated with the specified editor session.
     *
     * @param session - The Ace editor session representing the document to configure.
     * @param options - The service options to apply. The exact shape depends on the language services
     *                  active for this session (e.g. JSON schema settings).
     */
    setDocumentOptions(session, options) {
      let sessionLanguageProvider = this.$getSessionLanguageProvider(session);
      sessionLanguageProvider.setOptions(options);
    }
    /**
     * Configures the specified features for a given service.
     *
     * @param {SupportedServices} serviceName - The name of the service for which features are being configured.
     * @param {ServiceFeatures} features - The features to be configured for the given service.
     * @return {void} Does not return a value.
     */
    configureServiceFeatures(serviceName, features) {
      this.$messageController.configureFeatures(serviceName, features);
    }
    doHover(session, position, callback) {
      this.$messageController.doHover(this.$getFileName(session), fromPoint(position), (hover) => callback && callback(toTooltip(hover)));
    }
    provideSignatureHelp(session, position, callback) {
      if (!this.$getSessionLanguageProvider(session))
        return;
      this.$messageController.provideSignatureHelp(this.$getFileName(session), fromPoint(position), (signatureHelp) => callback && callback(fromSignatureHelp(signatureHelp)));
    }
    getTooltipText(hover) {
      return hover.content.type === "markdown" ? CommonConverter.cleanHtml(this.options.markdownConverter.makeHtml(hover.content.text)) : hover.content.text;
    }
    getSemanticTokens() {
      if (!this.options.functionality.semanticTokens)
        return;
      if (this.activeEditor) {
        let sessionLanguageProvider = this.$getSessionLanguageProvider(this.activeEditor.session);
        sessionLanguageProvider.getSemanticTokens();
      }
    }
    doComplete(editor, session, callback) {
      let cursor = editor.getCursorPosition();
      this.$messageController.doComplete(
        this.$getFileName(session),
        fromPoint(cursor),
        (completions) => completions && callback(toCompletions(completions))
      );
    }
    doInlineComplete(editor, session, callback) {
      let cursor = editor.getCursorPosition();
      this.$messageController.doInlineComplete(
        this.$getFileName(session),
        fromPoint(cursor),
        (completions) => completions && callback(toInlineCompletions(completions))
      );
    }
    doResolve(item, callback) {
      this.$messageController.doResolve(item["fileName"], toCompletionItem(item), callback);
    }
    $registerCompleters(editor) {
      var _a, _b, _c, _d, _e, _f, _g;
      let completer, inlineCompleter;
      if (!((_a = this.options.functionality) == null ? void 0 : _a.completion) && !((_b = this.options.functionality) == null ? void 0 : _b.inlineCompletion)) {
        return;
      }
      this.$editorOriginalState[editor.id] = {};
      if ((_c = this.options.functionality) == null ? void 0 : _c.completion) {
        this.$editorOriginalState[editor.id].completers = editor.completers ? [...editor.completers] : [];
        if (this.options.functionality.completion.overwriteCompleters) {
          editor.completers = [];
        }
      }
      if ((_d = this.options.functionality) == null ? void 0 : _d.inlineCompletion) {
        this.$editorOriginalState[editor.id].inlineCompleters = editor.inlineCompleters ? [...editor.inlineCompleters] : [];
        if (this.options.functionality.inlineCompletion.overwriteCompleters) {
          editor.inlineCompleters = [];
        }
      }
      if (this.options.functionality.completion) {
        completer = {
          getCompletions: async (editor2, session, pos, prefix, callback) => {
            this.$getSessionLanguageProvider(session).$sendDeltaQueue(() => {
              const completionCallback = (completions) => {
                var _a2;
                let popup = (_a2 = editor2 == null ? void 0 : editor2.completer) == null ? void 0 : _a2.getPopup();
                if (popup) {
                  popupManager.addAcePopup(popup);
                }
                let fileName = this.$getFileName(session);
                if (!completions)
                  return;
                completions.forEach((item) => {
                  item.completerId = completer.id;
                  item["fileName"] = fileName;
                });
                callback(null, CommonConverter.normalizeRanges(completions));
              };
              this.doComplete(editor2, session, completionCallback);
            });
          },
          getDocTooltip: (item) => {
            if (this.options.functionality.completionResolve && !item["isResolved"] && item.completerId === completer.id) {
              this.doResolve(item, (completionItem) => {
                item["isResolved"] = true;
                if (!completionItem)
                  return;
                let completion = toResolvedCompletion(item, completionItem);
                item.docText = completion.docText;
                if (completion.docHTML) {
                  item.docHTML = completion.docHTML;
                } else if (completion["docMarkdown"]) {
                  item.docHTML = CommonConverter.cleanHtml(this.options.markdownConverter.makeHtml(completion["docMarkdown"]));
                }
                if (editor["completer"]) {
                  editor["completer"].updateDocTooltip();
                }
              });
            }
            return item;
          },
          id: "lspCompleters"
        };
        editor.completers.push(completer);
      }
      if ((_f = (_e = this.options) == null ? void 0 : _e.functionality) == null ? void 0 : _f.inlineCompletion) {
        this.checkInlineCompletionAdapter(() => {
          var _a2;
          if (this.completerAdapter) {
            (_a2 = editor.inlineCompleters) != null ? _a2 : editor.inlineCompleters = [];
            this.completerAdapter.validateAceInlineCompleterWithEditor(editor);
            this.inlineCompleter = this.completerAdapter.InlineCompleter;
            this.doLiveAutocomplete = this.completerAdapter.doLiveAutocomplete;
          }
        });
      }
      if ((_g = this.options.functionality) == null ? void 0 : _g.inlineCompletion) {
        const existingCommand = editor.commands.commands["startInlineAutocomplete"];
        this.$editorOriginalState[editor.id].inlineAutocompleteCommand = existingCommand || null;
        editor.commands.addCommand({
          name: "startInlineAutocomplete",
          exec: (editor2, options) => {
            var _a2;
            var completer2 = (_a2 = this.inlineCompleter) == null ? void 0 : _a2.for(editor2);
            completer2.show(options);
          },
          bindKey: { win: "Alt-C", mac: "Option-C" }
        });
        this.$editorEventHandlers[editor.id].afterExec = this.doLiveAutocomplete;
        editor.commands.on("afterExec", this.doLiveAutocomplete);
        inlineCompleter = {
          getCompletions: async (editor2, session, pos, prefix, callback) => {
            this.$getSessionLanguageProvider(session).$sendDeltaQueue(() => {
              const completionCallback = (completions) => {
                let fileName = this.$getFileName(session);
                if (!completions)
                  return;
                completions.forEach((item) => {
                  item.completerId = completer.id;
                  item["fileName"] = fileName;
                });
                callback(null, CommonConverter.normalizeRanges(completions));
              };
              this.doInlineComplete(editor2, session, completionCallback);
            });
          },
          id: "lspInlineCompleters"
        };
        editor.inlineCompleters.push(inlineCompleter);
      }
    }
    closeConnection() {
      this.$messageController.closeConnection(() => {
        this.$messageController.$worker.terminate();
      });
    }
    /**
     * Removes document from all linked services by session id and cleans up all associated resources.
     * This includes removing event listeners, clearing marker groups, annotations, and notifying the server.
     * @param session - The Ace EditSession to close
     * @param [callback] - Optional callback to execute after the document is closed
     */
    closeDocument(session, callback) {
      let sessionProvider = this.$getSessionLanguageProvider(session);
      if (sessionProvider) {
        sessionProvider.dispose(callback);
        delete this.$sessionLanguageProviders[session["id"]];
      }
    }
    /**
     * Sends a request to the message controller.
     * @param serviceName - The name of the service/server to send the request to.
     * @param method - The method name for the request.
     * @param params - The parameters for the request.
     * @param callback - An optional callback function that will be called with the result of the request.
     */
    sendRequest(serviceName, method, params, callback) {
      this.$messageController.sendRequest(serviceName, method, params, callback);
    }
    showDocument(params, serviceName, callback) {
      try {
        window.open(params.uri, "_blank");
        callback && callback({
          success: true
        }, serviceName);
      } catch (e) {
        callback && callback({
          success: false,
          error: e
        }, serviceName);
      }
    }
  }
  exports2.LanguageProvider = LanguageProvider;
  exports2.MessageController = MessageController;
  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
}));


/***/ }),

/***/ 19631:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


/** @type {any} */var keys = __webpack_require__(29451);
var useragent = __webpack_require__(74943);

var pressedKeys = null;
var ts = 0;

var activeListenerOptions;
function detectListenerOptionsSupport() {
    activeListenerOptions = false;
    try {
        document.createComment("").addEventListener("test", function() {}, { 
            get passive() { 
                activeListenerOptions = {passive: false};
                return true;
            }
        });
    } catch(e) {}
}

function getListenerOptions() {
    if (activeListenerOptions == undefined)
        detectListenerOptionsSupport();
    return activeListenerOptions;
}

function EventListener(elem, type, callback) {
    this.elem = elem;
    this.type = type;
    this.callback = callback;
}
EventListener.prototype.destroy = function() {
    removeListener(this.elem, this.type, this.callback);
    this.elem = this.type = this.callback = undefined;
};

/**
 * Adds an event listener to the specified element.
 *
 * @param {any} elem - The element to add the event listener to.
 * @param {string} type - The type of event to listen for.
 * @param {any} callback - The callback function to be executed when the event is triggered.
 * @param {any} [destroyer] - An optional object that will have the created EventListener instance added to its $toDestroy array, allowing it to be easily destroyed later.
 */
var addListener = exports.addListener = function(elem, type, callback, destroyer) {
    elem.addEventListener(type, callback, getListenerOptions());
    if (destroyer)
        destroyer.$toDestroy.push(new EventListener(elem, type, callback));
};

var removeListener = exports.removeListener = function(elem, type, callback) {
    elem.removeEventListener(type, callback, getListenerOptions());
};

/*
* Prevents propagation and clobbers the default action of the passed event
*/
exports.stopEvent = function(e) {
    exports.stopPropagation(e);
    exports.preventDefault(e);
    return false;
};

exports.stopPropagation = function(e) {
    if (e.stopPropagation)
        e.stopPropagation();
};

exports.preventDefault = function(e) {
    if (e.preventDefault)
        e.preventDefault();
};

/*
 * @return {Number} 0 for left button, 1 for middle button, 2 for right button
 */
exports.getButton = function(e) {
    if (e.type == "dblclick")
        return 0;
    if (e.type == "contextmenu" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))
        return 2;

    // DOM Event
    return e.button;
};

exports.capture = function(el, eventHandler, releaseCaptureHandler) {
    var ownerDocument = el && el.ownerDocument || document;
    function onMouseUp(e) {
        eventHandler && eventHandler(e);
        releaseCaptureHandler && releaseCaptureHandler(e);

        removeListener(ownerDocument, "mousemove", eventHandler);
        removeListener(ownerDocument, "mouseup", onMouseUp);
        removeListener(ownerDocument, "dragstart", onMouseUp);
    }

    addListener(ownerDocument, "mousemove", eventHandler);
    addListener(ownerDocument, "mouseup", onMouseUp);
    addListener(ownerDocument, "dragstart", onMouseUp);
    
    return onMouseUp;
};

/**
 * @param el
 * @param callback
 * @param [destroyer]
 */
exports.addMouseWheelListener = function(el, callback, destroyer) {
    addListener(el, "wheel",  function(e) {
        var factor = 0.15;
        // workaround for firefox changing deltaMode based on which property is accessed first
        var deltaX = e.deltaX || 0;
        var deltaY = e.deltaY || 0;
        switch (e.deltaMode) {
            case e.DOM_DELTA_PIXEL:
                e.wheelX = deltaX * factor;
                e.wheelY = deltaY * factor;
                break;
            case e.DOM_DELTA_LINE:
                var linePixels = 15;
                e.wheelX = deltaX * linePixels;
                e.wheelY = deltaY * linePixels;
                break;
            case e.DOM_DELTA_PAGE:
                var pagePixels = 150;
                e.wheelX = deltaX * pagePixels;
                e.wheelY = deltaY * pagePixels;
                break;
        }
        callback(e);
    }, destroyer);
};

/**
 * @param elements
 * @param timeouts
 * @param eventHandler
 * @param callbackName
 * @param [destroyer]
 */
exports.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName, destroyer) {
    var clicks = 0;
    var startX, startY, timer; 
    var eventNames = {
        2: "dblclick",
        3: "tripleclick",
        4: "quadclick"
    };

    function onMousedown(e) {
        if (exports.getButton(e) !== 0) {
            clicks = 0;
        } else if (e.detail > 1) {
            clicks++;
            if (clicks > 4)
                clicks = 1;
        } else {
            clicks = 1;
        }
        if (useragent.isIE) {
            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
            if (!timer || isNewClick)
                clicks = 1;
            if (timer)
                clearTimeout(timer);
            timer = setTimeout(function() {timer = null;}, timeouts[clicks - 1] || 600);

            if (clicks == 1) {
                startX = e.clientX;
                startY = e.clientY;
            }
        }
        
        e._clicks = clicks;

        eventHandler[callbackName]("mousedown", e);

        if (clicks > 4)
            clicks = 0;
        else if (clicks > 1)
            return eventHandler[callbackName](eventNames[clicks], e);
    }
    if (!Array.isArray(elements))
        elements = [elements];
    elements.forEach(function(el) {
        addListener(el, "mousedown", onMousedown, destroyer);
    });
};

/** @param {KeyboardEvent|MouseEvent} e */
function getModifierHash(e) {
    return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
}

/**
 * @param {KeyboardEvent|MouseEvent} e
 * @returns string
 */
exports.getModifierString = function(e) {
    return keys.KEY_MODS[getModifierHash(e)];
};

/**
 * @param {(e: KeyboardEvent, hashId: number, keyCode: number)=> void } callback
 * @param {KeyboardEvent} e
 * @param {number} keyCode
 */
function normalizeCommandKeys(callback, e, keyCode) {
    var hashId = getModifierHash(e);

    if (!keyCode && e.code) {
        keyCode = keys.$codeToKeyCode[e.code] || keyCode;
    }

    if (!useragent.isMac && pressedKeys) {
        if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win")))
            hashId |= 8;
        if (pressedKeys.altGr) {
            if ((3 & hashId) != 3)
                pressedKeys.altGr = 0;
            else
                return;
        }
        if (keyCode === 18 || keyCode === 17) {
            var location = e.location;
            if (keyCode === 17 && location === 1) {
                if (pressedKeys[keyCode] == 1)
                    ts = e.timeStamp;
            } else if (keyCode === 18 && hashId === 3 && location === 2) {
                var dt = e.timeStamp - ts;
                if (dt < 50)
                    pressedKeys.altGr = true;
            }
        }
    }
    
    if (keyCode in keys.MODIFIER_KEYS) {
        keyCode = -1;
    }
    
    if (!hashId && keyCode === 13) {
        if (e.location === 3) {
            callback(e, hashId, -keyCode);
            if (e.defaultPrevented)
                return;
        }
    }
    
    if (useragent.isChromeOS && hashId & 8) {
        callback(e, hashId, keyCode);
        if (e.defaultPrevented)
            return;
        else
            hashId &= ~8;
    }

    // If there is no hashId and the keyCode is not a function key, then
    // we don't call the callback as we don't handle a command key here
    // (it's a normal key/character input).
    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
        return false;
    }
    
    return callback(e, hashId, keyCode);
}

/**
 * @param {EventTarget} el
 * @param {(e: KeyboardEvent, hashId: number, keyCode: number)=>void} callback
 * @param [destroyer]
 */
exports.addCommandKeyListener = function(el, callback, destroyer) {
    var lastDefaultPrevented = null;

    addListener(el, "keydown", function(e) {
        pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
        var result = normalizeCommandKeys(callback, e, e.keyCode);
        lastDefaultPrevented = e.defaultPrevented;
        return result;
    }, destroyer);

    addListener(el, "keypress", function(e) {
        if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
            exports.stopEvent(e);
            lastDefaultPrevented = null;
        }
    }, destroyer);

    addListener(el, "keyup", function(e) {
        pressedKeys[e.keyCode] = null;
    }, destroyer);

    if (!pressedKeys) {
        resetPressedKeys();
        addListener(window, "focus", resetPressedKeys);
    }
};
function resetPressedKeys() {
    pressedKeys = Object.create(null);
}

if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
    var postMessageId = 1;
    exports.nextTick = function(callback, win) {
        win = win || window;
        var messageName = "zero-timeout-message-" + (postMessageId++);
        
        var listener = function(e) {
            if (e.data == messageName) {
                exports.stopPropagation(e);
                removeListener(win, "message", listener);
                callback();
            }
        };
        
        addListener(win, "message", listener);
        win.postMessage(messageName, "*");
    };
}

exports.$idleBlocked = false;
/**
 *
 * @param {CallableFunction} cb
 * @param {number} timeout
 * @return {ReturnType<typeof setTimeout>}
 */
exports.onIdle = function(cb, timeout) {
    return setTimeout(function handler() {
        if (!exports.$idleBlocked) {
            cb();
        } else {
            setTimeout(handler, 100);
        }
    }, timeout);
};

/**@type {null | ReturnType<typeof setTimeout>}*/
exports.$idleBlockId = null;
/** @arg [delay] {null | number} */
exports.blockIdle = function(delay) {
    if (exports.$idleBlockId)
        clearTimeout(exports.$idleBlockId);
        
    exports.$idleBlocked = true;
    exports.$idleBlockId = setTimeout(function() {
        exports.$idleBlocked = false;
    }, delay || 100);
};

exports.nextFrame = typeof window == "object" && (window.requestAnimationFrame
    || window["mozRequestAnimationFrame"]
    || window["webkitRequestAnimationFrame"]
    || window["msRequestAnimationFrame"]
    || window["oRequestAnimationFrame"]);

if (exports.nextFrame)
    exports.nextFrame = exports.nextFrame.bind(window);
else
    exports.nextFrame = function(callback) {
        setTimeout(callback, 17);
    };


/***/ }),

/***/ 20845:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"no use strict";
var oop = __webpack_require__(2645);
var EventEmitter = (__webpack_require__(87366).EventEmitter);
const reportError = (__webpack_require__(53092)/* .reportError */ .N);
const defaultEnglishMessages = (__webpack_require__(63816)/* .defaultEnglishMessages */ .q);

var optionsProvider = {
    setOptions: function(optList) {
        Object.keys(optList).forEach(function(key) {
            this.setOption(key, optList[key]);
        }, this);
    },
    getOptions: function(optionNames) {
        var result = {};
        if (!optionNames) {
            var options = this.$options;
            optionNames = Object.keys(options).filter(function(key) {
                return !options[key].hidden;
            });
        } else if (!Array.isArray(optionNames)) {
            optionNames = Object.keys(optionNames);
        }
        optionNames.forEach(function(key) {
            result[key] = this.getOption(key);
        }, this);
        return result;
    },
    setOption: function(name, value) {
        if (this["$" + name] === value)
            return;
        //@ts-ignore
        var opt = this.$options[name];
        if (!opt) {
            return warn('misspelled option "' + name + '"');
        }
        if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);

        if (!opt.handlesSet)
            this["$" + name] = value;
        if (opt && opt.set)
            opt.set.call(this, value);
    },
    getOption: function(name) {
        var opt = this.$options[name];
        if (!opt) {
            return warn('misspelled option "' + name + '"');
        }
        if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
        return opt && opt.get ? opt.get.call(this) : this["$" + name];
    }
};

function warn(message) {
    if (typeof console != "undefined" && console.warn)
        console.warn.apply(console, arguments);
}

var messages;
var nlsPlaceholders;

class AppConfig {
    constructor() {
            this.$defaultOptions = {};
            messages = defaultEnglishMessages;
            nlsPlaceholders = "dollarSigns";
        }

    /**
     * @param {Object} obj
     * @param {string} path
     * @param {{ [key: string]: any }} options
     * @returns {import("../../ace-internal").Ace.AppConfig}
     */
    defineOptions(obj, path, options) {
        if (!obj.$options)
            this.$defaultOptions[path] = obj.$options = {};

        Object.keys(options).forEach(function(key) {
            var opt = options[key];
            if (typeof opt == "string")
                opt = {forwardTo: opt};

            opt.name || (opt.name = key);
            obj.$options[opt.name] = opt;
            if ("initialValue" in opt)
                obj["$" + opt.name] = opt.initialValue;
        });

        // implement option provider interface
        oop.implement(obj, optionsProvider);

        return this;
    }

    /**
     * @param {Object} obj
     */
    resetOptions(obj) {
        Object.keys(obj.$options).forEach(function(key) {
            var opt = obj.$options[key];
            if ("value" in opt)
                obj.setOption(key, opt.value);
        });
    }

    /**
     * @param {string} path
     * @param {string} name
     * @param {any} value
     */
    setDefaultValue(path, name, value) {
        if (!path) {
            for (path in this.$defaultOptions)
                if (this.$defaultOptions[path][name])
                    break;
            if (!this.$defaultOptions[path][name])
                return false;
        }
        var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
        if (opts[name]) {
            if (opts.forwardTo)
                this.setDefaultValue(opts.forwardTo, name, value);
            else
                opts[name].value = value;
        }
    }

    /**
     * @param {string} path
     * @param {{ [key: string]: any; }} optionHash
     */
    setDefaultValues(path, optionHash) {
        Object.keys(optionHash).forEach(function(key) {
            this.setDefaultValue(path, key, optionHash[key]);
        }, this);
    }

    /**
     * @param {any} value
     * @param {{placeholders?: "dollarSigns" | "curlyBrackets"}} [options]
     */
    setMessages(value, options) {
        messages = value;
        if (options && options.placeholders) {
            nlsPlaceholders = options.placeholders;
        }
    }

    /**
     * @param {string} key
     * @param {string} defaultString
     * @param {{ [x: string]: any; }} [params]
     */
    nls(key, defaultString, params) {
        if (!messages[key])  {
            warn("No message found for the key '" + key + "' in messages with id " + messages.$id + ", trying to find a translation for the default string '" + defaultString + "'.");
            if (!messages[defaultString]) {
                warn("No message found for the default string '" + defaultString + "' in the provided messages. Falling back to the default English message.");
            }
        }

        var translated = messages[key] || messages[defaultString] || defaultString;
        if (params) {
            // We support both $n or {n} as placeholder indicators in the provided translated strings
            if (nlsPlaceholders === "dollarSigns") {
                // Replace $n with the nth element in params
                translated = translated.replace(/\$(\$|[\d]+)/g, function(_, dollarMatch) {
                    if (dollarMatch == "$") return "$";
                    return params[dollarMatch];
                });
            }
            if (nlsPlaceholders === "curlyBrackets") {
                // Replace {n} with the nth element in params
                translated = translated.replace(/\{([^\}]+)\}/g, function(_, curlyBracketMatch) {
                    return params[curlyBracketMatch];
                });
            }
        }
        return translated;
    }
}
AppConfig.prototype.warn = warn;
AppConfig.prototype.reportError = reportError;

// module loading
oop.implement(AppConfig.prototype, EventEmitter);

exports.o = AppConfig;


/***/ }),

/***/ 21016:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./edit_session").EditSession} EditSession
 * @typedef {import("../ace-internal").Ace.Point} Point
 * @typedef {import("../ace-internal").Ace.Theme} Theme
 */
var oop = __webpack_require__(2645);
var dom = __webpack_require__(71435);
var lang = __webpack_require__(39955);
var config = __webpack_require__(76321);
var GutterLayer = (__webpack_require__(6166)/* .Gutter */ .W);
var MarkerLayer = (__webpack_require__(12187)/* .Marker */ .p);
var TextLayer = (__webpack_require__(10694)/* .Text */ .E);
var CursorLayer = (__webpack_require__(50643)/* .Cursor */ .b);
var HScrollBar = (__webpack_require__(17745)/* .HScrollBar */ .V1);
var VScrollBar = (__webpack_require__(17745)/* .VScrollBar */ .vB);
var HScrollBarCustom = (__webpack_require__(50311)/* .HScrollBar */ .V1);
var VScrollBarCustom = (__webpack_require__(50311)/* .VScrollBar */ .vB);
var RenderLoop = (__webpack_require__(99481)/* .RenderLoop */ .x);
var FontMetrics = (__webpack_require__(22150)/* .FontMetrics */ .X);
var EventEmitter = (__webpack_require__(87366).EventEmitter);
var editorCss = __webpack_require__(53120);
var Decorator = (__webpack_require__(31079)/* .Decorator */ .K);

var useragent = __webpack_require__(74943);
const isTextToken = (__webpack_require__(41109)/* .isTextToken */ .t);

dom.importCssString(editorCss, "ace_editor.css", false);

/**
 * The class that is responsible for drawing everything you see on the screen!
 * @related editor.renderer
 **/
class VirtualRenderer {
    /**
     * Constructs a new `VirtualRenderer` within the `container` specified, applying the given `theme`.
     * @param {HTMLElement | null} [container] The root element of the editor
     * @param {String} [theme] The starting theme

     **/
    constructor(container, theme) {
        var _self = this;
        this.container = container || dom.createElement("div");

        dom.addCssClass(this.container, "ace_editor");
        if (dom.HI_DPI) dom.addCssClass(this.container, "ace_hidpi");

        this.setTheme(theme);
        if (config.get("useStrictCSP") == null)
            config.set("useStrictCSP", false);

        this.$gutter = dom.createElement("div");
        this.$gutter.className = "ace_gutter";
        this.container.appendChild(this.$gutter);
        this.$gutter.setAttribute("aria-hidden", "true");
        /**@type {HTMLElement}*/
        this.scroller = dom.createElement("div");
        this.scroller.className = "ace_scroller";

        this.container.appendChild(this.scroller);
        /**@type {HTMLElement}*/
        this.content = dom.createElement("div");
        this.content.className = "ace_content";
        this.scroller.appendChild(this.content);

        this.$gutterLayer = new GutterLayer(this.$gutter);
        this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));

        this.$markerBack = new MarkerLayer(this.content);
        var textLayer = this.$textLayer = new TextLayer(this.content);
        this.canvas = textLayer.element;

        this.$markerFront = new MarkerLayer(this.content);

        this.$cursorLayer = new CursorLayer(this.content);

        // Indicates whether the horizontal scrollbar is visible
        this.$horizScroll = false;
        this.$vScroll = false;

        this.scrollBar =
            this.scrollBarV = new VScrollBar(this.container, this);
        this.scrollBarH = new HScrollBar(this.container, this);
        this.scrollBarV.on("scroll", function(e) {
            if (!_self.$scrollAnimation)
                _self.session.setScrollTop(e.data - _self.scrollMargin.top);
        });
        this.scrollBarH.on("scroll", function(e) {
            if (!_self.$scrollAnimation)
                _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
        });

        this.scrollTop = 0;
        this.scrollLeft = 0;

        this.cursorPos = {
            row : 0,
            column : 0
        };

        this.$fontMetrics = new FontMetrics(this.container);
        this.$textLayer.$setFontMetrics(this.$fontMetrics);
        this.$textLayer.on("changeCharacterSize", function(e) {
            _self.updateCharacterSize();
            _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
            _self._signal("changeCharacterSize", e);
        });

        this.$size = {
            width: 0,
            height: 0,
            scrollerHeight: 0,
            scrollerWidth: 0,
            $dirty: true
        };

        this.layerConfig = {
            width : 1,
            padding : 0,
            firstRow : 0,
            firstRowScreen: 0,
            lastRow : 0,
            lineHeight : 0,
            characterWidth : 0,
            minHeight : 1,
            maxHeight : 1,
            offset : 0,
            height : 1,
            gutterOffset: 1
        };

        this.scrollMargin = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            v: 0,
            h: 0
        };

        this.margin = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            v: 0,
            h: 0
        };

        this.$keepTextAreaAtCursor = !useragent.isIOS;

        this.$loop = new RenderLoop(
            this.$renderChanges.bind(this),
            this.container.ownerDocument.defaultView
        );
        this.$loop.schedule(this.CHANGE_FULL);

        this.updateCharacterSize();
        this.setPadding(4);
        this.$addResizeObserver();
        config.resetOptions(this);
        config._signal("renderer", this);
    }


    // this.$logChanges = function(changes) {
    //     var a = ""
    //     if (changes & this.CHANGE_CURSOR) a += " cursor";
    //     if (changes & this.CHANGE_MARKER) a += " marker";
    //     if (changes & this.CHANGE_GUTTER) a += " gutter";
    //     if (changes & this.CHANGE_SCROLL) a += " scroll";
    //     if (changes & this.CHANGE_LINES) a += " lines";
    //     if (changes & this.CHANGE_TEXT) a += " text";
    //     if (changes & this.CHANGE_SIZE) a += " size";
    //     if (changes & this.CHANGE_MARKER_BACK) a += " marker_back";
    //     if (changes & this.CHANGE_MARKER_FRONT) a += " marker_front";
    //     if (changes & this.CHANGE_FULL) a += " full";
    //     if (changes & this.CHANGE_H_SCROLL) a += " h_scroll";
    //     console.log(a.trim())
    // };

    updateCharacterSize() {
        // @ts-expect-error TODO: missing property initialization anywhere in codebase
        if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
            // @ts-expect-error TODO: missing property initialization anywhere in codebase
            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
            this.setStyle("ace_nobold", !this.$allowBoldFonts);
        }

        this.layerConfig.characterWidth =
        this.characterWidth = this.$textLayer.getCharacterWidth();
        this.layerConfig.lineHeight =
        this.lineHeight = this.$textLayer.getLineHeight();
        this.$updatePrintMargin();
        // set explicit line height to avoid normal resolving to different values based on text
        dom.setStyle(this.scroller.style, "line-height", this.lineHeight + "px");
    }

    /**
     *
     * Associates the renderer with an [[EditSession `EditSession`]].
     * @param {EditSession} session The session to associate with
     **/
    setSession(session) {
        if (this.session)
            this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);

        this.session = session;
        if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
            session.setScrollTop(-this.scrollMargin.top);

        this.$cursorLayer.setSession(session);
        this.$markerBack.setSession(session);
        this.$markerFront.setSession(session);
        this.$gutterLayer.setSession(session);
        this.$textLayer.setSession(session);
        if (!session)
            return;

        this.$loop.schedule(this.CHANGE_FULL);
        this.session.$setFontMetrics(this.$fontMetrics);
        this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;

        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
        this.onChangeNewLineMode();
        this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
    }

    /**
     * Triggers a partial update of the text, from the range given by the two parameters.
     * @param {Number} firstRow The first row to update
     * @param {Number} lastRow The last row to update
     * @param {boolean} [force]
     **/
    updateLines(firstRow, lastRow, force) {
        if (lastRow === undefined)
            lastRow = Infinity;

        if (!this.$changedLines) {
            this.$changedLines = {
                firstRow: firstRow,
                lastRow: lastRow
            };
        }
        else {
            if (this.$changedLines.firstRow > firstRow)
                this.$changedLines.firstRow = firstRow;

            if (this.$changedLines.lastRow < lastRow)
                this.$changedLines.lastRow = lastRow;
        }

        // If the change happened offscreen above us then it's possible
        // that a new line wrap will affect the position of the lines on our
        // screen so they need redrawn.
        // TODO: better solution is to not change scroll position when text is changed outside of visible area
        if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
            if (force)
                this.$changedLines.lastRow = this.layerConfig.lastRow;
            else
                return;
        }
        if (this.$changedLines.firstRow > this.layerConfig.lastRow)
            return;
        this.$loop.schedule(this.CHANGE_LINES);
    }

    /**
     * @internal
     */
    onChangeNewLineMode() {
        this.$loop.schedule(this.CHANGE_TEXT);
        this.$textLayer.$updateEolChar();
        this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
    }

    /**
     * @internal
     */
    onChangeTabSize() {
        this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
        this.$textLayer.onChangeTabSize();
    }

    /**
     * Triggers a full update of the text, for all the rows.
     **/
    updateText() {
        this.$loop.schedule(this.CHANGE_TEXT);
    }

    /**
     * Triggers a full update of all the layers, for all the rows.
     * @param {Boolean} [force] If `true`, forces the changes through

     **/
    updateFull(force) {
        if (force)
            this.$renderChanges(this.CHANGE_FULL, true);
        else
            this.$loop.schedule(this.CHANGE_FULL);
    }

    /**
     * Updates the font size.
     **/
    updateFontSize() {
        this.$textLayer.checkForSizeChanges();
    }

    $updateSizeAsync() {
        if (this.$loop.pending)
            this.$size.$dirty = true;
        else
            this.onResize();
    }
    /**
     * [Triggers a resize of the editor.]{: #VirtualRenderer.onResize}
     * @param {Boolean} [force] If `true`, recomputes the size, even if the height and width haven't changed
     * @param {Number} [gutterWidth] The width of the gutter in pixels
     * @param {Number} [width] The width of the editor in pixels
     * @param {Number} [height] The hiehgt of the editor, in pixels
     * @internal
     **/
    onResize(force, gutterWidth, width, height) {
        if (this.resizing > 2)
            return;
        else if (this.resizing > 0)
            this.resizing++;
        else
            this.resizing = force ? 1 : 0;
        // `|| el.scrollHeight` is required for autosizing editors on ie
        // where elements with clientHeight = 0 also have clientWidth = 0
        var el = this.container;
        if (!height)
            height = el.clientHeight || el.scrollHeight;
        if (!height && this.$maxLines && this.lineHeight > 1) {
            // if we are supposed to fit to content set height at least to 1
            // so that render does not exit early before calling $autosize
            if (!el.style.height || el.style.height == "0px") {
                el.style.height = "1px";
                height = el.clientHeight || el.scrollHeight;
            }
        }
        if (!width)
            width = el.clientWidth || el.scrollWidth;
        var changes = this.$updateCachedSize(force, gutterWidth, width, height);

        if (this.$resizeTimer) this.$resizeTimer.cancel();

        if (!this.$size.scrollerHeight || (!width && !height))
            return this.resizing = 0;

        if (force)
            this.$gutterLayer.$padding = null;

        if (force)
            this.$renderChanges(changes | this.$changes, true);
        else
            this.$loop.schedule(changes | this.$changes);

        if (this.resizing)
            this.resizing = 0;
        // reset cached values on scrollbars, needs to be removed when switching to non-native scrollbars
        // see https://github.com/ajaxorg/ace/issues/2195
        this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
        if (this.$customScrollbar) {
            this.$updateCustomScrollbar(true);
        }
    }

    /**
     * @param [force]
     * @param [gutterWidth]
     * @param [width]
     * @param [height]
     * @return {number}

     */
    $updateCachedSize(force, gutterWidth, width, height) {
        height -= (this.$extraHeight || 0);
        var changes = 0;
        var size = this.$size;
        var oldSize = {
            width: size.width,
            height: size.height,
            scrollerHeight: size.scrollerHeight,
            scrollerWidth: size.scrollerWidth
        };
        if (height && (force || size.height != height)) {
            size.height = height;
            changes |= this.CHANGE_SIZE;

            size.scrollerHeight = size.height;
            if (this.$horizScroll)
                size.scrollerHeight -= this.scrollBarH.getHeight();

            this.scrollBarV.setHeight(size.scrollerHeight);
            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";

            changes = changes | this.CHANGE_SCROLL;
        }

        if (width && (force || size.width != width)) {
            changes |= this.CHANGE_SIZE;
            size.width = width;

            if (gutterWidth == null)
                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;

            this.gutterWidth = gutterWidth;

            dom.setStyle(this.scrollBarH.element.style, "left", gutterWidth + "px");
            dom.setStyle(this.scroller.style, "left", gutterWidth + this.margin.left + "px");
            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth() - this.margin.h);
            dom.setStyle(this.$gutter.style, "left", this.margin.left + "px");

            var right = this.scrollBarV.getWidth() + "px";
            dom.setStyle(this.scrollBarH.element.style, "right", right);
            dom.setStyle(this.scroller.style, "right", right);
            dom.setStyle(this.scroller.style, "bottom", this.scrollBarH.getHeight());

            this.scrollBarH.setWidth(size.scrollerWidth);

            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) {
                changes |= this.CHANGE_FULL;
            }
        }

        size.$dirty = !width || !height;

        if (changes)
            this._signal("resize", oldSize);

        return changes;
    }

    /**
     *
     * @param {number} width
     * @internal
     */
    onGutterResize(width) {
        var gutterWidth = this.$showGutter ? width : 0;
        if (gutterWidth != this.gutterWidth)
            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);

        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
            this.$loop.schedule(this.CHANGE_FULL);
        } else if (this.$size.$dirty) {
            this.$loop.schedule(this.CHANGE_FULL);
        } else {
            this.$computeLayerConfig();
        }
    }

    /**
     * Adjusts the wrap limit, which is the number of characters that can fit within the width of the edit area on screen.

     **/
    adjustWrapLimit() {
        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
        var limit = Math.floor(availableWidth / this.characterWidth);
        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
    }

    /**
     * Identifies whether you want to have an animated scroll or not.
     * @param {Boolean} shouldAnimate Set to `true` to show animated scrolls

     **/
    setAnimatedScroll(shouldAnimate){
        this.setOption("animatedScroll", shouldAnimate);
    }

    /**
     * Returns whether an animated scroll happens or not.
     * @returns {Boolean}

     **/
    getAnimatedScroll() {
        return this.$animatedScroll;
    }

    /**
     * Identifies whether you want to show invisible characters or not.
     * @param {Boolean} showInvisibles Set to `true` to show invisibles

     **/
    setShowInvisibles(showInvisibles) {
        this.setOption("showInvisibles", showInvisibles);
        this.session.$bidiHandler.setShowInvisibles(showInvisibles);
    }

    /**
     * Returns whether invisible characters are being shown or not.
     * @returns {Boolean}

     **/
    getShowInvisibles() {
        return this.getOption("showInvisibles");
    }

    /**
     * @return {boolean}

     */
    getDisplayIndentGuides() {
        return this.getOption("displayIndentGuides");
    }

    /**
     * @param {boolean} display

     */
    setDisplayIndentGuides(display) {
        this.setOption("displayIndentGuides", display);
    }

    /**

     * @return {boolean}
     */
    getHighlightIndentGuides() {
        return this.getOption("highlightIndentGuides");
    }

    /**

     * @param {boolean} highlight
     */
    setHighlightIndentGuides(highlight) {
        this.setOption("highlightIndentGuides", highlight);
    }

    /**
     * Identifies whether you want to show the print margin or not.
     * @param {Boolean} showPrintMargin Set to `true` to show the print margin

     **/
    setShowPrintMargin(showPrintMargin) {
        this.setOption("showPrintMargin", showPrintMargin);
    }

    /**
     * Returns whether the print margin is being shown or not.
     * @returns {Boolean}

     **/
    getShowPrintMargin() {
        return this.getOption("showPrintMargin");
    }
    /**
     * Identifies whether you want to show the print margin column or not.
     * @param {number} printMarginColumn Set to `true` to show the print margin column

     **/
    setPrintMarginColumn(printMarginColumn) {
        this.setOption("printMarginColumn", printMarginColumn);
    }

    /**
     * Returns whether the print margin column is being shown or not.
     * @returns {number}

     **/
    getPrintMarginColumn() {
        return this.getOption("printMarginColumn");
    }

    /**
     * Returns `true` if the gutter is being shown.
     * @returns {Boolean}

     **/
    getShowGutter(){
        return this.getOption("showGutter");
    }

    /**
     * Identifies whether you want to show the gutter or not.
     * @param {Boolean} show Set to `true` to show the gutter

     **/
    setShowGutter(show){
        return this.setOption("showGutter", show);
    }

    /**

     * @returns {boolean}
     */
    getFadeFoldWidgets(){
        return this.getOption("fadeFoldWidgets");
    }

    /**

     * @param {boolean} show
     */
    setFadeFoldWidgets(show) {
        this.setOption("fadeFoldWidgets", show);
    }

    /**
      *
     * @param {boolean} shouldHighlight
     */
    setHighlightGutterLine(shouldHighlight) {
        this.setOption("highlightGutterLine", shouldHighlight);
    }

    /**

     * @returns {boolean}
     */
    getHighlightGutterLine() {
        return this.getOption("highlightGutterLine");
    }

    /**

     */
    $updatePrintMargin() {
        if (!this.$showPrintMargin && !this.$printMarginEl)
            return;

        if (!this.$printMarginEl) {
            var containerEl = dom.createElement("div");
            containerEl.className = "ace_layer ace_print-margin-layer";
            this.$printMarginEl = dom.createElement("div");
            this.$printMarginEl.className = "ace_print-margin";
            containerEl.appendChild(this.$printMarginEl);
            this.content.insertBefore(containerEl, this.content.firstChild);
        }

        var style = this.$printMarginEl.style;
        style.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + "px";
        style.visibility = this.$showPrintMargin ? "visible" : "hidden";

        if (this.session && this.session.$wrap == -1)
            this.adjustWrapLimit();
    }

    /**
     *
     * Returns the root element containing this renderer.
     * @returns {HTMLElement}
     **/
    getContainerElement() {
        return this.container;
    }

    /**
     *
     * Returns the element that the mouse events are attached to
     * @returns {HTMLElement}
     **/
    getMouseEventTarget() {
        return this.scroller;
    }

    /**
     *
     * Returns the element to which the hidden text area is added.
     * @returns {HTMLElement}
     **/
    getTextAreaContainer() {
        return this.container;
    }

    // move text input over the cursor
    // this is required for IME
    /**

     */
    $moveTextAreaToCursor() {
        if (this.$isMousePressed) return;
        var style = this.textarea.style;
        var composition = this.$composition;
        if (!this.$keepTextAreaAtCursor && !composition) {
            dom.translate(this.textarea, -100, 0);
            return;
        }
        var pixelPos = this.$cursorLayer.$pixelPos;
        if (!pixelPos)
            return;
        if (composition && composition.markerRange)
            pixelPos = this.$cursorLayer.getPixelPosition(composition.markerRange.start, true);

        var config = this.layerConfig;
        var posTop = pixelPos.top;
        var posLeft = pixelPos.left;
        posTop -= config.offset;

        var h = composition && composition.useTextareaForIME || useragent.isMobile ? this.lineHeight : 1;
        if (posTop < 0 || posTop > config.height - h) {
            dom.translate(this.textarea, 0, 0);
            return;
        }

        var w = 1;
        var maxTop = this.$size.height - h;
        if (!composition) {
            posTop += this.lineHeight;
        }
        else {
            if (composition.useTextareaForIME) {
                var val = this.textarea.value;
                w = this.characterWidth * (this.session.$getStringScreenWidth(val)[0]);
            }
            else {
                posTop += this.lineHeight + 2;
            }
        }

        posLeft -= this.scrollLeft;
        if (posLeft > this.$size.scrollerWidth - w)
            posLeft = this.$size.scrollerWidth - w;

        posLeft += this.gutterWidth + this.margin.left;

        dom.setStyle(style, "height", h + "px");
        dom.setStyle(style, "width", w + "px");
        dom.translate(this.textarea, Math.min(posLeft, this.$size.scrollerWidth - w), Math.min(posTop, maxTop));
    }

    /**
     * [Returns the index of the first visible row.]{: #VirtualRenderer.getFirstVisibleRow}
     * @returns {Number}
     **/
    getFirstVisibleRow() {
        return this.layerConfig.firstRow;
    }

    /**
     *
     * Returns the index of the first fully visible row. "Fully" here means that the characters in the row are not truncated; that the top and the bottom of the row are on the screen.
     * @returns {Number}
     **/
    getFirstFullyVisibleRow() {
        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
    }

    /**
     *
     * Returns the index of the last fully visible row. "Fully" here means that the characters in the row are not truncated; that the top and the bottom of the row are on the screen.
     * @returns {Number}
     **/
    getLastFullyVisibleRow() {
        var config = this.layerConfig;
        var lastRow = config.lastRow;
        var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;
        if (top - this.session.getScrollTop() > config.height - config.lineHeight)
            return lastRow - 1;
        return lastRow;
    }

    /**
     *
     * [Returns the index of the last visible row.]{: #VirtualRenderer.getLastVisibleRow}
     * @returns {Number}
     **/
    getLastVisibleRow() {
        return this.layerConfig.lastRow;
    }

    /**
     * Sets the padding for all the layers.
     * @param {Number} padding A new padding value (in pixels)

     **/
    setPadding(padding) {
        this.$padding = padding;
        this.$textLayer.setPadding(padding);
        this.$cursorLayer.setPadding(padding);
        this.$markerFront.setPadding(padding);
        this.$markerBack.setPadding(padding);
        this.$loop.schedule(this.CHANGE_FULL);
        this.$updatePrintMargin();
    }

    /**
     *
     * @param {number} [top]
     * @param {number} [bottom]
     * @param {number} [left]
     * @param {number} [right]

     */
    setScrollMargin(top, bottom, left, right) {
        var sm = this.scrollMargin;
        sm.top = top|0;
        sm.bottom = bottom|0;
        sm.right = right|0;
        sm.left = left|0;
        sm.v = sm.top + sm.bottom;
        sm.h = sm.left + sm.right;
        if (sm.top && this.scrollTop <= 0 && this.session)
            this.session.setScrollTop(-sm.top);
        this.updateFull();
    }

    /**
     *
     * @param {number} [top]
     * @param {number} [bottom]
     * @param {number} [left]
     * @param {number} [right]

     */
    setMargin(top, bottom, left, right) {
        var sm = this.margin;
        sm.top = top|0;
        sm.bottom = bottom|0;
        sm.right = right|0;
        sm.left = left|0;
        sm.v = sm.top + sm.bottom;
        sm.h = sm.left + sm.right;
        this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);
        this.updateFull();
    }

    /**
     * Returns whether the horizontal scrollbar is set to be always visible.
     * @returns {Boolean}

     **/
    getHScrollBarAlwaysVisible() {
        return this.$hScrollBarAlwaysVisible;
    }

    /**
     * Identifies whether you want to show the horizontal scrollbar or not.
     * @param {Boolean} alwaysVisible Set to `true` to make the horizontal scroll bar visible

     **/
    setHScrollBarAlwaysVisible(alwaysVisible) {
        this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
    }
    /**
     * Returns whether the horizontal scrollbar is set to be always visible.
     * @returns {Boolean}

     **/
    getVScrollBarAlwaysVisible() {
        return this.$vScrollBarAlwaysVisible;
    }

    /**
     * Identifies whether you want to show the horizontal scrollbar or not.
     * @param {Boolean} alwaysVisible Set to `true` to make the horizontal scroll bar visible
     **/
    setVScrollBarAlwaysVisible(alwaysVisible) {
        this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
    }

    /**

     */
    $updateScrollBarV() {
        var scrollHeight = this.layerConfig.maxHeight;
        var scrollerHeight = this.$size.scrollerHeight;
        if (!this.$maxLines && this.$scrollPastEnd) {
            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
            if (this.scrollTop > scrollHeight - scrollerHeight) {
                scrollHeight = this.scrollTop + scrollerHeight;
                this.scrollBarV.scrollTop = null;
            }
        }
        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
    }
    $updateScrollBarH() {
        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
    }

    freeze() {
        this.$frozen = true;
    }

    unfreeze() {
        this.$frozen = false;
    }

    /**
     *
     * @param {number} changes
     * @param {boolean} [force]
     * @returns {number}

     */
    $renderChanges(changes, force) {
        if (this.$changes) {
            changes |= this.$changes;
            this.$changes = 0;
        }
        if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {
            this.$changes |= changes;
            return;
        }
        if (this.$size.$dirty) {
            this.$changes |= changes;
            return this.onResize(true);
        }
        if (!this.lineHeight) {
            this.$textLayer.checkForSizeChanges();
        }
        // this.$logChanges(changes);

        this._signal("beforeRender", changes);

        if (this.session && this.session.$bidiHandler)
            this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);

        var config = this.layerConfig;
        // text, scrolling and resize changes can cause the view port size to change
        if (changes & this.CHANGE_FULL ||
            changes & this.CHANGE_SIZE ||
            changes & this.CHANGE_TEXT ||
            changes & this.CHANGE_LINES ||
            changes & this.CHANGE_SCROLL ||
            changes & this.CHANGE_H_SCROLL
        ) {
            changes |= this.$computeLayerConfig() | this.$loop.clear();
            // If a change is made offscreen and wrapMode is on, then the onscreen
            // lines may have been pushed down. If so, the first screen row will not
            // have changed, but the first actual row will. In that case, adjust
            // scrollTop so that the cursor and onscreen content stays in the same place.
            // TODO: find a better way to handle this, that works non wrapped case and doesn't compute layerConfig twice
            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
                var st = this.scrollTop + (config.firstRow - Math.max(this.layerConfig.firstRow, 0)) * this.lineHeight;
                if (st > 0) {
                    // this check is needed as a workaround for the documentToScreenRow returning -1 if document.length == 0
                    this.scrollTop = st;
                    changes = changes | this.CHANGE_SCROLL;
                    changes |= this.$computeLayerConfig() | this.$loop.clear();
                }
            }
            config = this.layerConfig;
            // update scrollbar first to not lose scroll position when gutter calls resize
            this.$updateScrollBarV();
            if (changes & this.CHANGE_H_SCROLL)
                this.$updateScrollBarH();

            dom.translate(this.content, -this.scrollLeft, -config.offset);

            var width = config.width + 2 * this.$padding + "px";
            var height = config.minHeight + "px";

            dom.setStyle(this.content.style, "width", width);
            dom.setStyle(this.content.style, "height", height);
        }

        // horizontal scrolling
        if (changes & this.CHANGE_H_SCROLL) {
            dom.translate(this.content, -this.scrollLeft, -config.offset);
            this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller " : "ace_scroller ace_scroll-left ";
            if (this.enableKeyboardAccessibility)
                this.scroller.className += this.keyboardFocusClassName;
        }

        // full
        if (changes & this.CHANGE_FULL) {
            this.$changedLines = null;
            this.$textLayer.update(config);
            if (this.$showGutter)
                this.$gutterLayer.update(config);
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this._signal("afterRender", changes);
            return;
        }

        // scrolling
        if (changes & this.CHANGE_SCROLL) {
            this.$changedLines = null;
            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
                this.$textLayer.update(config);
            else
                this.$textLayer.scrollLines(config);

            if (this.$showGutter) {
                if (changes & this.CHANGE_GUTTER || changes & this.CHANGE_LINES)
                    this.$gutterLayer.update(config);
                else
                    this.$gutterLayer.scrollLines(config);
            }
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this._signal("afterRender", changes);
            return;
        }

        if (changes & this.CHANGE_TEXT) {
            this.$changedLines = null;
            this.$textLayer.update(config);
            if (this.$showGutter)
                this.$gutterLayer.update(config);
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
        }
        else if (changes & this.CHANGE_LINES) {
            if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)
                this.$gutterLayer.update(config);
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
        }
        else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
            if (this.$showGutter)
                this.$gutterLayer.update(config);
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
        }
        else if (changes & this.CHANGE_CURSOR) {
            if (this.$highlightGutterLine)
                // @ts-expect-error TODO: potential wrong param
                this.$gutterLayer.updateLineHighlight(config);
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
        }

        if (changes & this.CHANGE_CURSOR) {
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
        }

        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
            this.$markerFront.update(config);
        }

        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
            this.$markerBack.update(config);
        }

        this._signal("afterRender", changes);
    }

    /**

     */
    $autosize() {
        var height = this.session.getScreenLength() * this.lineHeight;
        var maxHeight = this.$maxLines * this.lineHeight;
        var desiredHeight = Math.min(maxHeight,
            Math.max((this.$minLines || 1) * this.lineHeight, height)
        ) + this.scrollMargin.v + (this.$extraHeight || 0);
        if (this.$horizScroll)
            desiredHeight += this.scrollBarH.getHeight();
        if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)
            desiredHeight = this.$maxPixelHeight;

        var hideScrollbars = desiredHeight <= 2 * this.lineHeight;
        var vScroll = !hideScrollbars && height > maxHeight;

        if (desiredHeight != this.desiredHeight ||
            this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
            if (vScroll != this.$vScroll) {
                this.$vScroll = vScroll;
                this.scrollBarV.setVisible(vScroll);
            }

            var w = this.container.clientWidth;
            this.container.style.height = desiredHeight + "px";
            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
            // this.$loop.changes = 0;
            this.desiredHeight = desiredHeight;

            this._signal("autosize");
        }
    }

    /**

     * @returns {number}
     */
    $computeLayerConfig() {
        var session = this.session;
        var size = this.$size;

        var hideScrollbars = size.height <= 2 * this.lineHeight;
        var screenLines = this.session.getScreenLength();
        var maxHeight = screenLines * this.lineHeight;

        var longestLine = this.$getLongestLine();

        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||
            size.scrollerWidth - longestLine - 2 * this.$padding < 0);

        var hScrollChanged = this.$horizScroll !== horizScroll;
        if (hScrollChanged) {
            this.$horizScroll = horizScroll;
            this.scrollBarH.setVisible(horizScroll);
        }
        var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine
        // autoresize only after updating hscroll to include scrollbar height in desired height
        if (this.$maxLines && this.lineHeight > 1){
            this.$autosize();
            // recalculate this after $autosize so we take vertical scroll into account when calculating width
            hideScrollbars = size.height <= 2 * this.lineHeight;
        }

        var minHeight = size.scrollerHeight + this.lineHeight;

        var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd
            ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd
            : 0;
        maxHeight += scrollPastEnd;

        var sm = this.scrollMargin;
        this.session.setScrollTop(Math.max(-sm.top,
            Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));

        this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft,
            longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));

        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||
            size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
        var vScrollChanged = vScrollBefore !== vScroll;
        if (vScrollChanged) {
            this.$vScroll = vScroll;
            this.scrollBarV.setVisible(vScroll);
        }

        var offset = this.scrollTop % this.lineHeight;
        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
        var lastRow = firstRow + lineCount;

        // Map lines on the screen to lines in the document.
        var firstRowScreen, firstRowHeight;
        var lineHeight = this.lineHeight;
        firstRow = session.screenToDocumentRow(firstRow, 0);

        // Check if firstRow is inside of a foldLine. If true, then use the first
        // row of the foldLine.
        var foldLine = session.getFoldLine(firstRow);
        if (foldLine) {
            firstRow = foldLine.start.row;
        }

        firstRowScreen = session.documentToScreenRow(firstRow, 0);
        firstRowHeight = session.getRowLength(firstRow) * lineHeight;

        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +
                                                firstRowHeight;

        offset = this.scrollTop - firstRowScreen * lineHeight;
        // adjust firstRowScreen and offset in case there is a line widget above the first row
        if (offset < 0 && firstRowScreen > 0) {
            firstRowScreen = Math.max(0, firstRowScreen + Math.floor(offset / lineHeight));
            offset = this.scrollTop - firstRowScreen * lineHeight;
        }

        var changes = 0;
        if (this.layerConfig.width != longestLine || hScrollChanged)
            changes = this.CHANGE_H_SCROLL;
        // Horizontal scrollbar visibility may have changed, which changes
        // the client height of the scroller
        if (hScrollChanged || vScrollChanged) {
            changes |= this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
            this._signal("scrollbarVisibilityChanged");
            if (vScrollChanged)
                longestLine = this.$getLongestLine();
        }

        this.layerConfig = {
            width : longestLine,
            padding : this.$padding,
            firstRow : firstRow,
            firstRowScreen: firstRowScreen,
            lastRow : lastRow,
            lineHeight : lineHeight,
            characterWidth : this.characterWidth,
            minHeight : minHeight,
            maxHeight : maxHeight,
            offset : offset,
            gutterOffset : lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
            height : this.$size.scrollerHeight
        };

        if (this.session.$bidiHandler)
            this.session.$bidiHandler.setContentWidth(longestLine - this.$padding);
        // For debugging.
        // console.log(JSON.stringify(this.layerConfig));

        return changes;
    }

    /**
     * @returns {boolean | undefined}

     */
    $updateLines() {
        if (!this.$changedLines) return;
        var firstRow = this.$changedLines.firstRow;
        var lastRow = this.$changedLines.lastRow;
        this.$changedLines = null;

        var layerConfig = this.layerConfig;

        if (firstRow > layerConfig.lastRow + 1) { return; }
        if (lastRow < layerConfig.firstRow) { return; }

        // if the last row is unknown -> redraw everything
        if (lastRow === Infinity) {
            if (this.$showGutter)
                this.$gutterLayer.update(layerConfig);
            this.$textLayer.update(layerConfig);
            return;
        }

        // else update only the changed rows
        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
        return true;
    }

    /**
     *
     * @returns {number}

     */
    $getLongestLine() {
        var charCount = this.session.getScreenWidth();
        if (this.showInvisibles && !this.session.$useWrapMode)
            charCount += 1;

        if (this.$textLayer && charCount > this.$textLayer.MAX_LINE_LENGTH)
            charCount = this.$textLayer.MAX_LINE_LENGTH + 30;

        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
    }

    /**
     * Schedules an update to all the front markers in the document.
     **/
    updateFrontMarkers() {
        this.$markerFront.setMarkers(this.session.getMarkers(true));
        this.$loop.schedule(this.CHANGE_MARKER_FRONT);
    }

    /**
     *
     * Schedules an update to all the back markers in the document.
     **/
    updateBackMarkers() {
        this.$markerBack.setMarkers(this.session.getMarkers());
        this.$loop.schedule(this.CHANGE_MARKER_BACK);
    }

    /**
     *
     * Deprecated; (moved to [[EditSession]])
     * @deprecated
     **/
    addGutterDecoration(row, className){
        this.$gutterLayer.addGutterDecoration(row, className);
    }

    /**
     * Deprecated; (moved to [[EditSession]])
     * @deprecated
     **/
    removeGutterDecoration(row, className){
        this.$gutterLayer.removeGutterDecoration(row, className);
    }

    /**
     *
     * Redraw breakpoints.
     * @param {any} [rows]
     */
    updateBreakpoints(rows) {
        this._rows = rows;
        this.$loop.schedule(this.CHANGE_GUTTER);
    }

    /**
     * Sets annotations for the gutter.
     * @param {import("../ace-internal").Ace.Annotation[]} annotations An array containing annotations
     *
     **/
    setAnnotations(annotations) {
        this.$gutterLayer.setAnnotations(annotations);
        this.$loop.schedule(this.CHANGE_GUTTER);
    }

    /**
     *
     * Updates the cursor icon.
     **/
    updateCursor() {
        this.$loop.schedule(this.CHANGE_CURSOR);
    }

    /**
     *
     * Hides the cursor icon.
     **/
    hideCursor() {
        this.$cursorLayer.hideCursor();
    }

    /**
     *
     * Shows the cursor icon.
     **/
    showCursor() {
        this.$cursorLayer.showCursor();
    }

    /**
     *
     * @param {Point} anchor
     * @param {Point} lead
     * @param {number} [offset]
     */
    scrollSelectionIntoView(anchor, lead, offset) {
        // first scroll anchor into view then scroll lead into view
        this.scrollCursorIntoView(anchor, offset);
        this.scrollCursorIntoView(lead, offset);
    }

    /**
     *
     * Scrolls the cursor into the first visibile area of the editor
     * @param {Point} [cursor]
     * @param {number} [offset]
     * @param {{ top?: any; bottom?: any; }} [$viewMargin]
     */
    scrollCursorIntoView(cursor, offset, $viewMargin) {
        // the editor is not visible
        if (this.$size.scrollerHeight === 0)
            return;

        var pos = this.$cursorLayer.getPixelPosition(cursor);

        var newLeft = pos.left;
        var newTop = pos.top;

        var topMargin = $viewMargin && $viewMargin.top || 0;
        var bottomMargin = $viewMargin && $viewMargin.bottom || 0;

        if (this.$scrollAnimation) {
            this.$stopAnimation = true;
        }

        var currentTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;

        if (currentTop + topMargin > newTop) {
            if (offset && currentTop + topMargin > newTop + this.lineHeight)
                newTop -= offset * this.$size.scrollerHeight;
            if (newTop === 0)
                newTop = -this.scrollMargin.top;
            this.session.setScrollTop(newTop);
        } else if (currentTop + this.$size.scrollerHeight - bottomMargin < newTop + this.lineHeight) {
            if (offset && currentTop + this.$size.scrollerHeight - bottomMargin < newTop -  this.lineHeight)
                newTop += offset * this.$size.scrollerHeight;
            this.session.setScrollTop(newTop + this.lineHeight + bottomMargin - this.$size.scrollerHeight);
        }

        var currentLeft = this.scrollLeft;
        // Show 2 context characters of the line when moving to it
        var twoCharsWidth = 2 * this.layerConfig.characterWidth;

        if (newLeft - twoCharsWidth < currentLeft) {
            newLeft -= twoCharsWidth;
            if (newLeft < this.$padding + twoCharsWidth) {
                newLeft = -this.scrollMargin.left;
            }
            this.session.setScrollLeft(newLeft);
        } else {
            newLeft += twoCharsWidth;
            if (currentLeft + this.$size.scrollerWidth < newLeft + this.characterWidth) {
                this.session.setScrollLeft(Math.round(newLeft + this.characterWidth - this.$size.scrollerWidth));
            } else if (currentLeft <= this.$padding && newLeft - currentLeft < this.characterWidth) {
                this.session.setScrollLeft(0);
            }
        }
    }

    /**
     * {:EditSession.getScrollTop}
     * @related EditSession.getScrollTop
     * @returns {Number}
     **/
    getScrollTop() {
        return this.session.getScrollTop();
    }

    /**
     * {:EditSession.getScrollLeft}
     * @related EditSession.getScrollLeft
     * @returns {Number}
     **/
    getScrollLeft() {
        return this.session.getScrollLeft();
    }

    /**
     * Returns the first visible row, regardless of whether it's fully visible or not.
     * @returns {Number}
     **/
    getScrollTopRow() {
        return this.scrollTop / this.lineHeight;
    }

    /**
     * Returns the last visible row, regardless of whether it's fully visible or not.
     * @returns {Number}
     **/
    getScrollBottomRow() {
        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
    }

    /**
     * Gracefully scrolls from the top of the editor to the row indicated.
     * @param {Number} row A row id
     *
     * @related EditSession.setScrollTop
     **/
    scrollToRow(row) {
        this.session.setScrollTop(row * this.lineHeight);
    }

    /**
     *
     * @param {Point} cursor
     * @param {number} [alignment]
     * @returns {number}
     */
    alignCursor(cursor, alignment) {
        if (typeof cursor == "number")
            cursor = {row: cursor, column: 0};

        var pos = this.$cursorLayer.getPixelPosition(cursor);
        var h = this.$size.scrollerHeight - this.lineHeight;
        var offset = pos.top - h * (alignment || 0);

        this.session.setScrollTop(offset);
        return offset;
    }

    /**
     *
     * @param {number} fromValue
     * @param {number} toValue
     * @returns {*[]}
     */
    $calcSteps(fromValue, toValue){
        var i = 0;
        var l = this.STEPS;
        var steps = [];

        var func  = function(t, x_min, dx) {
            return dx * (Math.pow(t - 1, 3) + 1) + x_min;
        };

        for (i = 0; i < l; ++i)
            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));

        return steps;
    }

    /**
     * Gracefully scrolls the editor to the row indicated.
     * @param {Number} line A line number
     * @param {Boolean} center If `true`, centers the editor the to indicated line
     * @param {Boolean} animate If `true` animates scrolling
     * @param {() => void} [callback] Function to be called after the animation has finished

     **/
    scrollToLine(line, center, animate, callback) {
        var pos = this.$cursorLayer.getPixelPosition({row: line, column: 0});
        var offset = pos.top;
        if (center)
            offset -= this.$size.scrollerHeight / 2;

        var initialScroll = this.scrollTop;
        this.session.setScrollTop(offset);
        if (animate !== false)
            this.animateScrolling(initialScroll, callback);
    }

    /**
     *
     * @param fromValue
     * @param [callback]

     */
    animateScrolling(fromValue, callback) {
        var toValue = this.scrollTop;
        if (!this.$animatedScroll)
            return;
        var _self = this;

        if (fromValue == toValue)
            return;

        if (this.$scrollAnimation) {
            var oldSteps = this.$scrollAnimation.steps;
            if (oldSteps.length) {
                fromValue = oldSteps[0];
                if (fromValue == toValue)
                    return;
            }
        }

        var steps = _self.$calcSteps(fromValue, toValue);
        this.$scrollAnimation = {from: fromValue, to: toValue, steps: steps};

        clearInterval(this.$timer);

        _self.session.setScrollTop(steps.shift());
        // trick session to think it's already scrolled to not loose toValue
        _self.session.$scrollTop = toValue;

        function endAnimation() {
            // @ts-ignore
            _self.$timer = clearInterval(_self.$timer);
            _self.$scrollAnimation = null;
            _self.$stopAnimation = false;
            callback && callback();
        }

        this.$timer = setInterval(function() {
            if (_self.$stopAnimation) {
                endAnimation();
                return;
            }

            if (!_self.session)
                return clearInterval(_self.$timer);
            if (steps.length) {
                _self.session.setScrollTop(steps.shift());
                _self.session.$scrollTop = toValue;
            } else if (toValue != null) {
                _self.session.$scrollTop = -1;
                _self.session.setScrollTop(toValue);
                toValue = null;
            } else {
                // do this on separate step to not get spurious scroll event from scrollbar
                endAnimation();
            }
        }, 10);
    }

    /**
     * Scrolls the editor to the y pixel indicated.
     * @param {Number} scrollTop The position to scroll to
     **/
    scrollToY(scrollTop) {
        // after calling scrollBar.setScrollTop
        // scrollbar sends us event with same scrollTop. ignore it
        if (this.scrollTop !== scrollTop) {
            this.$loop.schedule(this.CHANGE_SCROLL);
            this.scrollTop = scrollTop;
        }
    }

    /**
     * Scrolls the editor across the x-axis to the pixel indicated.
     * @param {Number} scrollLeft The position to scroll to
     **/
    scrollToX(scrollLeft) {
        if (this.scrollLeft !== scrollLeft)
            this.scrollLeft = scrollLeft;
        this.$loop.schedule(this.CHANGE_H_SCROLL);
    }

    /**
     * Scrolls the editor across both x- and y-axes.
     * @param {Number} x The x value to scroll to
     * @param {Number} y The y value to scroll to
     **/
    scrollTo(x, y) {
        this.session.setScrollTop(y);
        this.session.setScrollLeft(x);
    }

    /**
     * Scrolls the editor across both x- and y-axes.
     * @param {Number} deltaX The x value to scroll by
     * @param {Number} deltaY The y value to scroll by
     **/
    scrollBy(deltaX, deltaY) {
        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
    }

    /**
     * Returns `true` if you can still scroll by either parameter; in other words, you haven't reached the end of the file or line.
     * @param {Number} deltaX The x value to scroll by
     * @param {Number} deltaY The y value to scroll by
     *
     * @returns {Boolean}
     **/
    isScrollableBy(deltaX, deltaY) {
        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
           return true;
        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight
            - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
           return true;
        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
            return true;
        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth
            - this.layerConfig.width < -1 + this.scrollMargin.right)
           return true;
    }

    /**
     *
     * @param {number} x
     * @param {number} y
     * @returns {import("../ace-internal").Ace.ScreenCoordinates}

     */
    pixelToScreenCoordinates(x, y) {
        var canvasPos;
        if (this.$hasCssTransforms) {
            canvasPos = {top:0, left: 0};
            var p = this.$fontMetrics.transformCoordinates([x, y]);
            x = p[1] - this.gutterWidth - this.margin.left;
            y = p[0];
        } else {
            canvasPos = this.scroller.getBoundingClientRect();
        }

        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
        var offset = offsetX / this.characterWidth;
        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);

        return {row: row, column: col, side: offset - col > 0 ? 1 : -1, offsetX:  offsetX};
    }

    /**
     *
     * @param {number} x
     * @param {number} y
     * @returns {Point}

     */
    screenToTextCoordinates(x, y) {
        var canvasPos;
        if (this.$hasCssTransforms) {
            canvasPos = {top:0, left: 0};
            var p = this.$fontMetrics.transformCoordinates([x, y]);
            x = p[1] - this.gutterWidth - this.margin.left;
            y = p[0];
        } else {
            canvasPos = this.scroller.getBoundingClientRect();
        }

        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
        var offset = offsetX / this.characterWidth;
        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);

        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);

        return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);
    }

    /**
     * Returns an object containing the `pageX` and `pageY` coordinates of the document position.
     * @param {Number} row The document row position
     * @param {Number} column The document column position
     *
     * @returns {{ pageX: number, pageY: number}}
     **/
    textToScreenCoordinates(row, column) {
        var canvasPos = this.scroller.getBoundingClientRect();
        var pos = this.session.documentToScreenPosition(row, column);

        var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row)
             ? this.session.$bidiHandler.getPosLeft(pos.column)
             : Math.round(pos.column * this.characterWidth));

        var y = pos.row * this.lineHeight;

        return {
            pageX: canvasPos.left + x - this.scrollLeft,
            pageY: canvasPos.top + y - this.scrollTop
        };
    }

    /**
     *
     * Focuses the current container.
     **/
    visualizeFocus() {
        dom.addCssClass(this.container, "ace_focus");
    }

    /**
     *
     * Blurs the current container.
     **/
    visualizeBlur() {
        dom.removeCssClass(this.container, "ace_focus");
    }

    /**
     * @param {Object} composition

     **/
    showComposition(composition) {
        this.$composition = composition;
        if (!composition.cssText) {
            composition.cssText = this.textarea.style.cssText;
        }
        if (composition.useTextareaForIME == undefined)
            composition.useTextareaForIME = this.$useTextareaForIME;

        if (this.$useTextareaForIME) {
            dom.addCssClass(this.textarea, "ace_composition");
            this.textarea.style.cssText = "";
            this.$moveTextAreaToCursor();
            this.$cursorLayer.element.style.display = "none";
        }
        else {
            composition.markerId = this.session.addMarker(composition.markerRange, "ace_composition_marker", "text");
        }
    }

    /**
     * @param {String} text A string of text to use
     *
     * Sets the inner text of the current composition to `text`.

     **/
    setCompositionText(text) {
        var cursor = this.session.selection.cursor;
        this.addToken(text, "composition_placeholder", cursor.row, cursor.column);
        this.$moveTextAreaToCursor();
    }

    /**
     *
     * Hides the current composition.

     **/
    hideComposition() {
        if (!this.$composition)
            return;

        if (this.$composition.markerId)
            this.session.removeMarker(this.$composition.markerId);

        dom.removeCssClass(this.textarea, "ace_composition");
        this.textarea.style.cssText = this.$composition.cssText;
        var cursor = this.session.selection.cursor;
        this.removeExtraToken(cursor.row, cursor.column);
        this.$composition = null;
        this.$cursorLayer.element.style.display = "";
    }

    /**
     * @param {string} text
     * @param {Point} [position]
     */
    setGhostText(text, position) {
        var cursor = this.session.selection.cursor;
        var insertPosition = position || { row: cursor.row, column: cursor.column };

        this.removeGhostText();

        var textChunks = this.$calculateWrappedTextChunks(text, insertPosition);
        this.addToken(textChunks[0].text, "ghost_text", insertPosition.row, insertPosition.column);

        this.$ghostText = {
            text: text,
            position: {
                row: insertPosition.row,
                column: insertPosition. column
            }
        };

        var widgetDiv = dom.createElement("div");
        if (textChunks.length > 1) {
            // If there are tokens to the right of the cursor, hide those.
            var hiddenTokens = this.hideTokensAfterPosition(insertPosition.row, insertPosition.column);

            var lastLineDiv;
            textChunks.slice(1).forEach(el => {
                var chunkDiv = dom.createElement("div");
                var chunkSpan = dom.createElement("span");
                chunkSpan.className = "ace_ghost_text";

                // If the line is wider than the viewport, wrap the line
                if (el.wrapped) chunkDiv.className = "ghost_text_line_wrapped";

                // If a given line doesn't have text (e.g. it's a line of whitespace), set a space as the
                // textcontent so that browsers render the empty line div.
                if (el.text.length === 0) el.text = " ";

                chunkSpan.appendChild(dom.createTextNode(el.text));
                chunkDiv.appendChild(chunkSpan);
                widgetDiv.appendChild(chunkDiv);

                // Overwrite lastLineDiv every iteration so at the end it points to
                // the last added element.
                lastLineDiv = chunkDiv;
            });

            // Add the hidden tokens to the last line of the ghost text.
            hiddenTokens.forEach(token => {
                var element = dom.createElement("span");
                if (!isTextToken(token.type)) element.className = "ace_" + token.type.replace(/\./g, " ace_");
                element.appendChild(dom.createTextNode(token.value));
                lastLineDiv.appendChild(element);
            });

            this.$ghostTextWidget = {
                el: widgetDiv,
                row: insertPosition.row,
                column: insertPosition.column,
                className: "ace_ghost_text_container"
            };
            this.session.widgetManager.addLineWidget(this.$ghostTextWidget);

            // Check wether the line widget fits in the part of the screen currently in view
            var pixelPosition = this.$cursorLayer.getPixelPosition(insertPosition, true);
            var el = this.container;
            var height = el.getBoundingClientRect().height;
            var ghostTextHeight = textChunks.length * this.lineHeight;
            var fitsY = ghostTextHeight < (height - pixelPosition.top);

            // If it fits, no action needed
            if (fitsY) return;

            // If it can fully fit in the screen, scroll down until it fits on the screen
            // if it cannot fully fit, scroll so that the row with the cursor
            // is at the top of the screen.
            if (ghostTextHeight < height) {
                this.scrollBy(0, (textChunks.length - 1) * this.lineHeight);
            } else {
                this.scrollToRow(insertPosition.row);
            }
        }

    }

    /**
     * Calculates and organizes text into wrapped chunks. Initially splits the text by newline characters,
     * then further processes each line based on display tokens and session settings for tab size and wrapping limits.
     *
     * @param {string} text
     * @param {Point} position
     * @return {{text: string, wrapped: boolean}[]}
     */
    $calculateWrappedTextChunks(text, position) {
        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
        var limit = Math.floor(availableWidth / this.characterWidth) - 2;
        limit = limit <= 0 ? 60 : limit; // this is a hack to prevent the editor from crashing when the window is too small

        var textLines = text.split(/\r?\n/);
        var textChunks = [];
        for (var i = 0; i < textLines.length; i++) {
            var displayTokens = this.session.$getDisplayTokens(textLines[i], position.column);
            var wrapSplits = this.session.$computeWrapSplits(displayTokens, limit, this.session.$tabSize);

            if (wrapSplits.length > 0) {
                var start = 0;
                wrapSplits.push(textLines[i].length);

                for (var j = 0; j < wrapSplits.length; j++) {
                    let textSlice = textLines[i].slice(start, wrapSplits[j]);
                    textChunks.push({text: textSlice, wrapped: true});
                    start = wrapSplits[j];
                }
            }
            else {
                textChunks.push({text: textLines[i], wrapped: false});
            }
        }
        return textChunks;
    }

    removeGhostText() {
        if (!this.$ghostText) return;

        var position = this.$ghostText.position;
        this.removeExtraToken(position.row, position.column);
        if (this.$ghostTextWidget) {
            this.session.widgetManager.removeLineWidget(this.$ghostTextWidget);
            this.$ghostTextWidget = null;
        }
        this.$ghostText = null;
    }

    /**
     * @param {string} text
     * @param {string} type
     * @param {number} row
     * @param {number} [column]
     */
    addToken(text, type, row, column) {
        var session = this.session;
        session.bgTokenizer.lines[row] = null;
        var newToken = {type: type, value: text};
        var tokens = session.getTokens(row);
        if (column == null || !tokens.length) {
            tokens.push(newToken);
        } else {
            var l = 0;
            for (var i =0; i < tokens.length; i++) {
                var token = tokens[i];
                l += token.value.length;
                if (column <= l) {
                    var diff = token.value.length - (l - column);
                    var before = token.value.slice(0, diff);
                    var after = token.value.slice(diff);

                    tokens.splice(i, 1, {type: token.type, value: before},  newToken,  {type: token.type, value: after});
                    break;
                }
            }
        }
        this.updateLines(row, row);
    }

    // Hide all non-ghost-text tokens to the right of a given position.
    hideTokensAfterPosition(row, column) {
        var tokens = this.session.getTokens(row);
        var l = 0;
        var hasPassedCursor = false;
        var hiddenTokens = [];
        // Loop over all tokens and track at what position in the line they end.
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            l += token.value.length;

            if (token.type === "ghost_text") continue;

            // If we've already passed the current cursor position, mark all of them as hidden.
            if (hasPassedCursor) {
                hiddenTokens.push({type: token.type, value: token.value});
                token.type = "hidden_token";
                continue;
            }
            // We call this method after we call addToken, so we are guaranteed a new token starts at the cursor position.
            // Once we reached that point in the loop, flip the flag.
            if (l === column) {
                hasPassedCursor = true;
            }
        }
        this.updateLines(row, row);
        return hiddenTokens;
    }

    removeExtraToken(row, column) {
        this.session.bgTokenizer.lines[row] = null;
        this.updateLines(row, row);
    }

    /**
     * [Sets a new theme for the editor. `theme` should exist, and be a directory path, like `ace/theme/textmate`.]{: #VirtualRenderer.setTheme}
     * @param {String | Theme} [theme] The path to a theme
     * @param {() => void} [cb] optional callback

     **/
    setTheme(theme, cb) {
        var _self = this;
        /**@type {any}*/
        this.$themeId = theme;
        _self._dispatchEvent('themeChange',{theme:theme});

        if (!theme || typeof theme == "string") {
            // @ts-ignore
            var moduleName = theme || this.$options.theme.initialValue;
            config.loadModule(["theme", moduleName], afterLoad);
        } else {
            afterLoad(theme);
        }

        /**
         * @param {Theme} module
         */
        function afterLoad(module) {
            if (_self.$themeId != theme)
                return cb && cb();
            if (!module || !module.cssClass)
                throw new Error("couldn't load module " + theme + " or it didn't call define");
            if (module.$id)
                _self.$themeId = module.$id;
            dom.importCssString(
                module.cssText,
                module.cssClass,
                _self.container
            );
            if (_self.theme)
                dom.removeCssClass(_self.container, _self.theme.cssClass);
            /**@type {any}*/
            var padding = "padding" in module ? module.padding
                : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
            if (_self.$padding && padding != _self.$padding)
                _self.setPadding(padding);

            if (_self.$gutterLayer) {
                var showGutterCursor = module["$showGutterCursorMarker"];
                if (showGutterCursor && !_self.$gutterLayer.$showCursorMarker) {
                    _self.$gutterLayer.$showCursorMarker = "theme";
                } else if (!showGutterCursor && _self.$gutterLayer.$showCursorMarker == "theme") {
                    _self.$gutterLayer.$showCursorMarker = null;
                }
            }

            // this is kept only for backwards compatibility
            _self.$theme = module.cssClass;

            _self.theme = module;
            dom.addCssClass(_self.container, module.cssClass);
            dom.setCssClass(_self.container, "ace_dark", module.isDark);

            // force re-measure of the gutter width
            if (_self.$size) {
                _self.$size.width = 0;
                _self.$updateSizeAsync();
            }

            _self._dispatchEvent('themeLoaded', {theme:module});
            cb && cb();

            // workaround for safari not redrawing the editor
            // https://github.com/ajaxorg/ace/issues/5569
            if (useragent.isSafari && _self.scroller) {
                _self.scroller.style.background = "red";
                _self.scroller.style.background = "";
            }
        }
    }

    /**
     * [Returns the path of the current theme.]{: #VirtualRenderer.getTheme}
     * @returns {String}
     **/
    getTheme() {
        return this.$themeId;
    }

    // Methods allows to add / remove CSS classnames to the editor element.
    // This feature can be used by plug-ins to provide a visual indication of
    // a certain mode that editor is in.

    /**
     * [Adds a new class, `style`, to the editor.]{: #VirtualRenderer.setStyle}
     * @param {String} style A class name
     * @param {boolean}[include]
     **/
    setStyle(style, include) {
        dom.setCssClass(this.container, style, include !== false);
    }

    /**
     * [Removes the class `style` from the editor.]{: #VirtualRenderer.unsetStyle}
     * @param {String} style A class name
     *
     **/
    unsetStyle(style) {
        dom.removeCssClass(this.container, style);
    }

    /**
     * @param {string} style
     */
    setCursorStyle(style) {
        dom.setStyle(this.scroller.style, "cursor", style);
    }

    /**
     * @param {String} cursorStyle A css cursor style
     **/
    setMouseCursor(cursorStyle) {
        dom.setStyle(this.scroller.style, "cursor", cursorStyle);
    }

    attachToShadowRoot() {
        dom.importCssString(editorCss, "ace_editor.css", this.container);
    }

    /**
     * Destroys the text and cursor layers for this renderer.

     **/
    destroy() {
        this.freeze();
        this.$fontMetrics.destroy();
        this.$cursorLayer.destroy();
        this.removeAllListeners();
        this.container.textContent = "";
        this.setOption("useResizeObserver", false);
    }

    /**
     *
     * @param {boolean} [val]
     */
    $updateCustomScrollbar(val) {
        var _self = this;
        this.$horizScroll = this.$vScroll = null;
        this.scrollBarV.element.remove();
        this.scrollBarH.element.remove();
        if (val === true) {
            /**@type {import("../ace-internal").Ace.VScrollbar}*/
            this.scrollBarV = new VScrollBarCustom(this.container, this);
            /**@type {import("../ace-internal").Ace.HScrollbar}*/
            this.scrollBarH = new HScrollBarCustom(this.container, this);
            this.scrollBarV.setHeight(this.$size.scrollerHeight);
            this.scrollBarH.setWidth(this.$size.scrollerWidth);

            this.scrollBarV.addEventListener("scroll", function (e) {
                if (!_self.$scrollAnimation) _self.session.setScrollTop(e.data - _self.scrollMargin.top);
            });
            this.scrollBarH.addEventListener("scroll", function (e) {
                if (!_self.$scrollAnimation) _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
            });
            if (!this.$scrollDecorator) {
                this.$scrollDecorator = new Decorator(this.scrollBarV, this);
                this.$scrollDecorator.$updateDecorators();
            } else {
                this.$scrollDecorator.setScrollBarV(this.scrollBarV);
                this.$scrollDecorator.$updateDecorators();
            }
        }
        else {
            this.scrollBarV = new VScrollBar(this.container, this);
            this.scrollBarH = new HScrollBar(this.container, this);
            this.scrollBarV.addEventListener("scroll", function (e) {
                if (!_self.$scrollAnimation) _self.session.setScrollTop(e.data - _self.scrollMargin.top);
            });
            this.scrollBarH.addEventListener("scroll", function (e) {
                if (!_self.$scrollAnimation) _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
            });
        }
    }

    /**

     */
    $addResizeObserver() {
        if (!window.ResizeObserver || this.$resizeObserver) return;
        var self = this;
        this.$resizeTimer = lang.delayedCall(function() {
            if (!self.destroyed)  self.onResize();
        }, 50);
        this.$resizeObserver = new window.ResizeObserver(function(e) {
            var w = e[0].contentRect.width;
            var h = e[0].contentRect.height;
            if (
                Math.abs(self.$size.width - w) > 1
                || Math.abs(self.$size.height - h) > 1
            ) {
                self.$resizeTimer.delay();
            } else {
                self.$resizeTimer.cancel();
            }
        });
        this.$resizeObserver.observe(this.container);
    }

}

VirtualRenderer.prototype.CHANGE_CURSOR = 1;
VirtualRenderer.prototype.CHANGE_MARKER = 2;
VirtualRenderer.prototype.CHANGE_GUTTER = 4;
VirtualRenderer.prototype.CHANGE_SCROLL = 8;
VirtualRenderer.prototype.CHANGE_LINES = 16;
VirtualRenderer.prototype.CHANGE_TEXT = 32;
VirtualRenderer.prototype.CHANGE_SIZE = 64;
VirtualRenderer.prototype.CHANGE_MARKER_BACK = 128;
VirtualRenderer.prototype.CHANGE_MARKER_FRONT = 256;
VirtualRenderer.prototype.CHANGE_FULL = 512;
VirtualRenderer.prototype.CHANGE_H_SCROLL = 1024;
VirtualRenderer.prototype.$changes = 0;
VirtualRenderer.prototype.$padding = null;
VirtualRenderer.prototype.$frozen = false;
VirtualRenderer.prototype.STEPS = 8;

oop.implement(VirtualRenderer.prototype, EventEmitter);

config.defineOptions(VirtualRenderer.prototype, "renderer", {
    useResizeObserver: {
        /**
         * @param value
         * @this{VirtualRenderer}
         */
        set: function(value) {
            if (!value && this.$resizeObserver) {
                this.$resizeObserver.disconnect();
                this.$resizeTimer.cancel();
                this.$resizeTimer = this.$resizeObserver = null;
            } else if (value && !this.$resizeObserver) {
                this.$addResizeObserver();
            }
        }
    },
    animatedScroll: {initialValue: false},
    showInvisibles: {
        set: function(value) {
            if (this.$textLayer.setShowInvisibles(value))
                this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: false
    },
    showPrintMargin: {
        set: function() { this.$updatePrintMargin(); },
        initialValue: true
    },
    printMarginColumn: {
        set: function() { this.$updatePrintMargin(); },
        initialValue: 80
    },
    printMargin: {
        /**
         * @param val
         * @this{VirtualRenderer}
         */
        set: function(val) {
            if (typeof val == "number")
                this.$printMarginColumn = val;
            this.$showPrintMargin = !!val;
            this.$updatePrintMargin();
        },
        get: function() {
            return this.$showPrintMargin && this.$printMarginColumn;
        }
    },
    showGutter: {
        set: function(show){
            this.$gutter.style.display = show ? "block" : "none";
            this.$loop.schedule(this.CHANGE_FULL);
            this.onGutterResize();
        },
        initialValue: true
    },
    useSvgGutterIcons: {
        set: function(value){
            this.$gutterLayer.$useSvgGutterIcons = value;
        },
        initialValue: false
    },
    showFoldedAnnotations: {
        set: function(value){
            this.$gutterLayer.$showFoldedAnnotations = value;
        },
        initialValue: false
    },
    fadeFoldWidgets: {
        set: function(show) {
            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
        },
        initialValue: false
    },
    showFoldWidgets: {
        set: function(show) {
            this.$gutterLayer.setShowFoldWidgets(show);
            this.$loop.schedule(this.CHANGE_GUTTER);
        },
        initialValue: true
    },
    displayIndentGuides: {
        set: function(show) {
            if (this.$textLayer.setDisplayIndentGuides(show))
                this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: true
    },
    highlightIndentGuides: {
        set: function (show) {
            if (this.$textLayer.setHighlightIndentGuides(show) == true) {
                this.$textLayer.$highlightIndentGuide();
            }
            else {
                this.$textLayer.$clearActiveIndentGuide(this.$textLayer.$lines.cells);
            }
        },
        initialValue: true
    },
    highlightGutterLine: {
        set: function(shouldHighlight) {
            this.$gutterLayer.setHighlightGutterLine(shouldHighlight);
            this.$loop.schedule(this.CHANGE_GUTTER);
        },
        initialValue: true
    },
    hScrollBarAlwaysVisible: {
        set: function(val) {
            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
    },
    vScrollBarAlwaysVisible: {
        set: function(val) {
            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
    },
    fontSize: {
        set: function(size) {
            if (typeof size == "number")
                size = size + "px";
            this.container.style.fontSize = size;
            this.updateFontSize();
        },
        initialValue: 12
    },
    fontFamily: {
        set: function(name) {
            this.container.style.fontFamily = name;
            this.updateFontSize();
        }
    },
    maxLines: {
        set: function(val) {
            this.updateFull();
        }
    },
    minLines: {
        /**
         * @param val
         * @this{VirtualRenderer}
         */
        set: function(val) {
            if (!(this.$minLines < 0x1ffffffffffff))
                this.$minLines = 0;
            this.updateFull();
        }
    },
    maxPixelHeight: {
        set: function(val) {
            this.updateFull();
        },
        initialValue: 0
    },
    scrollPastEnd: {
        /**
         * @param val
         * @this{VirtualRenderer}
         */
        set: function(val) {
            val = +val || 0;
            if (this.$scrollPastEnd == val)
                return;
            this.$scrollPastEnd = val;
            this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: 0,
        handlesSet: true
    },
    fixedWidthGutter: {
        set: function(val) {
            this.$gutterLayer.$fixedWidth = !!val;
            this.$loop.schedule(this.CHANGE_GUTTER);
        }
    },
    customScrollbar: {
        set: function(val) {
            this.$updateCustomScrollbar(val);
        },
        initialValue: false
    },
    theme: {
        set: function(val) { this.setTheme(val); },
        get: function() { return this.$themeId || this.theme; },
        initialValue: "./theme/textmate",
        handlesSet: true
    },
    hasCssTransforms: {
    },
    useTextareaForIME: {
        initialValue: !useragent.isMobile && !useragent.isIE
    }
});

exports.VirtualRenderer = VirtualRenderer;


/***/ }),

/***/ 21604:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var lang = __webpack_require__(39955);
var config = __webpack_require__(76321);
var Range = (__webpack_require__(91902)/* .Range */ .Q);

function bindKey(win, mac) {
    return {win: win, mac: mac};
}

/*
    multiSelectAction: "forEach"|"forEachLine"|function|undefined,
    scrollIntoView: true|"cursor"|"center"|"selectionPart"
*/
/**@type {import("../../ace-internal").Ace.Command[]} */
exports.P = [{
    name: "showSettingsMenu",
    description: "Show settings menu",
    bindKey: bindKey("Ctrl-,", "Command-,"),
    exec: function(editor) {
        config.loadModule("ace/ext/settings_menu", function(module) {
            module.init(editor);
            editor.showSettingsMenu();
        });
    },
    readOnly: true
}, {
    name: "goToNextError",
    description: "Go to next error",
    bindKey: bindKey("Alt-E", "F4"),
    exec: function(editor) {
        config.loadModule("ace/ext/error_marker", function(module) {
            module.showErrorMarker(editor, 1);
        });
    },
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "goToPreviousError",
    description: "Go to previous error",
    bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
    exec: function(editor) {
        config.loadModule("ace/ext/error_marker", function(module) {
            module.showErrorMarker(editor, -1);
        });
    },
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "selectall",
    description: "Select all",
    bindKey: bindKey("Ctrl-A", "Command-A"),
    exec: function(editor) { editor.selectAll(); },
    readOnly: true
}, {
    name: "centerselection",
    description: "Center selection",
    bindKey: bindKey(null, "Ctrl-L"),
    exec: function(editor) { editor.centerSelection(); },
    readOnly: true
}, {
    name: "gotoline",
    description: "Go to line...",
    bindKey: bindKey("Ctrl-L", "Command-L"),
    exec: function(editor, line) {
        // backwards compatibility
        if (typeof line === "number" && !isNaN(line))
            editor.gotoLine(line);
        editor.prompt({ $type: "gotoLine" });
    },
    readOnly: true
}, {
    name: "fold",
    bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
    exec: function(editor) { editor.session.toggleFold(false); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "unfold",
    bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
    exec: function(editor) { editor.session.toggleFold(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "toggleFoldWidget",
    description: "Toggle fold widget",
    bindKey: bindKey("F2", "F2"),
    exec: function(editor) { editor.session.toggleFoldWidget(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "toggleParentFoldWidget",
    description: "Toggle parent fold widget",
    bindKey: bindKey("Alt-F2", "Alt-F2"),
    exec: function(editor) { editor.session.toggleFoldWidget(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "foldall",
    description: "Fold all",
    bindKey: bindKey(null, "Ctrl-Command-Option-0"),
    exec: function(editor) { editor.session.foldAll(); },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "foldAllComments",
    description: "Fold all comments",
    bindKey: bindKey(null, "Ctrl-Command-Option-0"),
    exec: function(editor) { editor.session.foldAllComments(); },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "foldOther",
    description: "Fold other",
    bindKey: bindKey("Alt-0", "Command-Option-0"),
    exec: function(editor) { 
        editor.session.foldAll();
        editor.session.unfold(editor.selection.getAllRanges());
    },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "unfoldall",
    description: "Unfold all",
    bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
    exec: function(editor) { editor.session.unfold(); },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "findnext",
    description: "Find next",
    bindKey: bindKey("Ctrl-K", "Command-G"),
    exec: function(editor) { editor.findNext(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "findprevious",
    description: "Find previous",
    bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
    exec: function(editor) { editor.findPrevious(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "selectOrFindNext",
    description: "Select or find next",
    bindKey: bindKey("Alt-K", "Ctrl-G"),
    exec: function(editor) {
        if (editor.selection.isEmpty())
            editor.selection.selectWord();
        else
            editor.findNext(); 
    },
    readOnly: true
}, {
    name: "selectOrFindPrevious",
    description: "Select or find previous",
    bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
    exec: function(editor) { 
        if (editor.selection.isEmpty())
            editor.selection.selectWord();
        else
            editor.findPrevious();
    },
    readOnly: true
}, {
    name: "find",
    description: "Find",
    bindKey: bindKey("Ctrl-F", "Command-F"),
    exec: function(editor) {
        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor);});
    },
    readOnly: true
}, {
    name: "overwrite",
    description: "Overwrite",
    bindKey: "Insert",
    exec: function(editor) { editor.toggleOverwrite(); },
    readOnly: true
}, {
    name: "selecttostart",
    description: "Select to start",
    bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
    exec: function(editor) { editor.getSelection().selectFileStart(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "gotostart",
    description: "Go to start",
    bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
    exec: function(editor) { editor.navigateFileStart(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "selectup",
    description: "Select up",
    bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
    exec: function(editor) { editor.getSelection().selectUp(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "golineup",
    description: "Go line up",
    bindKey: bindKey("Up", "Up|Ctrl-P"),
    exec: function(editor, args) { editor.navigateUp(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttoend",
    description: "Select to end",
    bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
    exec: function(editor) { editor.getSelection().selectFileEnd(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "gotoend",
    description: "Go to end",
    bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
    exec: function(editor) { editor.navigateFileEnd(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "selectdown",
    description: "Select down",
    bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
    exec: function(editor) { editor.getSelection().selectDown(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "golinedown",
    description: "Go line down",
    bindKey: bindKey("Down", "Down|Ctrl-N"),
    exec: function(editor, args) { editor.navigateDown(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectwordleft",
    description: "Select word left",
    bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
    exec: function(editor) { editor.getSelection().selectWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotowordleft",
    description: "Go to word left",
    bindKey: bindKey("Ctrl-Left", "Option-Left"),
    exec: function(editor) { editor.navigateWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttolinestart",
    description: "Select to line start",
    bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
    exec: function(editor) { editor.getSelection().selectLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotolinestart",
    description: "Go to line start",
    bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
    exec: function(editor) { editor.navigateLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectleft",
    description: "Select left",
    bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
    exec: function(editor) { editor.getSelection().selectLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotoleft",
    description: "Go to left",
    bindKey: bindKey("Left", "Left|Ctrl-B"),
    exec: function(editor, args) { editor.navigateLeft(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectwordright",
    description: "Select word right",
    bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
    exec: function(editor) { editor.getSelection().selectWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotowordright",
    description: "Go to word right",
    bindKey: bindKey("Ctrl-Right", "Option-Right"),
    exec: function(editor) { editor.navigateWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttolineend",
    description: "Select to line end",
    bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
    exec: function(editor) { editor.getSelection().selectLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotolineend",
    description: "Go to line end",
    bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
    exec: function(editor) { editor.navigateLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectright",
    description: "Select right",
    bindKey: bindKey("Shift-Right", "Shift-Right"),
    exec: function(editor) { editor.getSelection().selectRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotoright",
    description: "Go to right",
    bindKey: bindKey("Right", "Right|Ctrl-F"),
    exec: function(editor, args) { editor.navigateRight(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectpagedown",
    description: "Select page down",
    bindKey: "Shift-PageDown",
    exec: function(editor) { editor.selectPageDown(); },
    readOnly: true
}, {
    name: "pagedown",
    description: "Page down",
    bindKey: bindKey(null, "Option-PageDown"),
    exec: function(editor) { editor.scrollPageDown(); },
    readOnly: true
}, {
    name: "gotopagedown",
    description: "Go to page down",
    bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
    exec: function(editor) { editor.gotoPageDown(); },
    readOnly: true
}, {
    name: "selectpageup",
    description: "Select page up",
    bindKey: "Shift-PageUp",
    exec: function(editor) { editor.selectPageUp(); },
    readOnly: true
}, {
    name: "pageup",
    description: "Page up",
    bindKey: bindKey(null, "Option-PageUp"),
    exec: function(editor) { editor.scrollPageUp(); },
    readOnly: true
}, {
    name: "gotopageup",
    description: "Go to page up",
    bindKey: "PageUp",
    exec: function(editor) { editor.gotoPageUp(); },
    readOnly: true
}, {
    name: "scrollup",
    description: "Scroll up",
    bindKey: bindKey("Ctrl-Up", null),
    exec: function(e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },
    readOnly: true
}, {
    name: "scrolldown",
    description: "Scroll down",
    bindKey: bindKey("Ctrl-Down", null),
    exec: function(e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },
    readOnly: true
}, {
    name: "selectlinestart",
    description: "Select line start",
    bindKey: "Shift-Home",
    exec: function(editor) { editor.getSelection().selectLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectlineend",
    description: "Select line end",
    bindKey: "Shift-End",
    exec: function(editor) { editor.getSelection().selectLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "togglerecording",
    description: "Toggle recording",
    bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
    exec: function(editor) { editor.commands.toggleRecording(editor); },
    readOnly: true
}, {
    name: "replaymacro",
    description: "Replay macro",
    bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
    exec: function(editor) { editor.commands.replay(editor); },
    readOnly: true
}, {
    name: "jumptomatching",
    description: "Jump to matching",
    bindKey: bindKey("Ctrl-\\|Ctrl-P", "Command-\\"),
    exec: function(editor) { editor.jumpToMatching(); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "selecttomatching",
    description: "Select to matching",
    bindKey: bindKey("Ctrl-Shift-\\|Ctrl-Shift-P", "Command-Shift-\\"),
    exec: function(editor) { editor.jumpToMatching(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "expandToMatching",
    description: "Expand to matching",
    bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
    exec: function(editor) { editor.jumpToMatching(true, true); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "passKeysToBrowser",
    description: "Pass keys to browser",
    bindKey: bindKey(null, null),
    exec: function() {},
    passEvent: true,
    readOnly: true
}, {
    name: "copy",
    description: "Copy",
    exec: function(editor) {
        // placeholder for replay macro
    },
    readOnly: true
},

// commands disabled in readOnly mode
{
    name: "cut",
    description: "Cut",
    exec: function(editor) {
        var cutLine = editor.$copyWithEmptySelection && editor.selection.isEmpty();
        var range = cutLine ? editor.selection.getLineRange() : editor.selection.getRange();
        editor._emit("cut", range);

        if (!range.isEmpty())
            editor.session.remove(range);
        editor.clearSelection();
    },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "paste",
    description: "Paste",
    exec: function(editor, args) {
        editor.$handlePaste(args);
    },
    scrollIntoView: "cursor"
}, {
    name: "removeline",
    description: "Remove line",
    bindKey: bindKey("Ctrl-D", "Command-D"),
    exec: function(editor) { editor.removeLines(); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEachLine"
}, {
    name: "duplicateSelection",
    description: "Duplicate selection",
    bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
    exec: function(editor) { editor.duplicateSelection(); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "sortlines",
    description: "Sort lines",
    bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
    exec: function(editor) { editor.sortLines(); },
    scrollIntoView: "selection",
    multiSelectAction: "forEachLine"
}, {
    name: "togglecomment",
    description: "Toggle comment",
    bindKey: bindKey("Ctrl-/", "Command-/"),
    exec: function(editor) { editor.toggleCommentLines(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "toggleBlockComment",
    description: "Toggle block comment",
    bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
    exec: function(editor) { editor.toggleBlockComment(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "modifyNumberUp",
    description: "Modify number up",
    bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
    exec: function(editor) { editor.modifyNumber(1); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "modifyNumberDown",
    description: "Modify number down",
    bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
    exec: function(editor) { editor.modifyNumber(-1); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "replace",
    description: "Replace",
    bindKey: bindKey("Ctrl-H", "Command-Option-F"),
    exec: function(editor) {
        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor, true);});
    }
}, {
    name: "undo",
    description: "Undo",
    bindKey: bindKey("Ctrl-Z", "Command-Z"),
    exec: function(editor) { editor.undo(); }
}, {
    name: "redo",
    description: "Redo",
    bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
    exec: function(editor) { editor.redo(); }
}, {
    name: "copylinesup",
    description: "Copy lines up",
    bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
    exec: function(editor) { editor.copyLinesUp(); },
    scrollIntoView: "cursor"
}, {
    name: "movelinesup",
    description: "Move lines up",
    bindKey: bindKey("Alt-Up", "Option-Up"),
    exec: function(editor) { editor.moveLinesUp(); },
    scrollIntoView: "cursor"
}, {
    name: "copylinesdown",
    description: "Copy lines down",
    bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
    exec: function(editor) { editor.copyLinesDown(); },
    scrollIntoView: "cursor"
}, {
    name: "movelinesdown",
    description: "Move lines down",
    bindKey: bindKey("Alt-Down", "Option-Down"),
    exec: function(editor) { editor.moveLinesDown(); },
    scrollIntoView: "cursor"
}, {
    name: "del",
    description: "Delete",
    bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
    exec: function(editor) { editor.remove("right"); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "backspace",
    description: "Backspace",
    bindKey: bindKey(
        "Shift-Backspace|Backspace",
        "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"
    ),
    exec: function(editor) { editor.remove("left"); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "cut_or_delete",
    description: "Cut or delete",
    bindKey: bindKey("Shift-Delete", null),
    exec: function(editor) { 
        if (editor.selection.isEmpty()) {
            editor.remove("left");
        } else {
            return false;
        }
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removetolinestart",
    description: "Remove to line start",
    bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
    exec: function(editor) { editor.removeToLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removetolineend",
    description: "Remove to line end",
    bindKey: bindKey("Alt-Delete", "Ctrl-K|Command-Delete"),
    exec: function(editor) { editor.removeToLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removetolinestarthard",
    description: "Remove to line start hard",
    bindKey: bindKey("Ctrl-Shift-Backspace", null),
    exec: function(editor) {
        var range = editor.selection.getRange();
        range.start.column = 0;
        editor.session.remove(range);
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removetolineendhard",
    description: "Remove to line end hard",
    bindKey: bindKey("Ctrl-Shift-Delete", null),
    exec: function(editor) {
        var range = editor.selection.getRange();
        range.end.column = Number.MAX_VALUE;
        editor.session.remove(range);
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removewordleft",
    description: "Remove word left",
    bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
    exec: function(editor) { editor.removeWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removewordright",
    description: "Remove word right",
    bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
    exec: function(editor) { editor.removeWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "outdent",
    description: "Outdent",
    bindKey: bindKey("Shift-Tab", "Shift-Tab"),
    exec: function(editor) { editor.blockOutdent(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "indent",
    description: "Indent",
    bindKey: bindKey("Tab", "Tab"),
    exec: function(editor) { editor.indent(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "blockoutdent",
    description: "Block outdent",
    bindKey: bindKey("Ctrl-[", "Ctrl-["),
    exec: function(editor) { editor.blockOutdent(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "blockindent",
    description: "Block indent",
    bindKey: bindKey("Ctrl-]", "Ctrl-]"),
    exec: function(editor) { editor.blockIndent(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "insertstring",
    description: "Insert string",
    exec: function(editor, str) { editor.insert(str); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "inserttext",
    description: "Insert text",
    exec: function(editor, args) {
        editor.insert(lang.stringRepeat(args.text  || "", args.times || 1));
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "splitline",
    description: "Split line",
    bindKey: bindKey(null, "Ctrl-O"),
    exec: function(editor) { editor.splitLine(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "transposeletters",
    description: "Transpose letters",
    bindKey: bindKey("Alt-Shift-X", "Ctrl-T"),
    exec: function(editor) { editor.transposeLetters(); },
    multiSelectAction: function(editor) {editor.transposeSelections(1); },
    scrollIntoView: "cursor"
}, {
    name: "touppercase",
    description: "To uppercase",
    bindKey: bindKey("Ctrl-U", "Ctrl-U"),
    exec: function(editor) { editor.toUpperCase(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "tolowercase",
    description: "To lowercase",
    bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
    exec: function(editor) { editor.toLowerCase(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "autoindent",
    description: "Auto Indent",
    bindKey: bindKey(null, null),
    exec: function(editor) { editor.autoIndent(); },
    scrollIntoView: "animate"
}, {
    name: "expandtoline",
    description: "Expand to line",
    bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
    exec: function(editor) {
        var range = editor.selection.getRange();

        range.start.column = range.end.column = 0;
        range.end.row++;
        editor.selection.setRange(range, false);
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "openlink",
    bindKey: bindKey("Ctrl+F3", "F3"),
    exec: function(editor) { editor.openLink(); }
}, {
    name: "joinlines",
    description: "Join lines",
    bindKey: bindKey(null, null),
    exec: function(editor) {
        var isBackwards = editor.selection.isBackwards();
        var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
        var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
        var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
        var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
        var selectedCount = selectedText.replace(/\n\s*/, " ").length;
        var insertLine = editor.session.doc.getLine(selectionStart.row);

        for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
            var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
            if (curLine.length !== 0) {
                curLine = " " + curLine;
            }
            insertLine += curLine;
        }

        if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {
            // Don't insert a newline at the end of the document
            insertLine += editor.session.doc.getNewLineCharacter();
        }

        editor.clearSelection();
        editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);

        if (selectedCount > 0) {
            // Select the text that was previously selected
            editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
            editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
        } else {
            // If the joined line had something in it, start the cursor at that something
            firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;
            editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
        }
    },
    multiSelectAction: "forEach",
    readOnly: true
}, {
    name: "invertSelection",
    description: "Invert selection",
    bindKey: bindKey(null, null),
    exec: function(editor) {
        var endRow = editor.session.doc.getLength() - 1;
        var endCol = editor.session.doc.getLine(endRow).length;
        var ranges = editor.selection.rangeList.ranges;
        var newRanges = [];

        // If multiple selections don't exist, rangeList will return 0 so replace with single range
        if (ranges.length < 1) {
            ranges = [editor.selection.getRange()];
        }

        for (var i = 0; i < ranges.length; i++) {
            if (i == (ranges.length - 1)) {
                // The last selection must connect to the end of the document, unless it already does
                if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
                    newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
                }
            }

            if (i === 0) {
                // The first selection must connect to the start of the document, unless it already does
                if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
                    newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
                }
            } else {
                newRanges.push(new Range(ranges[i-1].end.row, ranges[i-1].end.column, ranges[i].start.row, ranges[i].start.column));
            }
        }

        editor.exitMultiSelectMode();
        editor.clearSelection();

        for(var i = 0; i < newRanges.length; i++) {
            editor.selection.addRange(newRanges[i], false);
        }
    },
    readOnly: true,
    scrollIntoView: "none"
}, {
    name: "addLineAfter",
    description: "Add new line after the current line",
    exec: function(editor) {
        editor.selection.clearSelection();
        editor.navigateLineEnd();
        editor.insert("\n");
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "addLineBefore",
    description: "Add new line before the current line",
    exec: function(editor) {
        editor.selection.clearSelection();
        var cursor = editor.getCursorPosition();
        editor.selection.moveTo(cursor.row - 1, Number.MAX_VALUE);
        editor.insert("\n");
        if (cursor.row === 0) editor.navigateUp();
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "openCommandPallete",
    exec: function(editor) {
        console.warn("This is an obsolete command. Please use `openCommandPalette` instead.");
        editor.prompt({ $type: "commands" });
    },
    readOnly: true
}, {
    name: "openCommandPalette",
    description: "Open command palette",
    bindKey: bindKey("F1", "F1"),
    exec: function(editor) {
        editor.prompt({ $type: "commands" });
    },
    readOnly: true
}, {
    name: "modeSelect",
    description: "Change language mode...",
    bindKey: bindKey(null, null),
    exec: function(editor) {
        editor.prompt({ $type: "modes" });
    },
    readOnly: true
}];

for (var i = 1; i < 9; i++) {
    exports.P.push({
        name: "foldToLevel" + i,
        description: "Fold To Level " + i,
        level: i,
        exec: function(editor) { editor.session.foldToLevel(this.level); },
        scrollIntoView: "center",
        readOnly: true
    });
}


/***/ }),

/***/ 22150:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var oop = __webpack_require__(2645);
var dom = __webpack_require__(71435);
var lang = __webpack_require__(39955);
var event = __webpack_require__(19631);
var useragent = __webpack_require__(74943);
var EventEmitter = (__webpack_require__(87366).EventEmitter);

var CHAR_COUNT = 512;
var USE_OBSERVER = typeof ResizeObserver == "function";
var L = 200;

class FontMetrics {

    /**
     * @param {HTMLElement} parentEl
     */
    constructor(parentEl) {
        this.el = dom.createElement("div");
        this.$setMeasureNodeStyles(this.el.style, true);

        this.$main = dom.createElement("div");
        this.$setMeasureNodeStyles(this.$main.style);

        this.$measureNode = dom.createElement("div");
        this.$setMeasureNodeStyles(this.$measureNode.style);


        this.el.appendChild(this.$main);
        this.el.appendChild(this.$measureNode);
        parentEl.appendChild(this.el);

        this.$measureNode.textContent = lang.stringRepeat("X", CHAR_COUNT);

        this.$characterSize = {width: 0, height: 0};


        if (USE_OBSERVER)
            this.$addObserver();
        else
            this.checkForSizeChanges();
    }
    
    $setMeasureNodeStyles(style, isRoot) {
        style.width = style.height = "auto";
        style.left = style.top = "0px";
        style.visibility = "hidden";
        style.position = "absolute";
        style.whiteSpace = "pre";

        if (useragent.isIE < 8) {
            style["font-family"] = "inherit";
        } else {
            style.font = "inherit";
        }
        style.overflow = isRoot ? "hidden" : "visible";
    }

    /**
     * @param {{height: number, width: number} | null} [size]
     */
    checkForSizeChanges(size) {
        if (size === undefined)
            size = this.$measureSizes();
        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
            this.$measureNode.style.fontWeight = "bold";
            var boldSize = this.$measureSizes();
            this.$measureNode.style.fontWeight = "";
            this.$characterSize = size;
            this.charSizes = Object.create(null);
            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
            this._emit("changeCharacterSize", {data: size});
        }
    }

    $addObserver() {
        var self = this;
        this.$observer = new window.ResizeObserver(function(e) {
            // e[0].contentRect is broken on safari when zoomed;
            self.checkForSizeChanges();
        });
        this.$observer.observe(this.$measureNode);
    }

    /**
     * @return {number}
     */
    $pollSizeChanges() {
        if (this.$pollSizeChangesTimer || this.$observer)
            return this.$pollSizeChangesTimer;
        var self = this;
        
        return this.$pollSizeChangesTimer = event.onIdle(function cb() {
            self.checkForSizeChanges();
            event.onIdle(cb, 500);
        }, 500);
    }

    /**
     * @param {boolean} val
     */
    setPolling(val) {
        if (val) {
            this.$pollSizeChanges();
        } else if (this.$pollSizeChangesTimer) {
            clearInterval(this.$pollSizeChangesTimer);
            this.$pollSizeChangesTimer = 0;
        }
    }

    $measureSizes(node) {
        var size = {
            height: (node || this.$measureNode).clientHeight,
            width: (node || this.$measureNode).clientWidth / CHAR_COUNT
        };
        
        // Size and width can be null if the editor is not visible or
        // detached from the document
        if (size.width === 0 || size.height === 0)
            return null;
        return size;
    }

    $measureCharWidth(ch) {
        this.$main.textContent = lang.stringRepeat(ch, CHAR_COUNT);
        var rect = this.$main.getBoundingClientRect();
        return rect.width / CHAR_COUNT;
    }
    
    getCharacterWidth(ch) {
        var w = this.charSizes[ch];
        if (w === undefined) {
            w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
        }
        return w;
    }

    destroy() {
        clearInterval(this.$pollSizeChangesTimer);
        if (this.$observer)
            this.$observer.disconnect();
        if (this.el && this.el.parentNode)
            this.el.parentNode.removeChild(this.el);
    }

    
    $getZoom(element) {
        if (!element || !element.parentElement) return 1;
        return (Number(window.getComputedStyle(element)["zoom"]) || 1) * this.$getZoom(element.parentElement);
    }
    
    $initTransformMeasureNodes() {
        var t = function(t, l) {
            return ["div", {
                style: "position: absolute;top:" + t + "px;left:" + l + "px;"
            }];
        };
        this.els = dom.buildDom([t(0, 0), t(L, 0), t(0, L), t(L, L)], this.el);
    }
    // general transforms from element coordinates x to screen coordinates u have the form
    // | m1[0] m2[0] t[0] |   | x |       | u |
    // | m1[1] m2[1] t[1] | . | y |  == k | v |
    // | h[0]  h[1]  1    |   | 1 |       | 1 |
    // this function finds the coeeficients of the matrix using positions of four points
    //  
    transformCoordinates(clientPos, elPos) {
        if (clientPos) {
            var zoom = this.$getZoom(this.el);
            clientPos = mul(1 / zoom, clientPos);
        }
        function solve(l1, l2, r) {
            var det = l1[1] * l2[0] - l1[0] * l2[1];
            return [
                (-l2[1] * r[0] + l2[0] * r[1]) / det,
                (+l1[1] * r[0] - l1[0] * r[1]) / det
            ];
        }
        function sub(a, b) { return [a[0] - b[0], a[1] - b[1]]; }
        function add(a, b) { return [a[0] + b[0], a[1] + b[1]]; }
        function mul(a, b) { return [a * b[0], a * b[1]]; }

        if (!this.els)
            this.$initTransformMeasureNodes();
        
        function p(el) {
            var r = el.getBoundingClientRect();
            return [r.left, r.top];
        }

        var a = p(this.els[0]);
        var b = p(this.els[1]);
        var c = p(this.els[2]);
        var d = p(this.els[3]);

        var h = solve(sub(d, b), sub(d, c), sub(add(b, c), add(d, a)));

        var m1 = mul(1 + h[0], sub(b, a));
        var m2 = mul(1 + h[1], sub(c, a));
        
        if (elPos) {
            var x = elPos;
            var k = h[0] * x[0] / L + h[1] * x[1] / L + 1;
            var ut = add(mul(x[0], m1), mul(x[1], m2));
            return  add(mul(1 / k / L, ut), a);
        }
        var u = sub(clientPos, a);
        var f = solve(sub(m1, mul(h[0], u)), sub(m2, mul(h[1], u)), u);
        return mul(L, f);
    }
    
}
FontMetrics.prototype.$characterSize = {width: 0, height: 0};

oop.implement(FontMetrics.prototype, EventEmitter);

exports.X = FontMetrics;


/***/ }),

/***/ 26347:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./editor").Editor} Editor
 * @typedef {import("../ace-internal").Ace.CompletionProviderOptions} CompletionProviderOptions
 * @typedef {import("../ace-internal").Ace.CompletionOptions} CompletionOptions
 * @typedef {import("../ace-internal").Ace.Position} Position
 */
var HashHandler = (__webpack_require__(93050).HashHandler);
var AcePopup = (__webpack_require__(51826).AcePopup);
var AceInline = (__webpack_require__(76703)/* .AceInline */ .V);
var getAriaId = (__webpack_require__(51826).getAriaId);
var util = __webpack_require__(28630);
var lang = __webpack_require__(39955);
var dom = __webpack_require__(71435);
var snippetManager = (__webpack_require__(51509)/* .snippetManager */ .N);
var config = __webpack_require__(76321);
var event = __webpack_require__(19631);
var preventParentScroll = (__webpack_require__(58298)/* .preventParentScroll */ .K);

/**
 * @typedef BaseCompletion
 * @property {number} [score] - a numerical value that determines the order in which completions would be displayed.
 * A lower score means that the completion would be displayed further from the start
 * @property {string} [meta] - a short description of the completion
 * @property {string} [caption] - the text that would be displayed in the completion list. If omitted, value or snippet
 * would be shown instead.
 * @property {string} [docHTML] - an HTML string that would be displayed as an additional popup
 * @property {string} [docText] - a plain text that would be displayed as an additional popup. If `docHTML` exists,
 * it would be used instead of `docText`.
 * @property {string} [completerId] - the identifier of the completer
 * @property {boolean} [skipFilter] - a boolean value to decide if the popup item is going to skip the filtering process done using prefix text.
 * @property {import("../ace-internal").Ace.IRange} [range] - An object specifying the range of text to be replaced with the new completion value (experimental)
 * @property {any} [command] - A command to be executed after the completion is inserted (experimental)
 * @property {string} [snippet] - a text snippet that would be inserted when the completion is selected
 * @property {string} [value] - The text that would be inserted when selecting this completion.
 * @property {import("../ace-internal").Ace.Completer} [completer]
 * @property {boolean} [hideInlinePreview]
 * @export
 */

/**
 * @typedef {BaseCompletion & {snippet: string}} SnippetCompletion
 * @property {string} snippet
 * @property {string} [value]
 * @export
 */

/**
 * @typedef {BaseCompletion & {value: string}} ValueCompletion
 * @property {string} value
 * @property {string} [snippet]
 * @export
 */

/**
 * Represents a suggested text snippet intended to complete a user's input
 * @typedef Completion
 * @type {SnippetCompletion|ValueCompletion}
 * @export
 */

var destroyCompleter = function(e, editor) {
    editor.completer && editor.completer.destroy();
};

/**
 * This object controls the autocompletion components and their lifecycle.
 * There is an autocompletion popup, an optional inline ghost text renderer and a docuent tooltip popup inside.
 */
class Autocomplete {
    constructor() {
        this.autoInsert = false;
        this.autoSelect = true;
        this.autoShown = false;
        this.exactMatch = false;
        this.inlineEnabled = false;
        this.keyboardHandler = new HashHandler();
        this.keyboardHandler.bindKeys(this.commands);
        this.parentNode = null;
        this.setSelectOnHover = false;
        /**@private*/
        this.hasSeen = new Set();

        /**
         *  @property {Boolean} showLoadingState - A boolean indicating whether the loading states of the Autocompletion should be shown to the end-user. If enabled
         * it shows a loading indicator on the popup while autocomplete is loading.
         *
         * Experimental: This visualisation is not yet considered stable and might change in the future.
         */
        this.showLoadingState = false;

        /**
         *  @property {number} stickySelectionDelay - a numerical value that determines after how many ms the popup selection will become 'sticky'.
         *  Normally, when new elements are added to an open popup, the selection is reset to the first row of the popup. If sticky, the focus will remain
         *  on the currently selected item when new items are added to the popup. Set to a negative value to disable this feature and never set selection to sticky.
         */
        this.stickySelectionDelay = 500;

        this.blurListener = this.blurListener.bind(this);
        this.changeListener = this.changeListener.bind(this);
        this.mousedownListener = this.mousedownListener.bind(this);
        this.mousewheelListener = this.mousewheelListener.bind(this);
        this.onLayoutChange = this.onLayoutChange.bind(this);

        this.changeTimer = lang.delayedCall(function() {
            this.updateCompletions(true);
        }.bind(this));

        this.tooltipTimer = lang.delayedCall(this.updateDocTooltip.bind(this), 50);
        this.popupTimer = lang.delayedCall(this.$updatePopupPosition.bind(this), 50);

        this.stickySelectionTimer = lang.delayedCall(function() {
            this.stickySelection = true;
        }.bind(this), this.stickySelectionDelay);

        this.$firstOpenTimer = lang.delayedCall(/**@this{Autocomplete}*/function() {
            var initialPosition = this.completionProvider && this.completionProvider.initialPosition;
            if (this.autoShown || (this.popup && this.popup.isOpen) || !initialPosition || this.editor.completers.length === 0) return;

            this.completions = new FilteredList(Autocomplete.completionsForLoading);
            this.openPopup(this.editor, initialPosition.prefix, false);
            this.popup.renderer.setStyle("ace_loading", true);
        }.bind(this), this.stickySelectionDelay);
    }

    static get completionsForLoading() { return [{
            caption: config.nls("autocomplete.loading", "Loading..."),
            value: ""
        }];
    }

    $init() {
        /**@type {AcePopup}**/
        this.popup = new AcePopup(this.parentNode || document.body || document.documentElement);
        this.popup.on("click", function(e) {
            this.insertMatch();
            e.stop();
        }.bind(this));
        this.popup.focus = this.editor.focus.bind(this.editor);
        this.popup.on("show", this.$onPopupShow.bind(this));
        this.popup.on("hide", this.$onHidePopup.bind(this));
        this.popup.on("select", this.$onPopupChange.bind(this));
        event.addListener(this.popup.container, "mouseout", this.mouseOutListener.bind(this));
        this.popup.on("changeHoverMarker", this.tooltipTimer.bind(null, null));
        this.popup.renderer.on("afterRender", this.$onPopupRender.bind(this));
        return this.popup;
    }


    $initInline() {
        if (!this.inlineEnabled || this.inlineRenderer)
            return;
        this.inlineRenderer = new AceInline();
        return this.inlineRenderer;
    }

    /**
     * @return {AcePopup}
     */
    getPopup() {
        return this.popup || this.$init();
    }

    $onHidePopup() {
        if (this.inlineRenderer) {
            this.inlineRenderer.hide();
        }
        this.hideDocTooltip();
        this.stickySelectionTimer.cancel();
        this.popupTimer.cancel();
        this.stickySelection = false;
    }
    $seen(completion) {
        if (!this.hasSeen.has(completion) && completion && completion.completer && completion.completer.onSeen && typeof completion.completer.onSeen === "function") {
            completion.completer.onSeen(this.editor, completion);
            this.hasSeen.add(completion);
        }
    }
    $onPopupChange(hide) {
        if (this.inlineRenderer && this.inlineEnabled) {
            var completion = hide ? null : this.popup.getData(this.popup.getRow());
            this.$updateGhostText(completion);
            // If the mouse is over the tooltip, and we're changing selection on hover don't
            // move the tooltip while hovering over the popup.
            if (this.popup.isMouseOver && this.setSelectOnHover) {
                // @ts-expect-error TODO: potential wrong arguments
                this.tooltipTimer.call(null, null);
                return;
            }

            // Update the popup position after a short wait to account for potential scrolling
            this.popupTimer.schedule();
            this.tooltipTimer.schedule();
        } else {
            // @ts-expect-error TODO: potential wrong arguments
            this.popupTimer.call(null, null);
            // @ts-expect-error TODO: potential wrong arguments
            this.tooltipTimer.call(null, null);
        }
    }

    $updateGhostText(completion) {
        // Ghost text can include characters normally not part of the prefix (e.g. whitespace).
        // When typing ahead with ghost text however, we want to simply prefix with respect to the
        // base of the completion.
        var row = this.base.row;
        var column = this.base.column;
        var cursorColumn = this.editor.getCursorPosition().column;
        var prefix = this.editor.session.getLine(row).slice(column, cursorColumn);

        if (!this.inlineRenderer.show(this.editor, completion, prefix)) {
            this.inlineRenderer.hide();
        } else {
            this.$seen(completion);
        }
    }

    $onPopupRender() {
        const inlineEnabled = this.inlineRenderer && this.inlineEnabled;
        if (this.completions && this.completions.filtered && this.completions.filtered.length > 0) {
            for (var i = this.popup.getFirstVisibleRow(); i <= this.popup.getLastVisibleRow(); i++) {
                var completion = this.popup.getData(i);
                if (completion && (!inlineEnabled || completion.hideInlinePreview)) {
                    this.$seen(completion);
                }
            }
        }
    }

    $onPopupShow(hide) {
        this.$onPopupChange(hide);
        this.stickySelection = false;
        if (this.stickySelectionDelay >= 0)
            this.stickySelectionTimer.schedule(this.stickySelectionDelay);
    }

    observeLayoutChanges() {
        if (this.$elements || !this.editor) return;
        window.addEventListener("resize", this.onLayoutChange, {passive: true});
        window.addEventListener("wheel", this.mousewheelListener);

        var el = this.editor.container.parentNode;
        var elements = [];
        while (el) {
            elements.push(el);
            el.addEventListener("scroll", this.onLayoutChange, {passive: true});
            el = el.parentNode;
        }
        this.$elements = elements;
    }
    unObserveLayoutChanges() {
        // @ts-expect-error This is expected for some browsers
        window.removeEventListener("resize", this.onLayoutChange, {passive: true});
        window.removeEventListener("wheel", this.mousewheelListener);
        this.$elements && this.$elements.forEach((el) => {
            // @ts-expect-error This is expected for some browsers
            el.removeEventListener("scroll", this.onLayoutChange, {passive: true});
        });
        this.$elements = null;
    }

    /**
     * @internal
     */
    onLayoutChange() {
        if (!this.popup.isOpen) return this.unObserveLayoutChanges();
        this.$updatePopupPosition();
        this.updateDocTooltip();
    }

    $updatePopupPosition() {
        var editor = this.editor;
        var renderer = editor.renderer;

        var lineHeight = renderer.layerConfig.lineHeight;
        var pos = renderer.$cursorLayer.getPixelPosition(this.base, true);
        pos.left -= this.popup.getTextLeftOffset();

        var rect = editor.container.getBoundingClientRect();
        pos.top += rect.top - renderer.layerConfig.offset;
        pos.left += rect.left - editor.renderer.scrollLeft;
        pos.left += renderer.gutterWidth;

        var posGhostText = {
            top: pos.top,
            left: pos.left
        };

        if (renderer.$ghostText && renderer.$ghostTextWidget) {
            if (this.base.row === renderer.$ghostText.position.row) {
                posGhostText.top += renderer.$ghostTextWidget.el.offsetHeight;
            }
        }

        // posGhostText can be below the editor rendering the popup away from the editor.
        // In this case, we want to render the popup such that the top aligns with the bottom of the editor.
        var editorContainerBottom = editor.container.getBoundingClientRect().bottom - lineHeight;
        var lowestPosition = editorContainerBottom < posGhostText.top ?
            {top: editorContainerBottom, left: posGhostText.left} :
            posGhostText;

        // Try to render below ghost text, then above ghost text, then over ghost text
        if (this.popup.tryShow(lowestPosition, lineHeight, "bottom")) {
            return;
        }

        if (this.popup.tryShow(pos, lineHeight, "top")) {
            return;
        }

        this.popup.show(pos, lineHeight);
    }

    /**
     * @param {Editor} editor
     * @param {string} prefix
     * @param {boolean} [keepPopupPosition]
     */
    openPopup(editor, prefix, keepPopupPosition) {
        this.$firstOpenTimer.cancel();

        if (!this.popup)
            this.$init();

        if (this.inlineEnabled && !this.inlineRenderer)
            this.$initInline();

        this.popup.autoSelect = this.autoSelect;
        this.popup.setSelectOnHover(this.setSelectOnHover);

        var oldRow = this.popup.getRow();
        var previousSelectedItem = this.popup.data[oldRow];

        this.popup.setData(this.completions.filtered, this.completions.filterText);
        if (this.editor.textInput.setAriaOptions) {
            this.editor.textInput.setAriaOptions({
                activeDescendant: getAriaId(this.popup.getRow()),
                inline: this.inlineEnabled
            });
        }

        editor.keyBinding.addKeyboardHandler(this.keyboardHandler);

        var newRow;
        if (this.stickySelection)
            newRow = this.popup.data.indexOf(previousSelectedItem);
        if (!newRow || newRow === -1)
            newRow = 0;

        this.popup.setRow(this.autoSelect ? newRow : -1);

        // If we stay on the same row, but the content is different, we want to update the popup.
        if (newRow === oldRow && previousSelectedItem !== this.completions.filtered[newRow])
            this.$onPopupChange();

        // If we stay on the same line and have inlinePreview enabled, we want to make sure the
        // ghost text remains up-to-date.
        const inlineEnabled = this.inlineRenderer && this.inlineEnabled;
        if (newRow === oldRow && inlineEnabled) {
            var completion = this.popup.getData(this.popup.getRow());
            this.$updateGhostText(completion);
        }

        if (!keepPopupPosition) {
            this.popup.setTheme(editor.getTheme());
            this.popup.setFontSize(editor.getFontSize());

            this.$updatePopupPosition();
            if (this.tooltipNode) {
                this.updateDocTooltip();
            }
        }
        this.changeTimer.cancel();
        this.observeLayoutChanges();
    }

    /**
     * Detaches all elements from the editor, and cleans up the data for the session
     */
    detach() {
        if (this.editor) {
            this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
            this.editor.off("changeSelection", this.changeListener);
            this.editor.off("blur", this.blurListener);
            this.editor.off("mousedown", this.mousedownListener);
            this.editor.off("mousewheel", this.mousewheelListener);
        }
        this.$firstOpenTimer.cancel();

        this.changeTimer.cancel();
        this.hideDocTooltip();

        if (this.completionProvider) {
            this.completionProvider.detach();
        }

        if (this.popup && this.popup.isOpen)
            this.popup.hide();

        if (this.popup && this.popup.renderer) {
            this.popup.renderer.off("afterRender", this.$onPopupRender);
        }

        if (this.base)
            this.base.detach();
        this.activated = false;
        this.completionProvider = this.completions = this.base = null;
        this.unObserveLayoutChanges();
    }

    changeListener(e) {
        var cursor = this.editor.selection.lead;
        if (cursor.row != this.base.row || cursor.column < this.base.column) {
            this.detach();
        }
        if (this.activated)
            this.changeTimer.schedule();
        else
            this.detach();
    }

    blurListener(e) {
        // we have to check if activeElement is a child of popup because
        // on IE preventDefault doesn't stop scrollbar from being focussed
        var el = document.activeElement;
        var text = this.editor.textInput.getElement();
        var fromTooltip = e.relatedTarget && this.tooltipNode && this.tooltipNode.contains(e.relatedTarget);
        var container = this.popup && this.popup.container;
        if (el != text && el.parentNode != container && !fromTooltip
            && el != this.tooltipNode && e.relatedTarget != text
        ) {
            this.detach();
        }
    }

    mousedownListener(e) {
        this.detach();
    }

    mousewheelListener(e) {
        if (this.popup && !this.popup.isMouseOver)
            this.detach();
    }

    mouseOutListener(e) {
        // Check whether the popup is still open after the mouseout event,
        // if so, attempt to move it to its desired position.
        if (this.popup.isOpen)
            this.$updatePopupPosition();
    }

   goTo(where) {
        this.popup.goTo(where);
    }

    /**
     * @param {Completion} data
     * @param {undefined} [options]
     * @return {boolean | void}
     */
    insertMatch(data, options) {
        if (!data)
            data = this.popup.getData(this.popup.getRow());
        if (!data)
            return false;
        if (data.value === "") // Explicitly given nothing to insert, e.g. "No suggestion state"
            return this.detach();
        var completions = this.completions;
        // @ts-expect-error TODO: potential wrong arguments
        var result = this.getCompletionProvider().insertMatch(this.editor, data, completions.filterText, options);
        // detach only if new popup was not opened while inserting match
        if (this.completions == completions)
            this.detach();
        return result;
    }

    /**
     * This is the entry point for the autocompletion class, triggers the actions which collect and display suggestions
     * @param {Editor} editor
     * @param {CompletionOptions} [options]
     */
    showPopup(editor, options) {
        if (this.editor)
            this.detach();

        this.activated = true;

        this.editor = editor;
        if (editor.completer != this) {
            if (editor.completer)
                editor.completer.detach();
            editor.completer = this;
        }

        editor.on("changeSelection", this.changeListener);
        editor.on("blur", this.blurListener);
        editor.on("mousedown", this.mousedownListener);
        editor.on("mousewheel", this.mousewheelListener);

        this.updateCompletions(false, options);
    }

    /**
     *
     * @param {{pos: Position, prefix: string}} [initialPosition]
     * @return {CompletionProvider}
     */
    getCompletionProvider(initialPosition) {
        if (!this.completionProvider)
            this.completionProvider = new CompletionProvider(initialPosition);
        return this.completionProvider;
    }

    /**
     * This method is deprecated, it is only kept for backwards compatibility.
     * Use the same method include CompletionProvider instead for the same functionality.
     * @deprecated
     */
    gatherCompletions(editor, callback) {
        return this.getCompletionProvider().gatherCompletions(editor, callback);
    }

    /**
     * @param {boolean} keepPopupPosition
     * @param {CompletionOptions} [options]
     */
    updateCompletions(keepPopupPosition, options) {
        if (keepPopupPosition && this.base && this.completions) {
            var pos = this.editor.getCursorPosition();
            var prefix = this.editor.session.getTextRange({start: this.base, end: pos});
            if (prefix == this.completions.filterText)
                return;
            this.completions.setFilter(prefix);
            if (!this.completions.filtered.length)
                return this.detach();
            if (this.completions.filtered.length == 1
            && this.completions.filtered[0].value == prefix
            && !this.completions.filtered[0].snippet)
                return this.detach();
            this.openPopup(this.editor, prefix, keepPopupPosition);
            return;
        }

        if (options && options.matches) {
            var pos = this.editor.getSelectionRange().start;
            this.base = this.editor.session.doc.createAnchor(pos.row, pos.column);
            this.base.$insertRight = true;
            this.completions = new FilteredList(options.matches);
            this.getCompletionProvider().completions = this.completions;
            return this.openPopup(this.editor, "", keepPopupPosition);
        }

        var session = this.editor.getSession();
        var pos = this.editor.getCursorPosition();
        var prefix = util.getCompletionPrefix(this.editor);
        this.base = session.doc.createAnchor(pos.row, pos.column - prefix.length);
        this.base.$insertRight = true;
        var completionOptions = {
            exactMatch: this.exactMatch,
            // @ts-expect-error TODO: couldn't find initializer
            ignoreCaption: this.ignoreCaption
        };
        this.getCompletionProvider({
            prefix,
            pos
        }).provideCompletions(this.editor, completionOptions,
            /**
             * @type {(err: any, completions: FilteredList, finished: boolean) => void | boolean}
             * @this {Autocomplete}
             */
            function (err, completions, finished) {
                var filtered = completions.filtered;
                var prefix = util.getCompletionPrefix(this.editor);
            this.$firstOpenTimer.cancel();

                if (finished) {
                    // No results
                    if (!filtered.length) {
                        var emptyMessage = !this.autoShown && this.emptyMessage;
                        if (typeof emptyMessage == "function") emptyMessage = this.emptyMessage(prefix);
                        if (emptyMessage) {
                        var completionsForEmpty = [{
                            caption: emptyMessage,
                                    value: ""
                                }
                            ];
                            this.completions = new FilteredList(completionsForEmpty);
                            this.openPopup(this.editor, prefix, keepPopupPosition);
                            this.popup.renderer.setStyle("ace_loading", false);
                            this.popup.renderer.setStyle("ace_empty-message", true);
                            return;
                        }
                        return this.detach();
                    }

                    // One result equals to the prefix
                    if (filtered.length == 1 && filtered[0].value == prefix
                        && !filtered[0].snippet) return this.detach();

                    // Autoinsert if one result
                    if (this.autoInsert && !this.autoShown && filtered.length == 1) return this.insertMatch(
                        filtered[0]);
                }
            // If showLoadingState is true and there is still a completer loading, show 'Loading...'
            // in the top row of the completer popup.
            this.completions = !finished && this.showLoadingState ?
                new FilteredList(
                    Autocomplete.completionsForLoading.concat(filtered), completions.filterText
                ) :
                completions;

                this.openPopup(this.editor, prefix, keepPopupPosition);

            this.popup.renderer.setStyle("ace_empty-message", false);
            this.popup.renderer.setStyle("ace_loading", !finished);
        }.bind(this));

        if (this.showLoadingState && !this.autoShown && !(this.popup && this.popup.isOpen)) {
            this.$firstOpenTimer.delay(this.stickySelectionDelay/2);
        }
    }

    cancelContextMenu() {
        this.editor.$mouseHandler.cancelContextMenu();
    }

    updateDocTooltip() {
        var popup = this.popup;
        var all = this.completions && this.completions.filtered;
        var selected = all && (all[popup.getHoveredRow()] || all[popup.getRow()]);
        var doc = null;
        if (!selected || !this.editor || !this.popup.isOpen)
            return this.hideDocTooltip();

        var completersLength = this.editor.completers.length;
        for (var i = 0; i < completersLength; i++) {
            var completer = this.editor.completers[i];
            if (completer.getDocTooltip && selected.completerId === completer.id) {
                doc = completer.getDocTooltip(selected);
                break;
            }
        }
        if (!doc && typeof selected != "string")
            doc = selected;

        if (typeof doc == "string")
            doc = {docText: doc};
        if (!doc || !(doc.docHTML || doc.docText))
            return this.hideDocTooltip();
        this.showDocTooltip(doc);
    }

    showDocTooltip(item) {
        if (!this.tooltipNode) {
            this.tooltipNode = dom.createElement("div");
            this.tooltipNode.style.margin = "0";
            this.tooltipNode.style.pointerEvents = "auto";
            this.tooltipNode.style.overscrollBehavior = "contain";
            this.tooltipNode.tabIndex = -1;
            this.tooltipNode.onblur = this.blurListener.bind(this);
            this.tooltipNode.onclick = this.onTooltipClick.bind(this);
            this.tooltipNode.id = "doc-tooltip";
            this.tooltipNode.setAttribute("role", "tooltip");
            // prevent editor scroll if tooltip is inside an editor
            this.tooltipNode.addEventListener("wheel", preventParentScroll);
        }
        var theme = this.editor.renderer.theme;
        this.tooltipNode.className = "ace_tooltip ace_doc-tooltip " +
            (theme.isDark? "ace_dark " : "") + (theme.cssClass || "");

        var tooltipNode = this.tooltipNode;
        if (item.docHTML) {
            tooltipNode.innerHTML = item.docHTML;
        } else if (item.docText) {
            tooltipNode.textContent = item.docText;
        }

        if (!tooltipNode.parentNode)
            this.popup.container.appendChild(this.tooltipNode);

        var popup = this.popup;
        var rect = popup.container.getBoundingClientRect();

        var targetWidth = 400;
        var targetHeight = 300;
        var scrollBarSize = popup.renderer.scrollBar.width || 10;

        var leftSize = rect.left;
        var rightSize = window.innerWidth - rect.right - scrollBarSize;
        var topSize = popup.isTopdown ?  window.innerHeight - scrollBarSize - rect.bottom : rect.top;
        var scores = [
            Math.min(rightSize / targetWidth, 1),
            Math.min(leftSize / targetWidth, 1),
            Math.min(topSize / targetHeight, 1) * 0.9,
        ];
        var max = Math.max.apply(Math, scores);
        var tooltipStyle = tooltipNode.style;
        tooltipStyle.display = "block";

        if (max == scores[0] || scores[0] >= 1) {
            tooltipStyle.left = (rect.right + 1) + "px";
            tooltipStyle.right = "";
            tooltipStyle.maxWidth = targetWidth * max + "px";
            tooltipStyle.top = rect.top + "px";
            tooltipStyle.bottom = "";
            tooltipStyle.maxHeight = Math.min(window.innerHeight - scrollBarSize - rect.top, targetHeight) + "px";
        } else if (max == scores[1] || scores[1] >= 1) {
            tooltipStyle.right = window.innerWidth - rect.left + "px";
            tooltipStyle.left = "";
            tooltipStyle.maxWidth = targetWidth * max + "px";
            tooltipStyle.top = rect.top + "px";
            tooltipStyle.bottom = "";
            tooltipStyle.maxHeight = Math.min(window.innerHeight - scrollBarSize - rect.top, targetHeight) + "px";
        } else if (max == scores[2]) {
            tooltipStyle.left = rect.left + "px";
            tooltipStyle.right = "";
            tooltipStyle.maxWidth = Math.min(targetWidth, window.innerWidth - rect.left) + "px";

            if (popup.isTopdown) {
                tooltipStyle.top = rect.bottom + "px";
                tooltipStyle.bottom = "";
                tooltipStyle.maxHeight = Math.min(window.innerHeight - scrollBarSize - rect.bottom, targetHeight) + "px";
            } else {
                tooltipStyle.top = "";
                tooltipStyle.bottom = (window.innerHeight  - rect.top) + "px";
                tooltipStyle.maxHeight = Math.min(rect.top, targetHeight) + "px";
            }
        }
        dom.$fixPositionBug(tooltipNode);
    }

    hideDocTooltip() {
        this.tooltipTimer.cancel();
        if (!this.tooltipNode) return;
        var el = this.tooltipNode;
        if (!this.editor.isFocused() && document.activeElement == el)
            this.editor.focus();
        this.tooltipNode = null;
        if (el.parentNode)
            el.parentNode.removeChild(el);
    }

    /**
     * @param e
     * @internal
     */
    onTooltipClick(e) {
        var a = e.target;
        while (a && a != this.tooltipNode) {
            if (a.nodeName == "A" && a.href) {
                a.rel = "noreferrer";
                a.target = "_blank";
                break;
            }
            a = a.parentNode;
        }
    }

    destroy() {
        this.detach();
        if (this.popup) {
            this.popup.destroy();
            var el = this.popup.container;
            if (el && el.parentNode)
                el.parentNode.removeChild(el);
        }
        if (this.editor && this.editor.completer == this) {
            this.editor.off("destroy", destroyCompleter);
            this.editor.completer = null;
        }
        this.inlineRenderer = this.popup = this.editor = null;
    }

    /**
     * @param {Editor} editor
     * @return {Autocomplete}
     */
    static for(editor) {
        if (editor.completer instanceof Autocomplete) {
            return editor.completer;
        }
        if (editor.completer) {
            editor.completer.destroy();
            editor.completer = null;
        }
        if (config.get("sharedPopups")) {
            if (!Autocomplete["$sharedInstance"])
                Autocomplete["$sharedInstance"] = new Autocomplete();
            editor.completer = Autocomplete["$sharedInstance"];
        } else {
            editor.completer = new Autocomplete();
            editor.once("destroy", destroyCompleter);
        }
        // @ts-expect-error
        return editor.completer;
    }

}

Autocomplete.prototype.commands = {
    "Up": function(editor) { editor.completer.goTo("up"); },
    "Down": function(editor) { editor.completer.goTo("down"); },
    "Ctrl-Up|Ctrl-Home": function(editor) { editor.completer.goTo("start"); },
    "Ctrl-Down|Ctrl-End": function(editor) { editor.completer.goTo("end"); },

    "Esc": function(editor) { editor.completer.detach(); },
    "Return": function(editor) { return editor.completer.insertMatch(); },
    "Shift-Return": function(editor) { editor.completer.insertMatch(null, {deleteSuffix: true}); },
    "Tab": function(editor) {
        var result = editor.completer.insertMatch();
        if (!result && !editor.tabstopManager)
            editor.completer.goTo("down");
        else
            return result;
    },
    "Backspace": function(editor) {
        editor.execCommand("backspace");
        var prefix = util.getCompletionPrefix(editor);
        if (!prefix && editor.completer)
            editor.completer.detach();
    },

    "PageUp": function(editor) { editor.completer.popup.gotoPageUp(); },
    "PageDown": function(editor) { editor.completer.popup.gotoPageDown(); }
};

Autocomplete.startCommand = {
    name: "startAutocomplete",
    exec: function(editor, options) {
        var completer = Autocomplete.for(editor);
        completer.autoInsert = false;
        completer.autoSelect = true;
        completer.autoShown = false;
        completer.showPopup(editor, options);
        // prevent ctrl-space opening context menu on firefox on mac
        completer.cancelContextMenu();
    },
    bindKey: "Ctrl-Space|Ctrl-Shift-Space|Alt-Space"
};

/**
 * This class is responsible for providing completions and inserting them to the editor
 */
class CompletionProvider {


    /**
     * @param {{pos: Position, prefix: string}} [initialPosition]
     */
    constructor(initialPosition) {
        this.initialPosition = initialPosition;
        this.active = true;
    }

    /**
     * @param {Editor} editor
     * @param {number} index
     * @param {CompletionProviderOptions} [options]
     * @returns {boolean}
     */
    insertByIndex(editor, index, options) {
        if (!this.completions || !this.completions.filtered) {
            return false;
        }
        return this.insertMatch(editor, this.completions.filtered[index], options);
    }

    /**
     * @param {Editor} editor
     * @param {Completion} data
     * @param {CompletionProviderOptions} [options]
     * @returns {boolean}
     */
    insertMatch(editor, data, options) {
        if (!data)
            return false;

        editor.startOperation({command: {name: "insertMatch"}});
        if (data.completer && data.completer.insertMatch) {
            data.completer.insertMatch(editor, data);
        } else {
            // TODO add support for options.deleteSuffix
            if (!this.completions)
                return false;

            var replaceBefore = this.completions.filterText.length;
            var replaceAfter = 0;
            if (data.range && data.range.start.row === data.range.end.row) {
                replaceBefore -= this.initialPosition.prefix.length;
                replaceBefore += this.initialPosition.pos.column - data.range.start.column;
                replaceAfter += data.range.end.column - this.initialPosition.pos.column;
            }

            if (replaceBefore || replaceAfter) {
                var ranges;
                if (editor.selection.getAllRanges) {
                    ranges = editor.selection.getAllRanges();
                }
                else {
                    ranges = [editor.getSelectionRange()];
                }
                for (var i = 0, range; range = ranges[i]; i++) {
                    range.start.column -= replaceBefore;
                    range.end.column += replaceAfter;
                    editor.session.remove(range);
                }
            }

            if (data.snippet) {
                snippetManager.insertSnippet(editor, data.snippet);
            }
            else {
                this.$insertString(editor, data);
            }
            if (data.completer && data.completer.onInsert && typeof data.completer.onInsert == "function") {
                data.completer.onInsert(editor, data);
            }

            if (data.command && data.command === "startAutocomplete") {
                editor.execCommand(data.command);
            }
        }
        editor.endOperation();
        return true;
    }

    /**
     * @param {Editor} editor
     * @param {Completion} data
     */
    $insertString(editor, data) {
        var text = data.value || data;
        editor.execCommand("insertstring", text);
    }

    /**
     * @param {Editor} editor
     * @param {import("../ace-internal").Ace.CompletionCallbackFunction} callback
     */
    gatherCompletions(editor, callback) {
        var session = editor.getSession();
        var pos = editor.getCursorPosition();

        var prefix = util.getCompletionPrefix(editor);

        var matches = [];
        this.completers = editor.completers;
        var total = editor.completers.length;
        editor.completers.forEach(function(completer, i) {
            completer.getCompletions(editor, session, pos, prefix, function(err, results) {
                if (completer.hideInlinePreview)
                    results = results.map((result) =>  {
                        return Object.assign(result, {hideInlinePreview: completer.hideInlinePreview});
                    });

                if (!err && results)
                    matches = matches.concat(results);
                // Fetch prefix again, because they may have changed by now
                callback(null, {
                    prefix: util.getCompletionPrefix(editor),
                    matches: matches,
                    finished: (--total === 0)
                });
            });
        });
        return true;
    }

    /**
     * This is the entry point to the class, it gathers, then provides the completions asynchronously via callback.
     * The callback function may be called multiple times, the last invokation is marked with a `finished` flag
     * @param {Editor} editor
     * @param {CompletionProviderOptions} options
     * @param {(err: Error | undefined, completions: FilteredList | [], finished: boolean) => void} callback
     */
    provideCompletions(editor, options, callback) {
        var processResults = function(results) {
            var prefix = results.prefix;
            var matches = results.matches;

            this.completions = new FilteredList(matches);

            if (options.exactMatch)
                this.completions.exactMatch = true;

            if (options.ignoreCaption)
                this.completions.ignoreCaption = true;

            this.completions.setFilter(prefix);

            if (results.finished || this.completions.filtered.length)
                callback(null, this.completions, results.finished);
        }.bind(this);

        var isImmediate = true;
        var immediateResults = null;
        this.gatherCompletions(editor, function(err, results) {
            if (!this.active) {
                return;
            }
            if (err) {
                callback(err, [], true);
                this.detach();
            }
            var prefix = results.prefix;

            // Wrong prefix or wrong session -> ignore
            if (prefix.indexOf(results.prefix) !== 0)
                return;

            // If multiple completers return their results immediately, we want to process them together
            if (isImmediate) {
                immediateResults = results;
                return;
            }

            processResults(results);
        }.bind(this));

        isImmediate = false;
        if (immediateResults) {
            var results = immediateResults;
            immediateResults = null;
            processResults(results);
        }
    }

    detach() {
        this.active = false;
        this.completers && this.completers.forEach(function(completer) {
            if (typeof completer.cancel === "function") {
                completer.cancel();
            }
        });
    }
}

class FilteredList {
    /**
     * @param {any} array
     * @param {string} [filterText]
     */
    constructor(array, filterText) {
        this.all = array;
        this.filtered = array;
        this.filterText = filterText || "";
        this.exactMatch = false;
        this.ignoreCaption = false;
    }

    setFilter(str) {
        if (str.length > this.filterText && str.lastIndexOf(this.filterText, 0) === 0)
            var matches = this.filtered;
        else
            var matches = this.all;

        this.filterText = str;
        matches = this.filterCompletions(matches, this.filterText);
        matches = matches.sort(function(a, b) {
            return b.exactMatch - a.exactMatch || b.$score - a.$score
                || (a.caption || a.value).localeCompare(b.caption || b.value);
        });

        // make unique
        var prev = null;
        matches = matches.filter(function(item){
            var caption = item.snippet || item.caption || item.value;
            if (caption === prev) return false;
            prev = caption;
            return true;
        });

        this.filtered = matches;
    }

    filterCompletions(items, needle) {
        var results = [];
        var upper = needle.toUpperCase();
        var lower = needle.toLowerCase();
        loop: for (var i = 0, item; item = items[i]; i++) {
            if (item.skipFilter) {
                item.$score = item.score;
                results.push(item);
                continue;
            }
            var caption = (!this.ignoreCaption && item.caption) || item.value || item.snippet;
            if (!caption) continue;
            var lastIndex = -1;
            var matchMask = 0;
            var penalty = 0;
            var index, distance;

            if (this.exactMatch) {
                if (needle !== caption.substr(0, needle.length))
                    continue loop;
            } else {
                /**
                 * It is for situation then, for example, we find some like 'tab' in item.value="Check the table"
                 * and want to see "Check the TABle" but see "Check The tABle".
                 */
                var fullMatchIndex = caption.toLowerCase().indexOf(lower);
                if (fullMatchIndex > -1) {
                    penalty = fullMatchIndex;
                } else {
                    // caption char iteration is faster in Chrome but slower in Firefox, so lets use indexOf
                    for (var j = 0; j < needle.length; j++) {
                        // TODO add penalty on case mismatch
                        var i1 = caption.indexOf(lower[j], lastIndex + 1);
                        var i2 = caption.indexOf(upper[j], lastIndex + 1);
                        index = (i1 >= 0) ? ((i2 < 0 || i1 < i2) ? i1 : i2) : i2;
                        if (index < 0)
                            continue loop;
                        distance = index - lastIndex - 1;
                        if (distance > 0) {
                            // first char mismatch should be more sensitive
                            if (lastIndex === -1)
                                penalty += 10;
                            penalty += distance;
                            matchMask = matchMask | (1 << j);
                        }
                        lastIndex = index;
                    }
                }
            }
            item.matchMask = matchMask;
            item.exactMatch = penalty ? 0 : 1;
            item.$score = (item.score || 0) - penalty;
            results.push(item);
        }
        return results;
    }
}

exports.jT = Autocomplete;
exports.o2 = CompletionProvider;
exports.C3 = FilteredList;


/***/ }),

/***/ 27258:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


/**
 * @typedef {import("./virtual_renderer").VirtualRenderer} VirtualRenderer
 * @typedef {import("./selection").Selection} Selection
 * @typedef {import("../ace-internal").Ace.Point} Point
 * @typedef {import("../ace-internal").Ace.SearchOptions} SearchOptions
 */

var oop = __webpack_require__(2645);
var dom = __webpack_require__(71435);
var lang = __webpack_require__(39955);
var useragent = __webpack_require__(74943);
var TextInput = (__webpack_require__(82984)/* .TextInput */ .k);
var MouseHandler = (__webpack_require__(32291)/* .MouseHandler */ .e);
var FoldHandler = (__webpack_require__(99847)/* .FoldHandler */ .e);
var KeyBinding = (__webpack_require__(69957)/* .KeyBinding */ .$);
var EditSession = (__webpack_require__(33464)/* .EditSession */ .f);
var Search = (__webpack_require__(99427)/* .Search */ .v);
var Range = (__webpack_require__(91902)/* .Range */ .Q);
var EventEmitter = (__webpack_require__(87366).EventEmitter);
var CommandManager = (__webpack_require__(63379).CommandManager);
var defaultCommands = (__webpack_require__(21604)/* .commands */ .P);
var config = __webpack_require__(76321);
var TokenIterator = (__webpack_require__(99339).TokenIterator);
var GutterKeyboardHandler = (__webpack_require__(45545)/* .GutterKeyboardHandler */ .S);
var nls = (__webpack_require__(76321).nls);

var clipboard = __webpack_require__(65217);
var keys = __webpack_require__(29451);

var event = __webpack_require__(19631);
var HoverTooltip = (__webpack_require__(59864)/* .HoverTooltip */ .sX);

/**
 * The main entry point into the Ace functionality.
 *
 * The `Editor` manages the [[EditSession]] (which manages [[Document]]s), as well as the [[VirtualRenderer]], which draws everything to the screen.
 *
 * Event sessions dealing with the mouse and keyboard are bubbled up from `Document` to the `Editor`, which decides what to do with them.
 **/
class Editor {
    /**
     * Creates a new `Editor` object.
     *
     * @param {VirtualRenderer} renderer Associated `VirtualRenderer` that draws everything
     * @param {EditSession} [session] The `EditSession` to refer to
     * @param {Partial<import("../ace-internal").Ace.EditorOptions>} [options] The default options
     **/
    constructor(renderer, session, options) {
        /**@type {string}*/
        this.id = "editor" + (++Editor.$uid);
        /**@type{EditSession}*/this.session;
        this.$toDestroy = [];

        var container = renderer.getContainerElement();
        /**@type {HTMLElement & {env?:any, value?:any}}*/
        this.container = container;
        /**@type {VirtualRenderer}*/
        this.renderer = renderer;
        this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
        if (typeof document == "object") {
            this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
            this.renderer.textarea = this.textInput.getElement();
            // TODO detect touch event support
            /**@type {MouseHandler}*/
            this.$mouseHandler = new MouseHandler(this);
            new FoldHandler(this);
        }
        /**@type {KeyBinding}*/
        this.keyBinding = new KeyBinding(this);
        /**@type {Search}*/
        this.$search = new Search().set({
            wrap: true
        });

        this.$historyTracker = this.$historyTracker.bind(this);
        this.commands.on("exec", this.$historyTracker);

        this.$initOperationListeners();

        this._$emitInputEvent = lang.delayedCall(function() {
            this._signal("input", {});
            if (this.session && !this.session.destroyed)
                this.session.bgTokenizer.scheduleStart();
        }.bind(this));

        this.on("change", function(_, _self) {
            _self._$emitInputEvent.schedule(31);
        });

        this.setSession(session || options && options.session || new EditSession(""));
        config.resetOptions(this);
        if (options)
            this.setOptions(options);
        config._signal("editor", this);
    }

    $initOperationListeners() {
        this.commands.on("exec", this.startOperation.bind(this), true);
        this.commands.on("afterExec", this.endOperation.bind(this), true);
    }

    startOperation(commandEvent) {
        this.session.startOperation(commandEvent);
    }

    /**
     * @arg e
     */
    endOperation(e) {
        this.session.endOperation(e);
    }

    onStartOperation(commandEvent) {
        this.curOp = this.session.curOp;
        this.curOp.scrollTop = this.renderer.scrollTop;
        this.prevOp = this.session.prevOp;

        if (!commandEvent) {
            this.previousCommand = null;
        }
    }

    /**
     * @arg e
     */
    onEndOperation(e) {
        if (this.curOp && this.session) {
            if (e && e.returnValue === false) {
                this.curOp = null;
                return;
            }

            this._signal("beforeEndOperation");
            if (!this.curOp) return;

            var command = this.curOp.command;
            var scrollIntoView = command && command.scrollIntoView;
            if (scrollIntoView) {
                switch (scrollIntoView) {
                    case "center-animate":
                        scrollIntoView = "animate";
                    /* fall through */
                    case "center":
                        this.renderer.scrollCursorIntoView(null, 0.5);
                        break;
                    case "animate":
                    case "cursor":
                        this.renderer.scrollCursorIntoView();
                        break;
                    case "selectionPart":
                        var range = this.selection.getRange();
                        var config = this.renderer.layerConfig;
                        if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                        }
                        break;
                    default:
                        break;
                }
                if (scrollIntoView == "animate")
                    this.renderer.animateScrolling(this.curOp.scrollTop);
            }

            this.$lastSel = this.session.selection.toJSON();
            this.prevOp = this.curOp;
            this.curOp = null;
        }
    }

    /**
     * @param e
     */
    $historyTracker(e) {
        if (!this.$mergeUndoDeltas)
            return;

        var prev = this.prevOp;
        var mergeableCommands = this.$mergeableCommands;
        // previous command was the same
        var shouldMerge = prev.command && (e.command.name == prev.command.name);
        if (e.command.name == "insertstring") {
            var text = e.args;
            if (this.mergeNextCommand === undefined)
                this.mergeNextCommand = true;

            shouldMerge = shouldMerge
                && this.mergeNextCommand // previous command allows to coalesce with
                && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type

            this.mergeNextCommand = true;
        } else {
            shouldMerge = shouldMerge
                && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
        }

        if (
            this.$mergeUndoDeltas != "always"
            && Date.now() - this.sequenceStartTime > 2000
        ) {
            shouldMerge = false; // the sequence is too long
        }

        if (shouldMerge)
            this.session.mergeUndoDeltas = true;
        else if (mergeableCommands.indexOf(e.command.name) !== -1)
            this.sequenceStartTime = Date.now();
    }

    /**
     * Sets a new key handler, such as "vim" or "windows".
     * @param {String | import("../ace-internal").Ace.KeyboardHandler | null} keyboardHandler The new key handler
     * @param {() => void} [cb]
     **/
    setKeyboardHandler(keyboardHandler, cb) {
        if (keyboardHandler && typeof keyboardHandler === "string" && keyboardHandler != "ace") {
            this.$keybindingId = keyboardHandler;
            var _self = this;
            config.loadModule(["keybinding", keyboardHandler], function(module) {
                if (_self.$keybindingId == keyboardHandler)
                    _self.keyBinding.setKeyboardHandler(module && module.handler);
                cb && cb();
            });
        } else {
            this.$keybindingId = null;
            // @ts-ignore
            this.keyBinding.setKeyboardHandler(keyboardHandler);
            cb && cb();
        }
    }

    /**
     * Returns the keyboard handler, such as "vim" or "windows".
     * @returns {Object}
     **/
    getKeyboardHandler() {
        return this.keyBinding.getKeyboardHandler();
    }



    /**
     * Sets a new editsession to use. This method also emits the `'changeSession'` event.
     * @param {EditSession|null} [session] The new session to use
     **/
    setSession(session) {
        if (this.session == session)
            return;

        // make sure operationEnd events are not emitted to wrong session
        if (this.curOp) this.endOperation();
        this.curOp = {};

        var oldSession = this.session;
        if (oldSession) {
            this.session.off("change", this.$onDocumentChange);
            this.session.off("changeMode", this.$onChangeMode);
            this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
            this.session.off("changeTabSize", this.$onChangeTabSize);
            this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
            this.session.off("changeWrapMode", this.$onChangeWrapMode);
            this.session.off("changeFold", this.$onChangeFold);
            this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
            this.session.off("changeBackMarker", this.$onChangeBackMarker);
            this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
            this.session.off("changeAnnotation", this.$onChangeAnnotation);
            this.session.off("changeOverwrite", this.$onCursorChange);
            this.session.off("changeScrollTop", this.$onScrollTopChange);
            this.session.off("changeScrollLeft", this.$onScrollLeftChange);
            this.session.off("startOperation", this.$onStartOperation);
            this.session.off("endOperation", this.$onEndOperation);

            var selection = this.session.getSelection();
            selection.off("changeCursor", this.$onCursorChange);
            selection.off("changeSelection", this.$onSelectionChange);
        }

        this.session = session;
        if (session) {
            this.$onDocumentChange = this.onDocumentChange.bind(this);
            session.on("change", this.$onDocumentChange);
            this.renderer.setSession(session);

            this.$onChangeMode = this.onChangeMode.bind(this);
            session.on("changeMode", this.$onChangeMode);

            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
            session.on("tokenizerUpdate", this.$onTokenizerUpdate);

            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
            session.on("changeTabSize", this.$onChangeTabSize);

            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
            session.on("changeWrapLimit", this.$onChangeWrapLimit);

            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
            session.on("changeWrapMode", this.$onChangeWrapMode);

            this.$onChangeFold = this.onChangeFold.bind(this);
            session.on("changeFold", this.$onChangeFold);

            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
            this.session.on("changeFrontMarker", this.$onChangeFrontMarker);

            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
            this.session.on("changeBackMarker", this.$onChangeBackMarker);

            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
            this.session.on("changeBreakpoint", this.$onChangeBreakpoint);

            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
            this.session.on("changeAnnotation", this.$onChangeAnnotation);

            this.$onCursorChange = this.onCursorChange.bind(this);
            this.session.on("changeOverwrite", this.$onCursorChange);

            this.$onScrollTopChange = this.onScrollTopChange.bind(this);
            this.session.on("changeScrollTop", this.$onScrollTopChange);

            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
            this.session.on("changeScrollLeft", this.$onScrollLeftChange);

            this.selection = session.getSelection();
            this.selection.on("changeCursor", this.$onCursorChange);

            this.$onSelectionChange = this.onSelectionChange.bind(this);
            this.selection.on("changeSelection", this.$onSelectionChange);

            this.$onStartOperation = this.onStartOperation.bind(this);
            this.session.on("startOperation", this.$onStartOperation);
            this.$onEndOperation = this.onEndOperation.bind(this);
            this.session.on("endOperation", this.$onEndOperation);

            this.onChangeMode();

            this.onCursorChange();

            this.onScrollTopChange();
            this.onScrollLeftChange();
            this.onSelectionChange();
            this.onChangeFrontMarker();
            this.onChangeBackMarker();
            this.onChangeBreakpoint();
            this.onChangeAnnotation();
            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
            this.renderer.updateFull();
        } else {
            this.selection = null;
            this.renderer.setSession(session);
        }

        this._signal("changeSession", {
            session: session,
            oldSession: oldSession
        });

        this.curOp = null;

        oldSession && oldSession._signal("changeEditor", {oldEditor: this});
        if (oldSession) oldSession.$editor = null;
        session && session._signal("changeEditor", {editor: this});
        if (session) session.$editor = this;

        if (session && !session.destroyed)
            session.bgTokenizer.scheduleStart();
    }

    /**
     * Returns the current session being used.
     * @returns {EditSession}
     **/
    getSession() {
        return this.session;
    }

    /**
     * Sets the current document to `val`.
     * @param {String} val The new value to set for the document
     * @param {Number} [cursorPos] Where to set the new value. `undefined` or 0 is selectAll, -1 is at the document start, and 1 is at the end
     *
     * @returns {String} The current document value
     * @related Document.setValue
     **/
    setValue(val, cursorPos) {
        this.session.doc.setValue(val);

        if (!cursorPos)
            this.selectAll();
        else if (cursorPos == 1)
            this.navigateFileEnd();
        else if (cursorPos == -1)
            this.navigateFileStart();

        return val;
    }

    /**
     * Returns the current session's content.
     *
     * @returns {String}
     * @related EditSession.getValue
     **/
    getValue() {
        return this.session.getValue();
    }

    /**
     *
     * Returns the currently highlighted selection.
     * @returns {Selection} The selection object
     **/
    getSelection() {
        return this.selection;
    }

    /**
     * {:VirtualRenderer.onResize}
     * @param {Boolean} [force] If `true`, recomputes the size, even if the height and width haven't changed
     * @related VirtualRenderer.onResize
     **/
    resize(force) {
        this.renderer.onResize(force);
    }

    /**
     * {:VirtualRenderer.setTheme}
     * @param {string | import("../ace-internal").Ace.Theme} theme The path to a theme
     * @param {() => void} [cb] optional callback called when theme is loaded
     **/
    setTheme(theme, cb) {
        this.renderer.setTheme(theme, cb);
    }

    /**
     * {:VirtualRenderer.getTheme}
     *
     * @returns {String} The set theme
     * @related VirtualRenderer.getTheme
     **/
    getTheme() {
        return this.renderer.getTheme();
    }

    /**
     * {:VirtualRenderer.setStyle}
     * @param {String} style A class name
     * @param {boolean} [incluude] pass false to remove the class name
     * @related VirtualRenderer.setStyle
     **/
    setStyle(style, incluude) {
        this.renderer.setStyle(style, incluude);
    }

    /**
     * {:VirtualRenderer.unsetStyle}
     * @related VirtualRenderer.unsetStyle
     * @param {string} style
     */
    unsetStyle(style) {
        this.renderer.unsetStyle(style);
    }

    /**
     * Gets the current font size of the editor text.
     * @return {string | number}
     */
    getFontSize() {
        return this.getOption("fontSize") ||
            dom.computedStyle(this.container).fontSize;
    }

    /**
     * Set a new font size (in pixels) for the editor text.
     * @param {String | number} size A font size ( _e.g._ "12px")
     **/
    setFontSize(size) {
        this.setOption("fontSize", size);
    }

    $highlightBrackets() {
        if (this.$highlightPending) {
            return;
        }

        // perform highlight async to not block the browser during navigation
        var self = this;
        this.$highlightPending = true;
        setTimeout(function () {
            self.$highlightPending = false;
            var session = self.session;
            if (!session || session.destroyed) return;
            if (session.$bracketHighlight) {
                session.$bracketHighlight.markerIds.forEach(function(id) {
                    session.removeMarker(id);
                });
                session.$bracketHighlight = null;
            }
            var pos = self.getCursorPosition();
            var handler = self.getKeyboardHandler();
            var isBackwards = handler && handler.$getDirectionForHighlight && handler.$getDirectionForHighlight(self);
            var ranges = session.getMatchingBracketRanges(pos, isBackwards);

            if (!ranges) {
                var iterator = new TokenIterator(session, pos.row, pos.column);
                var token = iterator.getCurrentToken();

                if (token && /\b(?:tag-open|tag-name)/.test(token.type)) {
                    var tagNamesRanges = session.getMatchingTags(pos);
                    if (tagNamesRanges) {
                        ranges = [
                            tagNamesRanges.openTagName.isEmpty() ? tagNamesRanges.openTag : tagNamesRanges.openTagName,
                            tagNamesRanges.closeTagName.isEmpty() ? tagNamesRanges.closeTag : tagNamesRanges.closeTagName
                        ];
                    }
                }
            }
            if (!ranges && session.$mode.getMatching)
                ranges = session.$mode.getMatching(self.session);
            if (!ranges) {
                if (self.getHighlightIndentGuides()) self.renderer.$textLayer.$highlightIndentGuide();
                return;
            }

            var markerType = "ace_bracket";
            if (!Array.isArray(ranges)) {
                ranges = [ranges];
            } else if (ranges.length == 1) {
                markerType = "ace_error_bracket";
            }

            // show adjacent ranges as one
            if (ranges.length == 2) {
                if (Range.comparePoints(ranges[0].end, ranges[1].start) == 0)
                    ranges = [Range.fromPoints(ranges[0].start, ranges[1].end)];
                else if (Range.comparePoints(ranges[0].start, ranges[1].end) == 0)
                    ranges = [Range.fromPoints(ranges[1].start, ranges[0].end)];
            }

            session.$bracketHighlight = {
                ranges: ranges,
                markerIds: ranges.map(function(range) {
                    return session.addMarker(range, markerType, "text");
                })
            };
            if (self.getHighlightIndentGuides()) self.renderer.$textLayer.$highlightIndentGuide();
        }, 50);
    }

    /**
     *
     * Brings the current `textInput` into focus.
     **/
    focus() {
        this.textInput.focus();
    }

    /**
     * Returns `true` if the current `textInput` is in focus.
     * @return {Boolean}
     **/
    isFocused() {
        return this.textInput.isFocused();
    }

    /**
     *
     * Blurs the current `textInput`.
     **/
    blur() {
        this.textInput.blur();
    }

    /**
     * Emitted once the editor comes into focus.
     * @internal
     **/
    onFocus(e) {
        if (this.$isFocused)
            return;
        this.$isFocused = true;
        this.renderer.showCursor();
        this.renderer.visualizeFocus();
        this._emit("focus", e);
    }

    /**
     * Emitted once the editor has been blurred.
     * @internal
     **/
    onBlur(e) {
        if (!this.$isFocused)
            return;
        this.$isFocused = false;
        this.renderer.hideCursor();
        this.renderer.visualizeBlur();
        this._emit("blur", e);
    }

    /**
     */
    $cursorChange() {
        this.renderer.updateCursor();
        this.$highlightBrackets();
        this.$updateHighlightActiveLine();
    }

    /**
     * Emitted whenever the document is changed.
     * @param {import("../ace-internal").Ace.Delta} delta Contains a single property, `data`, which has the delta of changes
     * @internal
     **/
    onDocumentChange(delta) {
        // Rerender and emit "change" event.
        var wrap = this.session.$useWrapMode;
        var lastRow = (delta.start.row == delta.end.row ? delta.end.row : Infinity);
        this.renderer.updateLines(delta.start.row, lastRow, wrap);

        this._signal("change", delta);

        // Update cursor because tab characters can influence the cursor position.
        this.$cursorChange();
    }

    /**
     * @internal
     */
    onTokenizerUpdate(e) {
        var rows = e.data;
        this.renderer.updateLines(rows.first, rows.last);
    }

    /**
     * @internal
     */
    onScrollTopChange() {
        this.renderer.scrollToY(this.session.getScrollTop());
    }

    /**
     * @internal
     */
    onScrollLeftChange() {
        this.renderer.scrollToX(this.session.getScrollLeft());
    }

    /**
     * Emitted when the selection changes.
     * @internal
     **/
    onCursorChange() {
        this.$cursorChange();
        this._signal("changeSelection");
    }

    /**
     */
    $updateHighlightActiveLine() {
        var session = this.getSession();
        /**@type {Point|false}*/
        var highlight;
        if (this.$highlightActiveLine) {
            if (this.$selectionStyle != "line" || !this.selection.isMultiLine())
                highlight = this.getCursorPosition();
            if (this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty())
                highlight = false;
            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
                highlight = false;
        }

        if (session.$highlightLineMarker && !highlight) {
            session.removeMarker(session.$highlightLineMarker.id);
            session.$highlightLineMarker = null;
        } else if (!session.$highlightLineMarker && highlight) {
            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
            range.id = session.addMarker(range, "ace_active-line", "screenLine");
            session.$highlightLineMarker = range;
        } else if (highlight) {
            session.$highlightLineMarker.start.row = highlight.row;
            session.$highlightLineMarker.end.row = highlight.row;
            session.$highlightLineMarker.start.column = highlight.column;
            session._signal("changeBackMarker");
        }
    }

    /**
     * @param e
     * @internal
     */
    onSelectionChange(e) {
        var session = this.session;

        if (session.$selectionMarker) {
            session.removeMarker(session.$selectionMarker);
        }
        session.$selectionMarker = null;

        if (!this.selection.isEmpty()) {
            var range = this.selection.getRange();
            var style = this.getSelectionStyle();
            session.$selectionMarker = session.addMarker(range, "ace_selection", style);
        } else {
            this.$updateHighlightActiveLine();
        }

        var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
        this.session.highlight(re);

        this._signal("changeSelection");
    }

    $getSelectionHighLightRegexp() {
        var session = this.session;

        var selection = this.getSelectionRange();
        if (selection.isEmpty() || selection.isMultiLine())
            return;

        var startColumn = selection.start.column;
        var endColumn = selection.end.column;
        var line = session.getLine(selection.start.row);

        var needle = line.substring(startColumn, endColumn);
        // maximum allowed size for regular expressions in 32000,
        // but getting close to it has significant impact on the performance
        if (needle.length > 5000 || !/[\w\d]/.test(needle))
            return;

        var re = this.$search.$assembleRegExp({
            wholeWord: true,
            caseSensitive: true,
            needle: needle
        });

        var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);
        if (!re.test(wordWithBoundary))
            return;

        return re;
    }

    /**
     * @internal
     */
    onChangeFrontMarker() {
        this.renderer.updateFrontMarkers();
    }

    /**
     * @internal
     */
    onChangeBackMarker() {
        this.renderer.updateBackMarkers();
    }

    /**
     * @internal
     */
    onChangeBreakpoint() {
        this.renderer.updateBreakpoints();
    }

    /**
     * @internal
     */
    onChangeAnnotation() {
        this.renderer.setAnnotations(this.session.getAnnotations());
    }

    /**
     * @param e
     * @internal
     */
    onChangeMode (e) {
        this.renderer.updateText();
        this._emit("changeMode", e);
    }

    /**
     * @internal
     */
    onChangeWrapLimit() {
        this.renderer.updateFull();
    }

    /**
     * @internal
     */
    onChangeWrapMode() {
        this.renderer.onResize(true);
    }


    /**
     * @internal
     */
    onChangeFold() {
        // Update the active line marker as due to folding changes the current
        // line range on the screen might have changed.
        this.$updateHighlightActiveLine();
        // TODO: This might be too much updating. Okay for now.
        this.renderer.updateFull();
    }


    /**
     * Returns the string of text currently highlighted.
     * @returns {String}
     **/
    getSelectedText() {
        return this.session.getTextRange(this.getSelectionRange());
    }


    /**
     * Returns the string of text currently highlighted.
     * @returns {String}
     **/
    getCopyText () {
        var text = this.getSelectedText();
        var nl = this.session.doc.getNewLineCharacter();
        var copyLine= false;
        if (!text && this.$copyWithEmptySelection) {
            copyLine = true;
            var ranges = this.selection.getAllRanges();
            for (var i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                if (i && ranges[i - 1].start.row == range.start.row)
                    continue;
                text += this.session.getLine(range.start.row) + nl;
            }
        }
        var e = {text: text};
        this._signal("copy", e);
        clipboard.lineMode = copyLine ? e.text : false;
        return e.text;
    }

    /**
     * Called whenever a text "copy" happens.
     * @internal
     **/
    onCopy() {
        this.commands.exec("copy", this);
    }

    /**
     * Called whenever a text "cut" happens.
     * @internal
     **/
    onCut() {
        this.commands.exec("cut", this);
    }


    /**
     * Called whenever a text "paste" happens.
     * @param {String} text The pasted text
     * @param {ClipboardEvent} [event]
     * @internal
     **/
    onPaste(text, event) {
        var e = {text: text, event: event};
        this.commands.exec("paste", this, e);
    }

    /**
     *
     * @param {string | {text: string, event?: ClipboardEvent}} e
     * @returns {boolean}
     */
    $handlePaste(e) {
        if (typeof e == "string")
            e = {text: e};
        this._signal("paste", e);
        var text = e.text;

        var lineMode = text === clipboard.lineMode;
        var session = this.session;
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
            if (lineMode)
                session.insert({ row: this.selection.lead.row, column: 0 }, text);
            else
                this.insert(text);
        } else if (lineMode) {
            this.selection.rangeList.ranges.forEach(function(range) {
                session.insert({ row: range.start.row, column: 0 }, text);
            });
        } else {
            var lines = text.split(/\r\n|\r|\n/);
            var ranges = this.selection.rangeList.ranges;

            var isFullLine = lines.length == 2 && (!lines[0] || !lines[1]);
            if (lines.length != ranges.length || isFullLine)
                return this.commands.exec("insertstring", this, text);

            for (var i = ranges.length; i--;) {
                var range = ranges[i];
                if (!range.isEmpty())
                    session.remove(range);

                session.insert(range.start, lines[i]);
            }
        }
    }

    /**
     *
     * @param {string | string[] | import("../ace-internal").Ace.Command} command
     * @param [args]
     * @return {boolean}
     */
    execCommand(command, args) {
        return this.commands.exec(command, this, args);
    }

    /**
     * Inserts `text` into wherever the cursor is pointing.
     * @param {String} text The new text to add
     * @param {boolean} [pasted]
     **/
    insert(text, pasted) {
        var session = this.session;
        var mode = session.getMode();
        var cursor = this.getCursorPosition();

        if (this.getBehavioursEnabled() && !pasted) {
            // Get a transform if the current mode wants one.
            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
            if (transform) {
                if (text !== transform.text) {
                    // keep automatic insertion in a separate delta, unless it is in multiselect mode
                    if (!this.inVirtualSelectionMode) {
                        this.session.mergeUndoDeltas = false;
                        this.mergeNextCommand = false;
                    }
                }
                text = transform.text;

            }
        }

        if (text == "\t")
            text = this.session.getTabString();

        // remove selected text
        if (!this.selection.isEmpty()) {
            var range = this.getSelectionRange();
            cursor = this.session.remove(range);
            this.clearSelection();
        }
        else if (this.session.getOverwrite() && text.indexOf("\n") == -1) {
            var range = Range.fromPoints(cursor, cursor);
            range.end.column += text.length;
            this.session.remove(range);
        }

        if (text == "\n" || text == "\r\n") {
            var line = session.getLine(cursor.row);
            if (cursor.column > line.search(/\S|$/)) {
                var d = line.substr(cursor.column).search(/\S|$/);
                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
            }
        }
        this.clearSelection();

        var start = cursor.column;
        var lineState = session.getState(cursor.row);
        var line = session.getLine(cursor.row);
        var shouldOutdent = mode.checkOutdent(lineState, line, text);
        session.insert(cursor, text);

        if (transform && transform.selection) {
            if (transform.selection.length == 2) { // Transform relative to the current column
                this.selection.setSelectionRange(
                    new Range(cursor.row, start + transform.selection[0],
                        cursor.row, start + transform.selection[1]));
            } else { // Transform relative to the current row.
                this.selection.setSelectionRange(
                    new Range(cursor.row + transform.selection[0],
                        transform.selection[1],
                        cursor.row + transform.selection[2],
                        transform.selection[3]));
            }
        }
        if (this.$enableAutoIndent) {
            if (session.getDocument().isNewLine(text)) {
                var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());

                session.insert({row: cursor.row+1, column: 0}, lineIndent);
            }
            if (shouldOutdent)
                mode.autoOutdent(lineState, session, cursor.row);
        }
    }

    autoIndent() {
        var session = this.session;
        var mode = session.getMode();

        var ranges = this.selection.isEmpty()
            ? [new Range(0, 0, session.doc.getLength() - 1, 0)]
            : this.selection.getAllRanges();

        /**@type{string|string[]}*/
        var prevLineState = "";
        var prevLine = "";
        var lineIndent = "";
        var tab = session.getTabString();
        for (var i = 0; i < ranges.length; i++) {
            var startRow = ranges[i].start.row;
            var endRow = ranges[i].end.row;

            for (var row = startRow; row <= endRow; row++) {
                if (row > 0) {
                    prevLineState = session.getState(row - 1);
                    prevLine = session.getLine(row - 1);
                    lineIndent = mode.getNextLineIndent(prevLineState, prevLine, tab);
                }

                var line = session.getLine(row);
                var currIndent = mode.$getIndent(line);
                if (lineIndent !== currIndent) {
                    if (currIndent.length > 0) {
                        var range = new Range(row, 0, row, currIndent.length);
                        session.remove(range);
                    }
                    if (lineIndent.length > 0) {
                        session.insert({row: row, column: 0}, lineIndent);
                    }
                }

                mode.autoOutdent(prevLineState, session, row);
            }
        }
    }

    /**
     *
     * @param text
     * @param composition
     * @returns {*}
     * @internal
     */
    onTextInput(text, composition) {
        if (!composition)
            return this.keyBinding.onTextInput(text);

        this.startOperation({command: { name: "insertstring" }});
        var applyComposition = this.applyComposition.bind(this, text, composition);
        if (this.selection.rangeCount)
            this.forEachSelection(applyComposition);
        else
            applyComposition();
        this.endOperation();
    }

    /**
     * @param {string} [text]
     * @param {any} [composition]
     */
    applyComposition(text, composition) {
        if (composition.extendLeft || composition.extendRight) {
            var r = this.selection.getRange();
            r.start.column -= composition.extendLeft;
            r.end.column += composition.extendRight;
            if (r.start.column < 0) {
                r.start.row--;
                r.start.column += this.session.getLine(r.start.row).length + 1;
            }
            this.selection.setRange(r);
            if (!text && !r.isEmpty())
                this.remove();
        }
        if (text || !this.selection.isEmpty())
            this.insert(text, true);
        if (composition.restoreStart || composition.restoreEnd) {
            var r = this.selection.getRange();
            r.start.column -= composition.restoreStart;
            r.end.column -= composition.restoreEnd;
            this.selection.setRange(r);
        }
    }

    /**
     * @internal
     */
    onCommandKey(e, hashId, keyCode) {
        return this.keyBinding.onCommandKey(e, hashId, keyCode);
    }

    /**
     * Pass in `true` to enable overwrites in your session, or `false` to disable. If overwrites is enabled, any text you enter will type over any text after it. If the value of `overwrite` changes, this function also emits the `changeOverwrite` event.
     * @param {Boolean} overwrite Defines whether or not to set overwrites
     * @related EditSession.setOverwrite
     **/
    setOverwrite(overwrite) {
        this.session.setOverwrite(overwrite);
    }

    /**
     * Returns `true` if overwrites are enabled; `false` otherwise.
     * @returns {Boolean}
     * @related EditSession.getOverwrite
     **/
    getOverwrite() {
        return this.session.getOverwrite();
    }

    /**
     * Sets the value of overwrite to the opposite of whatever it currently is.
     * @related EditSession.toggleOverwrite
     **/
    toggleOverwrite() {
        this.session.toggleOverwrite();
    }

    /**
     * Sets how fast the mouse scrolling should do.
     * @param {Number} speed A value indicating the new speed (in milliseconds)
     **/
    setScrollSpeed(speed) {
        this.setOption("scrollSpeed", speed);
    }

    /**
     * Returns the value indicating how fast the mouse scroll speed is (in milliseconds).
     * @returns {Number}
     **/
    getScrollSpeed() {
        return this.getOption("scrollSpeed");
    }

    /**
     * Sets the delay (in milliseconds) of the mouse drag.
     * @param {Number} dragDelay A value indicating the new delay
     **/
    setDragDelay(dragDelay) {
        this.setOption("dragDelay", dragDelay);
    }

    /**
     * Returns the current mouse drag delay.
     * @returns {Number}
     **/
    getDragDelay() {
        return this.getOption("dragDelay");
    }


    /**
     * Draw selection markers spanning whole line, or only over selected text. Default value is "line"
     * @param {"fullLine" | "screenLine" | "text" | "line"} val The new selection style "line"|"text"
     **/
    setSelectionStyle(val) {
        this.setOption("selectionStyle", val);
    }

    /**
     * Returns the current selection style.
     * @returns {import("../ace-internal").Ace.EditorOptions["selectionStyle"]}
     **/
    getSelectionStyle() {
        return this.getOption("selectionStyle");
    }

    /**
     * Determines whether or not the current line should be highlighted.
     * @param {Boolean} shouldHighlight Set to `true` to highlight the current line
     **/
    setHighlightActiveLine(shouldHighlight) {
        this.setOption("highlightActiveLine", shouldHighlight);
    }
    /**
     * Returns `true` if current lines are always highlighted.
     * @return {Boolean}
     **/
    getHighlightActiveLine() {
        return this.getOption("highlightActiveLine");
    }

    /**
     * @param {boolean} shouldHighlight
     */
    setHighlightGutterLine(shouldHighlight) {
        this.setOption("highlightGutterLine", shouldHighlight);
    }

    /**
     * @returns {Boolean}
     */
    getHighlightGutterLine() {
        return this.getOption("highlightGutterLine");
    }

    /**
     * Determines if the currently selected word should be highlighted.
     * @param {Boolean} shouldHighlight Set to `true` to highlight the currently selected word
     **/
    setHighlightSelectedWord(shouldHighlight) {
        this.setOption("highlightSelectedWord", shouldHighlight);
    }

    /**
     * Returns `true` if currently highlighted words are to be highlighted.
     * @returns {Boolean}
     **/
    getHighlightSelectedWord() {
        return this.$highlightSelectedWord;
    }

    /**
     * @param {boolean} shouldAnimate
     */
    setAnimatedScroll(shouldAnimate){
        this.renderer.setAnimatedScroll(shouldAnimate);
    }

    /**
     * @return {boolean}
     */
    getAnimatedScroll(){
        return this.renderer.getAnimatedScroll();
    }

    /**
     * If `showInvisibles` is set to `true`, invisible characters&mdash;like spaces or new lines&mdash;are show in the editor.
     * @param {Boolean} showInvisibles Specifies whether or not to show invisible characters
     **/
    setShowInvisibles(showInvisibles) {
        this.renderer.setShowInvisibles(showInvisibles);
    }

    /**
     * Returns `true` if invisible characters are being shown.
     * @returns {Boolean}
     **/
    getShowInvisibles() {
        return this.renderer.getShowInvisibles();
    }

    /**
     * @param {boolean} display
     */
    setDisplayIndentGuides(display) {
        this.renderer.setDisplayIndentGuides(display);
    }

    /**
     * @return {boolean}
     */
    getDisplayIndentGuides() {
        return this.renderer.getDisplayIndentGuides();
    }

    /**
     * @param {boolean} highlight
     */
    setHighlightIndentGuides(highlight) {
        this.renderer.setHighlightIndentGuides(highlight);
    }

    /**
     * @return {boolean}
     */
    getHighlightIndentGuides() {
        return this.renderer.getHighlightIndentGuides();
    }

    /**
     * If `showPrintMargin` is set to `true`, the print margin is shown in the editor.
     * @param {Boolean} showPrintMargin Specifies whether or not to show the print margin
     *
     **/
    setShowPrintMargin(showPrintMargin) {
        this.renderer.setShowPrintMargin(showPrintMargin);
    }

    /**
     * Returns `true` if the print margin is being shown.
     * @returns {Boolean}
     **/
    getShowPrintMargin() {
        return this.renderer.getShowPrintMargin();
    }

    /**
     * Sets the column defining where the print margin should be.
     * @param {Number} showPrintMargin Specifies the new print margin
     *
     **/
    setPrintMarginColumn(showPrintMargin) {
        this.renderer.setPrintMarginColumn(showPrintMargin);
    }

    /**
     * Returns the column number of where the print margin is.
     * @returns {Number}
     **/
    getPrintMarginColumn() {
        return this.renderer.getPrintMarginColumn();
    }

    /**
     * If `readOnly` is true, then the editor is set to read-only mode, and none of the content can change.
     * @param {Boolean} readOnly Specifies whether the editor can be modified or not
     **/
    setReadOnly(readOnly) {
        this.setOption("readOnly", readOnly);
    }

    /**
     * Returns `true` if the editor is set to read-only mode.
     * @returns {Boolean}
     **/
    getReadOnly() {
        return this.getOption("readOnly");
    }

    /**
     * Specifies whether to use behaviors or not. ["Behaviors" in this case is the auto-pairing of special characters, like quotation marks, parenthesis, or brackets.]{: #BehaviorsDef}
     * @param {Boolean} enabled Enables or disables behaviors
     **/
    setBehavioursEnabled(enabled) {
        this.setOption("behavioursEnabled", enabled);
    }

    /**
     * Returns `true` if the behaviors are currently enabled. {:BehaviorsDef}
     * @returns {Boolean}
     **/
    getBehavioursEnabled() {
        return this.getOption("behavioursEnabled");
    }

    /**
     * Specifies whether to use wrapping behaviors or not, i.e. automatically wrapping the selection with characters such as brackets
     * when such a character is typed in.
     * @param {Boolean} enabled Enables or disables wrapping behaviors
     **/
    setWrapBehavioursEnabled(enabled) {
        this.setOption("wrapBehavioursEnabled", enabled);
    }

    /**
     * Returns `true` if the wrapping behaviors are currently enabled.
     * @returns {boolean}
     **/
    getWrapBehavioursEnabled() {
        return this.getOption("wrapBehavioursEnabled");
    }

    /**
     * Indicates whether the fold widgets should be shown or not.
     * @param {Boolean} show Specifies whether the fold widgets are shown
     **/
    setShowFoldWidgets(show) {
        this.setOption("showFoldWidgets", show);

    }
    /**
     * Returns `true` if the fold widgets are shown.
     * @return {Boolean}
     **/
    getShowFoldWidgets() {
        return this.getOption("showFoldWidgets");
    }

    /**
     * @param {boolean} fade
     */
    setFadeFoldWidgets(fade) {
        this.setOption("fadeFoldWidgets", fade);
    }

    /**
     * @returns {boolean}
     */
    getFadeFoldWidgets() {
        return this.getOption("fadeFoldWidgets");
    }

    /**
     * Removes the current selection or one character.
     * @param {'left' | 'right'} [dir] The direction of the deletion to occur, either "left" or "right"
     **/
    remove(dir) {
        if (this.selection.isEmpty()){
            if (dir == "left")
                this.selection.selectLeft();
            else
                this.selection.selectRight();
        }

        var range = this.getSelectionRange();
        if (this.getBehavioursEnabled()) {
            var session = this.session;
            var state = session.getState(range.start.row);
            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);

            if (range.end.column === 0) {
                var text = session.getTextRange(range);
                if (text[text.length - 1] == "\n") {
                    var line = session.getLine(range.end.row);
                    if (/^\s+$/.test(line)) {
                        range.end.column = line.length;
                    }
                }
            }
            if (new_range)
                // @ts-expect-error TODO: possible bug, new_range could be not a Range
                range = new_range;
        }

        this.session.remove(range);
        this.clearSelection();
    }

    /**
     * Removes the word directly to the right of the current selection.
     **/
    removeWordRight() {
        if (this.selection.isEmpty())
            this.selection.selectWordRight();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    }

    /**
     * Removes the word directly to the left of the current selection.
     **/
    removeWordLeft() {
        if (this.selection.isEmpty())
            this.selection.selectWordLeft();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    }

    /**
     * Removes all the words to the left of the current selection, until the start of the line.
     **/
    removeToLineStart() {
        if (this.selection.isEmpty())
            this.selection.selectLineStart();
        if (this.selection.isEmpty())
            this.selection.selectLeft();
        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    }

    /**
     * Removes all the words to the right of the current selection, until the end of the line.
     **/
    removeToLineEnd() {
        if (this.selection.isEmpty())
            this.selection.selectLineEnd();

        var range = this.getSelectionRange();
        if (range.start.column == range.end.column && range.start.row == range.end.row) {
            range.end.column = 0;
            range.end.row++;
        }

        this.session.remove(range);
        this.clearSelection();
    }

    /**
     * Splits the line at the current selection (by inserting an `'\n'`).
     **/
    splitLine() {
        if (!this.selection.isEmpty()) {
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
        }

        var cursor = this.getCursorPosition();
        this.insert("\n");
        this.moveCursorToPosition(cursor);
    }

    /**
     * Set the "ghost" text in provided position. "Ghost" text is a kind of
     * preview text inside the editor which can be used to preview some code
     * inline in the editor such as, for example, code completions.
     *
     * @param {String} text Text to be inserted as "ghost" text
     * @param {Point} [position] Position to insert text to
     */
    setGhostText(text, position) {
        this.renderer.setGhostText(text, position);
    }

    /**
     * Removes "ghost" text currently displayed in the editor.
     */
    removeGhostText() {
        this.renderer.removeGhostText();
    }

    /**
     * Transposes current line.
     **/
    transposeLetters() {
        if (!this.selection.isEmpty()) {
            return;
        }

        var cursor = this.getCursorPosition();
        var column = cursor.column;
        if (column === 0)
            return;

        var line = this.session.getLine(cursor.row);
        var swap, range;
        if (column < line.length) {
            swap = line.charAt(column) + line.charAt(column-1);
            range = new Range(cursor.row, column-1, cursor.row, column+1);
        }
        else {
            swap = line.charAt(column-1) + line.charAt(column-2);
            range = new Range(cursor.row, column-2, cursor.row, column);
        }
        this.session.replace(range, swap);
        this.session.selection.moveToPosition(range.end);
    }

    /**
     * Converts the current selection entirely into lowercase.
     **/
    toLowerCase() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }

        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toLowerCase());
        this.selection.setSelectionRange(originalRange);
    }

    /**
     * Converts the current selection entirely into uppercase.
     **/
    toUpperCase() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }

        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toUpperCase());
        this.selection.setSelectionRange(originalRange);
    }

    /**
     * Inserts an indentation into the current cursor position or indents the selected lines.
     *
     * @related EditSession.indentRows
     **/
    indent() {
        var session = this.session;
        var range = this.getSelectionRange();

        if (range.start.row < range.end.row) {
            var rows = this.$getSelectedRows();
            session.indentRows(rows.first, rows.last, "\t");
            return;
        } else if (range.start.column < range.end.column) {
            var text = session.getTextRange(range);
            if (!/^\s+$/.test(text)) {
                var rows = this.$getSelectedRows();
                session.indentRows(rows.first, rows.last, "\t");
                return;
            }
        }

        var line = session.getLine(range.start.row);
        var position = range.start;
        var size = session.getTabSize();
        var column = session.documentToScreenColumn(position.row, position.column);

        if (this.session.getUseSoftTabs()) {
            var count = (size - column % size);
            var indentString = lang.stringRepeat(" ", count);
        } else {
            var count = column % size;
            while (line[range.start.column - 1] == " " && count) {
                range.start.column--;
                count--;
            }
            this.selection.setSelectionRange(range);
            indentString = "\t";
        }
        return this.insert(indentString);
    }

    /**
     * Indents the current line.
     * @related EditSession.indentRows
     **/
    blockIndent() {
        var rows = this.$getSelectedRows();
        this.session.indentRows(rows.first, rows.last, "\t");
    }

    /**
     * Outdents the current line.
     * @related EditSession.outdentRows
     **/
    blockOutdent() {
        var selection = this.session.getSelection();
        this.session.outdentRows(selection.getRange());
    }

    // TODO: move out of core when we have good mechanism for managing extensions
    sortLines() {
        var rows = this.$getSelectedRows();
        var session = this.session;

        var lines = [];
        for (var i = rows.first; i <= rows.last; i++)
            lines.push(session.getLine(i));

        lines.sort(function(a, b) {
            if (a.toLowerCase() < b.toLowerCase()) return -1;
            if (a.toLowerCase() > b.toLowerCase()) return 1;
            return 0;
        });

        var deleteRange = new Range(0, 0, 0, 0);
        for (var i = rows.first; i <= rows.last; i++) {
            var line = session.getLine(i);
            deleteRange.start.row = i;
            deleteRange.end.row = i;
            deleteRange.end.column = line.length;
            session.replace(deleteRange, lines[i-rows.first]);
        }
    }

    /**
     * Given the currently selected range, this function either comments all the lines, or uncomments all of them.
     **/
    toggleCommentLines() {
        var state = this.session.getState(this.getCursorPosition().row);
        var rows = this.$getSelectedRows();
        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
    }

    toggleBlockComment() {
        var cursor = this.getCursorPosition();
        var state = this.session.getState(cursor.row);
        var range = this.getSelectionRange();
        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
    }

    /**
     * Works like [[EditSession.getTokenAt]], except it returns a number.
     * @returns {any}
     **/
    getNumberAt(row, column) {
        var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
        _numberRx.lastIndex = 0;

        var s = this.session.getLine(row);
        while (_numberRx.lastIndex < column) {
            var m = _numberRx.exec(s);
            if(m.index <= column && m.index+m[0].length >= column){
                var number = {
                    value: m[0],
                    start: m.index,
                    end: m.index+m[0].length
                };
                return number;
            }
        }
        return null;
    }

    /**
     * If the character before the cursor is a number, this functions changes its value by `amount`.
     * @param {Number} amount The value to change the numeral by (can be negative to decrease value)
     **/
    modifyNumber(amount) {
        var row = this.selection.getCursor().row;
        var column = this.selection.getCursor().column;

        // get the char before the cursor
        var charRange = new Range(row, column-1, row, column);

        var c = this.session.getTextRange(charRange);
        // if the char is a digit
        // @ts-ignore
        if (!isNaN(parseFloat(c)) && isFinite(c)) {
            // get the whole number the digit is part of
            var nr = this.getNumberAt(row, column);
            // if number found
            if (nr) {
                var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                var decimals = nr.start + nr.value.length - fp;

                var t = parseFloat(nr.value);
                t *= Math.pow(10, decimals);


                if(fp !== nr.end && column < fp){
                    amount *= Math.pow(10, nr.end - column - 1);
                } else {
                    amount *= Math.pow(10, nr.end - column);
                }

                t += amount;
                t /= Math.pow(10, decimals);
                var nnr = t.toFixed(decimals);

                //update number
                var replaceRange = new Range(row, nr.start, row, nr.end);
                this.session.replace(replaceRange, nnr);

                //reposition the cursor
                this.moveCursorTo(row, Math.max(nr.start +1, column + nnr.length - nr.value.length));

            }
        } else {
            this.toggleWord();
        }
    }

    /**
     */
    toggleWord() {
        var row = this.selection.getCursor().row;
        var column = this.selection.getCursor().column;
        this.selection.selectWord();
        var currentState = this.getSelectedText();
        var currWordStart = this.selection.getWordRange().start.column;
        var wordParts = currentState.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, '$1 ').split(/\s/);
        var delta = column - currWordStart - 1;
        if (delta < 0) delta = 0;
        var curLength = 0, itLength = 0;
        var that = this;
        if (currentState.match(/[A-Za-z0-9_]+/)) {
            wordParts.forEach(function (item, i) {
                itLength = curLength + item.length;
                if (delta >= curLength && delta <= itLength) {
                    currentState = item;
                    that.selection.clearSelection();
                    that.moveCursorTo(row, curLength + currWordStart);
                    that.selection.selectTo(row, itLength + currWordStart);
                }
                curLength = itLength;
            });
        }

        var wordPairs = this.$toggleWordPairs;
        var reg;
        for (var i = 0; i < wordPairs.length; i++) {
            var item = wordPairs[i];
            for (var j = 0; j <= 1; j++) {
                var negate = +!j;
                var firstCondition = currentState.match(new RegExp('^\\s?_?(' + lang.escapeRegExp(item[j]) + ')\\s?$', 'i'));
                if (firstCondition) {
                    var secondCondition = currentState.match(new RegExp('([_]|^|\\s)(' + lang.escapeRegExp(firstCondition[1]) + ')($|\\s)', 'g'));
                    if (secondCondition) {
                        reg = currentState.replace(new RegExp(lang.escapeRegExp(item[j]), 'i'), function (result) {
                            var res = item[negate];
                            if (result.toUpperCase() == result) {
                                res = res.toUpperCase();
                            } else if (result.charAt(0).toUpperCase() == result.charAt(0)) {
                                res = res.substr(0, 0) + item[negate].charAt(0).toUpperCase() + res.substr(1);
                            }
                            return res;
                        });
                        this.insert(reg);
                        reg = "";
                    }
                }
            }
        }
    }

    /**
     * Finds link at defined {row} and {column}
     * @returns {String}
     **/
    findLinkAt(row, column) {
        var line = this.session.getLine(row);
        var wordParts = line.split(/((?:https?|ftp):\/\/[\S]+)/);
        var columnPosition = column;
        if (columnPosition < 0) columnPosition = 0;
        var previousPosition = 0, currentPosition = 0, match;
        for (let item of wordParts) {
            currentPosition = previousPosition + item.length;
            if (columnPosition >= previousPosition && columnPosition <= currentPosition) {
                if (item.match(/((?:https?|ftp):\/\/[\S]+)/)) {
                    match = item.replace(/[\s:.,'";}\]]+$/, "");
                    break;
                }
            }
            previousPosition = currentPosition;
        }
        return match;
    }

    /**
     * Open valid url under cursor in another tab
     * @returns {Boolean}
     **/
    openLink() {
        var cursor =  this.selection.getCursor();
        var url = this.findLinkAt(cursor.row, cursor.column);
        if (url)
            window.open(url, '_blank');
        return url != null;
    }

    /**
     * Removes all the lines in the current selection
     * @related EditSession.remove
     **/
    removeLines() {
        var rows = this.$getSelectedRows();
        this.session.removeFullLines(rows.first, rows.last);
        this.clearSelection();
    }

    duplicateSelection() {
        var sel = this.selection;
        var doc = this.session;
        var range = sel.getRange();
        var reverse = sel.isBackwards();
        if (range.isEmpty()) {
            var row = range.start.row;
            doc.duplicateLines(row, row);
        } else {
            var point = reverse ? range.start : range.end;
            var endPoint = doc.insert(point, doc.getTextRange(range));
            range.start = point;
            range.end = endPoint;

            sel.setSelectionRange(range, reverse);
        }
    }

    /**
     * Shifts all the selected lines down one row.
     *
     * @related EditSession.moveLinesUp
     **/
    moveLinesDown() {
        this.$moveLines(1, false);
    }

    /**
     * Shifts all the selected lines up one row.
     * @related EditSession.moveLinesDown
     **/
    moveLinesUp() {
        this.$moveLines(-1, false);
    }

    /**
     * Moves a range of text from the given range to the given position. `toPosition` is an object that looks like this:
     * ```json
     *    { row: newRowLocation, column: newColumnLocation }
     * ```
     * @param {Range} range The range of text you want moved within the document
     * @param {Point} toPosition The location (row and column) where you want to move the text to
     * @param {boolean} [copy]
     *
     * @returns {Range} The new range where the text was moved to.
     * @related EditSession.moveText
     **/
    moveText(range, toPosition, copy) {
        return this.session.moveText(range, toPosition, copy);
    }

    /**
     * Copies all the selected lines up one row.
     *
     **/
    copyLinesUp() {
        this.$moveLines(-1, true);
    }

    /**
     * Copies all the selected lines down one row.
     * @related EditSession.duplicateLines
     *
     **/
    copyLinesDown() {
        this.$moveLines(1, true);
    }

    /**
     * for internal use
     * @ignore
     *
     **/
    $moveLines(dir, copy) {
        var rows, moved;
        var selection = this.selection;
        if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
            var range = selection.toOrientedRange();
            rows = this.$getSelectedRows(range);
            moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
            if (copy && dir == -1) moved = 0;
            range.moveBy(moved, 0);
            selection.fromOrientedRange(range);
        } else {
            var ranges = selection.rangeList.ranges;
            // @ts-expect-error TODO: possible bug, no args in parameters
            selection.rangeList.detach(this.session);
            this.inVirtualSelectionMode = true;

            var diff = 0;
            var totalDiff = 0;
            var l = ranges.length;
            for (var i = 0; i < l; i++) {
                var rangeIndex = i;
                ranges[i].moveBy(diff, 0);
                rows = this.$getSelectedRows(ranges[i]);
                var first = rows.first;
                var last = rows.last;
                while (++i < l) {
                    if (totalDiff) ranges[i].moveBy(totalDiff, 0);
                    var subRows = this.$getSelectedRows(ranges[i]);
                    if (copy && subRows.first != last)
                        break;
                    else if (!copy && subRows.first > last + 1)
                        break;
                    last = subRows.last;
                }
                i--;
                diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                if (copy && dir == -1) rangeIndex = i + 1;
                while (rangeIndex <= i) {
                    ranges[rangeIndex].moveBy(diff, 0);
                    rangeIndex++;
                }
                if (!copy) diff = 0;
                totalDiff += diff;
            }

            selection.fromOrientedRange(selection.ranges[0]);
            selection.rangeList.attach(this.session);
            this.inVirtualSelectionMode = false;
        }
    }

    /**
     * Returns an object indicating the currently selected rows. The object looks like this:
     *
     * ```json
     * { first: range.start.row, last: range.end.row }
     * ```
     *
     * @returns {Object}
     **/
    $getSelectedRows(range) {
        range = (range || this.getSelectionRange()).collapseRows();

        return {
            first: this.session.getRowFoldStart(range.start.row),
            last: this.session.getRowFoldEnd(range.end.row)
        };
    }

    /**
     * @internal
     */
    onCompositionStart(compositionState) {
        this.renderer.showComposition(compositionState);
    }

    /**
     * @internal
     */
    onCompositionUpdate(text) {
        this.renderer.setCompositionText(text);
    }

    /**
     * @internal
     */
    onCompositionEnd() {
        this.renderer.hideComposition();
    }

    /**
     * {:VirtualRenderer.getFirstVisibleRow}
     *
     * @returns {Number}
     * @related VirtualRenderer.getFirstVisibleRow
     **/
    getFirstVisibleRow() {
        return this.renderer.getFirstVisibleRow();
    }

    /**
     * {:VirtualRenderer.getLastVisibleRow}
     *
     * @returns {Number}
     * @related VirtualRenderer.getLastVisibleRow
     **/
    getLastVisibleRow() {
        return this.renderer.getLastVisibleRow();
    }

    /**
     * Indicates if the row is currently visible on the screen.
     * @param {Number} row The row to check
     *
     * @returns {Boolean}
     **/
    isRowVisible(row) {
        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
    }

    /**
     * Indicates if the entire row is currently visible on the screen.
     * @param {Number} row The row to check
     *
     *
     * @returns {Boolean}
     **/
    isRowFullyVisible(row) {
        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
    }

    /**
     * Returns the number of currently visible rows.
     * @returns {Number}
     **/
    $getVisibleRowCount() {
        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
    }

    $moveByPage(dir, select) {
        var renderer = this.renderer;
        var config = this.renderer.layerConfig;
        var rows = dir * Math.floor(config.height / config.lineHeight);

        if (select === true) {
            this.selection.$moveSelection(function(){
                this.moveCursorBy(rows, 0);
            });
        } else if (select === false) {
            this.selection.moveCursorBy(rows, 0);
            this.selection.clearSelection();
        }

        var scrollTop = renderer.scrollTop;

        renderer.scrollBy(0, rows * config.lineHeight);
        if (select != null)
            renderer.scrollCursorIntoView(null, 0.5);

        renderer.animateScrolling(scrollTop);
    }

    /**
     * Selects the text from the current position of the document until where a "page down" finishes.
     **/
    selectPageDown() {
        this.$moveByPage(1, true);
    }

    /**
     * Selects the text from the current position of the document until where a "page up" finishes.
     **/
    selectPageUp() {
        this.$moveByPage(-1, true);
    }

    /**
     * Shifts the document to wherever "page down" is, as well as moving the cursor position.
     **/
    gotoPageDown() {
        this.$moveByPage(1, false);
    }

    /**
     * Shifts the document to wherever "page up" is, as well as moving the cursor position.
     **/
    gotoPageUp() {
        this.$moveByPage(-1, false);
    }

    /**
     * Scrolls the document to wherever "page down" is, without changing the cursor position.
     **/
    scrollPageDown() {
        this.$moveByPage(1);
    }

    /**
     * Scrolls the document to wherever "page up" is, without changing the cursor position.
     **/
    scrollPageUp() {
        this.$moveByPage(-1);
    }

    /**
     * Moves the editor to the specified row.
     * @related VirtualRenderer.scrollToRow
     * @param {number} row
     */
    scrollToRow(row) {
        this.renderer.scrollToRow(row);
    }

    /**
     * Scrolls to a line. If `center` is `true`, it puts the line in middle of screen (or attempts to).
     * @param {Number} line The line to scroll to
     * @param {Boolean} center If `true`
     * @param {Boolean} animate If `true` animates scrolling
     * @param {() => void} [callback] Function to be called when the animation has finished
     *
     * @related VirtualRenderer.scrollToLine
     **/
    scrollToLine(line, center, animate, callback) {
        this.renderer.scrollToLine(line, center, animate, callback);
    }

    /**
     * Attempts to center the current selection on the screen.
     **/
    centerSelection() {
        var range = this.getSelectionRange();
        var pos = {
            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
        };
        this.renderer.alignCursor(pos, 0.5);
    }

    /**
     * Gets the current position of the cursor.
     * @returns {Point} An object that looks something like this:
     *
     * ```json
     * { row: currRow, column: currCol }
     * ```
     *
     * @related Selection.getCursor
     **/
    getCursorPosition() {
        return this.selection.getCursor();
    }

    /**
     * Returns the screen position of the cursor.
     * @returns {Point}
     * @related EditSession.documentToScreenPosition
     **/
    getCursorPositionScreen() {
        return this.session.documentToScreenPosition(this.getCursorPosition());
    }

    /**
     * {:Selection.getRange}
     * @returns {Range}
     * @related Selection.getRange
     **/
    getSelectionRange() {
        return this.selection.getRange();
    }

    /**
     * Selects all the text in editor.
     * @related Selection.selectAll
     **/
    selectAll() {
        this.selection.selectAll();
    }

    /**
     * {:Selection.clearSelection}
     * @related Selection.clearSelection
     **/
    clearSelection() {
        this.selection.clearSelection();
    }

    /**
     * Moves the cursor to the specified row and column. Note that this does not de-select the current selection.
     * @param {Number} row The new row number
     * @param {Number} column The new column number
     * @related Selection.moveCursorTo
     **/
    moveCursorTo(row, column) {
        this.selection.moveCursorTo(row, column);
    }

    /**
     * Moves the cursor to the position indicated by `pos.row` and `pos.column`.
     * @param {Point} pos An object with two properties, row and column
     * @related Selection.moveCursorToPosition
     **/
    moveCursorToPosition(pos) {
        this.selection.moveCursorToPosition(pos);
    }

    /**
     * Moves the cursor's row and column to the next matching bracket or HTML tag.
     * @param {boolean} [select]
     * @param {boolean} [expand]
     */
    jumpToMatching(select, expand) {
        var cursor = this.getCursorPosition();
        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
        var prevToken = iterator.getCurrentToken();
        var tokenCount = 0;
        if (prevToken && prevToken.type.indexOf('tag-name') !== -1) {
            prevToken = iterator.stepBackward();
        }
        var token = prevToken || iterator.stepForward();

        if (!token) return;

        //get next closing tag or bracket
        var matchType;
        var found = false;
        var depth = {};
        var i = cursor.column - token.start;
        var bracketType;
        var brackets = {
            ")": "(",
            "(": "(",
            "]": "[",
            "[": "[",
            "{": "{",
            "}": "{"
        };

        do {
            if (token.value.match(/[{}()\[\]]/g)) {
                for (; i < token.value.length && !found; i++) {
                    if (!brackets[token.value[i]]) {
                        continue;
                    }

                    bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");

                    if (isNaN(depth[bracketType])) {
                        depth[bracketType] = 0;
                    }

                    switch (token.value[i]) {
                        case '(':
                        case '[':
                        case '{':
                            depth[bracketType]++;
                            break;
                        case ')':
                        case ']':
                        case '}':
                            depth[bracketType]--;

                            if (depth[bracketType] === -1) {
                                matchType = 'bracket';
                                found = true;
                            }
                            break;
                    }
                }
            }
            else if (token.type.indexOf('tag-name') !== -1) {
                if (isNaN(depth[token.value])) {
                    depth[token.value] = 0;
                }

                if (prevToken.value === '<' && tokenCount > 1) {
                    depth[token.value]++;
                }
                else if (prevToken.value === '</') {
                    depth[token.value]--;
                }

                if (depth[token.value] === -1) {
                    matchType = 'tag';
                    found = true;
                }
            }

            if (!found) {
                prevToken = token;
                tokenCount++;
                token = iterator.stepForward();
                i = 0;
            }
        } while (token && !found);

        //no match found
        if (!matchType) return;

        var range, pos;
        if (matchType === 'bracket') {
            range = this.session.getBracketRange(cursor);
            if (!range) {
                range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1,
                    iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1
                );
                pos = range.start;
                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column)
                    < 2) range = this.session.getBracketRange(pos);
            }
        }
        else if (matchType === 'tag') {
            if (!token || token.type.indexOf('tag-name') === -1) return;
            range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2,
                iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2
            );

            //find matching tag
            if (range.compare(cursor.row, cursor.column) === 0) {
                var tagsRanges = this.session.getMatchingTags(cursor);
                if (tagsRanges) {
                    if (tagsRanges.openTag.contains(cursor.row, cursor.column)) {
                        range = tagsRanges.closeTag;
                        pos = range.start;
                    }
                    else {
                        range = tagsRanges.openTag;
                        if (tagsRanges.closeTag.start.row === cursor.row && tagsRanges.closeTag.start.column
                            === cursor.column) pos = range.end; else pos = range.start;
                    }
                }
            }

            //we found it
            pos = pos || range.start;
        }

        pos = range && range.cursor || pos;
        if (pos) {
            if (select) {
                if (range && expand) {
                    this.selection.setRange(range);
                }
                else if (range && range.isEqual(this.getSelectionRange())) {
                    this.clearSelection();
                }
                else {
                    this.selection.selectTo(pos.row, pos.column);
                }
            }
            else {
                this.selection.moveTo(pos.row, pos.column);
            }
        }
    }

    /**
     * Moves the cursor to the specified line number, and also into the indicated column.
     * @param {Number} lineNumber The line number to go to
     * @param {Number} [column] A column number to go to
     * @param {Boolean} [animate] If `true` animates scolling
     **/
    gotoLine(lineNumber, column, animate) {
        this.selection.clearSelection();
        this.session.unfold({row: lineNumber - 1, column: column || 0});

        // todo: find a way to automatically exit multiselect mode
        this.exitMultiSelectMode && this.exitMultiSelectMode();
        this.moveCursorTo(lineNumber - 1, column || 0);

        if (!this.isRowFullyVisible(lineNumber - 1))
            this.scrollToLine(lineNumber - 1, true, animate);
    }

    /**
     * Moves the cursor to the specified row and column. Note that this does de-select the current selection.
     * @param {Number} row The new row number
     * @param {Number} column The new column number
     *
     * @related Editor.moveCursorTo
     **/
    navigateTo(row, column) {
        this.selection.moveTo(row, column);
    }

    /**
     * Moves the cursor up in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} [times] The number of times to change navigation
     *
     **/
    navigateUp(times) {
        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
            var selectionStart = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionStart);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(-times || -1, 0);
    }

    /**
     * Moves the cursor down in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} [times] The number of times to change navigation
     *
     **/
    navigateDown(times) {
        if (this.selection.isMultiLine() && this.selection.isBackwards()) {
            var selectionEnd = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionEnd);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(times || 1, 0);
    }

    /**
     * Moves the cursor left in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} [times] The number of times to change navigation
     *
     **/
    navigateLeft(times) {
        if (!this.selection.isEmpty()) {
            var selectionStart = this.getSelectionRange().start;
            this.moveCursorToPosition(selectionStart);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorLeft();
            }
        }
        this.clearSelection();
    }

    /**
     * Moves the cursor right in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} [times] The number of times to change navigation
     *
     **/
    navigateRight(times) {
        if (!this.selection.isEmpty()) {
            var selectionEnd = this.getSelectionRange().end;
            this.moveCursorToPosition(selectionEnd);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorRight();
            }
        }
        this.clearSelection();
    }

    /**
     *
     * Moves the cursor to the start of the current line. Note that this does de-select the current selection.
     **/
    navigateLineStart() {
        this.selection.moveCursorLineStart();
        this.clearSelection();
    }

    /**
     *
     * Moves the cursor to the end of the current line. Note that this does de-select the current selection.
     **/
    navigateLineEnd() {
        this.selection.moveCursorLineEnd();
        this.clearSelection();
    }

    /**
     *
     * Moves the cursor to the end of the current file. Note that this does de-select the current selection.
     **/
    navigateFileEnd() {
        this.selection.moveCursorFileEnd();
        this.clearSelection();
    }

    /**
     *
     * Moves the cursor to the start of the current file. Note that this does de-select the current selection.
     **/
    navigateFileStart() {
        this.selection.moveCursorFileStart();
        this.clearSelection();
    }

    /**
     *
     * Moves the cursor to the word immediately to the right of the current position. Note that this does de-select the current selection.
     **/
    navigateWordRight() {
        this.selection.moveCursorWordRight();
        this.clearSelection();
    }

    /**
     *
     * Moves the cursor to the word immediately to the left of the current position. Note that this does de-select the current selection.
     **/
    navigateWordLeft() {
        this.selection.moveCursorWordLeft();
        this.clearSelection();
    }

    /**
     * Replaces the first occurrence of `options.needle` with the value in `replacement`.
     * @param {String} [replacement] The text to replace with
     * @param {Partial<SearchOptions>} [options] The [[Search `Search`]] options to use
     * @return {number}
     **/
    replace(replacement, options) {
        if (options)
            this.$search.set(options);

        var range = this.$search.find(this.session);
        var replaced = 0;
        if (!range)
            return replaced;

        if (this.$tryReplace(range, replacement)) {
            replaced = 1;
        }

        this.selection.setSelectionRange(range);
        this.renderer.scrollSelectionIntoView(range.start, range.end);

        return replaced;
    }

    /**
     * Replaces all occurrences of `options.needle` with the value in `replacement`.
     * @param {String} [replacement] The text to replace with
     * @param {Partial<SearchOptions>} [options] The [[Search `Search`]] options to use
     * @return {number}
     **/
    replaceAll(replacement, options) {
        if (options) {
            this.$search.set(options);
        }

        var ranges = this.$search.findAll(this.session);
        var replaced = 0;
        if (!ranges.length)
            return replaced;

        var selection = this.getSelectionRange();
        this.selection.moveTo(0, 0);

        for (var i = ranges.length - 1; i >= 0; --i) {
            if(this.$tryReplace(ranges[i], replacement)) {
                replaced++;
            }
        }

        this.selection.setSelectionRange(selection);

        return replaced;
    }

    /**
     * @param {import("../ace-internal").Ace.IRange} range
     * @param {string} [replacement]
     */
    $tryReplace(range, replacement) {
        var input = this.session.getTextRange(range);
        replacement = this.$search.replace(input, replacement);
        if (replacement !== null) {
            range.end = this.session.replace(range, replacement);
            return range;
        } else {
            return null;
        }
    }

    /**
     * {:Search.getOptions} For more information on `options`, see [[Search `Search`]].
     * @related Search.getOptions
     * @returns {Partial<SearchOptions>}
     **/
    getLastSearchOptions() {
        return this.$search.getOptions();
    }

    /**
     * Attempts to find `needle` within the document. For more information on `options`, see [[Search `Search`]].
     * @param {String|RegExp|Object} needle The text to search for (optional)
     * @param {Partial<SearchOptions>} [options] An object defining various search properties
     * @param {Boolean} [animate] If `true` animate scrolling
     * @related Search.find
     **/
    find(needle, options, animate) {
        if (!options)
            options = {};

        if (typeof needle == "string" || needle instanceof RegExp)
            options.needle = needle;
        else if (typeof needle == "object")
            oop.mixin(options, needle);

        var range = this.selection.getRange();
        if (options.needle == null) {
            needle = this.session.getTextRange(range)
                || this.$search.$options.needle;
            if (!needle) {
                range = this.session.getWordRange(range.start.row, range.start.column);
                needle = this.session.getTextRange(range);
            }
            this.$search.set({needle: needle});
        }

        this.$search.set(options);
        if (!options.start)
            this.$search.set({start: range});

        var newRange = this.$search.find(this.session);
        if (options.preventScroll)
            return newRange;
        if (newRange) {
            this.revealRange(newRange, animate);
            return newRange;
        }
        // clear selection if nothing is found
        if (options.backwards)
            range.start = range.end;
        else
            range.end = range.start;
        this.selection.setRange(range);
    }

    /**
     * Performs another search for `needle` in the document. For more information on `options`, see [[Search `Search`]].
     * @param {Partial<SearchOptions>} [options] search options
     * @param {Boolean} [animate] If `true` animate scrolling
     *
     * @related Editor.find
     **/
    findNext(options, animate) {
        this.find({skipCurrent: true, backwards: false}, options, animate);
    }

    /**
     * Performs a search for `needle` backwards. For more information on `options`, see [[Search `Search`]].
     * @param {Partial<SearchOptions>} [options] search options
     * @param {Boolean} [animate] If `true` animate scrolling
     *
     * @related Editor.find
     **/
    findPrevious(options, animate) {
        this.find(options, {skipCurrent: true, backwards: true}, animate);
    }

    /**
     *
     * @param {Range} range
     * @param {boolean} [animate]
     */
    revealRange(range, animate) {
        this.session.unfold(range);
        this.selection.setSelectionRange(range);

        var scrollTop = this.renderer.scrollTop;
        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
        if (animate !== false)
            this.renderer.animateScrolling(scrollTop);
    }

    /**
     * {:UndoManager.undo}
     * @related UndoManager.undo
     **/
    undo() {
        this.session.getUndoManager().undo(this.session);
        this.renderer.scrollCursorIntoView(null, 0.5);
    }

    /**
     * {:UndoManager.redo}
     * @related UndoManager.redo
     **/
    redo() {
        this.session.getUndoManager().redo(this.session);
        this.renderer.scrollCursorIntoView(null, 0.5);
    }

    /**
     *
     * Cleans up the entire editor.
     **/
    destroy() {
        /** true if editor is destroyed */
        this.destroyed = true;
        if (this.$toDestroy) {
            this.$toDestroy.forEach(function(el) {
                el.destroy();
            });
            this.$toDestroy = [];
        }
        if (this.$mouseHandler)
            this.$mouseHandler.destroy();
        this.renderer.destroy();
        this._signal("destroy", this);
        if (this.session)
            this.session.destroy();
        if (this._$emitInputEvent)
            this._$emitInputEvent.cancel();
        this.removeAllListeners();

    }

    /**
     * Enables automatic scrolling of the cursor into view when editor itself is inside scrollable element
     * @param {Boolean} enable default true
     **/
    setAutoScrollEditorIntoView(enable) {
        if (!enable)
            return;
        var rect;
        var self = this;
        var shouldScroll = false;
        if (!this.$scrollAnchor)
            this.$scrollAnchor = document.createElement("div");
        var scrollAnchor = this.$scrollAnchor;
        scrollAnchor.style.cssText = "position:absolute";
        this.container.insertBefore(scrollAnchor, this.container.firstChild);
        var onChangeSelection = this.on("changeSelection", function() {
            shouldScroll = true;
        });
        // needed to not trigger sync reflow
        var onBeforeRender = this.renderer.on("beforeRender", function() {
            if (shouldScroll)
                rect = self.renderer.container.getBoundingClientRect();
        });
        var onAfterRender = this.renderer.on("afterRender", function() {
            if (shouldScroll && rect && (self.isFocused()
                || self.searchBox && self.searchBox.isFocused())
            ) {
                var renderer = self.renderer;
                var pos = renderer.$cursorLayer.$pixelPos;
                var config = renderer.layerConfig;
                var top = pos.top - config.offset;
                if (pos.top >= 0 && top + rect.top < 0) {
                    shouldScroll = true;
                } else if (pos.top < config.height &&
                    pos.top + rect.top + config.lineHeight > window.innerHeight) {
                    shouldScroll = false;
                } else {
                    shouldScroll = null;
                }
                if (shouldScroll != null) {
                    scrollAnchor.style.top = top + "px";
                    scrollAnchor.style.left = pos.left + "px";
                    scrollAnchor.style.height = config.lineHeight + "px";
                    scrollAnchor.scrollIntoView(shouldScroll);
                }
                shouldScroll = rect = null;
            }
        });
        this.setAutoScrollEditorIntoView = function(enable) {
            if (enable)
                return;
            delete this.setAutoScrollEditorIntoView;
            this.off("changeSelection", onChangeSelection);
            this.renderer.off("afterRender", onAfterRender);
            this.renderer.off("beforeRender", onBeforeRender);
        };
    }

    $resetCursorStyle() {
        var style = this.$cursorStyle || "ace";
        var cursorLayer = this.renderer.$cursorLayer;
        if (!cursorLayer)
            return;
        cursorLayer.setSmoothBlinking(/smooth/.test(style));
        cursorLayer.isBlinking = !this.$readOnly && style != "wide";
        dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
    }

    /**
     * opens a prompt displaying message
     **/
    prompt(message, options, callback) {
        var editor = this;
        config.loadModule("ace/ext/prompt", function (module) {
            module.prompt(editor, message, options, callback);
        });
    }

    get hoverTooltip() {
        return this.$hoverTooltip || (this.$hoverTooltip = new HoverTooltip(this.container));
    }
    set hoverTooltip(value) {
        if (this.$hoverTooltip) this.$hoverTooltip.destroy();
            this.$hoverTooltip = value;
    }
}

Editor.$uid = 0;
Editor.prototype.curOp = null;
Editor.prototype.prevOp = {};
// TODO use property on commands instead of this
Editor.prototype.$mergeableCommands = ["backspace", "del", "insertstring"];
Editor.prototype.$toggleWordPairs = [
    ["first", "last"],
    ["true", "false"],
    ["yes", "no"],
    ["width", "height"],
    ["top", "bottom"],
    ["right", "left"],
    ["on", "off"],
    ["x", "y"],
    ["get", "set"],
    ["max", "min"],
    ["horizontal", "vertical"],
    ["show", "hide"],
    ["add", "remove"],
    ["up", "down"],
    ["before", "after"],
    ["even", "odd"],
    ["in", "out"],
    ["inside", "outside"],
    ["next", "previous"],
    ["increase", "decrease"],
    ["attach", "detach"],
    ["&&", "||"],
    ["==", "!="]
];

oop.implement(Editor.prototype, EventEmitter);


config.defineOptions(Editor.prototype, "editor", {
    selectionStyle: {
        set: function(style) {
            this.onSelectionChange();
            this._signal("changeSelectionStyle", {data: style});
        },
        initialValue: "line"
    },
    highlightActiveLine: {
        set: function() {this.$updateHighlightActiveLine();},
        initialValue: true
    },
    highlightSelectedWord: {
        set: function(shouldHighlight) {this.$onSelectionChange();},
        initialValue: true
    },
    readOnly: {
        set: function(/**@type{boolean}*/readOnly) {
            this.textInput.setReadOnly(readOnly);
            if (this.destroyed) return;
            this.$resetCursorStyle();
            if (!this.$readOnlyCallback) {
                this.$readOnlyCallback = (e) => {
                    var shouldShow = false;
                    if (e && e.type == "keydown") {
                        if (e && e.key && !e.ctrlKey && !e.metaKey) {
                            if (e.key == " ") e.preventDefault();
                            shouldShow = e.key.length == 1;
                        }
                        if (!shouldShow) return;
                    } else if (e && e.type !== "exec") {
                        shouldShow = true;
                    }
                    if (shouldShow) {
                        var domNode = dom.createElement("div");
                        domNode.textContent = nls("editor.tooltip.disable-editing", "Editing is disabled");
                        if (!this.hoverTooltip.isOpen) {
                            this.hoverTooltip.showForRange(this, this.getSelectionRange(), domNode);
                        }
                    } else if (this.hoverTooltip && this.hoverTooltip.isOpen) {
                        this.hoverTooltip.hide();
                    }
                };
            }
            var textArea = this.textInput.getElement();
            if (readOnly) {
                event.addListener(textArea, "keydown", this.$readOnlyCallback, this);
                this.commands.on("exec", this.$readOnlyCallback);
                this.commands.on("commandUnavailable", this.$readOnlyCallback);
            } else {
                event.removeListener(textArea, "keydown", this.$readOnlyCallback);
                this.commands.off("exec", this.$readOnlyCallback);
                this.commands.off("commandUnavailable", this.$readOnlyCallback);
            }
        },
        initialValue: false
    },
    copyWithEmptySelection: {
        set: function(value) {
            this.textInput.setCopyWithEmptySelection(value);
        },
        initialValue: false
    },
    cursorStyle: {
        set: function(val) { this.$resetCursorStyle(); },
        values: ["ace", "slim", "smooth", "wide"],
        initialValue: "ace"
    },
    mergeUndoDeltas: {
        values: [false, true, "always"],
        initialValue: true
    },
    behavioursEnabled: {initialValue: true},
    wrapBehavioursEnabled: {initialValue: true},
    enableAutoIndent: {initialValue: true},
    autoScrollEditorIntoView: {
        set: function(val) {this.setAutoScrollEditorIntoView(val);}
    },
    keyboardHandler: {
        set: function(val) { this.setKeyboardHandler(val); },
        get: function() { return this.$keybindingId; },
        handlesSet: true
    },
    value: {
        set: function(val) { this.session.setValue(val); },
        get: function() { return this.getValue(); },
        handlesSet: true,
        hidden: true
    },
    session: {
        set: function(val) { this.setSession(val); },
        get: function() { return this.session; },
        handlesSet: true,
        hidden: true
    },

    showLineNumbers: {
        set: function(show) {
            this.renderer.$gutterLayer.setShowLineNumbers(show);
            this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER);
            if (show && this.$relativeLineNumbers)
                relativeNumberRenderer.attach(this);
            else
                relativeNumberRenderer.detach(this);
        },
        initialValue: true
    },
    relativeLineNumbers: {
        set: function(value) {
            if (this.$showLineNumbers && value)
                relativeNumberRenderer.attach(this);
            else
                relativeNumberRenderer.detach(this);
        }
    },
    placeholder: {
        /**
         * @param message
         */
        set: function(message) {
            if (!this.$updatePlaceholder) {
                this.$updatePlaceholder = function() {
                    var hasValue = this.session && (this.renderer.$composition ||
                         this.session.getLength() > 1 || this.session.getLine(0).length > 0);
                    if (hasValue && this.renderer.placeholderNode) {
                        this.renderer.off("afterRender", this.$updatePlaceholder);
                        dom.removeCssClass(this.container, "ace_hasPlaceholder");
                        this.renderer.placeholderNode.remove();
                        this.renderer.placeholderNode = null;
                    } else if (!hasValue && !this.renderer.placeholderNode) {
                        this.renderer.on("afterRender", this.$updatePlaceholder);
                        dom.addCssClass(this.container, "ace_hasPlaceholder");
                        var el = dom.createElement("div");
                        el.className = "ace_placeholder";
                        el.textContent = this.$placeholder || "";
                        this.renderer.placeholderNode = el;
                        this.renderer.content.appendChild(this.renderer.placeholderNode);
                    } else if (!hasValue && this.renderer.placeholderNode) {
                        this.renderer.placeholderNode.textContent = this.$placeholder || "";
                    }
                }.bind(this);
                // @ts-ignore
                this.on("input", this.$updatePlaceholder);
            }
            this.$updatePlaceholder();
        }
    },
    enableKeyboardAccessibility: {
        set: function(value) {
            var blurCommand = {
                name: "blurTextInput",
                description: "Set focus to the editor content div to allow tabbing through the page",
                bindKey: "Esc",
                exec: function(editor) {
                    editor.blur();
                    editor.renderer.scroller.focus();
                },
                readOnly: true
            };

            var focusOnEnterKeyup = function (e) {
                if (e.target == this.renderer.scroller && e.keyCode === keys['enter']){
                    e.preventDefault();
                    var row = this.getCursorPosition().row;

                    if (!this.isRowVisible(row))
                        this.scrollToLine(row, true, true);

                    this.focus();
                }
            };
            /**@type {GutterKeyboardHandler}*/
            var gutterKeyboardHandler;

            // If keyboard a11y mode is enabled we:
            // - Enable keyboard operability gutter.
            // - Prevent tab-trapping.
            // - Hide irrelevant elements from assistive technology.
            // - On Windows, set more lines to the textarea.
            // - set aria-label to the text input.
            if (value){
                this.renderer.enableKeyboardAccessibility = true;
                this.renderer.keyboardFocusClassName = "ace_keyboard-focus";

                this.textInput.getElement().setAttribute("tabindex", -1);
                // VoiceOver on Mac OS works best with single line in the textarea, the screen readers on
                // Windows work best with multiple lines in the textarea.
                this.textInput.setNumberOfExtraLines(useragent.isWin ? 3 : 0);
                this.renderer.scroller.setAttribute("tabindex", 0);
                this.renderer.scroller.setAttribute("role", "group");
                this.renderer.scroller.setAttribute("aria-roledescription", nls("editor.scroller.aria-roledescription", "editor"));
                this.renderer.scroller.classList.add(this.renderer.keyboardFocusClassName);
                this.renderer.scroller.setAttribute("aria-label",
                    nls("editor.scroller.aria-label", "Editor content, press Enter to start editing, press Escape to exit")
                );

                this.renderer.scroller.addEventListener("keyup", focusOnEnterKeyup.bind(this));
                this.commands.addCommand(blurCommand);

                this.renderer.$gutter.setAttribute("tabindex", 0);
                this.renderer.$gutter.setAttribute("aria-hidden", false);
                this.renderer.$gutter.setAttribute("role", "group");
                this.renderer.$gutter.setAttribute("aria-roledescription", nls("editor.gutter.aria-roledescription", "editor gutter"));
                this.renderer.$gutter.setAttribute("aria-label",
                    nls("editor.gutter.aria-label", "Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit")
                );
                this.renderer.$gutter.classList.add(this.renderer.keyboardFocusClassName);

                this.renderer.content.setAttribute("aria-hidden", true);

                if (!gutterKeyboardHandler)
                    gutterKeyboardHandler = new GutterKeyboardHandler(this);

                gutterKeyboardHandler.addListener();

                this.textInput.setAriaOptions({
                    setLabel: true
                });
            } else {
                this.renderer.enableKeyboardAccessibility = false;

                this.textInput.getElement().setAttribute("tabindex", 0);
                this.textInput.setNumberOfExtraLines(0);
                this.renderer.scroller.setAttribute("tabindex", -1);
                this.renderer.scroller.removeAttribute("role");
                this.renderer.scroller.removeAttribute("aria-roledescription");
                this.renderer.scroller.classList.remove(this.renderer.keyboardFocusClassName);
                this.renderer.scroller.removeAttribute("aria-label");

                this.renderer.scroller.removeEventListener("keyup", focusOnEnterKeyup.bind(this));
                this.commands.removeCommand(blurCommand);

                this.renderer.content.removeAttribute("aria-hidden");

                this.renderer.$gutter.setAttribute("tabindex", -1);
                this.renderer.$gutter.setAttribute("aria-hidden", true);
                this.renderer.$gutter.removeAttribute("role");
                this.renderer.$gutter.removeAttribute("aria-roledescription");
                this.renderer.$gutter.removeAttribute("aria-label");
                this.renderer.$gutter.classList.remove(this.renderer.keyboardFocusClassName);

                if (gutterKeyboardHandler)
                    gutterKeyboardHandler.removeListener();
            }
        },
        initialValue: false
    },
    textInputAriaLabel: {
        set: function(val) { this.$textInputAriaLabel = val; },
        initialValue: ""
    },
    enableMobileMenu: {
        /**
         * @param {boolean} val
         */
        set: function(val) { this.$enableMobileMenu = val; },
        initialValue: true
    },
    customScrollbar: "renderer",
    hScrollBarAlwaysVisible: "renderer",
    vScrollBarAlwaysVisible: "renderer",
    highlightGutterLine: "renderer",
    animatedScroll: "renderer",
    showInvisibles: "renderer",
    showPrintMargin: "renderer",
    printMarginColumn: "renderer",
    printMargin: "renderer",
    fadeFoldWidgets: "renderer",
    showFoldWidgets: "renderer",
    displayIndentGuides: "renderer",
    highlightIndentGuides: "renderer",
    showGutter: "renderer",
    fontSize: "renderer",
    fontFamily: "renderer",
    maxLines: "renderer",
    minLines: "renderer",
    scrollPastEnd: "renderer",
    fixedWidthGutter: "renderer",
    theme: "renderer",
    hasCssTransforms: "renderer",
    maxPixelHeight: "renderer",
    useTextareaForIME: "renderer",
    useResizeObserver: "renderer",
    useSvgGutterIcons: "renderer",
    showFoldedAnnotations: "renderer",

    scrollSpeed: "$mouseHandler",
    dragDelay: "$mouseHandler",
    dragEnabled: "$mouseHandler",
    focusTimeout: "$mouseHandler",

    firstLineNumber: "session",
    overwrite: "session",
    newLineMode: "session",
    useWorker: "session",
    useSoftTabs: "session",
    navigateWithinSoftTabs: "session",
    tabSize: "session",
    wrap: "session",
    indentedSoftWrap: "session",
    foldStyle: "session",
    mode: "session"
});


var relativeNumberRenderer = {
    getText: function(/**@type{EditSession}*/session, /**@type{number}*/row) {
        return (Math.abs(session.selection.lead.row - row) || (row + 1 + (row < 9 ? "\xb7" : ""))) + "";
    },
    getWidth: function(session, /**@type{number}*/lastLineNumber, config) {
        return Math.max(
            lastLineNumber.toString().length,
            (config.lastRow + 1).toString().length,
            2
        ) * config.characterWidth;
    },
    update: function(e, /**@type{Editor}*/editor) {
        editor.renderer.$loop.schedule(editor.renderer.CHANGE_GUTTER);
    },
    attach: function(/**@type{Editor}*/editor) {
        editor.renderer.$gutterLayer.$renderer = this;
        editor.on("changeSelection", this.update);
        this.update(null, editor);
    },
    detach: function(/**@type{Editor}*/editor) {
        if (editor.renderer.$gutterLayer.$renderer == this)
            editor.renderer.$gutterLayer.$renderer = null;
        editor.off("changeSelection", this.update);
        this.update(null, editor);
    }
};
exports.Editor = Editor;


/***/ }),

/***/ 28402:
/***/ ((__unused_webpack_module, exports) => {

// not implemented
var WorkerClient;
WorkerClient = function() {
    this.attachToDocument = function() {};
    this.on = function() {};
    this.terminate = function() {};
};

exports.WorkerClient = WorkerClient;


/***/ }),

/***/ 28630:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * @typedef {import("../editor").Editor} Editor
 */

exports.parForEach = function(array, fn, callback) {
    var completed = 0;
    var arLength = array.length;
    if (arLength === 0)
        callback();
    for (var i = 0; i < arLength; i++) {
        fn(array[i], function(result, err) {
            completed++;
            if (completed === arLength)
                callback(result, err);
        });
    }
};

var ID_REGEX = /[a-zA-Z_0-9\$\-\u00A2-\u2000\u2070-\uFFFF]/;

exports.retrievePrecedingIdentifier = function(text, pos, regex) {
    regex = regex || ID_REGEX;
    var buf = [];
    for (var i = pos-1; i >= 0; i--) {
        if (regex.test(text[i]))
            buf.push(text[i]);
        else
            break;
    }
    return buf.reverse().join("");
};

exports.retrieveFollowingIdentifier = function(text, pos, regex) {
    regex = regex || ID_REGEX;
    var buf = [];
    for (var i = pos; i < text.length; i++) {
        if (regex.test(text[i]))
            buf.push(text[i]);
        else
            break;
    }
    return buf;
};

/**
 * @param editor
 * @return {string}
 */
exports.getCompletionPrefix = function (editor) {
    var pos = editor.getCursorPosition();
    var line = editor.session.getLine(pos.row);
    var prefix;
    editor.completers.forEach(function(completer) {
        if (completer.identifierRegexps) {
            completer.identifierRegexps.forEach(function(identifierRegex) {
                if (!prefix && identifierRegex)
                    prefix = this.retrievePrecedingIdentifier(line, pos.column, identifierRegex);
            }.bind(this));
        }
    }.bind(this));
    return prefix || this.retrievePrecedingIdentifier(line, pos.column);
};

/**
 * @param {Editor} editor
 * @param {string} [previousChar] if not provided, it falls back to the preceding character in the editor
 * @returns {boolean} whether autocomplete should be triggered
 */
exports.triggerAutocomplete = function (editor, previousChar) {
    var previousChar = previousChar == null
        ? editor.session.getPrecedingCharacter()
        : previousChar;
    return editor.completers.some((completer) => {
        if (completer.triggerCharacters && Array.isArray(completer.triggerCharacters)) {
            return completer.triggerCharacters.includes(previousChar);
        }
    });
};


/***/ }),

/***/ 28646:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function throwDeltaError(delta, errorText){
    console.log("Invalid Delta:", delta);
    throw "Invalid Delta: " + errorText;
}

function positionInDocument(docLines, position) {
    return position.row    >= 0 && position.row    <  docLines.length &&
           position.column >= 0 && position.column <= docLines[position.row].length;
}

function validateDelta(docLines, delta) {
    // Validate action string.
    if (delta.action != "insert" && delta.action != "remove")
        throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
    
    // Validate lines type.
    if (!(delta.lines instanceof Array))
        throwDeltaError(delta, "delta.lines must be an Array");

    // Validate range type.
    if (!delta.start || !delta.end)
       throwDeltaError(delta, "delta.start/end must be an present");

    // Validate that the start point is contained in the document.
    var start = delta.start;
    if (!positionInDocument(docLines, delta.start))
        throwDeltaError(delta, "delta.start must be contained in document");
    
    // Validate that the end point is contained in the document (remove deltas only).
    var end = delta.end;
    if (delta.action == "remove" && !positionInDocument(docLines, end))
        throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
    
    // Validate that the .range size matches the .lines size.
    var numRangeRows = end.row - start.row;
    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));
    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)
        throwDeltaError(delta, "delta.range must match delta lines");
}

/**
 * Applies a delta to a document.
 * @param {string[]} docLines
 * @param {import("../ace-internal").Ace.Delta} delta
 * @param [doNotValidate]
 */
exports.T = function(docLines, delta, doNotValidate) {
    // disabled validation since it breaks autocompletion popup
    // if (!doNotValidate)
    //    validateDelta(docLines, delta);
    
    var row = delta.start.row;
    var startColumn = delta.start.column;
    var line = docLines[row] || "";
    switch (delta.action) {
        case "insert":
            var lines = delta.lines;
            if (lines.length === 1) {
                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
            } else {
                // @ts-ignore
                var args = [row, 1].concat(delta.lines);
                docLines.splice.apply(docLines, args);
                docLines[row] = line.substring(0, startColumn) + docLines[row];
                docLines[row + delta.lines.length - 1] += line.substring(startColumn);
            }
            break;
        case "remove":
            var endColumn = delta.end.column;
            var endRow = delta.end.row;
            if (row === endRow) {
                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
            } else {
                docLines.splice(
                    row, endRow - row + 1,
                    line.substring(0, startColumn) + docLines[endRow].substring(endColumn)
                );
            }
            break;
    }
};


/***/ }),

/***/ 29451:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var oop = __webpack_require__(2645);


var Keys = {
    MODIFIER_KEYS: {
        16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta',
        91: 'MetaLeft', 92: 'MetaRight', 93: 'ContextMenu'
    },

    KEY_MODS: {
        "ctrl": 1, "alt": 2, "option" : 2, "shift": 4,
        "super": 8, "meta": 8, "command": 8, "cmd": 8, 
        "control": 1
    },

    FUNCTION_KEYS : {
        8  : "Backspace",
        9  : "Tab",
        13 : "Return",
        19 : "Pause",
        27 : "Esc",
        32 : "Space",
        33 : "PageUp",
        34 : "PageDown",
        35 : "End",
        36 : "Home",
        37 : "Left",
        38 : "Up",
        39 : "Right",
        40 : "Down",
        44 : "Print",
        45 : "Insert",
        46 : "Delete",
        '-13': "NumpadEnter",
        144: "Numlock",
        145: "Scrolllock"
    },

    PRINTABLE_KEYS: {
        32: ' ',  59: ';',  61: '=', 107: '+', 109: '-', 110: '.',
        186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',
        219: '[', 220: '\\',221: ']', 222: "'", 111: '/', 106: '*'
    }
};

var codeToKeyCode = {
    Command: 224,
    Backspace: 8,
    Tab: 9,
    Return: 13,
    Enter: 13,
    Pause: 19,
    Escape: 27,
    PageUp: 33,
    PageDown: 34,
    End: 35,
    Home: 36,
    Insert: 45,
    Delete: 46,
    ArrowLeft: 37,
    ArrowUp: 38,
    ArrowRight: 39,
    ArrowDown: 40,
    // special keys
    Backquote: 192,
    Minus: 189,
    Equal: 187,
    BracketLeft: 219,
    Backslash: 220,
    BracketRight: 221,
    Semicolon: 186,
    Quote: 222,
    Comma: 188,
    Period: 190,
    Slash: 191,
    Space: 32,
    NumpadAdd: 107,
    NumpadDecimal: 110,
    NumpadSubtract: 109,
    NumpadDivide: 111,
    NumpadMultiply: 106
};
for (var i = 0; i < 10; i++) {
    codeToKeyCode["Digit" + i] = 48 + i;
    codeToKeyCode["Numpad" + i] = 96 + i;
    Keys.PRINTABLE_KEYS[48 + i] = "" + i;
    Keys.FUNCTION_KEYS[96 + i] = "Numpad" + i;
}
for (var i = 65; i < 91; i++) {
    var chr = String.fromCharCode(i + 32);
    codeToKeyCode["Key" + chr.toUpperCase()] = i;
    Keys.PRINTABLE_KEYS[i] = chr;
}
for (var i = 1; i < 13; i++) {
    codeToKeyCode["F" + i] = 111 + i;
    Keys.FUNCTION_KEYS[111 + i] = "F" + i;
}
var modifiers = { 
    Shift: 16,
    Control: 17,
    Alt: 18,
    Meta: 224
};
for (var mod in modifiers) {
    codeToKeyCode[mod] = codeToKeyCode[mod + "Left"]
        = codeToKeyCode[mod + "Right"] = modifiers[mod];
}
exports.$codeToKeyCode = codeToKeyCode;

// workaround for firefox bug
Keys.PRINTABLE_KEYS[173] = '-';

// A reverse map of FUNCTION_KEYS
for (var j in Keys.FUNCTION_KEYS) {
    var name = Keys.FUNCTION_KEYS[j].toLowerCase();
    Keys[name] = parseInt(j, 10);
}

// A reverse map of PRINTABLE_KEYS
for (var j in Keys.PRINTABLE_KEYS) {
    var name = Keys.PRINTABLE_KEYS[j].toLowerCase();
    Keys[name] = parseInt(j, 10);
}

// Add the MODIFIER_KEYS, FUNCTION_KEYS and PRINTABLE_KEYS to the KEY
// variables as well.
oop.mixin(Keys, Keys.MODIFIER_KEYS);
oop.mixin(Keys, Keys.PRINTABLE_KEYS);
oop.mixin(Keys, Keys.FUNCTION_KEYS);

// aliases
Keys.enter = Keys["return"];
Keys.escape = Keys.esc;
Keys.del = Keys["delete"];

(function() {
    var mods = ["cmd", "ctrl", "alt", "shift"];
    for (var i = Math.pow(2, mods.length); i--;) {
        Keys.KEY_MODS[i] = mods.filter(function(x) {
            return i & Keys.KEY_MODS[x];
        }).join("-") + "-";
    }
})();

Keys.KEY_MODS[0] = "";
Keys.KEY_MODS[-1] = "input-";

/**@deprecated*/
oop.mixin(exports, Keys);

exports["default"] = exports;

/**
 * @param {number} keyCode
 * @return {string}
 */
exports.keyCodeToString = function(keyCode) {
    // Language-switching keystroke in Chrome/Linux emits keyCode 0.
    var keyString = Keys[keyCode];
    if (typeof keyString != "string")
        keyString = String.fromCharCode(keyCode);
    return keyString.toLowerCase();
};


/***/ }),

/***/ 30214:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./edit_session").EditSession} EditSession
 */
var Range = (__webpack_require__(91902)/* .Range */ .Q);
var EventEmitter = (__webpack_require__(87366).EventEmitter);
var oop = __webpack_require__(2645);

class PlaceHolder {
    /**
     * @param {EditSession} session
     * @param {Number} length
     * @param {import("../ace-internal").Ace.Point} pos
     * @param {any[]} others
     * @param {String} mainClass
     * @param {String} othersClass
     **/
    constructor(session, length, pos, others, mainClass, othersClass) {
        var _self = this;
        this.length = length;
        this.session = session;
        this.doc = session.getDocument();
        this.mainClass = mainClass;
        this.othersClass = othersClass;
        this.$onUpdate = this.onUpdate.bind(this);
        this.doc.on("change", this.$onUpdate, true);
        this.$others = others;

        this.$onCursorChange = function() {
            setTimeout(function() {
                _self.onCursorChange();
            });
        };

        this.$pos = pos;
        // Used for reset
        var undoStack = session.getUndoManager().$undoStack || session.getUndoManager()["$undostack"] || {length: -1};
        this.$undoStackDepth = undoStack.length;
        this.setup();

        session.selection.on("changeCursor", this.$onCursorChange);
    }

    /**
     * PlaceHolder.setup()
     *
     * TODO
     *
     **/
    setup() {
        var _self = this;
        var doc = this.doc;
        var session = this.session;

        this.selectionBefore = session.selection.toJSON();
        if (session.selection.inMultiSelectMode)
            session.selection.toSingleRange();

        this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
        var pos = this.pos;
        pos.$insertRight = true;
        pos.detach();
        pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
        this.others = [];
        this.$others.forEach(function(other) {
            var anchor = doc.createAnchor(other.row, other.column);
            anchor.$insertRight = true;
            anchor.detach();
            _self.others.push(anchor);
        });
        session.setUndoSelect(false);
    }

    /**
     * PlaceHolder.showOtherMarkers()
     *
     * TODO
     *
     **/
    showOtherMarkers() {
        if (this.othersActive) return;
        var session = this.session;
        var _self = this;
        this.othersActive = true;
        this.others.forEach(function(anchor) {
            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column+_self.length), _self.othersClass, null, false);
        });
    }

    /**
     * PlaceHolder.hideOtherMarkers()
     *
     * Hides all over markers in the [[EditSession `EditSession`]] that are not the currently selected one.
     *
     **/
    hideOtherMarkers() {
        if (!this.othersActive) return;
        this.othersActive = false;
        for (var i = 0; i < this.others.length; i++) {
            this.session.removeMarker(this.others[i].markerId);
        }
    }

    /**
     * PlaceHolder@onUpdate(e)
     *
     * Emitted when the place holder updates.
     * @param {import("../ace-internal").Ace.Delta} delta
     * @internal
     */
    onUpdate(delta) {
        if (this.$updating)
            return this.updateAnchors(delta);

        var range = delta;
        if (range.start.row !== range.end.row) return;
        if (range.start.row !== this.pos.row) return;
        this.$updating = true;
        var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
        var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
        var distanceFromStart = range.start.column - this.pos.column;

        this.updateAnchors(delta);

        if (inMainRange)
            this.length += lengthDiff;

        if (inMainRange && !this.session.$fromUndo) {
            if (delta.action === 'insert') {
                for (var i = this.others.length - 1; i >= 0; i--) {
                    var otherPos = this.others[i];
                    var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                    this.doc.insertMergedLines(newPos, delta.lines);
                }
            } else if (delta.action === 'remove') {
                for (var i = this.others.length - 1; i >= 0; i--) {
                    var otherPos = this.others[i];
                    var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                    this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                }
            }
        }

        this.$updating = false;
        this.updateMarkers();
    }

    /**
     * @param {import("../ace-internal").Ace.Delta} delta
     */
    updateAnchors(delta) {
        this.pos.onChange(delta);
        for (var i = this.others.length; i--;)
            this.others[i].onChange(delta);
        this.updateMarkers();
    }

    updateMarkers() {
        if (this.$updating)
            return;
        var _self = this;
        var session = this.session;
        var updateMarker = function(pos, className) {
            session.removeMarker(pos.markerId);
            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column+_self.length), className, null, false);
        };
        updateMarker(this.pos, this.mainClass);
        for (var i = this.others.length; i--;)
            updateMarker(this.others[i], this.othersClass);
    }


    /**
     * PlaceHolder@onCursorChange(e)
     *
     * Emitted when the cursor changes.
     * @param {any} [event]
     * @internal
     */
    onCursorChange(event) {
        if (this.$updating || !this.session) return;
        var pos = this.session.selection.getCursor();
        if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
            this.showOtherMarkers();
            this._emit("cursorEnter", event);
        } else {
            this.hideOtherMarkers();
            this._emit("cursorLeave", event);
        }
    }

    /**
     * PlaceHolder.detach()
     *
     * TODO
     *
     **/
    detach() {
        this.session.removeMarker(this.pos && this.pos.markerId);
        this.hideOtherMarkers();
        this.doc.off("change", this.$onUpdate);
        this.session.selection.off("changeCursor", this.$onCursorChange);
        this.session.setUndoSelect(true);
        this.session = null;
    }

    /**
     * PlaceHolder.cancel()
     *
     * TODO
     *
     **/
    cancel() {
        if (this.$undoStackDepth === -1)
            return;
        var undoManager = this.session.getUndoManager();
        var undosRequired = (undoManager.$undoStack || undoManager["$undostack"]).length - this.$undoStackDepth;
        for (var i = 0; i < undosRequired; i++) {
            undoManager.undo(this.session, true);
        }
        if (this.selectionBefore)
            this.session.selection.fromJSON(this.selectionBefore);
    }
}

oop.implement(PlaceHolder.prototype, EventEmitter);

exports.PlaceHolder = PlaceHolder;


/***/ }),

/***/ 30609:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("../edit_session").EditSession} EditSession
 * @typedef {import("../edit_session").Point} Point
 */
var TokenIterator = (__webpack_require__(99339).TokenIterator);
var Range = (__webpack_require__(91902)/* .Range */ .Q);

function BracketMatch() {

    /**
     * 
     * @param {Point} position
     * @param {string} [chr]
     * @this {EditSession}
     */
    this.findMatchingBracket = function(position, chr) {
        if (position.column == 0) return null;

        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column-1);
        if (charBeforeCursor == "") return null;

        var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
        if (!match)
            return null;

        if (match[1])
            return this.$findClosingBracket(match[1], position);
        else
            return this.$findOpeningBracket(match[2], position);
    };

    /**
     * @param {Point} pos
     * @return {null|Range}
     * @this {EditSession}
     */
    this.getBracketRange = function(pos) {
        var line = this.getLine(pos.row);
        var before = true, range;

        var chr = line.charAt(pos.column - 1);
        var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
        if (!match) {
            chr = line.charAt(pos.column);
            pos = {row: pos.row, column: pos.column + 1};
            match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            before = false;
        }
        if (!match)
            return null;

        if (match[1]) {
            var bracketPos = this.$findClosingBracket(match[1], pos);
            if (!bracketPos)
                return null;
            range = Range.fromPoints(pos, bracketPos);
            if (!before) {
                range.end.column++;
                range.start.column--;
            }
            range.cursor = range.end;
        } else {
            var bracketPos = this.$findOpeningBracket(match[2], pos);
            if (!bracketPos)
                return null;
            range = Range.fromPoints(bracketPos, pos);
            if (!before) {
                range.start.column++;
                range.end.column--;
            }
            range.cursor = range.start;
        }
        
        return range;
    };

    /**
     * Returns:
     * * null if there is no any bracket at `pos`;
     * * two Ranges if there is opening and closing brackets;
     * * one Range if there is only one bracket
     *
     * @param {Point} pos
     * @param {boolean} [isBackwards]
     * @returns {null|Range[]}
     * @this {EditSession}
     */
    this.getMatchingBracketRanges = function(pos, isBackwards) {
        var line = this.getLine(pos.row);
        var bracketsRegExp = /([\(\[\{])|([\)\]\}])/;
        var chr = !isBackwards && line.charAt(pos.column - 1);
        var match = chr && chr.match(bracketsRegExp);
        if (!match) {
            chr = (isBackwards === undefined || isBackwards) && line.charAt(pos.column);
            pos = {
                row: pos.row,
                column: pos.column + 1
            };
            match = chr && chr.match(bracketsRegExp);
        }

        if (!match)
            return null;

        var startRange = new Range(pos.row, pos.column - 1, pos.row, pos.column);
        var bracketPos = match[1] ? this.$findClosingBracket(match[1], pos)
            : this.$findOpeningBracket(match[2], pos);
        if (!bracketPos)
            return [startRange];
        var endRange = new Range(bracketPos.row, bracketPos.column, bracketPos.row, bracketPos.column + 1);

        return [startRange, endRange];
    };

    this.$brackets = {
        ")": "(",
        "(": ")",
        "]": "[",
        "[": "]",
        "{": "}",
        "}": "{",
        "<": ">",
        ">": "<"
    };

    /**
     * 
     * @param {string} bracket
     * @param {Point} position
     * @param {RegExp} [typeRe]
     * @return {Point|null}
     * @this {EditSession}
     */
    this.$findOpeningBracket = function(bracket, position, typeRe) {
        var openBracket = this.$brackets[bracket];
        var depth = 1;

        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
            token = iterator.stepForward();
        if (!token)
            return;
        
         if (!typeRe){
            typeRe = new RegExp(
                "(\\.?" +
                token.type.replace(".", "\\.").replace("rparen", ".paren")
                    .replace(/\b(?:end)\b/, "(?:start|begin|end)")
                    .replace(/-close\b/, "-(close|open)")
                + ")+"
            );
        }
        
        // Start searching in token, just before the character at position.column
        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
        var value = token.value;
        
        while (true) {
        
            while (valueIndex >= 0) {
                var chr = value.charAt(valueIndex);
                if (chr == openBracket) {
                    depth -= 1;
                    if (depth == 0) {
                        return {row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn()};
                    }
                }
                else if (chr == bracket) {
                    depth += 1;
                }
                valueIndex -= 1;
            }

            // Scan backward through the document, looking for the next token
            // whose type matches typeRe
            do {
                token = iterator.stepBackward();
            } while (token && !typeRe.test(token.type));

            if (token == null)
                break;
                
            value = token.value;
            valueIndex = value.length - 1;
        }
        
        return null;
    };

    /**
     *
     * @param {string} bracket
     * @param {Point} position
     * @param {RegExp} [typeRe]
     * @return {Point|null}
     * @this {EditSession}
     */
    this.$findClosingBracket = function(bracket, position, typeRe) {
        var closingBracket = this.$brackets[bracket];
        var depth = 1;

        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
            token = iterator.stepForward();
        if (!token)
            return;

        if (!typeRe){
            typeRe = new RegExp(
                "(\\.?" +
                token.type.replace(".", "\\.").replace("lparen", ".paren")
                    .replace(/\b(?:start|begin)\b/, "(?:start|begin|end)")
                    .replace(/-open\b/, "-(close|open)")
                + ")+"
            );
        }

        // Start searching in token, after the character at position.column
        var valueIndex = position.column - iterator.getCurrentTokenColumn();

        while (true) {

            var value = token.value;
            var valueLength = value.length;
            while (valueIndex < valueLength) {
                var chr = value.charAt(valueIndex);
                if (chr == closingBracket) {
                    depth -= 1;
                    if (depth == 0) {
                        return {row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn()};
                    }
                }
                else if (chr == bracket) {
                    depth += 1;
                }
                valueIndex += 1;
            }

            // Scan forward through the document, looking for the next token
            // whose type matches typeRe
            do {
                token = iterator.stepForward();
            } while (token && !typeRe.test(token.type));

            if (token == null)
                break;

            valueIndex = 0;
        }
        
        return null;
    };

    /**
     * Returns [[Range]]'s for matching tags and tag names, if there are any
     * @param {Point} pos
     * @returns {{closeTag: Range, closeTagName: Range, openTag: Range, openTagName: Range} | undefined}
     * @this {EditSession}
     */
    this.getMatchingTags = function (pos) {
        var iterator = new TokenIterator(this, pos.row, pos.column);
        var token = this.$findTagName(iterator);
        if (!token) return;

        var prevToken = iterator.stepBackward();

        if (prevToken.value === '<') {
            return this.$findClosingTag(iterator, token);
        }
        else {
            return this.$findOpeningTag(iterator, token);
        }
    };

    this.$findTagName = function (iterator) {
        var token = iterator.getCurrentToken();
        var found = false;
        var backward = false;
        if (token && token.type.indexOf('tag-name') === -1) {
            do {
                if (backward) token = iterator.stepBackward(); else token = iterator.stepForward();
                if (token) {
                    if (token.value === "/>") {
                        //changing iterator direction for self-closing tags, when cursor is in between tag
                        //name and tag closing
                        backward = true;
                    }
                    else if (token.type.indexOf('tag-name') !== -1) {
                        found = true;
                    }
                }
            } while (token && !found);
        }
        return token;
    };

    this.$findClosingTag = function (iterator, token) {
        var prevToken;
        var currentTag = token.value;
        var tag = token.value;
        var depth = 0;

        var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(),
            iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1
        );
        token = iterator.stepForward();
        var openTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(),
            iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length
        );
        var foundOpenTagEnd = false;
        do {
            prevToken = token;
            if (prevToken.type.indexOf('tag-close') !== -1 && !foundOpenTagEnd) {
                var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(),
                    iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1
                ); //Range for `>`
                foundOpenTagEnd = true;
            }
            token = iterator.stepForward();
            if (token) {
                if (token.value === '>' && !foundOpenTagEnd) {
                    var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(),
                        iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1
                    ); //Range for `>`
                    foundOpenTagEnd = true;
                }
                if (token.type.indexOf('tag-name') !== -1) {
                    currentTag = token.value;
                    if (tag === currentTag) {
                        if (prevToken.value === '<') {
                            depth++;
                        }
                        else if (prevToken.value === '</') {
                            depth--;
                            if (depth < 0) {//found closing tag
                                iterator.stepBackward();
                                var closeTagStart = new Range(iterator.getCurrentTokenRow(),
                                    iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(),
                                    iterator.getCurrentTokenColumn() + 2
                                ); //Range for </
                                token = iterator.stepForward();
                                var closeTagName = new Range(iterator.getCurrentTokenRow(),
                                    iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(),
                                    iterator.getCurrentTokenColumn() + token.value.length
                                );
                                if (token.type.indexOf('tag-close') === -1) {
                                    token = iterator.stepForward();
                                }
                                if (token && token.value === '>') {
                                    var closeTagEnd = new Range(iterator.getCurrentTokenRow(),
                                        iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(),
                                        iterator.getCurrentTokenColumn() + 1
                                    ); //Range for >
                                }
                                else {
                                    return;
                                }
                            }
                        }
                    }
                }
                else if (tag === currentTag && token.value === '/>') { // self-closing tag
                    depth--;
                    if (depth < 0) {//found self-closing tag end
                        //Example: <tagName attr/>
                        //`<tagName ` - opening part of tag consist of `openTagStart`, `openTagName` and `openTagEnd`
                        //`/>` - closing part of tag consist of `closeTagStart`, `closeTagName` and `closeTagEnd`
                        var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(),
                            iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2
                        );
                        var closeTagName = closeTagStart;
                        var closeTagEnd = closeTagName;

                        var openTagEnd = new Range(openTagName.end.row, openTagName.end.column, openTagName.end.row,
                            openTagName.end.column + 1
                        );

                    }
                }
            }
        } while (token && depth >= 0);

        if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {
            return {
                openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row,
                    openTagEnd.end.column
                ),
                closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row,
                    closeTagEnd.end.column
                ),
                openTagName: openTagName,
                closeTagName: closeTagName
            };
        }
    };

    this.$findOpeningTag = function (iterator, token) {
        var prevToken = iterator.getCurrentToken();
        var tag = token.value;
        var depth = 0;

        var startRow = iterator.getCurrentTokenRow();
        var startColumn = iterator.getCurrentTokenColumn();
        var endColumn = startColumn + 2;

        //closing tag
        var closeTagStart = new Range(startRow, startColumn, startRow, endColumn); //Range for </
        iterator.stepForward();
        var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(),
            iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length
        );

        if (token.type.indexOf('tag-close') === -1) {
            token = iterator.stepForward();
        }
        if (!token || token.value !== ">") return;
        var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(),
            iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1
        ); //Range for >

        iterator.stepBackward();
        iterator.stepBackward();
        do {
            token = prevToken;
            startRow = iterator.getCurrentTokenRow();
            startColumn = iterator.getCurrentTokenColumn();
            endColumn = startColumn + token.value.length;

            prevToken = iterator.stepBackward();

            if (token) {
                if (token.type.indexOf('tag-name') !== -1) {
                    if (tag === token.value) {
                        if (prevToken.value === '<') {
                            depth++;
                            if (depth > 0) {//found opening tag
                                var openTagName = new Range(startRow, startColumn, startRow, endColumn);
                                var openTagStart = new Range(iterator.getCurrentTokenRow(),
                                    iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(),
                                    iterator.getCurrentTokenColumn() + 1
                                ); //Range for <
                                do {
                                    token = iterator.stepForward();
                                } while (token && token.value !== '>');
                                var openTagEnd = new Range(iterator.getCurrentTokenRow(),
                                    iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(),
                                    iterator.getCurrentTokenColumn() + 1
                                ); //Range for >
                            }
                        }
                        else if (prevToken.value === '</') {
                            depth--;
                        }
                    }
                }
                else if (token.value === '/>') { // self-closing tag
                    var stepCount = 0;
                    var tmpToken = prevToken;
                    while (tmpToken) {
                        if (tmpToken.type.indexOf('tag-name') !== -1 && tmpToken.value === tag) {
                            depth--;
                            break;
                        }
                        else if (tmpToken.value === '<') {
                            break;
                        }
                        tmpToken = iterator.stepBackward();
                        stepCount++;
                    }
                    for (var i = 0; i < stepCount; i++) {
                        iterator.stepForward();
                    }
                }
            }
        } while (prevToken && depth <= 0);

        if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {
            return {
                openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row,
                    openTagEnd.end.column
                ),
                closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row,
                    closeTagEnd.end.column
                ),
                openTagName: openTagName,
                closeTagName: closeTagName
            };
        }
    };
}
exports.k = BracketMatch;


/***/ }),

/***/ 31079:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var dom = __webpack_require__(71435);
var oop = __webpack_require__(2645);
var EventEmitter = (__webpack_require__(87366).EventEmitter);

class Decorator {
    /**
     * @param {import("../../ace-internal").Ace.VScrollbar} scrollbarV
     * @param {import("../virtual_renderer").VirtualRenderer} renderer
     */
    constructor(scrollbarV, renderer) {
        this.renderer = renderer;

        this.pixelRatio = 1;
        this.maxHeight = renderer.layerConfig.maxHeight;
        this.lineHeight = renderer.layerConfig.lineHeight;
        this.minDecorationHeight = (2 * this.pixelRatio) | 0;
        this.halfMinDecorationHeight = (this.minDecorationHeight / 2) | 0;
        this.colors = {};
        this.colors.dark = {
            "error": "rgba(255, 18, 18, 1)",
            "warning": "rgba(18, 136, 18, 1)",
            "info": "rgba(18, 18, 136, 1)",
        };

        this.colors.light = {
            "error": "rgb(255,51,51)",
            "warning": "rgb(32,133,72)",
            "info": "rgb(35,68,138)",
        };

        this.setScrollBarV(scrollbarV);
    }

    $createCanvas() {
        this.canvas = dom.createElement("canvas");
        this.canvas.style.top = 0 + "px";
        this.canvas.style.right = 0 + "px";
        this.canvas.style.zIndex = "7";
        this.canvas.style.position = "absolute";
    }

    setScrollBarV(scrollbarV) {
        this.$createCanvas();
        this.scrollbarV = scrollbarV;
        scrollbarV.element.appendChild(this.canvas);
        this.setDimensions();
    }

    $updateDecorators(config) {
        if (typeof this.canvas.getContext !== "function") {
            return;
        }
        var colors = (this.renderer.theme.isDark === true) ? this.colors.dark : this.colors.light;
        this.setDimensions(config);

        var ctx = this.canvas.getContext("2d");

        function compare(a, b) {
            if (a.priority < b.priority) return -1;
            if (a.priority > b.priority) return 1;
            return 0;
        }

        var annotations = this.renderer.session.$annotations;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        if (annotations) {
            var priorities = {
                "info": 1,
                "warning": 2,
                "error": 3
            };
            annotations.forEach(function (item) {
                item["priority"] = priorities[item.type] || null;
            });
            annotations = annotations.sort(compare);

            for (let i = 0; i < annotations.length; i++) {
                let row = annotations[i].row;
                const offset1 = this.getVerticalOffsetForRow(row);
                const offset2 = offset1 + this.lineHeight;

                const y1 = Math.round(this.heightRatio * offset1);
                const y2 = Math.round(this.heightRatio * offset2);
                let ycenter = Math.round((y1 + y2) / 2);
                let halfHeight = (y2 - ycenter);

                if (halfHeight < this.halfMinDecorationHeight) {
                    halfHeight = this.halfMinDecorationHeight;
                }
                if (ycenter - halfHeight < 0) {
                    ycenter = halfHeight;
                }
                if (ycenter + halfHeight > this.canvasHeight) {
                    ycenter = this.canvasHeight - halfHeight;
                }

                const from =  ycenter - halfHeight;
                const to = ycenter + halfHeight;
                const zoneHeight = to - from;

                ctx.fillStyle = colors[annotations[i].type] || null;
                ctx.fillRect(0, from, Math.round(this.oneZoneWidth - 1), zoneHeight);
            }
        }
        var cursor = this.renderer.session.selection.getCursor();
        if (cursor) {
            let currentY = Math.round(this.getVerticalOffsetForRow(cursor.row) * this.heightRatio);
            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            ctx.fillRect(0, currentY, this.canvasWidth, 2);
        }

    }

    getVerticalOffsetForRow(row) {
        row = row | 0;
        const offset = this.renderer.session.documentToScreenRow(row, 0) * this.lineHeight;
        return offset;
    }

    setDimensions(config) {
        config = config || this.renderer.layerConfig;
        this.maxHeight = config.maxHeight;
        this.lineHeight = config.lineHeight;
        this.canvasHeight = config.height;
        this.canvasWidth = this.scrollbarV.width || this.canvasWidth;

        this.setZoneWidth();

        this.canvas.width = this.canvasWidth;
        this.canvas.height = this.canvasHeight;

        if (this.maxHeight < this.canvasHeight) {
            this.heightRatio = 1;
        }
        else {
            this.heightRatio = this.canvasHeight / this.maxHeight;
        }
    }

    setZoneWidth() {
        this.oneZoneWidth = this.canvasWidth;
    }

    destroy() {
        this.canvas.parentNode.removeChild(this.canvas);
    }
}

oop.implement(Decorator.prototype, EventEmitter);

exports.K = Decorator;


/***/ }),

/***/ 32291:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("../editor").Editor} Editor
 */
var event = __webpack_require__(19631);
var useragent = __webpack_require__(74943);
var DefaultHandlers = (__webpack_require__(88416)/* .DefaultHandlers */ .J);
var DefaultGutterHandler = (__webpack_require__(83229)/* .GutterHandler */ .Y);
var MouseEvent = (__webpack_require__(85519)/* .MouseEvent */ .C);
var DragdropHandler = (__webpack_require__(69615)/* .DragdropHandler */ .O);
var addTouchListeners = (__webpack_require__(55119)/* .addTouchListeners */ .A);
var config = __webpack_require__(76321);

class MouseHandler {
    /**
     * @param {Editor} editor
     */
    constructor(editor) {
        /** @type {boolean} */this.$dragDelay;
        /** @type {boolean} */this.$dragEnabled;
        /** @type {boolean} */this.$mouseMoved;
        /** @type {MouseEvent} */this.mouseEvent;
        /** @type {number} */this.$focusTimeout;
        var _self = this;
        this.editor = editor;

        new DefaultHandlers(this);
        new DefaultGutterHandler(this);
        new DragdropHandler(this);

        var focusEditor = function(e) {
            // because we have to call event.preventDefault() any window on ie and iframes
            // on other browsers do not get focus, so we have to call window.focus() here
            var windowBlurred = !document.hasFocus || !document.hasFocus()
                || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());
            if (windowBlurred)
                window.focus();
            editor.focus();
            // Without this editor is blurred after double click
            setTimeout(function () {
                if (!editor.isFocused()) editor.focus();
            });
        };

        var mouseTarget = editor.renderer.getMouseEventTarget();
        event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"), editor);
        event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"), editor);
        event.addMultiMouseDownListener([
            mouseTarget,
            editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,
            editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,
            editor.textInput && editor.textInput.getElement()
        ].filter(Boolean), [400, 300, 250], this, "onMouseEvent", editor);
        event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"), editor);
        addTouchListeners(editor.container, editor);

        var gutterEl = editor.renderer.$gutter;
        event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"), editor);
        event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"), editor);
        event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"), editor);
        event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"), editor);

        event.addListener(mouseTarget, "mousedown", focusEditor, editor);
        event.addListener(gutterEl, "mousedown", focusEditor, editor);
        if (useragent.isIE && editor.renderer.scrollBarV) {
            event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor, editor);
            event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor, editor);
        }

        editor.on("mousemove", function(e){
            if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
                return;

            var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
            var range = editor.session.selection.getRange();
            var renderer = editor.renderer;

            if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
                renderer.setCursorStyle("default");
            } else {
                renderer.setCursorStyle("");
            }

        }, //@ts-expect-error TODO: seems mistyping - should be boolean
            editor);
    }

    onMouseEvent(name, e) {
        if (!this.editor.session) return;
        this.editor._emit(name, new MouseEvent(e, this.editor));
    }

    onMouseMove(name, e) {
        // optimization, because mousemove doesn't have a default handler.
        var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
        if (!listeners || !listeners.length)
            return;

        this.editor._emit(name, new MouseEvent(e, this.editor));
    }

    /**
     * @param {any} name
     * @param {{ wheelX: number; wheelY: number; }} e
     */
    onMouseWheel(name, e) {
        var mouseEvent = new MouseEvent(e, this.editor);
        //@ts-expect-error TODO: couldn't find this property init in the ace codebase
        mouseEvent.speed = this.$scrollSpeed * 2;
        mouseEvent.wheelX = e.wheelX;
        mouseEvent.wheelY = e.wheelY;

        this.editor._emit(name, mouseEvent);
    }

    setState(state) {
        this.state = state;
    }

    /**
     *
     * @param {MouseEvent} ev
     * @param [mouseMoveHandler]
     * @return {ReturnType<typeof setTimeout> | undefined}
     */
    captureMouse(ev, mouseMoveHandler) {
        this.x = ev.x;
        this.y = ev.y;

        this.isMousePressed = true;

        // do not move textarea during selection
        var editor = this.editor;
        var renderer = this.editor.renderer;
        renderer.$isMousePressed = true;

        var self = this;
        var continueCapture = true;

        var onMouseMove = function(e) {
            if (!e) return;
            // if editor is loaded inside iframe, and mouseup event is outside
            // we won't recieve it, so we cancel on first mousemove without button
            if (useragent.isWebKit && !e.which && self.releaseMouse)
                return self.releaseMouse();

            self.x = e.clientX;
            self.y = e.clientY;
            mouseMoveHandler && mouseMoveHandler(e);
            self.mouseEvent = new MouseEvent(e, self.editor);
            self.$mouseMoved = true;
        };

        var onCaptureEnd = function(e) {
            editor.off("beforeEndOperation", onOperationEnd);
            continueCapture = false;
            if (editor.session) onCaptureUpdate();
            self[self.state + "End"] && self[self.state + "End"](e);
            self.state = "";
            self.isMousePressed = renderer.$isMousePressed = false;
            if (renderer.$keepTextAreaAtCursor)
                renderer.$moveTextAreaToCursor();
            self.$onCaptureMouseMove = self.releaseMouse = null;
            e && self.onMouseEvent("mouseup", e);
            editor.endOperation();
        };

        var onCaptureUpdate = function() {
            self[self.state] && self[self.state]();
            self.$mouseMoved = false;
        };

        var onCaptureInterval = function() {
            if (continueCapture) {
                onCaptureUpdate();
                event.nextFrame(onCaptureInterval);
            }
        };

        if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
            return setTimeout(function() {onCaptureEnd(ev);});
        }

        var onOperationEnd = function(e) {
            if (!self.releaseMouse) return;
            // some touchpads fire mouseup event after a slight delay,
            // which can cause problems if user presses a keyboard shortcut quickly
            if (editor.curOp.command.name && editor.curOp.selectionChanged) {
                self[self.state + "End"] && self[self.state + "End"]();
                self.state = "";
                self.releaseMouse();
            }
        };

        editor.on("beforeEndOperation", onOperationEnd);
        editor.startOperation({command: {name: "mouse"}});

        self.$onCaptureMouseMove = onMouseMove;
        self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);

        onCaptureInterval();
    }
    cancelContextMenu() {
        var stop = function(e) {
            if (e && e.domEvent && e.domEvent.type != "contextmenu")
                return;
            this.editor.off("nativecontextmenu", stop);
            if (e && e.domEvent)
                event.stopEvent(e.domEvent);
        }.bind(this);
        setTimeout(stop, 10);
        this.editor.on("nativecontextmenu", stop);
    }
    destroy() {
        if (this.releaseMouse) this.releaseMouse();
        if (this.$tooltip) this.$tooltip.destroy();
    }
}

MouseHandler.prototype.releaseMouse = null;

config.defineOptions(MouseHandler.prototype, "mouseHandler", {
    scrollSpeed: {initialValue: 2},
    dragDelay: {initialValue: (useragent.isMac ? 150 : 0)},
    dragEnabled: {initialValue: true},
    focusTimeout: {initialValue: 0},
});


exports.e = MouseHandler;


/***/ }),

/***/ 32589:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var oop = __webpack_require__(2645);
var Behaviour = (__webpack_require__(75684)/* .Behaviour */ .Q);
var TokenIterator = (__webpack_require__(99339).TokenIterator);
var lang = __webpack_require__(39955);

var SAFE_INSERT_IN_TOKENS =
    ["text", "paren.rparen", "rparen", "paren", "punctuation.operator"];
var SAFE_INSERT_BEFORE_TOKENS =
    ["text", "paren.rparen", "rparen", "paren", "punctuation.operator", "comment"];

var context;
var contextCache = {};
var defaultQuotes = {'"' : '"', "'" : "'"};

var initContext = function(editor) {
    var id = -1;
    if (editor.multiSelect) {
        id = editor.selection.index;
        if (contextCache.rangeCount != editor.multiSelect.rangeCount)
            contextCache = {rangeCount: editor.multiSelect.rangeCount};
    }
    if (contextCache[id])
        return context = contextCache[id];
    context = contextCache[id] = {
        autoInsertedBrackets: 0,
        autoInsertedRow: -1,
        autoInsertedLineEnd: "",
        maybeInsertedBrackets: 0,
        maybeInsertedRow: -1,
        maybeInsertedLineStart: "",
        maybeInsertedLineEnd: ""
    };
};

var getWrapped = function(selection, selected, opening, closing) {
    var rowDiff = selection.end.row - selection.start.row;
    return {
        text: opening + selected + closing,
        selection: [
                0,
                selection.start.column + 1,
                rowDiff,
                selection.end.column + (rowDiff ? 0 : 1)
            ]
    };
};
/**
 * Creates a new Cstyle behaviour object with the specified options.
 * @param {Object} [options] - The options for the Cstyle behaviour object.
 * @param {boolean} [options.braces] - Whether to force braces auto-pairing.
 * @param {boolean} [options.closeDocComment] - enables automatic insertion of closing tags for documentation comments.
 */
var CstyleBehaviour;
CstyleBehaviour = function(options) {
    options = options || {};
    this.add("braces", "insertion", function(state, action, editor, session, text) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (text == '{') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            var token = session.getTokenAt(cursor.row, cursor.column);
            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '{', '}');
            }
            else if (token && /(?:string)\.quasi|\.xml/.test(token.type)) {
                let excludeTokens = [
                    /tag\-(?:open|name)/, /attribute\-name/
                ];
                if (excludeTokens.some((el) => el.test(token.type)) || /(string)\.quasi/.test(token.type)
                    && token.value[cursor.column - token.start - 1] !== '$') return;

                CstyleBehaviour.recordAutoInsert(editor, session, "}");
                return {
                    text: '{}',
                    selection: [1, 1]
                };
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options.braces) {
                    CstyleBehaviour.recordAutoInsert(editor, session, "}");
                    return {
                        text: '{}',
                        selection: [1, 1]
                    };
                } else {
                    CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                    return {
                        text: '{',
                        selection: [1, 1]
                    };
                }
            }
        } else if (text == '}') {
            initContext(editor);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == '}') {
                var matching = session.$findOpeningBracket('}', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        } else if (text == "\n" || text == "\r\n") {
            initContext(editor);
            var closing = "";
            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
                closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
                CstyleBehaviour.clearMaybeInsertedClosing();
            }
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === '}') {
                var openBracePos = session.findMatchingBracket({row: cursor.row, column: cursor.column+1}, '}');
                if (!openBracePos)
                     return null;
                var next_indent = this.$getIndent(session.getLine(openBracePos.row));
            } else if (closing) {
                var next_indent = this.$getIndent(line);
            } else {
                CstyleBehaviour.clearMaybeInsertedClosing();
                return;
            }
            var indent = next_indent + session.getTabString();

            return {
                text: '\n' + indent + '\n' + next_indent + closing,
                selection: [1, indent.length, 1, indent.length]
            };
        } else {
            CstyleBehaviour.clearMaybeInsertedClosing();
        }
    });

    this.add("braces", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '{') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.end.column, range.end.column + 1);
            if (rightChar == '}') {
                range.end.column++;
                return range;
            } else {
                context.maybeInsertedBrackets--;
            }
        }
    });

    this.add("parens", "insertion", function(state, action, editor, session, text) {
        if (text == '(') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '(', ')');
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, ")");
                return {
                    text: '()',
                    selection: [1, 1]
                };
            }
        } else if (text == ')') {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ')') {
                var matching = session.$findOpeningBracket(')', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        }
    });

    this.add("parens", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '(') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ')') {
                range.end.column++;
                return range;
            }
        }
    });

    this.add("brackets", "insertion", function(state, action, editor, session, text) {
        if (text == '[') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '[', ']');
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, "]");
                return {
                    text: '[]',
                    selection: [1, 1]
                };
            }
        } else if (text == ']') {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ']') {
                var matching = session.$findOpeningBracket(']', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        }
    });

    this.add("brackets", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '[') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ']') {
                range.end.column++;
                return range;
            }
        }
    });

    this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
        var quotes = session.$mode.$quotes || defaultQuotes;
        if (text.length == 1 && quotes[text]) {
            if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1)
                return;
            initContext(editor);
            var quote = text;
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, quote, quote);
            } else if (!selected) {
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                var leftChar = line.substring(cursor.column-1, cursor.column);
                var rightChar = line.substring(cursor.column, cursor.column + 1);

                var token = session.getTokenAt(cursor.row, cursor.column);
                var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
                // We're escaped.
                if (leftChar == "\\" && token && /escape/.test(token.type))
                    return null;

                var stringBefore = token && /string|escape/.test(token.type);
                var stringAfter = !rightToken || /string|escape/.test(rightToken.type);

                var pair;
                if (rightChar == quote) {
                    pair = stringBefore !== stringAfter;
                    if (pair && /string\.end/.test(rightToken.type))
                        pair = false;
                } else {
                    if (stringBefore && !stringAfter)
                        return null; // wrap string with different quote
                    if (stringBefore && stringAfter)
                        return null; // do not pair quotes inside strings
                    var wordRe = session.$mode.tokenRe;
                    wordRe.lastIndex = 0;
                    var isWordBefore = wordRe.test(leftChar);
                    wordRe.lastIndex = 0;
                    var isWordAfter = wordRe.test(rightChar);

                    var pairQuotesAfter = session.$mode.$pairQuotesAfter;
                    var shouldPairQuotes = pairQuotesAfter && pairQuotesAfter[quote] && pairQuotesAfter[quote].test(leftChar);

                    if ((!shouldPairQuotes && isWordBefore) || isWordAfter)
                        return null; // before or after alphanumeric
                    if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
                        return null; // there is rightChar and it isn't closing
                    var charBefore = line[cursor.column - 2];
                    if (leftChar == quote &&  (charBefore == quote || wordRe.test(charBefore)))
                        return null;
                    pair = true;
                }
                return {
                    text: pair ? quote + quote : "",
                    selection: [1,1]
                };
            }
        }
    });

    this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
        var quotes = session.$mode.$quotes || defaultQuotes;

        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && quotes.hasOwnProperty(selected)) {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
                range.end.column++;
                return range;
            }
        }
    });

    if (options.closeDocComment !== false) {
        this.add("doc comment end", "insertion", function (state, action, editor, session, text) {
            if (state === "doc-start" && (text === "\n" || text === "\r\n") && editor.selection.isEmpty()) {
                var cursor = editor.getCursorPosition();
                if (cursor.column === 0) {
                    return;
                }
                var line = session.doc.getLine(cursor.row);
                var nextLine = session.doc.getLine(cursor.row + 1);
                var tokens = session.getTokens(cursor.row);
                var index = 0;
                for (var i = 0; i < tokens.length; i++) {
                    index += tokens[i].value.length;
                    var currentToken = tokens[i];
                    if (index >= cursor.column) {
                        if (index === cursor.column) {
                            if (!/\.doc/.test(currentToken.type)) {
                                return;
                            }
                            if (/\*\//.test(currentToken.value)) {
                                var nextToken = tokens[i + 1];
                                if (!nextToken || !/\.doc/.test(nextToken.type)) {
                                    return;
                                }
                            }
                        }
                        var cursorPosInToken = cursor.column - (index - currentToken.value.length);

                        // Check for the pattern `*/` followed by `/**` within the token
                        var closeDocPos = currentToken.value.indexOf("*/");
                        var openDocPos = currentToken.value.indexOf("/**", closeDocPos > - 1 ? closeDocPos + 2 : 0);

                        if (openDocPos !== -1 && cursorPosInToken > openDocPos && cursorPosInToken < openDocPos + 3) {
                            return;
                        }
                        if (closeDocPos !== -1 && openDocPos !== -1 && cursorPosInToken >= closeDocPos
                            && cursorPosInToken <= openDocPos || !/\.doc/.test(currentToken.type)) {
                            return;
                        }
                        break;
                    }
                }
                var indent = this.$getIndent(line);
                if (/\s*\*/.test(nextLine)) {
                    if (/^\s*\*/.test(line)) {
                        return {
                            text: text + indent + "* ",
                            selection: [1, 2 + indent.length, 1, 2 + indent.length]
                        };
                    }
                    else {
                        return {
                            text: text + indent + " * ",
                            selection: [1, 3 + indent.length, 1, 3 + indent.length]
                        };
                    }

                }
                if (/\/\*\*/.test(line.substring(0, cursor.column))) {
                    return {
                        text: text + indent + " * " + text + " " + indent + "*/",
                        selection: [1, 4 + indent.length, 1, 4 + indent.length]
                    };
                }
            }
        });
    }
};

/**
 * @this {CstyleBehaviour}
 */
// @ts-ignore
CstyleBehaviour.isSaneInsertion = function(editor, session) {
    var cursor = editor.getCursorPosition();
    var iterator = new TokenIterator(session, cursor.row, cursor.column);

    // Don't insert in the middle of a keyword/identifier/lexical
    if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
        if (/[)}\]]/.test(editor.session.getLine(cursor.row)[cursor.column]))
            return true;
        // Look ahead in case we're at the end of a token
        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
        if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
            return false;
    }

    // Only insert in front of whitespace/comments
    iterator.stepForward();
    return iterator.getCurrentTokenRow() !== cursor.row ||
        this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
};
CstyleBehaviour["$matchTokenType"] = function(token, types) {
    return types.indexOf(token.type || token) > -1;
};

CstyleBehaviour["recordAutoInsert"] = function(editor, session, bracket) {
    var cursor = editor.getCursorPosition();
    var line = session.doc.getLine(cursor.row);
    // Reset previous state if text or context changed too much
    if (!this["isAutoInsertedClosing"](cursor, line, context.autoInsertedLineEnd[0]))
        context.autoInsertedBrackets = 0;
    context.autoInsertedRow = cursor.row;
    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
    context.autoInsertedBrackets++;
};

CstyleBehaviour["recordMaybeInsert"] = function(editor, session, bracket) {
    var cursor = editor.getCursorPosition();
    var line = session.doc.getLine(cursor.row);
    if (!this["isMaybeInsertedClosing"](cursor, line))
        context.maybeInsertedBrackets = 0;
    context.maybeInsertedRow = cursor.row;
    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
    context.maybeInsertedLineEnd = line.substr(cursor.column);
    context.maybeInsertedBrackets++;
};

CstyleBehaviour["isAutoInsertedClosing"] = function(cursor, line, bracket) {
    return context.autoInsertedBrackets > 0 &&
        cursor.row === context.autoInsertedRow &&
        bracket === context.autoInsertedLineEnd[0] &&
        line.substr(cursor.column) === context.autoInsertedLineEnd;
};

CstyleBehaviour["isMaybeInsertedClosing"] = function(cursor, line) {
    return context.maybeInsertedBrackets > 0 &&
        cursor.row === context.maybeInsertedRow &&
        line.substr(cursor.column) === context.maybeInsertedLineEnd &&
        line.substr(0, cursor.column) == context.maybeInsertedLineStart;
};

CstyleBehaviour["popAutoInsertedClosing"] = function() {
    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
    context.autoInsertedBrackets--;
};

CstyleBehaviour["clearMaybeInsertedClosing"] = function() {
    if (context) {
        context.maybeInsertedBrackets = 0;
        context.maybeInsertedRow = -1;
    }
};



oop.inherits(CstyleBehaviour, Behaviour);

exports._ = CstyleBehaviour;


/***/ }),

/***/ 32934:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

const reportError = (__webpack_require__(53092)/* .reportError */ .N);

// tokenizing lines longer than this makes editor very slow
var MAX_TOKEN_COUNT = 2000;
/**
 * This class takes a set of highlighting rules, and creates a tokenizer out of them. For more information, see [the wiki on extending highlighters](https://github.com/ajaxorg/ace/wiki/Creating-or-Extending-an-Edit-Mode#wiki-extendingTheHighlighter).
 **/
class Tokenizer {
    /**
     * Constructs a new tokenizer based on the given rules and flags.
     * @param {Object} rules The highlighting rules
     **/
    constructor(rules) {
        /**@type {RegExp}*/
        this.splitRegex;
        this.states = rules;

        this.regExps = {};
        this.matchMappings = {};
        for (var key in this.states) {
            var state = this.states[key];
            var ruleRegExps = [];
            var matchTotal = 0;
            var mapping = this.matchMappings[key] = {defaultToken: "text"};
            var flag = "g";

            var splitterRurles = [];
            for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                if (rule.defaultToken)
                    mapping.defaultToken = rule.defaultToken;
                if (rule.caseInsensitive && flag.indexOf("i") === -1)
                    flag += "i";
                if (rule.unicode && flag.indexOf("u") === -1)
                    flag += "u";
                if (rule.regex == null)
                    continue;

                if (rule.regex instanceof RegExp)
                    rule.regex = rule.regex.toString().slice(1, -1);

                // Count number of matching groups. 2 extra groups from the full match
                // And the catch-all on the end (used to force a match);
                var adjustedregex = rule.regex;
                var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
                if (Array.isArray(rule.token)) {
                    if (rule.token.length == 1 || matchcount == 1) {
                        rule.token = rule.token[0];
                    } else if (matchcount - 1 != rule.token.length) {
                        this.reportError("number of classes and regexp groups doesn't match", {
                            rule: rule,
                            groupCount: matchcount - 1
                        });
                        rule.token = rule.token[0];
                    } else {
                        rule.tokenArray = rule.token;
                        rule.token = null;
                        rule.onMatch = this.$arrayTokens;
                    }
                } else if (typeof rule.token == "function" && !rule.onMatch) {
                    if (matchcount > 1)
                        rule.onMatch = this.$applyToken;
                    else
                        rule.onMatch = rule.token;
                }

                if (matchcount > 1) {
                    if (/\\\d/.test(rule.regex)) {
                        // Replace any backreferences and offset appropriately.
                        adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
                            return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                        });
                    } else {
                        matchcount = 1;
                        adjustedregex = this.removeCapturingGroups(rule.regex);
                    }
                    if (!rule.splitRegex && typeof rule.token != "string")
                        splitterRurles.push(rule); // flag will be known only at the very end
                }

                mapping[matchTotal] = i;
                matchTotal += matchcount;

                ruleRegExps.push(adjustedregex);

                // makes property access faster
                if (!rule.onMatch)
                    rule.onMatch = null;
            }

            if (!ruleRegExps.length) {
                mapping[0] = 0;
                ruleRegExps.push("$");
            }

            splitterRurles.forEach(function(rule) {
                rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
            }, this);

            this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
        }
    }

    /**
     * @param {number} m
     */
    $setMaxTokenCount(m) {
        MAX_TOKEN_COUNT = m | 0;
    }

    /**
     * @param {string} str
     * @return {import("../ace-internal").Ace.Token[]}
     */
    $applyToken(str) {
        var values = this.splitRegex.exec(str).slice(1);
        //@ts-ignore
        var types = this.token.apply(this, values);

        // required for compatibility with old modes
        if (typeof types === "string")
            return [{type: types, value: str}];

        var tokens = [];
        for (var i = 0, l = types.length; i < l; i++) {
            if (values[i])
                tokens[tokens.length] = {
                    type: types[i],
                    value: values[i]
                };
        }
        return tokens;
    }

    /**
     * @param {string} str
     * @return {import("../ace-internal").Ace.Token[] | string}
     */
    $arrayTokens(str) {
        if (!str)
            return [];
        var values = this.splitRegex.exec(str);
        if (!values)
            return "text";
        var tokens = [];
        //@ts-ignore
        var types = this.tokenArray;
        for (var i = 0, l = types.length; i < l; i++) {
            if (values[i + 1])
                tokens[tokens.length] = {
                    type: types[i],
                    value: values[i + 1]
                };
        }
        return tokens;
    }

    /**
     * @param {string} src
     * @returns {string}
     */
    removeCapturingGroups(src) {
        var r = src.replace(
            /\\.|\[(?:\\.|[^\\\]])*|\(\?[:=!<]|(\()/g,
            function(x, y) {return y ? "(?:" : x;}
        );
        return r;
    }

    /**
     * @param {string} src
     * @param {string} flag
     */
    createSplitterRegexp(src, flag) {
        if (src.indexOf("(?=") != -1) {
            var stack = 0;
            var inChClass = false;
            var lastCapture = {};
            src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(
                m, esc, parenOpen, parenClose, square, index
            ) {
                if (inChClass) {
                    inChClass = square != "]";
                } else if (square) {
                    inChClass = true;
                } else if (parenClose) {
                    if (stack == lastCapture.stack) {
                        lastCapture.end = index+1;
                        lastCapture.stack = -1;
                    }
                    stack--;
                } else if (parenOpen) {
                    stack++;
                    if (parenOpen.length != 1) {
                        lastCapture.stack = stack;
                        lastCapture.start = index;
                    }
                }
                return m;
            });

            if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
        }
        
        // this is needed for regexps that can match in multiple ways
        if (src.charAt(0) != "^") src = "^" + src;
        if (src.charAt(src.length - 1) != "$") src += "$";
        
        return new RegExp(src, (flag||"").replace("g", ""));
    }

    /**
     * Returns an object containing two properties: `tokens`, which contains all the tokens; and `state`, the current state.
     * @param {string} line
     * @param {string | string[]} startState
     * @returns {{tokens:import("../ace-internal").Ace.Token[], state: string|string[]}}
     */
    getLineTokens(line, startState) {
        if (startState && typeof startState != "string") {
            /**@type {any[]}*/
            var stack = startState.slice(0);
            startState = stack[0];
            if (startState === "#tmp") {
                stack.shift();
                startState = stack.shift();
            }
        } else
            var stack = [];

        var currentState = /**@type{string}*/(startState) || "start";
        var state = this.states[currentState];
        if (!state) {
            currentState = "start";
            state = this.states[currentState];
        }
        var mapping = this.matchMappings[currentState];
        var re = this.regExps[currentState];
        re.lastIndex = 0;

        var match, tokens = [];
        var lastIndex = 0;
        var matchAttempts = 0;

        var token = {type: null, value: ""};

        while (match = re.exec(line)) {
            var type = mapping.defaultToken;
            var rule = null;
            var value = match[0];
            var index = re.lastIndex;

            if (index - value.length > lastIndex) {
                var skipped = line.substring(lastIndex, index - value.length);
                if (token.type == type) {
                    token.value += skipped;
                } else {
                    if (token.type)
                        tokens.push(token);
                    token = {type: type, value: skipped};
                }
            }

            for (var i = 0; i < match.length-2; i++) {
                if (match[i + 1] === undefined)
                    continue;

                rule = state[mapping[i]];

                if (rule.onMatch)
                    type = rule.onMatch(value, currentState, stack, line);
                else
                    type = rule.token;

                if (rule.next) {
                    if (typeof rule.next == "string") {
                        currentState = rule.next;
                    } else {
                        currentState = rule.next(currentState, stack);
                    }
                    
                    state = this.states[currentState];
                    if (!state) {
                        this.reportError("state doesn't exist", currentState);
                        currentState = "start";
                        state = this.states[currentState];
                    }
                    mapping = this.matchMappings[currentState];
                    lastIndex = index;
                    re = this.regExps[currentState];
                    re.lastIndex = index;
                }
                if (rule.consumeLineEnd)
                    lastIndex = index;
                break;
            }

            if (value) {
                if (typeof type === "string") {
                    if ((!rule || rule.merge !== false) && token.type === type) {
                        token.value += value;
                    } else {
                        if (token.type)
                            tokens.push(token);
                        token = {type: type, value: value};
                    }
                } else if (type) {
                    if (token.type)
                        tokens.push(token);
                    token = {type: null, value: ""};
                    for (var i = 0; i < type.length; i++)
                        tokens.push(type[i]);
                }
            }

            if (lastIndex == line.length)
                break;

            lastIndex = index;

            if (matchAttempts++ > MAX_TOKEN_COUNT) {
                if (matchAttempts > 2 * line.length) {
                    this.reportError("infinite loop with in ace tokenizer", {
                        startState: startState,
                        line: line
                    });
                }
                // chrome doens't show contents of text nodes with very long text
                while (lastIndex < line.length) {
                    if (token.type)
                        tokens.push(token);
                    token = {
                        value: line.substring(lastIndex, lastIndex += 500),
                        type: "overflow"
                    };
                }
                currentState = "start";
                stack = [];
                break;
            }
        }

        if (token.type)
            tokens.push(token);
        
        if (stack.length > 1) {
            if (stack[0] !== currentState)
                stack.unshift("#tmp", currentState);
        }
        return {
            tokens : tokens,
            state : stack.length ? stack : currentState
        };
    }
}

Tokenizer.prototype.reportError = reportError;
exports.Tokenizer = Tokenizer;


/***/ }),

/***/ 33464:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./layer/font_metrics").FontMetrics} FontMetrics
 * @typedef {import("./edit_session/fold_line").FoldLine} FoldLine
 * @typedef {import("../ace-internal").Ace.Point} Point
 * @typedef {import("../ace-internal").Ace.Delta} Delta
 * @typedef {import("../ace-internal").Ace.IRange} IRange
 * @typedef {import("../ace-internal").Ace.SyntaxMode} SyntaxMode
 * @typedef {import("../ace-internal").Ace.LineWidget} LineWidget
 */

var oop = __webpack_require__(2645);
var lang = __webpack_require__(39955);
var BidiHandler = (__webpack_require__(16585)/* .BidiHandler */ .t);
var config = __webpack_require__(76321);
var EventEmitter = (__webpack_require__(87366).EventEmitter);
var Selection = (__webpack_require__(98345)/* .Selection */ .L);
var TextMode = (__webpack_require__(49432).Mode);
var Range = (__webpack_require__(91902)/* .Range */ .Q);
var LineWidgets = (__webpack_require__(90563)/* .LineWidgets */ .G);
var Document = (__webpack_require__(98306)/* .Document */ .y);
var BackgroundTokenizer = (__webpack_require__(93857)/* .BackgroundTokenizer */ .K);
var SearchHighlight = (__webpack_require__(10464)/* .SearchHighlight */ .V);
var UndoManager = (__webpack_require__(79870)/* .UndoManager */ .a);

/**
 * @typedef TextMode
 * @type {SyntaxMode}
 */

/**
 * Stores all the data about [[Editor `Editor`]] state providing easy way to change editors state.
 *
 * `EditSession` can be attached to only one [[Document `Document`]]. Same `Document` can be attached to several `EditSession`s.
 **/
class EditSession {
    /**
     * Sets up a new `EditSession` and associates it with the given `Document` and `Mode`.
     * @param {Document | String} [text] [If `text` is a `Document`, it associates the `EditSession` with it. Otherwise, a new `Document` is created, with the initial text]{: #textParam}
     * @param {SyntaxMode} [mode] [The initial language mode to use for the document]{: #modeParam}
     **/
    constructor(text, mode) {
        /**@type {Document}*/this.doc;
        this.$breakpoints = [];
        this.$decorations = [];
        this.$frontMarkers = {};
        this.$backMarkers = {};
        this.$markerId = 1;
        this.$undoSelect = true;
        this.$editor = null;
        this.prevOp = {};

        /** @type {FoldLine[]} */
        this.$foldData = [];
        this.id = "session" + (++EditSession.$uid);
        this.$foldData.toString = function() {
            return this.join("\n");
        };

        // @experimental
        this.$gutterCustomWidgets = {};

        // Set default background tokenizer with Text mode until editor session mode is set
        this.bgTokenizer = new BackgroundTokenizer((new TextMode()).getTokenizer(), this);


        var _self = this;
        this.bgTokenizer.on("update", function(e) {
            _self._signal("tokenizerUpdate", e);
        });

        this.on("changeFold", this.onChangeFold.bind(this));
        this.$onChange = this.onChange.bind(this);

        if (typeof text != "object" || !text.getLine)
            text = new Document(/**@type{string}*/(text));

        this.setDocument(text);

        this.selection = new Selection(this);
        this.$onSelectionChange = this.onSelectionChange.bind(this);
        this.selection.on("changeSelection", this.$onSelectionChange);
        this.selection.on("changeCursor", this.$onSelectionChange);

        this.$bidiHandler = new BidiHandler(this);

        config.resetOptions(this);
        this.setMode(mode);
        config._signal("session", this);

        this.destroyed = false;
        this.$initOperationListeners();
    }

    $initOperationListeners() {
        /**@type {import("../ace-internal").Ace.Operation | null}*/
        this.curOp = null;
        this.on("change", () => {
            if (!this.curOp) {
                this.startOperation();
                this.curOp.selectionBefore = this.$lastSel;
            }
            this.curOp.docChanged = true;
        }, true);
        this.on("changeSelection", () => {
            if (!this.curOp) {
                this.startOperation();
                this.curOp.selectionBefore = this.$lastSel;
            }
            this.curOp.selectionChanged = true;
        }, true);

        // Fallback mechanism in case current operation doesn't finish more explicitly.
        // Triggered, for example, when a consumer makes programmatic changes without invoking endOperation afterwards.
        this.$operationResetTimer = lang.delayedCall(this.endOperation.bind(this, true));
    }

    /**
     * Start an Ace operation, which will then batch all the subsequent changes (to either content or selection) under a single atomic operation.
     * @param {{command?: {name?: string}, args?: any}|undefined} [commandEvent] Optional name for the operation
     */
    startOperation(commandEvent) {
        if (this.curOp) {
            if (!commandEvent || this.curOp.command) {
                return;
            }
            this.prevOp = this.curOp;
        }
        if (!commandEvent) {
            commandEvent = {};
        }

        this.$operationResetTimer.schedule();
        this.curOp = {
            command: commandEvent.command || {},
            args: commandEvent.args
        };
        this.curOp.selectionBefore = this.selection.toJSON();
        this._signal("startOperation", commandEvent);
    }

    /**
     * End current Ace operation.
     * Emits "beforeEndOperation" event just before clearing everything, where the current operation can be accessed through `curOp` property.
     * @param {any} [e]
     */
    endOperation(e) {
        if (this.curOp) {
            if (e && e.returnValue === false) {
                this.curOp = null;
                this._signal("endOperation", e);
                return;
            }
            if (e == true && this.curOp.command && this.curOp.command.name == "mouse") {
                // When current operation is mousedown, we wait for the mouseup to end the operation.
                // So during a user selection, we would only end the operation when the final selection is known.
                return;
            }

            const currentSelection = this.selection.toJSON();
            this.curOp.selectionAfter = currentSelection;
            this.$lastSel = this.selection.toJSON();
            this.getUndoManager().addSelection(currentSelection);

            this._signal("beforeEndOperation");
            this.prevOp = this.curOp;
            this.curOp = null;
            this._signal("endOperation", e);
        }
    }

    /**
     * Sets the `EditSession` to point to a new `Document`. If a `BackgroundTokenizer` exists, it also points to `doc`.
     *
     * @param {Document} doc The new `Document` to use
     *
     **/
    setDocument(doc) {
        if (this.doc)
            this.doc.off("change", this.$onChange);
        this.doc = doc;
        doc.on("change", this.$onChange, true);

        this.bgTokenizer.setDocument(this.getDocument());

        this.resetCaches();
    }

    /**
     * Returns the `Document` associated with this session.
     * @return {Document}
     **/
    getDocument() {
        return this.doc;
    }

    /**
     * Get "widgetManager" from EditSession
     *
     * @returns {LineWidgets} object
     */
    get widgetManager() {
        const widgetManager = new LineWidgets(this);
        // todo remove the widgetManger assignement from lineWidgets constructor when introducing breaking changes
        this.widgetManager = widgetManager;

        if (this.$editor)
            widgetManager.attach(this.$editor);

        return widgetManager;
    }

    /**
     * Set "widgetManager" in EditSession
     *
     * @returns void
     */
    set widgetManager(value) {
        Object.defineProperty(this, "widgetManager", {
            writable: true,
            enumerable: true,
            configurable: true,
            value: value,
        });
    }
    /**
     * @param {Number} docRow The row to work with
     *
     **/
    $resetRowCache(docRow) {
        if (!docRow) {
            /** @type {number[]} */
            this.$docRowCache = [];
            /** @type {number[]} */
            this.$screenRowCache = [];
            return;
        }
        var l = this.$docRowCache.length;
        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
        if (l > i) {
            this.$docRowCache.splice(i, l);
            this.$screenRowCache.splice(i, l);
        }
    }

    $getRowCacheIndex(cacheArray, val) {
        var low = 0;
        var hi = cacheArray.length - 1;

        while (low <= hi) {
            var mid = (low + hi) >> 1;
            var c = cacheArray[mid];

            if (val > c)
                low = mid + 1;
            else if (val < c)
                hi = mid - 1;
            else
                return mid;
        }

        return low -1;
    }

    resetCaches() {
        this.$modified = true;
        this.$wrapData = [];
        this.$rowLengthCache = [];
        this.$resetRowCache(0);
        if (!this.destroyed)
            this.bgTokenizer.start(0);
    }

    /**
     * @param e
     * @internal
     */
    onChangeFold(e) {
        var fold = e.data;
        this.$resetRowCache(fold.start.row);
    }

    /**
     *
     * @param {Delta} delta
     * @internal
     */
    onChange(delta) {
        this.$modified = true;
        this.$bidiHandler.onChange(delta);
        this.$resetRowCache(delta.start.row);

        var removedFolds = this.$updateInternalDataOnChange(delta);
        if (!this.$fromUndo && this.$undoManager) {
            if (removedFolds && removedFolds.length) {
                this.$undoManager.add({
                    // @ts-expect-error TODO: this action type is missing in the types
                    action: "removeFolds",
                    folds:  removedFolds
                }, this.mergeUndoDeltas);
                this.mergeUndoDeltas = true;
            }
            this.$undoManager.add(delta, this.mergeUndoDeltas);
            this.mergeUndoDeltas = true;

            this.$informUndoManager.schedule();
        }

        this.bgTokenizer.$updateOnChange(delta);
        this._signal("change", delta);
    }

    onSelectionChange() {
        this._signal("changeSelection");
    }

    /**
     * Sets the session text.
     * @param {String} text The new text to place
     **/
    setValue(text) {
        this.doc.setValue(text);
        this.selection.moveTo(0, 0);

        this.$resetRowCache(0);
        this.setUndoManager(this.$undoManager);
        this.getUndoManager().reset();
    }

     /**
     * Returns a new instance of EditSession with state from JSON.
     * @method fromJSON
     * @param {string|object} session The EditSession state.
     * @returns {EditSession}
     */
    static fromJSON(session) {
        if (typeof session == "string")
            session = JSON.parse(session);
        const undoManager = new UndoManager();
        undoManager.$undoStack = session.history.undo;
        undoManager.$redoStack = session.history.redo;
        undoManager.mark = session.history.mark;
        undoManager.$rev = session.history.rev;

        const editSession = new EditSession(session.value);
        session.folds.forEach(function(fold) {
          editSession.addFold("...", Range.fromPoints(fold.start, fold.end));
        });
        editSession.setAnnotations(session.annotations);
        editSession.setBreakpoints(session.breakpoints);
        editSession.setMode(session.mode);
        editSession.setScrollLeft(session.scrollLeft);
        editSession.setScrollTop(session.scrollTop);
        editSession.setUndoManager(undoManager);
        editSession.selection.fromJSON(session.selection);

        return editSession;
    }

    /**
     * Returns the current edit session.
     * @method toJSON
     * @returns {Object}
     */
    toJSON() {
        return {
            annotations: this.$annotations,
            breakpoints: this.$breakpoints,
            folds: this.getAllFolds().map(function(fold) {
                return fold.range;
            }),
            history: this.getUndoManager(),
            mode: this.$mode.$id,
            scrollLeft: this.$scrollLeft,
            scrollTop: this.$scrollTop,
            selection: this.selection.toJSON(),
            value: this.doc.getValue()
        };
    }

    /**
     * Returns the current [[Document `Document`]] as a string.
     * @method toString
     * @returns {String}
     * @alias EditSession.getValue
     *
     **/
    toString() {
        return this.doc.getValue();
    }

    /**
     * Returns selection object.
     * @returns {Selection}
     **/
    getSelection() {
        return this.selection;
    }

    /**
     * {:BackgroundTokenizer.getState}
     * @param {Number} row The row to start at
     * @returns {string | string[]}
     * @related BackgroundTokenizer.getState
     **/
    getState(row) {
        return this.bgTokenizer.getState(row);
    }

    /**
     * Starts tokenizing at the row indicated. Returns a list of objects of the tokenized rows.
     * @param {Number} row The row to start at
     * @returns {import("../ace-internal").Ace.Token[]}
     **/
    getTokens(row) {
        return this.bgTokenizer.getTokens(row);
    }

    /**
     * Returns an object indicating the token at the current row. The object has two properties: `index` and `start`.
     * @param {Number} row The row number to retrieve from
     * @param {Number} column The column number to retrieve from
     * @returns {import("../ace-internal").Ace.Token}
     *
     **/
    getTokenAt(row, column) {
        var tokens = this.bgTokenizer.getTokens(row);
        var token, c = 0;
        if (column == null) {
            var i = tokens.length - 1;
            c = this.getLine(row).length;
        } else {
            for (var i = 0; i < tokens.length; i++) {
                c += tokens[i].value.length;
                if (c >= column)
                    break;
            }
        }
        token = tokens[i];
        if (!token)
            return null;
        token.index = i;
        token.start = c - token.value.length;
        return token;
    }

    /**
     * Sets the undo manager.
     * @param {UndoManager} undoManager The new undo manager
     **/
    setUndoManager(undoManager) {
        this.$undoManager = undoManager;

        if (this.$informUndoManager)
            this.$informUndoManager.cancel();

        if (undoManager) {
            var self = this;
            undoManager.addSession(this);
            this.$syncInformUndoManager = function() {
                self.$informUndoManager.cancel();
                self.mergeUndoDeltas = false;
            };
            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
        } else {
            this.$syncInformUndoManager = function() {};
        }
    }

    /**
     * starts a new group in undo history
     **/
    markUndoGroup() {
        if (this.$syncInformUndoManager)
            this.$syncInformUndoManager();
    }

    /**
     * Returns the current undo manager.
     * @returns {UndoManager}
     **/
    getUndoManager() {
        // @ts-ignore
        return this.$undoManager || this.$defaultUndoManager;
    }

    /**
     * Returns the current value for tabs. If the user is using soft tabs, this will be a series of spaces (defined by [[EditSession.getTabSize `getTabSize()`]]); otherwise it's simply `'\t'`.
     * @returns {String}
     **/
    getTabString() {
        if (this.getUseSoftTabs()) {
            return lang.stringRepeat(" ", this.getTabSize());
        } else {
            return "\t";
        }
    }

    /**
     * Pass `true` to enable the use of soft tabs. Soft tabs means you're using spaces instead of the tab character (`'\t'`).
     * @param {Boolean} val Value indicating whether or not to use soft tabs
     **/
    setUseSoftTabs(val) {
        this.setOption("useSoftTabs", val);
    }

    /**
     * Returns `true` if soft tabs are being used, `false` otherwise.
     * @returns {Boolean}
     **/
    getUseSoftTabs() {
        // todo might need more general way for changing settings from mode, but this is ok for now
        return this.$useSoftTabs && !this.$mode.$indentWithTabs;
    }
    /**
     * Set the number of spaces that define a soft tab; for example, passing in `4` transforms the soft tabs to be equivalent to four spaces. This function also emits the `changeTabSize` event.
     * @param {Number} tabSize The new tab size
     **/
    setTabSize(tabSize) {
        this.setOption("tabSize", tabSize);
    }
    /**
     * Returns the current tab size.
     * @return {number}
     **/
    getTabSize() {
        return this.$tabSize;
    }

    /**
     * Returns `true` if the character at the position is a soft tab.
     * @param {Point} position The position to check
     **/
    isTabStop(position) {
        return this.$useSoftTabs && (position.column % this.$tabSize === 0);
    }

    /**
     * Set whether keyboard navigation of soft tabs moves the cursor within the soft tab, rather than over
     * @param {Boolean} navigateWithinSoftTabs Value indicating whether or not to navigate within soft tabs
     **/
    setNavigateWithinSoftTabs(navigateWithinSoftTabs) {
        this.setOption("navigateWithinSoftTabs", navigateWithinSoftTabs);
    }
    /**
     * Returns `true` if keyboard navigation moves the cursor within soft tabs, `false` if it moves the cursor over soft tabs.
     * @returns {Boolean}
     **/
    getNavigateWithinSoftTabs() {
        return this.$navigateWithinSoftTabs;
    }

    /**
     * Pass in `true` to enable overwrites in your session, or `false` to disable.
     *
     * If overwrites is enabled, any text you enter will type over any text after it. If the value of `overwrite` changes, this function also emits the `changeOverwrite` event.
     *
     * @param {Boolean} overwrite Defines whether or not to set overwrites
     *
     **/
    setOverwrite(overwrite) {
        this.setOption("overwrite", overwrite);
    }

    /**
     * Returns `true` if overwrites are enabled; `false` otherwise.
     **/
    getOverwrite() {
        return this.$overwrite;
    }

    /**
     * Sets the value of overwrite to the opposite of whatever it currently is.
     **/
    toggleOverwrite() {
        this.setOverwrite(!this.$overwrite);
    }

    /**
     * Adds `className` to the `row`, to be used for CSS stylings and whatnot.
     * @param {Number} row The row number
     * @param {String} className The class to add
     **/
    addGutterDecoration(row, className) {
        if (!this.$decorations[row])
            this.$decorations[row] = "";
        this.$decorations[row] += " " + className;
        this._signal("changeBreakpoint", {});
    }

    /**
     * Replaces the custom icon with the fold widget if present from a specific row in the gutter
     * @param {number} row The row number for which to hide the custom icon
     * @experimental
     */
    removeGutterCustomWidget(row) {
        if(this.$editor) {
            this.$editor.renderer.$gutterLayer.$removeCustomWidget(row);
        }
    }

    /**
     * Replaces the fold widget if present with the custom icon from a specific row in the gutter
     * @param {number} row - The row number where the widget will be displayed
     * @param {Object} attributes - Configuration attributes for the widget
     * @param {string} attributes.className - CSS class name for styling the widget
     * @param {string} attributes.label - Text label to display in the widget
     * @param {string} attributes.title - Tooltip text for the widget
     * @param {Object} attributes.callbacks - Event callback functions for the widget e.g onClick; 
     * @returns {void}
     * @experimental
    */
    addGutterCustomWidget(row,attributes) {
        if(this.$editor) {
            this.$editor.renderer.$gutterLayer.$addCustomWidget(row,attributes);
        }
    }

    /**
     * Removes `className` from the `row`.
     * @param {Number} row The row number
     * @param {String} className The class to add
     **/
    removeGutterDecoration(row, className) {
        this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
        this._signal("changeBreakpoint", {});
    }

    /**
     * Returns an array of strings, indicating the breakpoint class (if any) applied to each row.
     * @returns {String[]}
     **/
    getBreakpoints() {
        return this.$breakpoints;
    }

    /**
     * Sets a breakpoint on every row number given by `rows`. This function also emites the `'changeBreakpoint'` event.
     * @param {number[]} rows An array of row indices
     **/
    setBreakpoints(rows) {
        this.$breakpoints = [];
        for (var i=0; i<rows.length; i++) {
            this.$breakpoints[rows[i]] = "ace_breakpoint";
        }
        this._signal("changeBreakpoint", {});
    }

    /**
     * Removes all breakpoints on the rows. This function also emits the `'changeBreakpoint'` event.
     **/
    clearBreakpoints() {
        this.$breakpoints = [];
        this._signal("changeBreakpoint", {});
    }

    /**
     * Sets a breakpoint on the row number given by `row`. This function also emits the `'changeBreakpoint'` event.
     * @param {Number} row A row index
     * @param {String} className Class of the breakpoint
     **/
    setBreakpoint(row, className) {
        if (className === undefined)
            className = "ace_breakpoint";
        if (className)
            this.$breakpoints[row] = className;
        else
            delete this.$breakpoints[row];
        this._signal("changeBreakpoint", {});
    }

    /**
     * Removes a breakpoint on the row number given by `row`. This function also emits the `'changeBreakpoint'` event.
     * @param {Number} row A row index
     **/
    clearBreakpoint(row) {
        delete this.$breakpoints[row];
        this._signal("changeBreakpoint", {});
    }

    /**
     * Adds a new marker to the given `Range`. If `inFront` is `true`, a front marker is defined, and the `'changeFrontMarker'` event fires; otherwise, the `'changeBackMarker'` event fires.
     * @param {Range} range Define the range of the marker
     * @param {String} clazz Set the CSS class for the marker
     * @param {import("../ace-internal").Ace.MarkerRenderer | "fullLine" | "screenLine" | "text" | "line"} [type] Identify the renderer type of the marker. If string provided, corresponding built-in renderer is used. Supported string types are "fullLine", "screenLine", "text" or "line". If a Function is provided, that Function is used as renderer.
     * @param {Boolean} [inFront] Set to `true` to establish a front marker
     *
     * @return {Number} The new marker id
     **/
    addMarker(range, clazz, type, inFront) {
        var id = this.$markerId++;

        var marker = {
            range : range,
            type : type || "line",
            renderer: typeof type == "function" ? type : null,
            clazz : clazz,
            inFront: !!inFront,
            id: id
        };

        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal("changeFrontMarker");
        } else {
            this.$backMarkers[id] = marker;
            this._signal("changeBackMarker");
        }

        return id;
    }

    /**
     * Adds a dynamic marker to the session.
     * @param {import("../ace-internal").Ace.MarkerLike} marker object with update method
     * @param {Boolean} [inFront] Set to `true` to establish a front marker
     *
     * @return {import("../ace-internal").Ace.MarkerLike} The added marker
     **/
    addDynamicMarker(marker, inFront) {
        if (!marker.update)
            return;
        var id = this.$markerId++;
        marker.id = id;
        marker.inFront = !!inFront;

        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal("changeFrontMarker");
        } else {
            this.$backMarkers[id] = marker;
            this._signal("changeBackMarker");
        }

        return marker;
    }

    /**
     * Removes the marker with the specified ID. If this marker was in front, the `'changeFrontMarker'` event is emitted. If the marker was in the back, the `'changeBackMarker'` event is emitted.
     * @param {Number} markerId A number representing a marker
     **/
    removeMarker(markerId) {
        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
        if (!marker)
            return;

        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
        delete (markers[markerId]);
        this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
    }

    /**
     * Returns an object containing all of the markers, either front or back.
     * @param {Boolean} [inFront] If `true`, indicates you only want front markers; `false` indicates only back markers
     *
     * @returns {{[id: number]: import("../ace-internal").Ace.MarkerLike}}
     **/
    getMarkers(inFront) {
        return inFront ? this.$frontMarkers : this.$backMarkers;
    }

    /**
     * @param {RegExp} re
     */
    highlight(re) {
        if (!this.$searchHighlight) {
            var highlight = new SearchHighlight(null, "ace_selected-word", "text");
            this.$searchHighlight = this.addDynamicMarker(highlight);
        }
        this.$searchHighlight.setRegexp(re);
    }

    /**
     * experimental
     * @param {number} startRow
     * @param {number} endRow
     * @param {string} clazz
     * @param {boolean} [inFront]
     * @return {Range}
     */
    highlightLines(startRow, endRow, clazz, inFront) {
        if (typeof endRow != "number") {
            clazz = endRow;
            endRow = startRow;
        }
        if (!clazz)
            clazz = "ace_step";

        var range = new Range(startRow, 0, endRow, Infinity);
        range.id = this.addMarker(range, clazz, "fullLine", inFront);
        return range;
    }

    /*
     * Error:
     *  {
     *    row: 12,
     *    column: 2, //can be undefined
     *    text: "Missing argument",
     *    type: "error" // or "warning" or "info"
     *  }
     */
    /**
     * Sets annotations for the `EditSession`. This functions emits the `'changeAnnotation'` event.
     * @param {import("../ace-internal").Ace.Annotation[]} annotations A list of annotations
     **/
    setAnnotations(annotations) {
        this.$annotations = annotations;
        this._signal("changeAnnotation", {});
    }

    /**
     * Returns the annotations for the `EditSession`.
     * @returns {import("../ace-internal").Ace.Annotation[]}
     **/
    getAnnotations() {
        return this.$annotations || [];
    }

    /**
     * Clears all the annotations for this session. This function also triggers the `'changeAnnotation'` event.
     **/
    clearAnnotations() {
        this.setAnnotations([]);
    }

    /**
     * If `text` contains either the newline (`\n`) or carriage-return ('\r') characters, `$autoNewLine` stores that value.
     * @param {String} text A block of text
     *
     **/
    $detectNewLine(text) {
        var match = text.match(/^.*?(\r?\n)/m);
        if (match) {
            this.$autoNewLine = match[1];
        } else {
            this.$autoNewLine = "\n";
        }
    }

    /**
     * Given a starting row and column, this method returns the `Range` of the first word boundary it finds.
     * @param {Number} row The row to start at
     * @param {Number} column The column to start at
     *
     * @returns {Range}
     **/
    getWordRange(row, column) {
        var line = this.getLine(row);

        var inToken = false;
        if (column > 0)
            inToken = !!line.charAt(column - 1).match(this.tokenRe);

        if (!inToken)
            inToken = !!line.charAt(column).match(this.tokenRe);

        if (inToken)
            var re = this.tokenRe;
        else if (/^\s+$/.test(line.slice(column-1, column+1)))
            var re = /\s/;
        else
            var re = this.nonTokenRe;

        var start = column;
        if (start > 0) {
            do {
                start--;
            }
            while (start >= 0 && line.charAt(start).match(re));
            start++;
        }

        var end = column;
        while (end < line.length && line.charAt(end).match(re)) {
            end++;
        }

        return new Range(row, start, row, end);
    }

    /**
     * Gets the range of a word, including its right whitespace.
     * @param {Number} row The row number to start from
     * @param {Number} column The column number to start from
     *
     * @return {Range}
     **/
    getAWordRange(row, column) {
        var wordRange = this.getWordRange(row, column);
        var line = this.getLine(wordRange.end.row);

        while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
            wordRange.end.column += 1;
        }
        return wordRange;
    }

    /**
     * {:Document.setNewLineMode.desc}
     * @param {import("../ace-internal").Ace.NewLineMode} newLineMode {:Document.setNewLineMode.param}
     *
     *
     * @related Document.setNewLineMode
     **/
    setNewLineMode(newLineMode) {
        this.doc.setNewLineMode(newLineMode);
    }

    /**
     *
     * Returns the current new line mode.
     * @returns {import("../ace-internal").Ace.NewLineMode}
     * @related Document.getNewLineMode
     **/
    getNewLineMode() {
        return this.doc.getNewLineMode();
    }

    /**
     * Identifies if you want to use a worker for the `EditSession`.
     * @param {Boolean} useWorker Set to `true` to use a worker
     **/
    setUseWorker(useWorker) { this.setOption("useWorker", useWorker); }

    /**
     * Returns `true` if workers are being used.
     **/
    getUseWorker() { return this.$useWorker; }

    /**
     * Reloads all the tokens on the current session. This function calls [[BackgroundTokenizer.start `BackgroundTokenizer.start ()`]] to all the rows; it also emits the `'tokenizerUpdate'` event.
     * @internal
     **/
    onReloadTokenizer(e) {
        var rows = e.data;
        this.bgTokenizer.start(rows.first);
        this._signal("tokenizerUpdate", e);
    }

    /**
     * Sets a new text mode for the `EditSession`. This method also emits the `'changeMode'` event. If a [[BackgroundTokenizer `BackgroundTokenizer`]] is set, the `'tokenizerUpdate'` event is also emitted.
     * @param {SyntaxMode | string} mode Set a new text mode
     * @param {() => void} [cb] optional callback
     **/
    setMode(mode, cb) {
        if (mode && typeof mode === "object") {
            if (mode.getTokenizer)
                return this.$onChangeMode(mode);
            var options = mode;
            var path = options.path;
        } else {
            path = /**@type{string}*/(mode) || "ace/mode/text";
        }

        // this is needed if ace isn't on require path (e.g tests in node)
        if (!this.$modes["ace/mode/text"])
            this.$modes["ace/mode/text"] = new TextMode();

        if (this.$modes[path] && !options) {
            this.$onChangeMode(this.$modes[path]);
            cb && cb();
            return;
        }
        // load on demand
        this.$modeId = path;
        config.loadModule(["mode", path], function(m) {
            if (this.destroyed) {
                return;
            }
            if (this.$modeId !== path)
                return cb && cb();
            if (this.$modes[path] && !options) {
                this.$onChangeMode(this.$modes[path]);
            } else if (m && m.Mode) {
                m = new m.Mode(options);
                if (!options) {
                    this.$modes[path] = m;
                    m.$id = path;
                }
                this.$onChangeMode(m);
            }
            cb && cb();
        }.bind(this));

        // set mode to text until loading is finished
        if (!this.$mode)
            this.$onChangeMode(this.$modes["ace/mode/text"], true);
    }

    /**
     * @param mode
     * @param [$isPlaceholder]
     */
    $onChangeMode(mode, $isPlaceholder) {
        if (!$isPlaceholder)
            this.$modeId = mode.$id;
        if (this.$mode === mode)
            return;

        var oldMode = this.$mode;
        this.$mode = mode;

        this.$stopWorker();

        if (this.$useWorker)
            this.$startWorker();

        var tokenizer = mode.getTokenizer();

        if(tokenizer.on !== undefined) {
            var onReloadTokenizer = this.onReloadTokenizer.bind(this);
            tokenizer.on("update", onReloadTokenizer);
        }

        this.bgTokenizer.setTokenizer(tokenizer);
        this.bgTokenizer.setDocument(this.getDocument());

        /**@type {RegExp}*/
        this.tokenRe = mode.tokenRe;
        /**@type {RegExp}*/
        this.nonTokenRe = mode.nonTokenRe;


        if (!$isPlaceholder) {
            // experimental method, used by c9 findiniles
            if (mode.attachToSession)
                mode.attachToSession(this);
            this.$options.wrapMethod.set.call(this, this.$wrapMethod);
            this.$setFolding(mode.foldingRules);
            this.bgTokenizer.start(0);
            this._emit("changeMode", {oldMode: oldMode, mode: mode});
        }
    }

    $stopWorker() {
        if (this.$worker) {
            this.$worker.terminate();
            this.$worker = null;
        }
    }

    $startWorker() {
        try {
            this.$worker = this.$mode.createWorker(this);
        } catch (e) {
            config.warn("Could not load worker", e);
            this.$worker = null;
        }
    }

    /**
     * Returns the current text mode.
     * @returns {TextMode} The current text mode
     **/
    getMode() {
        return this.$mode;
    }

    /**
     * This function sets the scroll top value. It also emits the `'changeScrollTop'` event.
     * @param {Number} scrollTop The new scroll top value
     **/
    setScrollTop(scrollTop) {
        // TODO: should we force integer lineheight instead? scrollTop = Math.round(scrollTop);
        if (this.$scrollTop === scrollTop || isNaN(scrollTop))
            return;

        this.$scrollTop = scrollTop;
        this._signal("changeScrollTop", scrollTop);
    }

    /**
     * [Returns the value of the distance between the top of the editor and the topmost part of the visible content.]{: #EditSession.getScrollTop}
     * @returns {Number}
     **/
    getScrollTop() {
        return this.$scrollTop;
    }

    /**
     * [Sets the value of the distance between the left of the editor and the leftmost part of the visible content.]{: #EditSession.setScrollLeft}
     * @param {number} scrollLeft
     */
    setScrollLeft(scrollLeft) {
        // scrollLeft = Math.round(scrollLeft);
        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
            return;

        this.$scrollLeft = scrollLeft;
        this._signal("changeScrollLeft", scrollLeft);
    }

    /**
     * [Returns the value of the distance between the left of the editor and the leftmost part of the visible content.]{: #EditSession.getScrollLeft}
     * @returns {Number}
     **/
    getScrollLeft() {
        return this.$scrollLeft;
    }

    /**
     * Returns the width of the screen.
     * @returns {Number}
     **/
    getScreenWidth() {
        this.$computeWidth();
        if (this.lineWidgets)
            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
        return this.screenWidth;
    }

    /**
     * @return {number}
     */
    getLineWidgetMaxWidth() {
        if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
        var width = 0;
        this.lineWidgets.forEach(function(w) {
            if (w && w.screenWidth > width)
                width = w.screenWidth;
        });
        return this.lineWidgetWidth = width;
    }

    /**
     * @param {boolean} [force]
     */
    $computeWidth(force) {
        if (this.$modified || force) {
            this.$modified = false;

            if (this.$useWrapMode)
                return this.screenWidth = this.$wrapLimit;

            var lines = this.doc.getAllLines();
            var cache = this.$rowLengthCache;
            var longestScreenLine = 0;
            var foldIndex = 0;
            var foldLine = this.$foldData[foldIndex];
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            var len = lines.length;

            for (var i = 0; i < len; i++) {
                if (i > foldStart) {
                    i = foldLine.end.row + 1;
                    if (i >= len)
                        break;
                    foldLine = this.$foldData[foldIndex++];
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }

                if (cache[i] == null)
                    cache[i] = this.$getStringScreenWidth(lines[i])[0];

                if (cache[i] > longestScreenLine)
                    longestScreenLine = cache[i];
            }
            this.screenWidth = longestScreenLine;
        }
    }

    /**
     * Returns a verbatim copy of the given line as it is in the document
     * @param {Number} row The row to retrieve from
     * @returns {String}
     **/
    getLine(row) {
        return this.doc.getLine(row);
    }

    /**
     * Returns an array of strings of the rows between `firstRow` and `lastRow`. This function is inclusive of `lastRow`.
     * @param {Number} firstRow The first row index to retrieve
     * @param {Number} lastRow The final row index to retrieve
     *
     * @returns {String[]}
     *
     **/
    getLines(firstRow, lastRow) {
        return this.doc.getLines(firstRow, lastRow);
    }

    /**
     * Returns the number of rows in the document.
     * @returns {Number}
     **/
    getLength() {
        return this.doc.getLength();
    }

    /**
     * {:Document.getTextRange.desc}
     * @param {IRange} [range] The range to work with
     *
     * @returns {String}
     **/
    getTextRange(range) {
        return this.doc.getTextRange(range || this.selection.getRange());
    }

    /**
     * Inserts a block of `text` and the indicated `position`.
     * @param {Point} position The position {row, column} to start inserting at
     * @param {String} text A chunk of text to insert
     * @returns {Point} The position of the last line of `text`. If the length of `text` is 0, this function simply returns `position`.
     **/
    insert(position, text) {
        return this.doc.insert(position, text);
    }

    /**
     * Removes the `range` from the document.
     * @param {IRange} range A specified Range to remove
     * @returns {Point} The new `start` property of the range, which contains `startRow` and `startColumn`. If `range` is empty, this function returns the unmodified value of `range.start`.
     **/
    remove(range) {
        return this.doc.remove(range);
    }

    /**
     * Removes a range of full lines. This method also triggers the `'change'` event.
     * @param {Number} firstRow The first row to be removed
     * @param {Number} lastRow The last row to be removed
     * @returns {String[]} Returns all the removed lines.
     *
     * @related Document.removeFullLines
     *
     **/
    removeFullLines(firstRow, lastRow){
        return this.doc.removeFullLines(firstRow, lastRow);
    }

    /**
     * Reverts previous changes to your document.
     * @param {Delta[]} deltas An array of previous changes
     * @param {Boolean} [dontSelect] If `true`, doesn't select the range of where the change occured
     **/
    undoChanges(deltas, dontSelect) {
        if (!deltas.length)
            return;

        this.$fromUndo = true;
        for (var i = deltas.length - 1; i != -1; i--) {
            var delta = deltas[i];
            if (delta.action == "insert" || delta.action == "remove") {
                this.doc.revertDelta(delta);
            } else if (delta.folds) {
                this.addFolds(delta.folds);
            }
        }
        if (!dontSelect && this.$undoSelect) {
            //@ts-expect-error TODO: potential wrong property
            if (deltas.selectionBefore)
                //@ts-expect-error TODO: potential wrong property
                this.selection.fromJSON(deltas.selectionBefore);
            else
                this.selection.setRange(this.$getUndoSelection(deltas, true));
        }
        this.$fromUndo = false;
    }

    /**
     * Re-implements a previously undone change to your document.
     * @param {Delta[]} deltas An array of previous changes
     * @param {Boolean} [dontSelect] {:dontSelect}
     **/
    redoChanges(deltas, dontSelect) {
        if (!deltas.length)
            return;

        this.$fromUndo = true;
        for (var i = 0; i < deltas.length; i++) {
            var delta = deltas[i];
            if (delta.action == "insert" || delta.action == "remove") {
                this.doc.$safeApplyDelta(delta);
            }
        }

        if (!dontSelect && this.$undoSelect) {
            //@ts-expect-error TODO: potential wrong property
            if (deltas.selectionAfter)
                //@ts-expect-error TODO: potential wrong property
                this.selection.fromJSON(deltas.selectionAfter);
            else
                this.selection.setRange(this.$getUndoSelection(deltas, false));
        }
        this.$fromUndo = false;
    }

    /**
     * Enables or disables highlighting of the range where an undo occurred.
     * @param {Boolean} enable If `true`, selects the range of the reinserted change
     *
     **/
    setUndoSelect(enable) {
        this.$undoSelect = enable;
    }

    /**
     *
     * @param {Delta[]} deltas
     * @param {boolean} [isUndo]
     * @return {Range}
     */
    $getUndoSelection(deltas, isUndo) {
        function isInsert(delta) {
            return isUndo ? delta.action !== "insert" : delta.action === "insert";
        }

        var range, point;

        for (var i = 0; i < deltas.length; i++) {
            var delta = deltas[i];
            if (!delta.start) continue; // skip folds
            if (!range) {
                if (isInsert(delta)) {
                    range = Range.fromPoints(delta.start, delta.end);
                } else {
                    range = Range.fromPoints(delta.start, delta.start);
                }
                continue;
            }

            if (isInsert(delta)) {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                    range.setStart(point);
                }
                point = delta.end;
                if (range.compare(point.row, point.column) == 1) {
                    range.setEnd(point);
                }
            } else {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                    range = Range.fromPoints(delta.start, delta.start);
                }
            }
        }
        return range;
    }

    /**
     * Replaces a range in the document with the new `text`.
     *
     * @param {IRange} range A specified Range to replace
     * @param {String} text The new text to use as a replacement
     * @returns {Point} An object containing the final row and column, like this:
     * ```
     * {row: endRow, column: 0}
     * ```
     * If the text and range are empty, this function returns an object containing the current `range.start` value.
     * If the text is the exact same as what currently exists, this function returns an object containing the current `range.end` value.
     *
     * @related Document.replace
     **/
    replace(range, text) {
        return this.doc.replace(range, text);
    }

    /**
     * Moves a range of text from the given range to the given position. `toPosition` is an object that looks like this:
     *  ```json
     *    { row: newRowLocation, column: newColumnLocation }
     *  ```
     * @param {Range} fromRange The range of text you want moved within the document
     * @param {Point} toPosition The location (row and column) where you want to move the text to
     * @param {boolean} [copy]
     * @returns {Range} The new range where the text was moved to.
     **/
    moveText(fromRange, toPosition, copy) {
        var text = this.getTextRange(fromRange);
        var folds = this.getFoldsInRange(fromRange);

        var toRange = Range.fromPoints(toPosition, toPosition);
        if (!copy) {
            this.remove(fromRange);
            var rowDiff = fromRange.start.row - fromRange.end.row;
            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
            if (collDiff) {
                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
                    toRange.start.column += collDiff;
                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
                    toRange.end.column += collDiff;
            }
            if (rowDiff && toRange.start.row >= fromRange.end.row) {
                toRange.start.row += rowDiff;
                toRange.end.row += rowDiff;
            }
        }

        toRange.end = this.insert(toRange.start, text);
        if (folds.length) {
            var oldStart = fromRange.start;
            var newStart = toRange.start;
            var rowDiff = newStart.row - oldStart.row;
            var collDiff = newStart.column - oldStart.column;
            this.addFolds(folds.map(function(x) {
                x = x.clone();
                if (x.start.row == oldStart.row)
                    x.start.column += collDiff;
                if (x.end.row == oldStart.row)
                    x.end.column += collDiff;
                x.start.row += rowDiff;
                x.end.row += rowDiff;
                return x;
            }));
        }

        return toRange;
    }

    /**
     * Indents all the rows, from `startRow` to `endRow` (inclusive), by prefixing each row with the token in `indentString`.
     *
     * If `indentString` contains the `'\t'` character, it's replaced by whatever is defined by [[EditSession.getTabString `getTabString()`]].
     * @param {Number} startRow Starting row
     * @param {Number} endRow Ending row
     * @param {String} indentString The indent token
     **/
    indentRows(startRow, endRow, indentString) {
        indentString = indentString.replace(/\t/g, this.getTabString());
        for (var row=startRow; row<=endRow; row++)
            this.doc.insertInLine({row: row, column: 0}, indentString);
    }

    /**
     * Outdents all the rows defined by the `start` and `end` properties of `range`.
     * @param {Range} range A range of rows
     **/
    outdentRows(range) {
        var rowRange = range.collapseRows();
        var deleteRange = new Range(0, 0, 0, 0);
        var size = this.getTabSize();

        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
            var line = this.getLine(i);

            deleteRange.start.row = i;
            deleteRange.end.row = i;
            for (var j = 0; j < size; ++j)
                if (line.charAt(j) != ' ')
                    break;
            if (j < size && line.charAt(j) == '\t') {
                deleteRange.start.column = j;
                deleteRange.end.column = j + 1;
            } else {
                deleteRange.start.column = 0;
                deleteRange.end.column = j;
            }
            this.remove(deleteRange);
        }
    }

    /**
     *
     * @param {number} firstRow
     * @param {number} lastRow
     * @param [dir]
     * @returns {number}
     */
    $moveLines(firstRow, lastRow, dir) {
        firstRow = this.getRowFoldStart(firstRow);
        lastRow = this.getRowFoldEnd(lastRow);
        if (dir < 0) {
            var row = this.getRowFoldStart(firstRow + dir);
            if (row < 0) return 0;
            var diff = row-firstRow;
        } else if (dir > 0) {
            var row = this.getRowFoldEnd(lastRow + dir);
            if (row > this.doc.getLength()-1) return 0;
            var diff = row-lastRow;
        } else {
            firstRow = this.$clipRowToDocument(firstRow);
            lastRow = this.$clipRowToDocument(lastRow);
            var diff = lastRow - firstRow + 1;
        }

        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
        var folds = this.getFoldsInRange(range).map(function(x){
            x = x.clone();
            x.start.row += diff;
            x.end.row += diff;
            return x;
        });

        var lines = dir == 0
            ? this.doc.getLines(firstRow, lastRow)
            : this.doc.removeFullLines(firstRow, lastRow);
        this.doc.insertFullLines(firstRow+diff, lines);
        folds.length && this.addFolds(folds);
        return diff;
    }
    /**
     * Shifts all the lines in the document up one, starting from `firstRow` and ending at `lastRow`.
     * @param {Number} firstRow The starting row to move up
     * @param {Number} lastRow The final row to move up
     * @returns {Number} If `firstRow` is less-than or equal to 0, this function returns 0. Otherwise, on success, it returns -1.
     **/
    moveLinesUp(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, -1);
    }

    /**
     * Shifts all the lines in the document down one, starting from `firstRow` and ending at `lastRow`.
     * @param {Number} firstRow The starting row to move down
     * @param {Number} lastRow The final row to move down
     * @returns {Number} If `firstRow` is less-than or equal to 0, this function returns 0. Otherwise, on success, it returns -1.
     **/
    moveLinesDown(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 1);
    }

    /**
     * Duplicates all the text between `firstRow` and `lastRow`.
     * @param {Number} firstRow The starting row to duplicate
     * @param {Number} lastRow The final row to duplicate
     * @returns {Number} Returns the number of new rows added; in other words, `lastRow - firstRow + 1`.
     **/
    duplicateLines(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 0);
    }

    /**
     * @param {number} row
     * @returns {number}
     */
    $clipRowToDocument(row) {
        return Math.max(0, Math.min(row, this.doc.getLength()-1));
    }

    /**
     * @param {number} row
     * @param {number} column
     * @returns {number}
     */
    $clipColumnToRow(row, column) {
        if (column < 0) return 0;
        return Math.min(this.doc.getLine(row).length, column);
    }

    /**
     * @param {number} row
     * @param {number} column
     * @returns {Point}
     */
    $clipPositionToDocument(row, column) {
        column = Math.max(0, column);

        if (row < 0) {
            row = 0;
            column = 0;
        } else {
            var len = this.doc.getLength();
            if (row >= len) {
                row = len - 1;
                column = this.doc.getLine(len-1).length;
            } else {
                column = Math.min(this.doc.getLine(row).length, column);
            }
        }

        return {
            row: row,
            column: column
        };
    }

    /**
     * @param {Range} range
     * @returns {Range}
     */
    $clipRangeToDocument(range) {
        if (range.start.row < 0) {
            range.start.row = 0;
            range.start.column = 0;
        } else {
            range.start.column = this.$clipColumnToRow(
                range.start.row,
                range.start.column
            );
        }

        var len = this.doc.getLength() - 1;
        if (range.end.row > len) {
            range.end.row = len;
            range.end.column = this.doc.getLine(len).length;
        } else {
            range.end.column = this.$clipColumnToRow(
                range.end.row,
                range.end.column
            );
        }
        return range;
    }

    /**
     * Sets whether or not line wrapping is enabled. If `useWrapMode` is different than the current value, the `'changeWrapMode'` event is emitted.
     * @param {Boolean} useWrapMode Enable (or disable) wrap mode
     **/
    setUseWrapMode(useWrapMode) {
        if (useWrapMode != this.$useWrapMode) {
            this.$useWrapMode = useWrapMode;
            this.$modified = true;
            this.$resetRowCache(0);

            // If wrapMode is activaed, the wrapData array has to be initialized.
            if (useWrapMode) {
                var len = this.getLength();
                this.$wrapData = Array(len);
                this.$updateWrapData(0, len - 1);
            }

            this._signal("changeWrapMode");
        }
    }

    /**
     * Returns `true` if wrap mode is being used; `false` otherwise.
     * @returns {Boolean}
     **/
    getUseWrapMode() {
        return this.$useWrapMode;
    }

    // Allow the wrap limit to move freely between min and max. Either
    // parameter can be null to allow the wrap limit to be unconstrained
    // in that direction. Or set both parameters to the same number to pin
    // the limit to that value.
    /**
     * Sets the boundaries of wrap. Either value can be `null` to have an unconstrained wrap, or, they can be the same number to pin the limit. If the wrap limits for `min` or `max` are different, this method also emits the `'changeWrapMode'` event.
     * @param {Number} min The minimum wrap value (the left side wrap)
     * @param {Number} max The maximum wrap value (the right side wrap)
     **/
    setWrapLimitRange(min, max) {
        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
            this.$wrapLimitRange = { min: min, max: max };
            this.$modified = true;
            this.$bidiHandler.markAsDirty();

            // This will force a recalculation of the wrap limit
            if (this.$useWrapMode)
                this._signal("changeWrapMode");
        }
    }

    /**
     * This should generally only be called by the renderer when a resize is detected.
     * @param {Number} desiredLimit The new wrap limit
     * @param [$printMargin]
     * @returns {Boolean}
     **/
    adjustWrapLimit(desiredLimit, $printMargin) {
        var limits = this.$wrapLimitRange;
        if (limits.max < 0)
            limits = {min: $printMargin, max: $printMargin};
        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
            this.$wrapLimit = wrapLimit;
            this.$modified = true;
            if (this.$useWrapMode) {
                this.$updateWrapData(0, this.getLength() - 1);
                this.$resetRowCache(0);
                this._signal("changeWrapLimit");
            }
            return true;
        }
        return false;
    }

    /**
     *
     * @param {number} wrapLimit
     * @param {number} [min]
     * @param {number} [max]
     * @returns {number}
     */
    $constrainWrapLimit(wrapLimit, min, max) {
        if (min)
            wrapLimit = Math.max(min, wrapLimit);

        if (max)
            wrapLimit = Math.min(max, wrapLimit);

        return wrapLimit;
    }

    /**
     * Returns the value of wrap limit.
     * @returns {Number} The wrap limit.
     **/
    getWrapLimit() {
        return this.$wrapLimit;
    }

    /**
     * Sets the line length for soft wrap in the editor. Lines will break
     *  at a minimum of the given length minus 20 chars and at a maximum
     *  of the given number of chars.
     * @param {number} limit The maximum line length in chars, for soft wrapping lines.
     */
    setWrapLimit(limit) {
        this.setWrapLimitRange(limit, limit);
    }

    /**
     * Returns an object that defines the minimum and maximum of the wrap limit; it looks something like this:
     *
     *     { min: wrapLimitRange_min, max: wrapLimitRange_max }
     *
     * @returns {{ min: number, max: number }}
     **/
    getWrapLimitRange() {
        // Avoid unexpected mutation by returning a copy
        return {
            min : this.$wrapLimitRange.min,
            max : this.$wrapLimitRange.max
        };
    }

    /**
     * @param {Delta} delta
     */
    $updateInternalDataOnChange(delta) {
        var useWrapMode = this.$useWrapMode;
        var action = delta.action;
        var start = delta.start;
        var end = delta.end;
        var firstRow = start.row;
        var lastRow = end.row;
        var len = lastRow - firstRow;
        var removedFolds = null;

        this.$updating = true;
        if (len != 0) {
            if (action === "remove") {
                this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);

                var foldLines = this.$foldData;
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);

                var foldLine = this.getFoldLine(end.row);
                var idx = 0;
                if (foldLine) {
                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                    foldLine.shiftRow(-len);

                    var foldLineBefore = this.getFoldLine(firstRow);
                    if (foldLineBefore && foldLineBefore !== foldLine) {
                        foldLineBefore.merge(foldLine);
                        foldLine = foldLineBefore;
                    }
                    idx = foldLines.indexOf(foldLine) + 1;
                }

                for (idx; idx < foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row >= end.row) {
                        foldLine.shiftRow(-len);
                    }
                }

                lastRow = firstRow;
            } else {
                var args = Array(len);
                args.unshift(firstRow, 0);
                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
                arr.splice.apply(arr, args);

                // If some new line is added inside of a foldLine, then split
                // the fold line up.
                var foldLines = this.$foldData;
                var foldLine = this.getFoldLine(firstRow);
                var idx = 0;
                if (foldLine) {
                    var cmp = foldLine.range.compareInside(start.row, start.column);
                    // Inside of the foldLine range. Need to split stuff up.
                    if (cmp == 0) {
                        foldLine = foldLine.split(start.row, start.column);
                        if (foldLine) {
                            foldLine.shiftRow(len);
                            foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                        }
                    } else
                    // Infront of the foldLine but same row. Need to shift column.
                    if (cmp == -1) {
                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                        foldLine.shiftRow(len);
                    }
                    // Nothing to do if the insert is after the foldLine.
                    idx = foldLines.indexOf(foldLine) + 1;
                }

                for (idx; idx < foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row >= firstRow) {
                        foldLine.shiftRow(len);
                    }
                }
            }
        } else {
            // Realign folds. E.g. if you add some new chars before a fold, the
            // fold should "move" to the right.
            len = Math.abs(delta.start.column - delta.end.column);
            if (action === "remove") {
                // Get all the folds in the change range and remove them.
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);

                len = -len;
            }
            var foldLine = this.getFoldLine(firstRow);
            if (foldLine) {
                foldLine.addRemoveChars(firstRow, start.column, len);
            }
        }

        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
            console.error("doc.getLength() and $wrapData.length have to be the same!");
        }
        this.$updating = false;

        if (useWrapMode)
            this.$updateWrapData(firstRow, lastRow);
        else
            this.$updateRowLengthCache(firstRow, lastRow);

        return removedFolds;
    }

    /**
     * @param {number} firstRow
     * @param {number} lastRow
     */
    $updateRowLengthCache(firstRow, lastRow) {
        this.$rowLengthCache[firstRow] = null;
        this.$rowLengthCache[lastRow] = null;
    }

    /**
     * @param {number} firstRow
     * @param {number} lastRow
     */
    $updateWrapData(firstRow, lastRow) {
        var lines = this.doc.getAllLines();
        var tabSize = this.getTabSize();
        var wrapData = this.$wrapData;
        var wrapLimit = this.$wrapLimit;
        var tokens;
        var foldLine;

        var row = firstRow;
        lastRow = Math.min(lastRow, lines.length - 1);
        while (row <= lastRow) {
            foldLine = this.getFoldLine(row, foldLine);
            if (!foldLine) {
                tokens = this.$getDisplayTokens(lines[row]);
                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row ++;
            } else {
                tokens = [];
                foldLine.walk(function(placeholder, row, column, lastColumn) {
                        var walkTokens;
                        if (placeholder != null) {
                            walkTokens = this.$getDisplayTokens(
                                            placeholder, tokens.length);
                            walkTokens[0] = PLACEHOLDER_START;
                            for (var i = 1; i < walkTokens.length; i++) {
                                walkTokens[i] = PLACEHOLDER_BODY;
                            }
                        } else {
                            walkTokens = this.$getDisplayTokens(
                                lines[row].substring(lastColumn, column),
                                tokens.length);
                        }
                        tokens = tokens.concat(walkTokens);
                    }.bind(this),
                    foldLine.end.row,
                    lines[foldLine.end.row].length + 1
                );

                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row = foldLine.end.row + 1;
            }
        }
    }

    /**
     * @param {number[]}tokens
     * @param {number} wrapLimit
     * @param {number} tabSize
     * @returns {*[]}
     */
    $computeWrapSplits(tokens, wrapLimit, tabSize) {
        if (tokens.length == 0) {
            return [];
        }

        var splits = [];
        var displayLength = tokens.length;
        var lastSplit = 0, lastDocSplit = 0;

        var isCode = this.$wrapAsCode;

        var indentedSoftWrap = this.$indentedSoftWrap;
        var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8)
            || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);

        function getWrapIndent() {
            var indentation = 0;
            if (maxIndent === 0)
                return indentation;
            if (indentedSoftWrap) {
                for (var i = 0; i < tokens.length; i++) {
                    var token = tokens[i];
                    if (token == SPACE)
                        indentation += 1;
                    else if (token == TAB)
                        indentation += tabSize;
                    else if (token == TAB_SPACE)
                        continue;
                    else
                        break;
                }
            }
            if (isCode && indentedSoftWrap !== false)
                indentation += tabSize;
            return Math.min(indentation, maxIndent);
        }
        function addSplit(screenPos) {
            // The document size is the current size - the extra width for tabs
            // and multipleWidth characters.
            var len = screenPos - lastSplit;
            for (var i = lastSplit; i < screenPos; i++) {
                var ch = tokens[i];
                if (ch === 12 || ch === 2) len -= 1;
            }

            if (!splits.length) {
                indent = getWrapIndent();
                //@ts-expect-error TODO: potential wrong property
                splits.indent = indent;
            }
            lastDocSplit += len;
            splits.push(lastDocSplit);
            lastSplit = screenPos;
        }
        var indent = 0;
        while (displayLength - lastSplit > wrapLimit - indent) {
            // This is, where the split should be.
            var split = lastSplit + wrapLimit - indent;

            // If there is a space or tab at this split position, then making
            // a split is simple.
            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
                /* disabled see https://github.com/ajaxorg/ace/issues/1186
                // Include all following spaces + tabs in this split as well.
                while (tokens[split] >= SPACE) {
                    split ++;
                } */
                addSplit(split);
                continue;
            }

            // === ELSE ===
            // Check if split is inside of a placeholder. Placeholder are
            // not splitable. Therefore, seek the beginning of the placeholder
            // and try to place the split before the placeholder's start.
            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                // Seek the start of the placeholder and do the split
                // before the placeholder. By definition there always
                // a PLACEHOLDER_START between split and lastSplit.
                for (split; split != lastSplit - 1; split--) {
                    if (tokens[split] == PLACEHOLDER_START) {
                        // split++; << No incremental here as we want to
                        //  have the position before the Placeholder.
                        break;
                    }
                }

                // If the PLACEHOLDER_START is not the index of the
                // last split, then we can do the split
                if (split > lastSplit) {
                    addSplit(split);
                    continue;
                }

                // If the PLACEHOLDER_START IS the index of the last
                // split, then we have to place the split after the
                // placeholder. So, let's seek for the end of the placeholder.
                split = lastSplit + wrapLimit;
                for (split; split < tokens.length; split++) {
                    if (tokens[split] != PLACEHOLDER_BODY) {
                        break;
                    }
                }

                // If spilt == tokens.length, then the placeholder is the last
                // thing in the line and adding a new split doesn't make sense.
                if (split == tokens.length) {
                    break;  // Breaks the while-loop.
                }

                // Finally, add the split...
                addSplit(split);
                continue;
            }

            // === ELSE ===
            // Search for the first non space/tab/placeholder/punctuation token backwards.
            var minSplit = Math.max(split - (wrapLimit -(wrapLimit>>2)), lastSplit - 1);
            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                split --;
            }
            if (isCode) {
                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                    split --;
                }
                while (split > minSplit && tokens[split] == PUNCTUATION) {
                    split --;
                }
            } else {
                while (split > minSplit && tokens[split] < SPACE) {
                    split --;
                }
            }
            // If we found one, then add the split.
            if (split > minSplit) {
                addSplit(++split);
                continue;
            }

            // === ELSE ===
            split = lastSplit + wrapLimit;
            // The split is inside of a CHAR or CHAR_EXT token and no space
            // around -> force a split.
            if (tokens[split] == CHAR_EXT)
                split--;
            addSplit(split - indent);
        }
        return splits;
    }

    /**
     * Given a string, returns an array of the display characters, including tabs and spaces.
     * @param {String} str The string to check
     * @param {Number} [offset] The value to start at
     * @returns {number[]}
     **/
    $getDisplayTokens(str, offset) {
        var arr = [];
        var tabSize;
        offset = offset || 0;

        for (var i = 0; i < str.length; i++) {
            var c = str.charCodeAt(i);
            // Tab
            if (c == 9) {
                tabSize = this.getScreenTabSize(arr.length + offset);
                arr.push(TAB);
                for (var n = 1; n < tabSize; n++) {
                    arr.push(TAB_SPACE);
                }
            }
            // Space
            else if (c == 32) {
                arr.push(SPACE);
            } else if((c > 39 && c < 48) || (c > 57 && c < 64)) {
                arr.push(PUNCTUATION);
            }
            // full width characters
            else if (c >= 0x1100 && isFullWidth(c)) {
                arr.push(CHAR, CHAR_EXT);
            } else {
                arr.push(CHAR);
            }
        }
        return arr;
    }

    /**
     * Calculates the width of the string `str` on the screen while assuming that the string starts at the first column on the screen.
     * @param {String} str The string to calculate the screen width of
     * @param {Number} [maxScreenColumn]
     * @param {Number} [screenColumn]
     * @returns {Number[]} Returns an `int[]` array with two elements:<br/>
     * The first position indicates the number of columns for `str` on screen.<br/>
     * The second value contains the position of the document column that this function read until.
     **/
    $getStringScreenWidth(str, maxScreenColumn, screenColumn) {
        if (maxScreenColumn == 0)
            return [0, 0];
        if (maxScreenColumn == null)
            maxScreenColumn = Infinity;
        screenColumn = screenColumn || 0;

        var c, column;
        for (column = 0; column < str.length; column++) {
            c = str.charCodeAt(column);
            // tab
            if (c == 9) {
                screenColumn += this.getScreenTabSize(screenColumn);
            }
            // full width characters
            else if (c >= 0x1100 && isFullWidth(c)) {
                screenColumn += 2;
            } else {
                screenColumn += 1;
            }
            if (screenColumn > maxScreenColumn) {
                break;
            }
        }

        return [screenColumn, column];
    }

    /**
     * Returns number of screenrows in a wrapped line.
     * @param {Number} row The row number to check
     * @returns {Number}
     **/
    getRowLength(row) {
        var h = 1;
        if (this.lineWidgets)
            h += this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;

        if (!this.$useWrapMode || !this.$wrapData[row])
            return h;
        else
            return this.$wrapData[row].length + h;
    }

    /**
     * @param {Number} row
     * @returns {Number}
     **/
    getRowLineCount(row) {
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1;
        } else {
            return this.$wrapData[row].length + 1;
        }
    }

    /**
     * @param {Number} screenRow
     * @returns {Number}
     **/
    getRowWrapIndent(screenRow) {
        if (this.$useWrapMode) {
            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
            var splits = this.$wrapData[pos.row];
            return splits.length && splits[0] < pos.column ? splits.indent : 0;
        } else {
            return 0;
        }
    }

    /**
     * Returns the position (on screen) for the last character in the provided screen row.
     * @param {Number} screenRow The screen row to check
     * @returns {Number}
     *
     * @related EditSession.documentToScreenColumn
     **/
    getScreenLastRowColumn(screenRow) {
        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
        return this.documentToScreenColumn(pos.row, pos.column);
    }

    /**
     * For the given document row and column, this returns the column position of the last screen row.
     * @param {Number} docRow
     * @param {Number} docColumn
     * @returns {number}
     **/
    getDocumentLastRowColumn(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.getScreenLastRowColumn(screenRow);
    }

    /**
     * For the given document row and column, this returns the document position of the last row.
     * @param {Number} docRow
     * @param {Number} docColumn
     * @returns {Point}
     **/
    getDocumentLastRowColumnPosition(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
    }

    /**
     * For the given row, this returns the split data.
     * @param {number} row
     * @returns {String | undefined}
     */
    getRowSplitData(row) {
        if (!this.$useWrapMode) {
            return undefined;
        } else {
            return this.$wrapData[row];
        }
    }

    /**
     * The distance to the next tab stop at the specified screen column.
     * @param {Number} screenColumn The screen column to check
     *
     * @returns {Number}
     **/
    getScreenTabSize(screenColumn) {
        return this.$tabSize - (screenColumn % this.$tabSize | 0);
    }

    /**
     * @param {number} screenRow
     * @param {number} screenColumn
     * @returns {number}
     */
    screenToDocumentRow(screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).row;
    }

    /**
     * @param {number} screenRow
     * @param {number} screenColumn
     * @returns {number}
     */
    screenToDocumentColumn(screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).column;
    }

    /**
     * Converts characters coordinates on the screen to characters coordinates within the document. [This takes into account code folding, word wrap, tab size, and any other visual modifications.]{: #conversionConsiderations}
     * @param {Number} screenRow The screen row to check
     * @param {Number} screenColumn The screen column to check
     * @param {Number} [offsetX] screen character x-offset [optional]
     *
     * @returns {Point} The object returned has two properties: `row` and `column`.
     *
     * @related EditSession.documentToScreenPosition
     **/
    screenToDocumentPosition(screenRow, screenColumn, offsetX) {
        if (screenRow < 0)
            return {row: 0, column: 0};

        var line;
        var docRow = 0;
        var docColumn = 0;
        var column;
        var row = 0;
        var rowLength = 0;

        var rowCache = this.$screenRowCache;
        var i = this.$getRowCacheIndex(rowCache, screenRow);
        var l = rowCache.length;
        if (l && i >= 0) {
            var row = rowCache[i];
            var docRow = this.$docRowCache[i];
            var doCache = screenRow > rowCache[l - 1];
        } else {
            var doCache = !l;
        }

        var maxRow = this.getLength() - 1;
        var foldLine = this.getNextFoldLine(docRow);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (row <= screenRow) {
            rowLength = this.getRowLength(docRow);
            if (row + rowLength > screenRow || docRow >= maxRow) {
                break;
            } else {
                row += rowLength;
                docRow++;
                if (docRow > foldStart) {
                    docRow = foldLine.end.row+1;
                    foldLine = this.getNextFoldLine(docRow, foldLine);
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }
            }

            if (doCache) {
                this.$docRowCache.push(docRow);
                this.$screenRowCache.push(row);
            }
        }

        if (foldLine && foldLine.start.row <= docRow) {
            line = this.getFoldDisplayLine(foldLine);
            docRow = foldLine.start.row;
        } else if (row + rowLength <= screenRow || docRow > maxRow) {
            // clip at the end of the document
            return {
                row: maxRow,
                column: this.getLine(maxRow).length
            };
        } else {
            line = this.getLine(docRow);
            foldLine = null;
        }
        var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);
        if (this.$useWrapMode) {
            var splits = this.$wrapData[docRow];
            if (splits) {
                column = splits[splitIndex];
                if(splitIndex > 0 && splits.length) {
                    wrapIndent = splits.indent;
                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                    line = line.substring(docColumn);
                }
            }
        }

        if (offsetX !== undefined && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))
            screenColumn = this.$bidiHandler.offsetToCol(offsetX);

        docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];

        // We remove one character at the end so that the docColumn
        // position returned is not associated to the next row on the screen.
        if (this.$useWrapMode && docColumn >= column)
            docColumn = column - 1;

        if (foldLine)
            return foldLine.idxToPosition(docColumn);

        return {row: docRow, column: docColumn};
    }

    /**
     * Converts document coordinates to screen coordinates. {:conversionConsiderations}
     * @param {Number|Point} docRow The document row to check
     * @param {Number|undefined} [docColumn] The document column to check
     * @returns {Point} The object returned by this method has two properties: `row` and `column`.
     *
     * @related EditSession.screenToDocumentPosition
     **/
    documentToScreenPosition(docRow, docColumn) {
        // Normalize the passed in arguments.
        if (typeof docColumn === "undefined")
            var pos = this.$clipPositionToDocument(/**@type{Point}*/(docRow).row, /**@type{Point}*/(docRow).column);
        else
            pos = this.$clipPositionToDocument(/**@type{number}*/(docRow), docColumn);

        docRow = pos.row;
        docColumn = pos.column;

        var screenRow = 0;
        var foldStartRow = null;
        var fold = null;

        // Clamp the docRow position in case it's inside of a folded block.
        fold = this.getFoldAt(docRow, docColumn, 1);
        if (fold) {
            docRow = fold.start.row;
            docColumn = fold.start.column;
        }

        var rowEnd, row = 0;

        var rowCache = this.$docRowCache;
        var i = this.$getRowCacheIndex(rowCache, docRow);
        var l = rowCache.length;
        if (l && i >= 0) {
            var row = rowCache[i];
            var screenRow = this.$screenRowCache[i];
            var doCache = docRow > rowCache[l - 1];
        } else {
            var doCache = !l;
        }

        var foldLine = this.getNextFoldLine(row);
        var foldStart = foldLine ?foldLine.start.row :Infinity;

        while (row < docRow) {
            if (row >= foldStart) {
                rowEnd = foldLine.end.row + 1;
                if (rowEnd > docRow)
                    break;
                foldLine = this.getNextFoldLine(rowEnd, foldLine);
                foldStart = foldLine ?foldLine.start.row :Infinity;
            }
            else {
                rowEnd = row + 1;
            }

            screenRow += this.getRowLength(row);
            row = rowEnd;

            if (doCache) {
                this.$docRowCache.push(row);
                this.$screenRowCache.push(screenRow);
            }
        }

        // Calculate the text line that is displayed in docRow on the screen.
        var textLine = "";
        // Check if the final row we want to reach is inside of a fold.
        if (foldLine && row >= foldStart) {
            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
            foldStartRow = foldLine.start.row;
        } else {
            textLine = this.getLine(docRow).substring(0, docColumn);
            foldStartRow = docRow;
        }
        var wrapIndent = 0;
        // Clamp textLine if in wrapMode.
        if (this.$useWrapMode) {
            var wrapRow = this.$wrapData[foldStartRow];
            if (wrapRow) {
                var screenRowOffset = 0;
                while (textLine.length >= wrapRow[screenRowOffset]) {
                    screenRow ++;
                    screenRowOffset++;
                }
                textLine = textLine.substring(
                    wrapRow[screenRowOffset - 1] || 0, textLine.length
                );
                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
            }
        }

        if (this.lineWidgets && this.lineWidgets[row] && this.lineWidgets[row].rowsAbove)
            screenRow += this.lineWidgets[row].rowsAbove;

        return {
            row: screenRow,
            column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
        };
    }

    /**
     * For the given document row and column, returns the screen column.
     * @param {Number|Point} row
     * @param {Number} [docColumn]
     * @returns {Number}
     **/
    documentToScreenColumn(row, docColumn) {
        return this.documentToScreenPosition(row, docColumn).column;
    }

    /**
     * For the given document row and column, returns the screen row.
     * @param {Number|Point} docRow
     * @param {Number} [docColumn]
     * @returns {number}
     **/
    documentToScreenRow(docRow, docColumn) {
        return this.documentToScreenPosition(docRow, docColumn).row;
    }

    /**
     * Returns the length of the screen.
     * @returns {Number}
     **/
    getScreenLength() {
        var screenRows = 0;
        /**@type {FoldLine}*/
        var fold = null;
        if (!this.$useWrapMode) {
            screenRows = this.getLength();

            // Remove the folded lines again.
            var foldData = this.$foldData;
            for (var i = 0; i < foldData.length; i++) {
                fold = foldData[i];
                screenRows -= fold.end.row - fold.start.row;
            }
        } else {
            var lastRow = this.$wrapData.length;
            var row = 0, i = 0;
            var fold = this.$foldData[i++];
            var foldStart = fold ? fold.start.row :Infinity;

            while (row < lastRow) {
                var splits = this.$wrapData[row];
                screenRows += splits ? splits.length + 1 : 1;
                row ++;
                if (row > foldStart) {
                    row = fold.end.row+1;
                    fold = this.$foldData[i++];
                    foldStart = fold ?fold.start.row :Infinity;
                }
            }
        }

        // todo
        if (this.lineWidgets)
            screenRows += this.$getWidgetScreenLength();

        return screenRows;
    }

    /**
     * @param {FontMetrics} fm
     */
    $setFontMetrics(fm) {
        if (!this.$enableVarChar) return;
        this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
            if (maxScreenColumn === 0)
                return [0, 0];
            if (!maxScreenColumn)
                maxScreenColumn = Infinity;
            screenColumn = screenColumn || 0;

            var c, column;
            for (column = 0; column < str.length; column++) {
                c = str.charAt(column);
                // tab
                if (c === "\t") {
                    screenColumn += this.getScreenTabSize(screenColumn);
                } else {
                    screenColumn += fm.getCharacterWidth(c);
                }
                if (screenColumn > maxScreenColumn) {
                    break;
                }
            }

            return [screenColumn, column];
        };
    }

    /**
     * @returns {string} the last character preceding the cursor in the editor
     */
    getPrecedingCharacter() {
        var pos = this.selection.getCursor();

        if (pos.column === 0) {
            return pos.row === 0 ? "" : this.doc.getNewLineCharacter();
        }

        var currentLine = this.getLine(pos.row);
        return currentLine[pos.column - 1];
    }

    destroy() {
        if (!this.destroyed) {
            this.bgTokenizer.setDocument(null);
            this.bgTokenizer.cleanup();
            this.destroyed = true;
        }
        this.endOperation();
        this.$stopWorker();
        this.removeAllListeners();
        if (this.doc) {
            this.doc.off("change", this.$onChange);
        }
        if (this.selection) {
            this.selection.off("changeCursor", this.$onSelectionChange);
            this.selection.off("changeSelection", this.$onSelectionChange);
        }
        this.selection.detach();
    }
}

EditSession.$uid = 0;
EditSession.prototype.$modes = config.$modes;
/**
 * Returns the current [[Document `Document`]] as a string.
 * @method getValue
 * @returns {String}
 * @alias EditSession.toString
 **/
EditSession.prototype.getValue = EditSession.prototype.toString;

EditSession.prototype.$defaultUndoManager = {
    undo: function() {},
    redo: function() {},
    hasUndo: function() {},
    hasRedo: function() {},
    reset: function() {},
    add: function() {},
    addSelection: function() {},
    startNewGroup: function() {},
    addSession: function() {}
};
EditSession.prototype.$overwrite = false;

EditSession.prototype.$mode = null;
EditSession.prototype.$modeId = null;
EditSession.prototype.$scrollTop = 0;
EditSession.prototype.$scrollLeft = 0;
// WRAPMODE
EditSession.prototype.$wrapLimit = 80;
EditSession.prototype.$useWrapMode = false;
EditSession.prototype.$wrapLimitRange = {
    min : null,
    max : null
};
/**
 *
 * @type {null | import("../ace-internal").Ace.LineWidget[]}
 */
EditSession.prototype.lineWidgets = null;
EditSession.prototype.isFullWidth = isFullWidth;

oop.implement(EditSession.prototype, EventEmitter);

// "Tokens"
var CHAR = 1,
    CHAR_EXT = 2,
    PLACEHOLDER_START = 3,
    PLACEHOLDER_BODY =  4,
    PUNCTUATION = 9,
    SPACE = 10,
    TAB = 11,
    TAB_SPACE = 12;
// For every keystroke this gets called once per char in the whole doc!!
// Wouldn't hurt to make it a bit faster for c >= 0x1100
function isFullWidth(c) {
    if (c < 0x1100)
        return false;
    return c >= 0x1100 && c <= 0x115F ||
        c >= 0x11A3 && c <= 0x11A7 ||
        c >= 0x11FA && c <= 0x11FF ||
        c >= 0x2329 && c <= 0x232A ||
        c >= 0x2E80 && c <= 0x2E99 ||
        c >= 0x2E9B && c <= 0x2EF3 ||
        c >= 0x2F00 && c <= 0x2FD5 ||
        c >= 0x2FF0 && c <= 0x2FFB ||
        c >= 0x3000 && c <= 0x303E ||
        c >= 0x3041 && c <= 0x3096 ||
        c >= 0x3099 && c <= 0x30FF ||
        c >= 0x3105 && c <= 0x312D ||
        c >= 0x3131 && c <= 0x318E ||
        c >= 0x3190 && c <= 0x31BA ||
        c >= 0x31C0 && c <= 0x31E3 ||
        c >= 0x31F0 && c <= 0x321E ||
        c >= 0x3220 && c <= 0x3247 ||
        c >= 0x3250 && c <= 0x32FE ||
        c >= 0x3300 && c <= 0x4DBF ||
        c >= 0x4E00 && c <= 0xA48C ||
        c >= 0xA490 && c <= 0xA4C6 ||
        c >= 0xA960 && c <= 0xA97C ||
        c >= 0xAC00 && c <= 0xD7A3 ||
        c >= 0xD7B0 && c <= 0xD7C6 ||
        c >= 0xD7CB && c <= 0xD7FB ||
        c >= 0xF900 && c <= 0xFAFF ||
        c >= 0xFE10 && c <= 0xFE19 ||
        c >= 0xFE30 && c <= 0xFE52 ||
        c >= 0xFE54 && c <= 0xFE66 ||
        c >= 0xFE68 && c <= 0xFE6B ||
        c >= 0xFF01 && c <= 0xFF60 ||
        c >= 0xFFE0 && c <= 0xFFE6;
}
(__webpack_require__(62830)/* .Folding */ .M).call(EditSession.prototype);
(__webpack_require__(30609)/* .BracketMatch */ .k).call(EditSession.prototype);


config.defineOptions(EditSession.prototype, "session", {
    wrap: {
        /**
         * @param {string | boolean | number} value
         * @this {EditSession}
         */
        set: function(value) {
            if (!value || value == "off")
                value = false;
            else if (value == "free")
                value = true;
            else if (value == "printMargin")
                value = -1;
            else if (typeof value == "string")
                value = parseInt(value, 10) || false;

            if (this.$wrap == value)
                return;
            this.$wrap = value;
            if (!value) {
                this.setUseWrapMode(false);
            } else {
                var col = typeof value == "number" ? value : null;
                this.setWrapLimitRange(col, col);
                this.setUseWrapMode(true);
            }
        },
        get: function() {
            if (this.getUseWrapMode()) {
                if (this.$wrap == -1)
                    return "printMargin";
                if (!this.getWrapLimitRange().min)
                    return "free";
                return this.$wrap;
            }
            return "off";
        },
        handlesSet: true
    },
    wrapMethod: {
        /**
         * @param {"code"|"text"|"auto"|boolean} val
         * @this{EditSession}
         */
        set: function(val) {
            val = val == "auto"
                ? this.$mode.type != "text"
                : val != "text";
            if (val != this.$wrapAsCode) {
                this.$wrapAsCode = val;
                if (this.$useWrapMode) {
                    this.$useWrapMode = false;
                    this.setUseWrapMode(true);
                }
            }
        },
        initialValue: "auto"
    },
    indentedSoftWrap: {
        /**
         * @this{EditSession}
         */
        set: function() {
            if (this.$useWrapMode) {
                this.$useWrapMode = false;
                this.setUseWrapMode(true);
            }
        },
        initialValue: true
    },
    firstLineNumber: {
        set: function() {this._signal("changeBreakpoint");},
        initialValue: 1
    },
    useWorker: {
        /**
         * @param {boolean} useWorker
         * @this{EditSession}
         */
        set: function(useWorker) {
            this.$useWorker = useWorker;

            this.$stopWorker();
            if (useWorker)
                this.$startWorker();
        },
        initialValue: true
    },
    useSoftTabs: {initialValue: true},
    tabSize: {
        /**
         * @param tabSize
         * @this{EditSession}
         */
        set: function(tabSize) {
            tabSize = parseInt(tabSize);
            if (tabSize > 0 && this.$tabSize !== tabSize) {
                this.$modified = true;
                this.$rowLengthCache = [];
                this.$tabSize = tabSize;
                this._signal("changeTabSize");
            }
        },
        initialValue: 4,
        handlesSet: true
    },
    navigateWithinSoftTabs: {initialValue: false},
    foldStyle: {
        set: function(val) {this.setFoldStyle(val);},
        handlesSet: true
    },
    overwrite: {
        set: function(val) {this._signal("changeOverwrite");},
        initialValue: false
    },
    newLineMode: {
        set: function(val) {this.doc.setNewLineMode(val);},
        get: function() {return this.doc.getNewLineMode();},
        handlesSet: true
    },
    mode: {
        set: function(val) { this.setMode(val); },
        get: function() { return this.$modeId; },
        handlesSet: true
    }
});

exports.f = EditSession;


/***/ }),

/***/ 38610:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var event = __webpack_require__(19631);
var useragent = __webpack_require__(74943);

// mouse
function isSamePoint(p1, p2) {
    return p1.row == p2.row && p1.column == p2.column;
}

function onMouseDown(e) {
    var ev = e.domEvent;
    var alt = ev.altKey;
    var shift = ev.shiftKey;
    var ctrl = ev.ctrlKey;
    var accel = e.getAccelKey();
    var button = e.getButton();
    
    if (ctrl && useragent.isMac)
        button = ev.button;

    if (e.editor.inMultiSelectMode && button == 2) {
        e.editor.textInput.onContextMenu(e.domEvent);
        return;
    }
    
    if (!ctrl && !alt && !accel) {
        if (button === 0 && e.editor.inMultiSelectMode)
            e.editor.exitMultiSelectMode();
        return;
    }
    
    if (button !== 0)
        return;

    var editor = e.editor;
    var selection = editor.selection;
    var isMultiSelect = editor.inMultiSelectMode;
    var pos = e.getDocumentPosition();
    var cursor = selection.getCursor();
    var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));

    var mouseX = e.x, mouseY = e.y;
    var onMouseSelection = function(e) {
        mouseX = e.clientX;
        mouseY = e.clientY;
    };
    
    var session = editor.session;
    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
    var screenCursor = screenAnchor;
    
    var selectionMode;
    if (editor.$mouseHandler.$enableJumpToDef) {
        if (ctrl && alt || accel && alt)
            selectionMode = shift ? "block" : "add";
        else if (alt && editor.$blockSelectEnabled)
            selectionMode = "block";
    } else {
        if (accel && !alt) {
            selectionMode = "add";
            if (!isMultiSelect && shift)
                return;
        } else if (alt && editor.$blockSelectEnabled) {
            selectionMode = "block";
        }
    }
    
    if (selectionMode && useragent.isMac && ev.ctrlKey) {
        editor.$mouseHandler.cancelContextMenu();
    }

    if (selectionMode == "add") {
        if (!isMultiSelect && inSelection)
            return; // dragging

        if (!isMultiSelect) {
            var range = selection.toOrientedRange();
            editor.addSelectionMarker(range);
        }

        var oldRange = selection.rangeList.rangeAtPoint(pos);
        
        editor.inVirtualSelectionMode = true;
        
        if (shift) {
            oldRange = null;
            range = selection.ranges[0] || range;
            editor.removeSelectionMarker(range);
        }
        editor.once("mouseup", function() {
            var tmpSel = selection.toOrientedRange();

            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
                selection.substractPoint(tmpSel.cursor);
            else {
                if (shift) {
                    selection.substractPoint(range.cursor);
                } else if (range) {
                    editor.removeSelectionMarker(range);
                    selection.addRange(range);
                }
                selection.addRange(tmpSel);
            }
            editor.inVirtualSelectionMode = false;
        });

    } else if (selectionMode == "block") {
        e.stop();
        editor.inVirtualSelectionMode = true;        
        var initialRange;
        var rectSel = [];
        var blockSelect = function() {
            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);

            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))
                return;
            screenCursor = newCursor;
            
            editor.selection.moveToPosition(cursor);
            editor.renderer.scrollCursorIntoView();

            editor.removeSelectionMarkers(rectSel);
            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
                rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
            rectSel.forEach(editor.addSelectionMarker, editor);
            editor.updateSelectionMarkers();
        };
        if (isMultiSelect && !accel) {
            selection.toSingleRange();
        } else if (!isMultiSelect && accel) {
            initialRange = selection.toOrientedRange();
            editor.addSelectionMarker(initialRange);
        }
        
        if (shift)
            screenAnchor = session.documentToScreenPosition(selection.lead);            
        else
            selection.moveToPosition(pos);
        
        screenCursor = {row: -1, column: -1};

        var onMouseSelectionEnd = function(e) {
            blockSelect();
            clearInterval(timerId);
            editor.removeSelectionMarkers(rectSel);
            if (!rectSel.length)
                rectSel = [selection.toOrientedRange()];
            if (initialRange) {
                editor.removeSelectionMarker(initialRange);
                selection.toSingleRange(initialRange);
            }
            for (var i = 0; i < rectSel.length; i++)
                selection.addRange(rectSel[i]);
            editor.inVirtualSelectionMode = false;
            editor.$mouseHandler.$clickSelection = null;
        };

        var onSelectionInterval = blockSelect;

        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
        var timerId = setInterval(function() {onSelectionInterval();}, 20);

        return e.preventDefault();
    }
}


exports.r = onMouseDown;


/***/ }),

/***/ 39955:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.last = function(a) {
    return a[a.length - 1];
};


/** @param {string} string */
exports.stringReverse = function(string) {
    return string.split("").reverse().join("");
};

exports.stringRepeat = function (string, count) {
    var result = '';
    while (count > 0) {
        if (count & 1)
            result += string;

        if (count >>= 1)
            string += string;
    }
    return result;
};

var trimBeginRegexp = /^\s\s*/;
var trimEndRegexp = /\s\s*$/;

exports.stringTrimLeft = function (string) {
    return string.replace(trimBeginRegexp, '');
};

exports.stringTrimRight = function (string) {
    return string.replace(trimEndRegexp, '');
};
/**
 * @template T
 * @param {T} obj
 * @return {T}
 */
exports.copyObject = function(obj) {
    /** @type Object*/
    var copy = {};
    for (var key in obj) {
        copy[key] = obj[key];
    }
    return copy;
};

exports.copyArray = function(array){
    var copy = [];
    for (var i=0, l=array.length; i<l; i++) {
        if (array[i] && typeof array[i] == "object")
            copy[i] = this.copyObject(array[i]);
        else
            copy[i] = array[i];
    }
    return copy;
};

exports.deepCopy = __webpack_require__(77893).deepCopy;

exports.arrayToMap = function(arr) {
    var map = {};
    for (var i=0; i<arr.length; i++) {
        map[arr[i]] = 1;
    }
    return map;

};

exports.createMap = function(props) {
    var map = Object.create(null);
    for (var i in props) {
        map[i] = props[i];
    }
    return map;
};

/*
 * splice out of 'array' anything that === 'value'
 */
exports.arrayRemove = function(array, value) {
  for (var i = 0; i <= array.length; i++) {
    if (value === array[i]) {
      array.splice(i, 1);
    }
  }
};

exports.escapeRegExp = function(str) {
    return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
};

exports.escapeHTML = function(str) {
    return ("" + str).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
};

exports.getMatchOffsets = function(string, regExp) {
    var matches = [];

    string.replace(regExp, function(str) {
        matches.push({
            offset: arguments[arguments.length-2],
            length: str.length
        });
    });

    return matches;
};

/* deprecated */
exports.deferredCall = function(fcn) {
    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };

    var deferred = function(timeout) {
        deferred.cancel();
        timer = setTimeout(callback, timeout || 0);
        return deferred;
    };

    deferred.schedule = deferred;

    deferred.call = function() {
        this.cancel();
        fcn();
        return deferred;
    };

    deferred.cancel = function() {
        clearTimeout(timer);
        timer = null;
        return deferred;
    };

    deferred.isPending = function() {
        return timer;
    };

    return deferred;
};

/**
 * @param {number} [defaultTimeout]
 */
exports.delayedCall = function(fcn, defaultTimeout) {
    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };
    /**
     * @param {number} [timeout]
     */
    var _self = function(timeout) {
        if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
    };
    /**
     * @param {number} [timeout]
     */
    _self.delay = function(timeout) {
        timer && clearTimeout(timer);
        timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.schedule = _self;

    _self.call = function() {
        this.cancel();
        fcn();
    };

    _self.cancel = function() {
        timer && clearTimeout(timer);
        timer = null;
    };

    _self.isPending = function() {
        return timer;
    };

    return _self;
};

exports.supportsLookbehind = function () {
    try {
        new RegExp('(?<=.)');
    } catch (e) {
        return false;
    }
    return true;
};

exports.skipEmptyMatch = function(line, last, supportsUnicodeFlag) {
    return supportsUnicodeFlag && line.codePointAt(last) > 0xffff ? 2 : 1;
};


/***/ }),

/***/ 41109:
/***/ ((__unused_webpack_module, exports) => {

// Tokens for which Ace just uses a simple TextNode and does not add any special className.
const textTokens = new Set(["text", "rparen", "lparen"]);

exports.t = function(tokenType) {
    return textTokens.has(tokenType);
};


/***/ }),

/***/ 42393:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * @typedef {import("./edit_session").EditSession} EditSession
 * @typedef {{range: import("./range").Range, className: string}} MarkerGroupItem
 * @typedef {import("../ace-internal").Ace.LayerConfig} LayerConfig
 */
/**
 * @typedef {import("./layer/marker").Marker} Marker
 */

/*
Potential improvements:
- use binary search when looking for hover match
*/

class MarkerGroup {
    /**
     * @param {EditSession} session
     * @param {{markerType: "fullLine" | "line" | undefined}} [options] Options controlling the behvaiour of the marker.
     * User `markerType` to control how the markers which are part of this group will be rendered:
     * - `undefined`: uses `text` type markers where only text characters within the range will be highlighted.
     * - `fullLine`: will fully highlight all the rows within the range, including the characters before and after the range on the respective rows.
     * - `line`: will fully highlight the lines within the range but will only cover the characters between the start and end of the range.
     */
    constructor(session, options) {
        if (options)
            this.markerType = options.markerType;
        /**@type {import("../ace-internal").Ace.MarkerGroupItem[]}*/
        this.markers = [];
        /**@type {EditSession}*/
        this.session = session;
        // @ts-expect-error TODO: could potential error here, or most likely missing checks in other places
        session.addDynamicMarker(this);
    }

    /**
     * Finds the first marker containing pos
     * @param {import("../ace-internal").Ace.Point} pos
     * @returns {import("../ace-internal").Ace.MarkerGroupItem | undefined}
     */
    getMarkerAtPosition(pos) {
        return this.markers.find(function(marker) {
            return marker.range.contains(pos.row, pos.column);
        });
    }

    /**
     * Comparator for Array.sort function, which sorts marker definitions by their positions
     *
     * @param {MarkerGroupItem} a first marker.
     * @param {MarkerGroupItem} b second marker.
     * @returns {number} negative number if a should be before b, positive number if b should be before a, 0 otherwise.
     */
    markersComparator(a, b) {
        return a.range.start.row - b.range.start.row;
    }

    /**
     * Sets marker definitions to be rendered. Limits the number of markers at MAX_MARKERS.
     * @param {MarkerGroupItem[]} markers an array of marker definitions.
     */
    setMarkers(markers) {
        this.markers = markers.sort(this.markersComparator).slice(0, this.MAX_MARKERS);
        this.session._signal("changeBackMarker");
    }

    /**
     * @param {any} html
     * @param {Marker} markerLayer
     * @param {EditSession} session
     * @param {LayerConfig} config
     */
    update(html, markerLayer, session, config) {
        if (!this.markers || !this.markers.length)
            return;
        var visibleRangeStartRow = config.firstRow, visibleRangeEndRow = config.lastRow;
        var foldLine;
        var markersOnOneLine = 0;
        var lastRow = 0;

        for (var i = 0; i < this.markers.length; i++) {
            var marker = this.markers[i];

            if (marker.range.end.row < visibleRangeStartRow) continue;
            if (marker.range.start.row > visibleRangeEndRow) continue;

            if (marker.range.start.row === lastRow) {
                markersOnOneLine++;
            } else {
                lastRow = marker.range.start.row;
                markersOnOneLine = 0;
            }
            // do not render too many markers on one line
            // because we do not have virtual scroll for horizontal direction
            if (markersOnOneLine > 200) {
                continue;
            }

            var markerVisibleRange = marker.range.clipRows(visibleRangeStartRow, visibleRangeEndRow);
            if (markerVisibleRange.start.row === markerVisibleRange.end.row
                && markerVisibleRange.start.column === markerVisibleRange.end.column) {
                    continue; // visible range is empty
                }

            var screenRange = markerVisibleRange.toScreenRange(session);
            if (screenRange.isEmpty()) {
                // we are inside a fold
                foldLine = session.getNextFoldLine(markerVisibleRange.end.row, foldLine);
                if (foldLine && foldLine.end.row > markerVisibleRange.end.row) {
                    visibleRangeStartRow = foldLine.end.row;
                }
                continue;
            }

            if (this.markerType === "fullLine") {
                markerLayer.drawFullLineMarker(html, screenRange, marker.className, config);
            } else if (screenRange.isMultiLine()) {
                if (this.markerType === "line")
                    markerLayer.drawMultiLineMarker(html, screenRange, marker.className, config);
                else
                    markerLayer.drawTextMarker(html, screenRange, marker.className, config);
            } else {
                markerLayer.drawSingleLineMarker(html, screenRange, marker.className + " ace_br15", config);
            }
        }
    }

}

// this caps total amount of markers at 10K
MarkerGroup.prototype.MAX_MARKERS = 10000;

exports.o = MarkerGroup;



/***/ }),

/***/ 45375:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * commands to enter multiselect mode
 * @type {import("../../ace-internal").Ace.Command[]}
 */
exports.defaultCommands = [{
    name: "addCursorAbove",
    description: "Add cursor above",
    exec: function(editor) { editor.selectMoreLines(-1); },
    bindKey: {win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "addCursorBelow",
    description: "Add cursor below",
    exec: function(editor) { editor.selectMoreLines(1); },
    bindKey: {win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "addCursorAboveSkipCurrent",
    description: "Add cursor above (skip current)",
    exec: function(editor) { editor.selectMoreLines(-1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "addCursorBelowSkipCurrent",
    description: "Add cursor below (skip current)",
    exec: function(editor) { editor.selectMoreLines(1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectMoreBefore",
    description: "Select more before",
    exec: function(editor) { editor.selectMore(-1); },
    bindKey: {win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectMoreAfter",
    description: "Select more after",
    exec: function(editor) { editor.selectMore(1); },
    bindKey: {win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectNextBefore",
    description: "Select next before",
    exec: function(editor) { editor.selectMore(-1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectNextAfter",
    description: "Select next after",
    exec: function(editor) { editor.selectMore(1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "toggleSplitSelectionIntoLines",
    description: "Split selection into lines",
    exec: function(editor) {
        if (editor.multiSelect.rangeCount > 1)
            editor.multiSelect.joinSelections();
        else
            editor.multiSelect.splitIntoLines();
    },
    bindKey: {win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L"},
    readOnly: true
}, {
    name: "splitSelectionIntoLines",
    description: "Split into lines",
    exec: function(editor) { editor.multiSelect.splitIntoLines(); },
    readOnly: true
}, {
    name: "alignCursors",
    description: "Align cursors",
    exec: function(editor) { editor.alignCursors(); },
    bindKey: {win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A"},
    scrollIntoView: "cursor"
}, {
    name: "findAll",
    description: "Find all",
    exec: function(editor) { editor.findAll(); },
    bindKey: {win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G"},
    scrollIntoView: "cursor",
    readOnly: true
}];

/**
 * commands active only in multiselect mode
 * @type {import("../../ace-internal").Ace.Command[]}
 */
exports.multiSelectCommands = [{
    name: "singleSelection",
    description: "Single selection",
    bindKey: "esc",
    exec: function(editor) { editor.exitMultiSelectMode(); },
    scrollIntoView: "cursor",
    readOnly: true,
    isAvailable: function(editor) {return editor && editor.inMultiSelectMode;}
}];

var HashHandler = (__webpack_require__(93050).HashHandler);
exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);


/***/ }),

/***/ 45545:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


var keys = __webpack_require__(29451);

class GutterKeyboardHandler {
    constructor(editor) {
        this.editor = editor;
        this.gutterLayer = editor.renderer.$gutterLayer;
        this.element = editor.renderer.$gutter;
        this.lines = editor.renderer.$gutterLayer.$lines;

        this.activeRowIndex = null;
        this.activeLane = null;

        this.annotationTooltip = this.editor.$mouseHandler.$tooltip;
    }

    addListener() {
        this.element.addEventListener("keydown", this.$onGutterKeyDown.bind(this));
        this.element.addEventListener("focusout", this.$blurGutter.bind(this));
        this.editor.on("mousewheel", this.$blurGutter.bind(this));
    }

    removeListener() {
        this.element.removeEventListener("keydown", this.$onGutterKeyDown.bind(this));
        this.element.removeEventListener("focusout", this.$blurGutter.bind(this));
        this.editor.off("mousewheel", this.$blurGutter.bind(this));
    }

    $onGutterKeyDown(e) {
        // if the tooltip is open, we only want to respond to commands to close it (like a modal)
        if (this.annotationTooltip.isOpen) {
            e.preventDefault();

            if (e.keyCode === keys["escape"])
                this.annotationTooltip.hide();

            return;
        }

        // If focus is on the gutter element, set focus to nearest gutter icon on enter press.
        if (e.target === this.element) {
            if (e.keyCode != keys["enter"]) {return;}
            e.preventDefault();

            // Scroll if the cursor is not currently within the viewport.
            var row = this.editor.getCursorPosition().row;       
            if (!this.editor.isRowVisible(row))
                this.editor.scrollToLine(row, true, true);

            // After scrolling is completed, find the nearest gutter icon and set focus to it.
            setTimeout(
                /** @this {GutterKeyboardHandler} */
                function () {
                    var index = this.$rowToRowIndex(this.gutterLayer.$cursorCell.row);
                    var nearestFoldLaneWidgetIndex = this.$findNearestFoldLaneWidget(index);
                    var nearestAnnotationIndex = this.$findNearestAnnotation(index);

                    if (nearestFoldLaneWidgetIndex === null && nearestAnnotationIndex === null) return;

                    var futureActiveRowIndex = this.$findClosestNumber(nearestFoldLaneWidgetIndex, nearestAnnotationIndex, index);

                    if (futureActiveRowIndex === nearestFoldLaneWidgetIndex) {
                        this.activeLane = "fold";
                        this.activeRowIndex = nearestFoldLaneWidgetIndex;
                        if(this.$isCustomWidgetVisible(nearestFoldLaneWidgetIndex)){
                            this.$focusCustomWidget(this.activeRowIndex);
                            return;
                        }
                        else {
                            this.$focusFoldWidget(this.activeRowIndex);
                            return;
                        }
                    }
                    else {
                        this.activeRowIndex = nearestAnnotationIndex;
                        this.activeLane = "annotation";
                        this.$focusAnnotation(this.activeRowIndex);
                        return;
                    }
                }.bind(this), 10);
            return;
        } 

        // After here, foucs is on a gutter icon and we want to interact with them.
        this.$handleGutterKeyboardInteraction(e);

        // Wait until folding is completed and then signal gutterkeydown to the editor.
        setTimeout(function() {
            // Signal to the editor that a key is pressed inside the gutter.
            this.editor._signal("gutterkeydown", new GutterKeyboardEvent(e, this));
        }.bind(this), 10);
    }

    $handleGutterKeyboardInteraction(e) {
        // Prevent tabbing when interacting with the gutter icons.
        if (e.keyCode === keys["tab"]){
            e.preventDefault();
            return;
        } 

        // If focus is on a gutter icon, set focus to gutter on escape press.
        if (e.keyCode === keys["escape"]) {
            e.preventDefault();
            this.$blurGutter();
            this.element.focus();
            this.lane = null;
            return;
        }

        if (e.keyCode === keys["up"]) {
            e.preventDefault();
  
            switch (this.activeLane){
                case "fold":
                    this.$moveFoldWidgetUp();
                    break;
                
                case "annotation":
                    this.$moveAnnotationUp();
                    break;
            }
            return;
        }

        if (e.keyCode === keys["down"]) {
            e.preventDefault();

            switch (this.activeLane){
                case "fold":
                    this.$moveFoldWidgetDown();
                    break;
                
                case "annotation":
                    this.$moveAnnotationDown();
                    break;
            }
            return;
        }

        // Try to switch from fold widgets to annotations.
        if (e.keyCode === keys["left"]){
            e.preventDefault();
            this.$switchLane("annotation");
            return;
        }

        // Try to switch from annotations to fold widgets.
        if (e.keyCode === keys["right"]){
            e.preventDefault();
            this.$switchLane("fold");
            return;
        }

        if (e.keyCode === keys["enter"] || e.keyCode === keys["space"]){
            e.preventDefault();

            switch (this.activeLane) {
                case "fold":
                    var row = this.$rowIndexToRow(this.activeRowIndex);
                    var customWidget = this.editor.session.$gutterCustomWidgets[row];
                    if (customWidget) {
                        if (customWidget.callbacks && customWidget.callbacks.onClick) {
                            customWidget.callbacks.onClick(e, row);
                        }
                    }
                    else if (this.gutterLayer.session.foldWidgets[row] === 'start') {
                        this.editor.session.onFoldWidgetClick(this.$rowIndexToRow(this.activeRowIndex), e);
                        // After folding, check that the right fold widget is still in focus.
                        // If not (e.g. folding close to bottom of doc), put right widget in focus.
                        setTimeout(
                            /** @this {GutterKeyboardHandler} */
                            function () {
                                if (this.$rowIndexToRow(this.activeRowIndex) !== row) {
                                    this.$blurFoldWidget(this.activeRowIndex);
                                    this.activeRowIndex = this.$rowToRowIndex(row);
                                    this.$focusFoldWidget(this.activeRowIndex);
                                }
                        }.bind(this), 10);
                        break;
                    } else if (this.gutterLayer.session.foldWidgets[this.$rowIndexToRow(this.activeRowIndex)] === 'end') {
                        /* TO DO: deal with 'end' fold widgets */
                        break;
                    }
                    return; 
                
                case "annotation":
                    this.annotationTooltip.showTooltip(this.$rowIndexToRow(this.activeRowIndex));
                    this.annotationTooltip.$fromKeyboard = true;
                    break;
            }
            return;
        }   
    }

    $blurGutter() {
        if (this.activeRowIndex !== null){
            switch (this.activeLane){
                case "fold":
                    this.$blurFoldWidget(this.activeRowIndex);
                    this.$blurCustomWidget(this.activeRowIndex);
                    break;

                case "annotation":
                    this.$blurAnnotation(this.activeRowIndex);
                    break;
            }
        }

        if (this.annotationTooltip.isOpen)
            this.annotationTooltip.hide();

        return;
    }

    $isFoldWidgetVisible(index) {
        var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));
        var isIconVisible = this.$getFoldWidget(index).style.display !== "none";
        return isRowFullyVisible && isIconVisible;
    }

    $isCustomWidgetVisible(index) {
        var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));
        var isIconVisible = !!this.$getCustomWidget(index);
        return isRowFullyVisible && isIconVisible;
    }

    $isAnnotationVisible(index) {
        var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));
        var isIconVisible = this.$getAnnotation(index).style.display !== "none";
        return isRowFullyVisible && isIconVisible;
    }

    $getFoldWidget(index) {
        var cell = this.lines.get(index);
        var element = cell.element;
        return element.childNodes[1];
    }

    $getCustomWidget(index) {
        var cell = this.lines.get(index);
        var element = cell.element;
        return element.childNodes[3];
    }

    $getAnnotation(index) {
        var cell = this.lines.get(index);
        var element = cell.element;
        return element.childNodes[2];
    }

    // Given an index, find the nearest index with a widget in fold lane
    $findNearestFoldLaneWidget(index) {
        // If custom widget exists at index, return index
        if (this.$isCustomWidgetVisible(index))
            return index;

        // If fold widget exists at index, return index.
        if (this.$isFoldWidgetVisible(index))
            return index;

        // else, find the nearest index with widget within viewport.
        var i = 0;
        while (index - i > 0 || index + i < this.lines.getLength() - 1){
            i++;
            if (index - i >= 0 && this.$isCustomWidgetVisible(index - i))
                return index - i;

            if (index + i <= this.lines.getLength() - 1 && this.$isCustomWidgetVisible(index + i))
                return index + i;

            if (index - i >= 0 && this.$isFoldWidgetVisible(index - i))
                return index - i;

            if (index + i <= this.lines.getLength() - 1 && this.$isFoldWidgetVisible(index + i))
                return index + i;
        }

        // If there are no widgets within the viewport, return null.
        return null;
    }

    // Given an index, find the nearest index with an annotation.
    $findNearestAnnotation(index) {
        // If annotation exists at index, return index.
        if (this.$isAnnotationVisible(index))
            return index;

        // else, find the nearest index with annotation within viewport.
        var i = 0;
        while (index - i > 0 || index + i < this.lines.getLength() - 1){
            i++;

            if (index - i >= 0 && this.$isAnnotationVisible(index - i))
                return index - i;

            if (index + i <= this.lines.getLength() - 1 && this.$isAnnotationVisible(index + i))
                return index + i;
        }

        // If there are no annotations within the viewport, return null.
        return null;
    }

    $focusFoldWidget(index) {
        if (index == null)
            return;

        var foldWidget = this.$getFoldWidget(index);

        foldWidget.classList.add(this.editor.renderer.keyboardFocusClassName);
        foldWidget.focus();
    }

    $focusCustomWidget(index) {
        if (index == null)
            return;

        var customWidget = this.$getCustomWidget(index);
        if (customWidget) {
            customWidget.classList.add(this.editor.renderer.keyboardFocusClassName);
            customWidget.focus();
        }
    }

    $focusAnnotation(index) {
        if (index == null)
            return;

        var annotation = this.$getAnnotation(index);

        annotation.classList.add(this.editor.renderer.keyboardFocusClassName);
        annotation.focus();
    }

    $blurFoldWidget(index) {
        var foldWidget = this.$getFoldWidget(index);

        foldWidget.classList.remove(this.editor.renderer.keyboardFocusClassName);
        foldWidget.blur();
    }

    $blurCustomWidget(index) {
        var customWidget = this.$getCustomWidget(index);
        if (customWidget) {
            customWidget.classList.remove(this.editor.renderer.keyboardFocusClassName);
            customWidget.blur();
        }
    }

    $blurAnnotation(index) {
        var annotation = this.$getAnnotation(index);

        annotation.classList.remove(this.editor.renderer.keyboardFocusClassName);
        annotation.blur();
    }

    $moveFoldWidgetUp() {
        var index = this.activeRowIndex;

        while (index > 0){
            index--;

            if (this.$isFoldWidgetVisible(index) || this.$isCustomWidgetVisible(index)){
                this.$blurFoldWidget(this.activeRowIndex);
                this.$blurCustomWidget(this.activeRowIndex);
                this.activeRowIndex = index;
                if (this.$isFoldWidgetVisible(index)) {
                    this.$focusFoldWidget(this.activeRowIndex);
                }
                else {
                    this.$focusCustomWidget(this.activeRowIndex);
                }
                return;
            }
        }
        return;
    }

    $moveFoldWidgetDown() {
        var index = this.activeRowIndex;

        while (index < this.lines.getLength() - 1){
            index++;

            if (this.$isFoldWidgetVisible(index) || this.$isCustomWidgetVisible(index)){
                this.$blurFoldWidget(this.activeRowIndex);
                this.$blurCustomWidget(this.activeRowIndex);
                this.activeRowIndex = index;
                if (this.$isFoldWidgetVisible(index)) {
                    this.$focusFoldWidget(this.activeRowIndex);
                }
                else {
                    this.$focusCustomWidget(this.activeRowIndex);
                }
                return;
            }
        }
        return;
    }

    $moveAnnotationUp() {
        var index = this.activeRowIndex;

        while (index > 0){
            index--;

            if (this.$isAnnotationVisible(index)){
                this.$blurAnnotation(this.activeRowIndex);
                this.activeRowIndex = index;
                this.$focusAnnotation(this.activeRowIndex);
                return;
            }
        }
        return;
    }

    $moveAnnotationDown() {
        var index = this.activeRowIndex;

        while (index < this.lines.getLength() - 1){
            index++;

            if (this.$isAnnotationVisible(index)){
                this.$blurAnnotation(this.activeRowIndex);
                this.activeRowIndex = index;
                this.$focusAnnotation(this.activeRowIndex);
                return;
            }
        }
        return;
    }

    $findClosestNumber(num1, num2, target) {
        if (num1 === null) return num2;
        if (num2 === null) return num1;
        
        return (Math.abs(target - num1) <= Math.abs(target - num2)) ? num1 : num2;
    }

    $switchLane(desinationLane){
        switch (desinationLane) {
            case "annotation":
                if (this.activeLane === "annotation") {break;}
                var annotationIndex = this.$findNearestAnnotation(this.activeRowIndex);
                if (annotationIndex == null) {break;}

                this.activeLane = "annotation";

                this.$blurFoldWidget(this.activeRowIndex);
                this.$blurCustomWidget(this.activeRowIndex);
                this.activeRowIndex = annotationIndex;
                this.$focusAnnotation(this.activeRowIndex);

                break;

            case "fold": 
            if (this.activeLane === "fold") {break;}
            var foldLaneWidgetIndex = this.$findNearestFoldLaneWidget(this.activeRowIndex);
            if (foldLaneWidgetIndex === null) {break;}

            this.activeLane = "fold";

            this.$blurAnnotation(this.activeRowIndex);

            this.activeRowIndex = foldLaneWidgetIndex;

            if (this.$isCustomWidgetVisible(foldLaneWidgetIndex)) {
                this.$focusCustomWidget(this.activeRowIndex);
            }
            else {
                this.$focusFoldWidget(this.activeRowIndex);
            }
                break;
        }
        return;
    }

    // Convert row index (viewport space) to row (document space).
    $rowIndexToRow(index) {
        var cell = this.lines.get(index);
        if (cell)
            return cell.row;

        return null;
    }

    // Convert row (document space) to row index (viewport space).
    $rowToRowIndex(row) {
        for (var i = 0; i < this.lines.getLength(); i++){
            var cell = this.lines.get(i);
            if (cell.row == row)
                return i;
        }

        return null;
    }
}

exports.S = GutterKeyboardHandler;

/*
 * Custom Ace gutter keyboard event
 */
class GutterKeyboardEvent {
    constructor(domEvent, gutterKeyboardHandler) {
        this.gutterKeyboardHandler = gutterKeyboardHandler;
        this.domEvent = domEvent;
    }

    /**
     * Returns the key that was presssed.
     * 
     * @return {string} the key that was pressed.
     */
    getKey() {
        return keys.keyCodeToString(this.domEvent.keyCode);
    }

    /**
     * Returns the row in the gutter that was focused after the keyboard event was handled.
     * 
     * @return {number} the key that was pressed.
     */
    getRow() {
        return this.gutterKeyboardHandler.$rowIndexToRow(this.gutterKeyboardHandler.activeRowIndex);
    }

    /**
     * Returns whether focus is on the annotation lane after the keyboard event was handled.
     * 
     * @return {boolean} true if focus was on the annotation lane after the keyboard event.
     */
    isInAnnotationLane() {
        return this.gutterKeyboardHandler.activeLane === "annotation";
    }

    /**
     * Returns whether focus is on the fold lane after the keyboard event was handled.
     * 
     * @return {boolean} true if focus was on the fold lane after the keyboard event.
     */
    isInFoldLane() {
        return this.gutterKeyboardHandler.activeLane === "fold";
    }
}

__webpack_unused_export__ = GutterKeyboardEvent;


/***/ }),

/***/ 45816:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./fold_line").FoldLine} FoldLine
 * @typedef {import("../range").Range} Range
 * @typedef {import("../../ace-internal").Ace.Point} Point
 * @typedef {import("../../ace-internal").Ace.IRange} IRange
 */
var RangeList = (__webpack_require__(53509)/* .RangeList */ .U);

/*
 * Simple fold-data struct.
 **/
class Fold extends RangeList {

    /**
     * @param {Range} range
     * @param {any} placeholder
     */
    constructor(range, placeholder) {
        super();
        this.foldLine = null;
        this.placeholder = placeholder;
        this.range = range;
        this.start = range.start;
        this.end = range.end;

        this.sameRow = range.start.row == range.end.row;
        /**@type {Fold[]}*/
        this.subFolds = this.ranges = [];
    }
    
    toString() {
        return '"' + this.placeholder + '" ' + this.range.toString();
    }

    /**
     * @param {FoldLine} foldLine
     */
    setFoldLine(foldLine) {
        this.foldLine = foldLine;
        this.subFolds.forEach(function(fold) {
            fold.setFoldLine(foldLine);
        });
    }

    clone() {
        var range = this.range.clone();
        var fold = new Fold(range, this.placeholder);
        this.subFolds.forEach(function(subFold) {
            fold.subFolds.push(subFold.clone());
        });
        fold.collapseChildren = this.collapseChildren;
        return fold;
    }

    /**
     * @param {Fold} fold
     */
    addSubFold(fold) {
        if (this.range.isEqual(fold))
            return;

        // transform fold to local coordinates
        consumeRange(fold, this.start);

        var row = fold.start.row, column = fold.start.column;
        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
            cmp = this.subFolds[i].range.compare(row, column);
            if (cmp != 1)
                break;
        }
        var afterStart = this.subFolds[i];
        var firstConsumed = 0;

        if (cmp == 0) {
            if (afterStart.range.containsRange(fold))
                return afterStart.addSubFold(fold);
            else
                firstConsumed = 1;
        }

        // cmp == -1
        var row = fold.range.end.row, column = fold.range.end.column;
        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
            cmp = this.subFolds[j].range.compare(row, column);
            if (cmp != 1)
                break;
        }
        if (cmp == 0)  j++;
        var consumedFolds = this.subFolds.splice(i, j - i, fold);
        var last = cmp == 0 ? consumedFolds.length - 1 : consumedFolds.length;
        for (var k = firstConsumed; k < last; k++) {
            fold.addSubFold(consumedFolds[k]);
        }
        fold.setFoldLine(this.foldLine);

        return fold;
    }

    /**
     * @param {IRange} range
     */
    restoreRange(range) {
        return restoreRange(range, this.start);
    }

}

/**
 * @param {Point} point
 * @param {Point} anchor
 */
function consumePoint(point, anchor) {
    point.row -= anchor.row;
    if (point.row == 0)
        point.column -= anchor.column;
}
/**
 * @param {IRange} range
 * @param {Point} anchor
 */
function consumeRange(range, anchor) {
    consumePoint(range.start, anchor);
    consumePoint(range.end, anchor);
}
/**
 * @param {Point} point
 * @param {Point} anchor
 */
function restorePoint(point, anchor) {
    if (point.row == 0)
        point.column += anchor.column;
    point.row += anchor.row;
}
/**
 * @param {IRange} range
 * @param {Point} anchor
 */
function restoreRange(range, anchor) {
    restorePoint(range.start, anchor);
    restorePoint(range.end, anchor);
}

exports.a = Fold;


/***/ }),

/***/ 48369:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * @typedef {import("./anchor").Anchor} Anchor
 * @typedef {import("../ace-internal").Ace.Point} Point
 * @typedef {import("../ace-internal").Ace.ScreenCoordinates} ScreenCoordinates
 */

var RangeList = (__webpack_require__(53509)/* .RangeList */ .U);
var Range = (__webpack_require__(91902)/* .Range */ .Q);
var Selection = (__webpack_require__(98345)/* .Selection */ .L);
var onMouseDown = (__webpack_require__(38610)/* .onMouseDown */ .r);
var event = __webpack_require__(19631);
var lang = __webpack_require__(39955);
var commands = __webpack_require__(45375);
exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);

// Todo: session.find or editor.findVolatile that returns range
var Search = (__webpack_require__(99427)/* .Search */ .v);
var search = new Search();

/**
 * @param {EditSession} session
 * @param {string | RegExp} needle
 * @param {number} dir
 */
function find(session, needle, dir) {
    search.$options.wrap = true;
    search.$options.needle = needle;
    search.$options.backwards = dir == -1;
    return search.find(session);
}

// extend EditSession
var EditSession = (__webpack_require__(33464)/* .EditSession */ .f);
(function() {
    /**
     * @this {EditSession}
     */
    this.getSelectionMarkers = function() {
        return this.$selectionMarkers;
    };
}).call(EditSession.prototype);

// extend Selection
(function() {
    // list of ranges in reverse addition order
    this.ranges = null;

    // automatically sorted list of ranges
    /**@type {RangeList | null} */
    this.rangeList = null;

    /**
     * Adds a range to a selection by entering multiselect mode, if necessary.
     * @param {Range} range The new range to add
     * @param {Boolean} $blockChangeEvents Whether or not to block changing events
     * @this {Selection}
     **/
    this.addRange = function(range, $blockChangeEvents) {
        if (!range)
            return;

        if (!this.inMultiSelectMode && this.rangeCount === 0) {
            var oldRange = this.toOrientedRange();
            this.rangeList.add(oldRange);
            this.rangeList.add(range);
            if (this.rangeList.ranges.length != 2) {
                this.rangeList.removeAll();
                return $blockChangeEvents || this.fromOrientedRange(range);
            }
            this.rangeList.removeAll();
            this.rangeList.add(oldRange);
            this.$onAddRange(oldRange);
        }

        if (!range.cursor)
            range.cursor = range.end;

        var removed = this.rangeList.add(range);

        this.$onAddRange(range);

        if (removed.length)
            this.$onRemoveRange(removed);

        if (this.rangeCount > 1 && !this.inMultiSelectMode) {
            this._signal("multiSelect");
            this.inMultiSelectMode = true;
            this.session.$undoSelect = false;
            this.rangeList.attach(this.session);
        }

        return $blockChangeEvents || this.fromOrientedRange(range);
    };

    /**
     * @param {Range} [range]
     * @this {Selection}
     **/
    this.toSingleRange = function(range) {
        range = range || this.ranges[0];
        var removed = this.rangeList.removeAll();
        if (removed.length)
            this.$onRemoveRange(removed);

        range && this.fromOrientedRange(range);
    };

    /**
     * Removes a Range containing pos (if it exists).
     * @param {Point} pos The position to remove, as a `{row, column}` object
     * @this {Selection}
     **/
    this.substractPoint = function(pos) {
        var removed = this.rangeList.substractPoint(pos);
        if (removed) {
            this.$onRemoveRange(removed);
            return removed[0];
        }
    };

    /**
     * Merges overlapping ranges ensuring consistency after changes
     * @this {Selection}
     **/
    this.mergeOverlappingRanges = function() {
        var removed = this.rangeList.merge();
        if (removed.length)
            this.$onRemoveRange(removed);
    };

    /**
     * @param {Range} range
     * @this {Selection}
     */
    this.$onAddRange = function(range) {
        this.rangeCount = this.rangeList.ranges.length;
        this.ranges.unshift(range);
        this._signal("addRange", {range: range});
    };

    /**
     * @param {Range[]} removed
     * @this {Selection}
     */
    this.$onRemoveRange = function(removed) {
        this.rangeCount = this.rangeList.ranges.length;
        if (this.rangeCount == 1 && this.inMultiSelectMode) {
            var lastRange = this.rangeList.ranges.pop();
            removed.push(lastRange);
            this.rangeCount = 0;
        }

        for (var i = removed.length; i--; ) {
            var index = this.ranges.indexOf(removed[i]);
            this.ranges.splice(index, 1);
        }

        this._signal("removeRange", {ranges: removed});

        if (this.rangeCount === 0 && this.inMultiSelectMode) {
            this.inMultiSelectMode = false;
            this._signal("singleSelect");
            this.session.$undoSelect = true;
            // @ts-expect-error TODO: possible bug, no args in parameters
            this.rangeList.detach(this.session);
        }

        lastRange = lastRange || this.ranges[0];
        if (lastRange && !lastRange.isEqual(this.getRange()))
            this.fromOrientedRange(lastRange);
    };

    /**
     * adds multicursor support to selection
     * @this {Selection}
     */
    this.$initRangeList = function() {
        if (this.rangeList)
            return;

        this.rangeList = new RangeList();
        this.ranges = [];
        this.rangeCount = 0;
    };

    /**
     * Returns a concatenation of all the ranges.
     * @returns {Range[]}
     * @this {Selection}
     **/
    this.getAllRanges = function() {
        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
    };

    /**
     * Splits all the ranges into lines.
     * @this {Selection}
     **/
    this.splitIntoLines = function () {
        var ranges = this.ranges.length ? this.ranges : [this.getRange()];
        var newRanges = [];
        for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            var row = range.start.row;
            var endRow = range.end.row;
            if (row === endRow) {
                newRanges.push(range.clone());
            } else {
                newRanges.push(new Range(row, range.start.column, row, this.session.getLine(row).length));
                while (++row < endRow)
                    newRanges.push(this.getLineRange(row, true));
                newRanges.push(new Range(endRow, 0, endRow, range.end.column));
            }
            if (i == 0 && !this.isBackwards())
                newRanges = newRanges.reverse();
        }
        this.toSingleRange();
        for (var i = newRanges.length; i--;)
            this.addRange(newRanges[i]);
    };

    /**
     * @this {Selection}
     */
    this.joinSelections = function () {
        var ranges = this.rangeList.ranges;
        var lastRange = ranges[ranges.length - 1];
        var range = Range.fromPoints(ranges[0].start, lastRange.end);

        this.toSingleRange();
        this.setSelectionRange(range, lastRange.cursor == lastRange.start);
    };

    /**
     * @this {Selection}
     **/
    this.toggleBlockSelection = function () {
        if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);

            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        } else {
            var cursor = this.session.documentToScreenPosition(this.cursor);
            var anchor = this.session.documentToScreenPosition(this.anchor);

            var rectSel = this.rectangularRangeBlock(cursor, anchor);
            // @ts-expect-error TODO: possible bug
            rectSel.forEach(this.addRange, this);
        }
    };

    /**
     * Gets list of ranges composing rectangular block on the screen
     *
     * @param {ScreenCoordinates} screenCursor The cursor to use
     * @param {ScreenCoordinates} screenAnchor The anchor to use
     * @param {Boolean} [includeEmptyLines] If true, this includes ranges inside the block which are empty due to clipping
     * @returns {Range[]}
     * @this {Selection}
     **/
    this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
        var rectSel = [];

        var xBackwards = screenCursor.column < screenAnchor.column;
        if (xBackwards) {
            var startColumn = screenCursor.column;
            var endColumn = screenAnchor.column;
            var startOffsetX = screenCursor.offsetX;
            var endOffsetX = screenAnchor.offsetX;
        } else {
            var startColumn = screenAnchor.column;
            var endColumn = screenCursor.column;
            var startOffsetX = screenAnchor.offsetX;
            var endOffsetX = screenCursor.offsetX;
        }

        var yBackwards = screenCursor.row < screenAnchor.row;
        if (yBackwards) {
            var startRow = screenCursor.row;
            var endRow = screenAnchor.row;
        } else {
            var startRow = screenAnchor.row;
            var endRow = screenCursor.row;
        }

        if (startColumn < 0)
            startColumn = 0;
        if (startRow < 0)
            startRow = 0;

        if (startRow == endRow)
            includeEmptyLines = true;

        var docEnd;
        for (var row = startRow; row <= endRow; row++) {
            var range = Range.fromPoints(
                this.session.screenToDocumentPosition(row, startColumn, startOffsetX),
                this.session.screenToDocumentPosition(row, endColumn, endOffsetX)
            );
            if (range.isEmpty()) {
                if (docEnd && isSamePoint(range.end, docEnd))
                    break;
                docEnd = range.end;
            }
            range.cursor = xBackwards ? range.start : range.end;
            rectSel.push(range);
        }

        if (yBackwards)
            rectSel.reverse();

        if (!includeEmptyLines) {
            var end = rectSel.length - 1;
            while (rectSel[end].isEmpty() && end > 0)
                end--;
            if (end > 0) {
                var start = 0;
                while (rectSel[start].isEmpty())
                    start++;
            }
            for (var i = end; i >= start; i--) {
                if (rectSel[i].isEmpty())
                    rectSel.splice(i, 1);
            }
        }

        return rectSel;
    };
}).call(Selection.prototype);

// extend Editor
var Editor = (__webpack_require__(27258).Editor);
(function() {

    /**
     *
     * Updates the cursor and marker layers.
     * @method Editor.updateSelectionMarkers
     * @this {Editor}
     **/
    this.updateSelectionMarkers = function() {
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    /**
     * Adds the selection and cursor.
     * @param {Range & {marker?}} orientedRange A range containing a cursor
     * @returns {Range & {marker?}}
     * @this {Editor}
     **/
    this.addSelectionMarker = function(orientedRange) {
        if (!orientedRange.cursor)
            orientedRange.cursor = orientedRange.end;

        var style = this.getSelectionStyle();
        orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);

        this.session.$selectionMarkers.push(orientedRange);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        return orientedRange;
    };

    /**
     * Removes the selection marker.
     * @param {Range & {marker?}} range The selection range added with [[Editor.addSelectionMarker `addSelectionMarker()`]].
     * @this {Editor}
     **/
    this.removeSelectionMarker = function(range) {
        if (!range.marker)
            return;
        this.session.removeMarker(range.marker);
        var index = this.session.$selectionMarkers.indexOf(range);
        if (index != -1)
            this.session.$selectionMarkers.splice(index, 1);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
    };

    /**
     * @param {(Range & {marker?})[]} ranges
     * @this {Editor}
     */
    this.removeSelectionMarkers = function(ranges) {
        var markerList = this.session.$selectionMarkers;
        for (var i = ranges.length; i--; ) {
            var range = ranges[i];
            if (!range.marker)
                continue;
            this.session.removeMarker(range.marker);
            var index = markerList.indexOf(range);
            if (index != -1)
                markerList.splice(index, 1);
        }
        this.session.selectionMarkerCount = markerList.length;
    };

    /**
     * @param e
     * @this {Editor}
     */
    this.$onAddRange = function(e) {
        this.addSelectionMarker(e.range);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    /**
     * @param e
     * @this {Editor}
     */
    this.$onRemoveRange = function(e) {
        this.removeSelectionMarkers(e.ranges);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    /**
     * @param e
     * @this {Editor}
     */
    this.$onMultiSelect = function(e) {
        if (this.inMultiSelectMode)
            return;
        this.inMultiSelectMode = true;

        this.setStyle("ace_multiselect");
        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
        this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);

        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    /**
     * @param e
     * @this {Editor}
     */
    this.$onSingleSelect = function(e) {
        if (this.session.multiSelect.inVirtualMode)
            return;
        this.inMultiSelectMode = false;

        this.unsetStyle("ace_multiselect");
        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);

        this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
        this._emit("changeSelection");
    };

    /**
     * @param e
     * @this {Editor}
     */
    this.$onMultiSelectExec = function(e) {
        var command = e.command;
        var editor = e.editor;
        if (!editor.multiSelect)
            return;
        if (!command.multiSelectAction) {
            var result = command.exec(editor, e.args || {});
            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
            editor.multiSelect.mergeOverlappingRanges();
        } else if (command.multiSelectAction == "forEach") {
            result = editor.forEachSelection(command, e.args);
        } else if (command.multiSelectAction == "forEachLine") {
            result = editor.forEachSelection(command, e.args, true);
        } else if (command.multiSelectAction == "single") {
            editor.exitMultiSelectMode();
            result = command.exec(editor, e.args || {});
        } else {
            result = command.multiSelectAction(editor, e.args || {});
        }
        return result;
    };

    /**
     * Executes a command for each selection range.
     * @param {any} cmd The command to execute
     * @param {String} [args] Any arguments for the command
     * @param {Object|true} [options]
     * @this {Editor}
     **/
    this.forEachSelection = function(cmd, args, options) {
        if (this.inVirtualSelectionMode)
            return;
        var keepOrder = options && options.keepOrder;
        var $byLines = options == true || options && options.$byLines;
        var session = this.session;
        var selection = this.selection;
        var rangeList = selection.rangeList;
        var ranges = (keepOrder ? selection : rangeList).ranges;
        var result;

        if (!ranges.length)
            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});

        var reg = selection._eventRegistry;
        selection._eventRegistry = {};
        var tmpSel = new Selection(session);
        this.inVirtualSelectionMode = true;
        for (var i = ranges.length; i--;) {
            if ($byLines) {
                while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
                    i--;
            }
            tmpSel.fromOrientedRange(ranges[i]);
            tmpSel.index = i;
            this.selection = session.selection = tmpSel;
            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
            if (!result && cmdResult !== undefined)
                result = cmdResult;
            tmpSel.toOrientedRange(ranges[i]);
        }
        tmpSel.detach();

        this.selection = session.selection = selection;
        this.inVirtualSelectionMode = false;
        selection._eventRegistry = reg;
        selection.mergeOverlappingRanges();
        if (selection.ranges[0])
            selection.fromOrientedRange(selection.ranges[0]);

        var anim = this.renderer.$scrollAnimation;
        this.onCursorChange();
        this.onSelectionChange();
        if (anim && anim.from == anim.to)
            this.renderer.animateScrolling(anim.from);

        return result;
    };

    /**
    * Removes all the selections except the last added one.
    * @this {Editor}
    **/
    this.exitMultiSelectMode = function() {
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
            return;
        this.multiSelect.toSingleRange();
    };

    /**
     * @this {Editor}
     * @return {string}
     */
    this.getSelectedText = function() {
        var text = "";
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var ranges = this.multiSelect.rangeList.ranges;
            var buf = [];
            for (var i = 0; i < ranges.length; i++) {
                buf.push(this.session.getTextRange(ranges[i]));
            }
            var nl = this.session.getDocument().getNewLineCharacter();
            text = buf.join(nl);
            if (text.length == (buf.length - 1) * nl.length)
                text = "";
        } else if (!this.selection.isEmpty()) {
            text = this.session.getTextRange(this.getSelectionRange());
        }
        return text;
    };

    /**
     * @param e
     * @param {Anchor} anchor
     * @this {Editor}
     */
    this.$checkMultiselectChange = function(e, anchor) {
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var range = this.multiSelect.ranges[0];
            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
                return;
            var pos = anchor == this.multiSelect.anchor
                ? range.cursor == range.start ? range.end : range.start
                : range.cursor;
            if (pos.row != anchor.row
                || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
                this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
            else
                this.multiSelect.mergeOverlappingRanges();
        }
    };

    /**
     * Finds and selects all the occurrences of `needle`.
     * @param {String} [needle] The text to find
     * @param {Partial<import("../ace-internal").Ace.SearchOptions>} [options] The search options
     * @param {Boolean} [additive] keeps
     *
     * @returns {Number} The cumulative count of all found matches
     * @this {Editor}
     **/
    this.findAll = function(needle, options, additive) {
        options = options || {};
        options.needle = needle || options.needle;
        if (options.needle == undefined) {
            var range = this.selection.isEmpty()
                ? this.selection.getWordRange()
                : this.selection.getRange();
            options.needle = this.session.getTextRange(range);
        }
        this.$search.set(options);

        var ranges = this.$search.findAll(this.session);
        if (!ranges.length)
            return 0;

        var selection = this.multiSelect;

        if (!additive)
            selection.toSingleRange(ranges[0]);

        for (var i = ranges.length; i--; )
            selection.addRange(ranges[i], true);

        // keep old selection as primary if possible
        if (range && selection.rangeList.rangeAtPoint(range.start))
            selection.addRange(range, true);

        return ranges.length;
    };

    /**
     * Adds a cursor above or below the active cursor.
     *
     * @param {Number} dir The direction of lines to select: -1 for up, 1 for down
     * @param {Boolean} [skip] If `true`, removes the active selection range
     *
     * @this {Editor}
     */
    this.selectMoreLines = function(dir, skip) {
        var range = this.selection.toOrientedRange();
        var isBackwards = range.cursor == range.end;

        var screenLead = this.session.documentToScreenPosition(range.cursor);
        if (this.selection.$desiredColumn)
            screenLead.column = this.selection.$desiredColumn;

        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);

        if (!range.isEmpty()) {
            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
        } else {
            var anchor = lead;
        }

        if (isBackwards) {
            /**@type {Range & {desiredColumn?: number}}*/
            var newRange = Range.fromPoints(lead, anchor);
            newRange.cursor = newRange.start;
        } else {
            /**@type {Range & {desiredColumn?: number}}*/
            var newRange = Range.fromPoints(anchor, lead);
            newRange.cursor = newRange.end;
        }

        newRange.desiredColumn = screenLead.column;
        if (!this.selection.inMultiSelectMode) {
            this.selection.addRange(range);
        } else {
            if (skip)
                var toRemove = range.cursor;
        }

        this.selection.addRange(newRange);
        if (toRemove)
            this.selection.substractPoint(toRemove);
    };

    /**
     * Transposes the selected ranges.
     * @param {Number} dir The direction to rotate selections
     * @this {Editor}
     **/
    this.transposeSelections = function(dir) {
        var session = this.session;
        var sel = session.multiSelect;
        var all = sel.ranges;

        for (var i = all.length; i--; ) {
            var range = all[i];
            if (range.isEmpty()) {
                let tmp = session.getWordRange(range.start.row, range.start.column);
                range.start.row = tmp.start.row;
                range.start.column = tmp.start.column;
                range.end.row = tmp.end.row;
                range.end.column = tmp.end.column;
            }
        }
        sel.mergeOverlappingRanges();

        var words = [];
        for (var i = all.length; i--; ) {
            var range = all[i];
            words.unshift(session.getTextRange(range));
        }

        if (dir < 0)
            words.unshift(words.pop());
        else
            words.push(words.shift());

        for (var i = all.length; i--; ) {
            var range = all[i];
            var tmp = range.clone();
            session.replace(range, words[i]);
            range.start.row = tmp.start.row;
            range.start.column = tmp.start.column;
        }
        sel.fromOrientedRange(sel.ranges[0]);
    };

    /**
     * Finds the next occurrence of text in an active selection and adds it to the selections.
     * @param {Number} dir The direction of lines to select: -1 for up, 1 for down
     * @param {Boolean} [skip] If `true`, removes the active selection range
     * @param {Boolean} [stopAtFirst]
     * @this {Editor}
     **/
    this.selectMore = function(dir, skip, stopAtFirst) {
        var session = this.session;
        var sel = session.multiSelect;

        var range = sel.toOrientedRange();
        if (range.isEmpty()) {
            range = session.getWordRange(range.start.row, range.start.column);
            range.cursor = dir == -1 ? range.start : range.end;
            this.multiSelect.addRange(range);
            if (stopAtFirst)
                return;
        }
        var needle = session.getTextRange(range);

        var newRange = find(session, needle, dir);
        if (newRange) {
            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
            this.session.unfold(newRange);
            this.multiSelect.addRange(newRange);
            this.renderer.scrollCursorIntoView(null, 0.5);
        }
        if (skip)
            this.multiSelect.substractPoint(range.cursor);
    };

    /**
     * Aligns the cursors or selected text.
     * @this {Editor}
     **/
    this.alignCursors = function() {
        var session = this.session;
        var sel = session.multiSelect;
        var ranges = sel.ranges;
        // filter out ranges on same row
        var row = -1;
        var sameRowRanges = ranges.filter(function(r) {
            if (r.cursor.row == row)
                return true;
            row = r.cursor.row;
        });

        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
            var range = this.selection.getRange();
            var fr = range.start.row, lr = range.end.row;
            var guessRange = fr == lr;
            if (guessRange) {
                var max = this.session.getLength();
                var line;
                do {
                    line = this.session.getLine(lr);
                } while (/[=:]/.test(line) && ++lr < max);
                do {
                    line = this.session.getLine(fr);
                } while (/[=:]/.test(line) && --fr > 0);

                if (fr < 0) fr = 0;
                if (lr >= max) lr = max - 1;
            }
            var lines = this.session.removeFullLines(fr, lr);
            lines = this.$reAlignText(lines, guessRange);
            this.session.insert({row: fr, column: 0}, lines.join("\n") + "\n");
            if (!guessRange) {
                range.start.column = 0;
                range.end.column = lines[lines.length - 1].length;
            }
            this.selection.setRange(range);
        } else {
            sameRowRanges.forEach(function(r) {
                sel.substractPoint(r.cursor);
            });

            var maxCol = 0;
            var minSpace = Infinity;
            var spaceOffsets = ranges.map(function(r) {
                var p = r.cursor;
                var line = session.getLine(p.row);
                var spaceOffset = line.substr(p.column).search(/\S/g);
                if (spaceOffset == -1)
                    spaceOffset = 0;

                if (p.column > maxCol)
                    maxCol = p.column;
                if (spaceOffset < minSpace)
                    minSpace = spaceOffset;
                return spaceOffset;
            });
            ranges.forEach(function(r, i) {
                var p = r.cursor;
                var l = maxCol - p.column;
                var d = spaceOffsets[i] - minSpace;
                if (l > d)
                    session.insert(p, lang.stringRepeat(" ", l - d));
                else
                    session.remove(new Range(p.row, p.column, p.row, p.column - l + d));

                r.start.column = r.end.column = maxCol;
                r.start.row = r.end.row = p.row;
                r.cursor = r.end;
            });
            sel.fromOrientedRange(ranges[0]);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
        }
    };

    /**
     * @param {string[]} lines
     * @param {boolean} [forceLeft]
     * @return {*}
     * @this {Editor}
     */
    this.$reAlignText = function(lines, forceLeft) {
        var isLeftAligned = true, isRightAligned = true;
        var startW, textW, endW;

        return lines.map(function(line) {
            var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
            if (!m)
                return [line];

            if (startW == null) {
                startW = m[1].length;
                textW = m[2].length;
                endW = m[3].length;
                return m;
            }

            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
                isRightAligned = false;
            if (startW != m[1].length)
                isLeftAligned = false;

            if (startW > m[1].length)
                startW = m[1].length;
            if (textW < m[2].length)
                textW = m[2].length;
            if (endW > m[3].length)
                endW = m[3].length;

            return m;
        }).map(forceLeft ? alignLeft :
            isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);

        function spaces(n) {
            return lang.stringRepeat(" ", n);
        }

        function alignLeft(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2]
                + spaces(textW - m[2].length + endW)
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
        function alignRight(m) {
            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]
                + spaces(endW)
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
        function unAlign(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2]
                + spaces(endW)
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
    };
}).call(Editor.prototype);


/** @param {Point} p1  @param {Point} p2 */
function isSamePoint(p1, p2) {
    return p1.row == p2.row && p1.column == p2.column;
}


/**
 * patch
 * adds multicursor support to a session
 * @this {Editor}
 * @type {(e: any) => void}
 */
exports.onSessionChange = function(e) {
    var session = e.session;
    if (session && !session.multiSelect) {
        session.$selectionMarkers = [];
        session.selection.$initRangeList();
        session.multiSelect = session.selection;
    }
    this.multiSelect = session && session.multiSelect;

    var oldSession = e.oldSession;
    if (oldSession) {
        oldSession.multiSelect.off("addRange", this.$onAddRange);
        oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
        oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
        oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
        oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
        oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
    }

    if (session) {
        session.multiSelect.on("addRange", this.$onAddRange);
        session.multiSelect.on("removeRange", this.$onRemoveRange);
        session.multiSelect.on("multiSelect", this.$onMultiSelect);
        session.multiSelect.on("singleSelect", this.$onSingleSelect);
        session.multiSelect.lead.on("change", this.$checkMultiselectChange);
        session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
    }

    if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
        if (session.selection.inMultiSelectMode)
            this.$onMultiSelect();
        else
            this.$onSingleSelect();
    }
};

// MultiSelect(editor)
// adds multiple selection support to the editor
// (note: should be called only once for each editor instance)
/**
 * @param {Editor} editor
 */
function MultiSelect(editor) {
    if (editor.$multiselectOnSessionChange)
        return;
    editor.$onAddRange = editor.$onAddRange.bind(editor);
    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
    editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);

    editor.$multiselectOnSessionChange(editor);
    editor.on("changeSession", editor.$multiselectOnSessionChange);

    editor.on("mousedown", onMouseDown);
    editor.commands.addCommands(commands.defaultCommands);

    addAltCursorListeners(editor);
}

/**
 * @param {Editor} editor
 */
function addAltCursorListeners(editor){
    if (!editor.textInput) return;
    var el = editor.textInput.getElement();
    var altCursor = false;
    event.addListener(el, "keydown", function(e) {
        var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
        if (editor.$blockSelectEnabled && altDown) {
            if (!altCursor) {
                editor.renderer.setMouseCursor("crosshair");
                altCursor = true;
            }
        } else if (altCursor) {
            reset();
        }
    }, editor);

    event.addListener(el, "keyup", reset, editor);
    event.addListener(el, "blur", reset, editor);
    function reset(e) {
        if (altCursor) {
            editor.renderer.setMouseCursor("");
            altCursor = false;
            // TODO disable menu popping up
            // e && e.preventDefault()
        }
    }
}

exports.MultiSelect = MultiSelect;


(__webpack_require__(76321).defineOptions)(Editor.prototype, "editor", {
    enableMultiselect: {
        /**
         * @param {boolean} val
         * @this {Editor}
         */
        set: function(val) {
            MultiSelect(this);
            if (val) {
                this.on("mousedown", onMouseDown);
            } else {
                this.off("mousedown", onMouseDown);
            }
        },
        value: true
    },
    enableBlockSelect: {
        set: function(val) {
            this.$blockSelectEnabled = val;
        },
        value: true
    }
});


/***/ }),

/***/ 49432:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("../../ace-internal").Ace.SyntaxMode} SyntaxMode
 */

var config = __webpack_require__(76321);

var Tokenizer = (__webpack_require__(32934).Tokenizer);

var TextHighlightRules = (__webpack_require__(16387)/* .TextHighlightRules */ .r);
var CstyleBehaviour = (__webpack_require__(32589)/* .CstyleBehaviour */ ._);
var unicode = __webpack_require__(6672);
var lang = __webpack_require__(39955);
var TokenIterator = (__webpack_require__(99339).TokenIterator);
var Range = (__webpack_require__(91902)/* .Range */ .Q);

var Mode;
Mode = function() {
    this.HighlightRules = TextHighlightRules;
};

(function() {
    this.$defaultBehaviour = new CstyleBehaviour();

    this.tokenRe = new RegExp("^[" + unicode.wordChars + "\\$_]+", "g");

    this.nonTokenRe = new RegExp("^(?:[^" + unicode.wordChars + "\\$_]|\\s])+", "g");

    /**
     * @this {SyntaxMode}
     */
    this.getTokenizer = function() {
        if (!this.$tokenizer) {
            this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
        }
        return this.$tokenizer;
    };

    this.lineCommentStart = "";
    this.blockComment = "";

    /**
     * @this {SyntaxMode}
     */
    this.toggleCommentLines = function(state, session, startRow, endRow) {
        var doc = session.doc;

        var ignoreBlankLines = true;
        var shouldRemove = true;
        var minIndent = Infinity;
        var tabSize = session.getTabSize();
        var insertAtTabStop = false;

        if (!this.lineCommentStart) {
            if (!this.blockComment)
                return false;
            /**@type {any}*/
            var lineCommentStart = this.blockComment.start;
            var lineCommentEnd = this.blockComment.end;
            /**@type {any}*/
            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");

            var comment = function(line, i) {
                if (testRemove(line, i))
                    return;
                if (!ignoreBlankLines || /\S/.test(line)) {
                    doc.insertInLine({row: i, column: line.length}, lineCommentEnd);
                    doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
                }
            };

            var uncomment = function(line, i) {
                var m;
                if (m = line.match(regexpEnd))
                    doc.removeInLine(i, line.length - m[0].length, line.length);
                if (m = line.match(regexpStart))
                    doc.removeInLine(i, m[1].length, m[0].length);
            };

            /**@type {any}*/
            var testRemove = function(line, row) {
                if (regexpStart.test(line))
                    return true;
                var tokens = session.getTokens(row);
                for (var i = 0; i < tokens.length; i++) {
                    if (tokens[i].type === "comment")
                        return true;
                }
            };
        } else {
            if (Array.isArray(this.lineCommentStart)) {
                /**@type {any}*/
                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
                /**@type {any}*/
                var lineCommentStart = this.lineCommentStart[0];
            } else {
                var regexpStart = lang.escapeRegExp(this.lineCommentStart);
                /**@type {any}*/
                var lineCommentStart = this.lineCommentStart;
            }
            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");

            insertAtTabStop = session.getUseSoftTabs();

            var uncomment = function(line, i) {
                var m = line.match(regexpStart);
                if (!m) return;
                var start = m[1].length, end = m[0].length;
                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
                    end--;
                doc.removeInLine(i, start, end);
            };
            var commentWithSpace = lineCommentStart + " ";
            var comment = function(line, i) {
                if (!ignoreBlankLines || /\S/.test(line)) {
                    if (shouldInsertSpace(line, minIndent, minIndent))
                        doc.insertInLine({row: i, column: minIndent}, commentWithSpace);
                    else
                        doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
                }
            };
            /**@type {any}*/
            var testRemove = function(line, i) {
                return regexpStart.test(line);
            };

            var shouldInsertSpace = function(line, before, after) {
                var spaces = 0;
                while (before-- && line.charAt(before) == " ")
                    spaces++;
                if (spaces % tabSize != 0)
                    return false;
                var spaces = 0;
                while (line.charAt(after++) == " ")
                    spaces++;
                if (tabSize > 2)
                    return spaces % tabSize != tabSize - 1;
                else
                    return spaces % tabSize == 0;
            };
        }

        function iter(fun) {
            for (var i = startRow; i <= endRow; i++)
                fun(doc.getLine(i), i);
        }


        var minEmptyLength = Infinity;
        iter(function(line, i) {
            var indent = line.search(/\S/);
            if (indent !== -1) {
                if (indent < minIndent)
                    minIndent = indent;
                if (shouldRemove && !testRemove(line, i))
                    shouldRemove = false;
            } else if (minEmptyLength > line.length) {
                minEmptyLength = line.length;
            }
        });

        if (minIndent == Infinity) {
            minIndent = minEmptyLength;
            ignoreBlankLines = false;
            shouldRemove = false;
        }

        if (insertAtTabStop && minIndent % tabSize != 0)
            minIndent = Math.floor(minIndent / tabSize) * tabSize;

        iter(shouldRemove ? uncomment : comment);
    };

    /**
     * @this {SyntaxMode}
     */
    this.toggleBlockComment = function(state, session, range, cursor) {
        var comment = this.blockComment;
        if (!comment)
            return;
        if (!comment.start && comment[0])
            comment = comment[0];

        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        var token = iterator.getCurrentToken();

        var sel = session.selection;
        var initialRange = session.selection.toOrientedRange();
        var startRow, colDiff;

        if (token && /comment/.test(token.type)) {
            var startRange, endRange;
            while (token && /comment/.test(token.type)) {
                var i = token.value.indexOf(comment.start);
                if (i != -1) {
                    var row = iterator.getCurrentTokenRow();
                    var column = iterator.getCurrentTokenColumn() + i;
                    startRange = new Range(row, column, row, column + comment.start.length);
                    break;
                }
                token = iterator.stepBackward();
            }

            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            while (token && /comment/.test(token.type)) {
                var i = token.value.indexOf(comment.end);
                if (i != -1) {
                    var row = iterator.getCurrentTokenRow();
                    var column = iterator.getCurrentTokenColumn() + i;
                    endRange = new Range(row, column, row, column + comment.end.length);
                    break;
                }
                token = iterator.stepForward();
            }
            if (endRange)
                session.remove(endRange);
            if (startRange) {
                session.remove(startRange);
                startRow = startRange.start.row;
                colDiff = -comment.start.length;
            }
        } else {
            colDiff = comment.start.length;
            startRow = range.start.row;
            session.insert(range.end, comment.end);
            session.insert(range.start, comment.start);
        }
        // todo: selection should have ended up in the right place automatically!
        if (initialRange.start.row == startRow)
            initialRange.start.column += colDiff;
        if (initialRange.end.row == startRow)
            initialRange.end.column += colDiff;
        session.selection.fromOrientedRange(initialRange);
    };

    this.getNextLineIndent = function(state, line, tab) {
        return this.$getIndent(line);
    };

    this.checkOutdent = function(state, line, input) {
        return false;
    };

    this.autoOutdent = function(state, doc, row) {
    };

    this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
    };

    this.createWorker = function(session) {
        return null;
    };

    this.createModeDelegates = function (mapping) {
        this.$embeds = [];
        this.$modes = {};
        for (let i in mapping) {
            if (mapping[i]) {
                var Mode = mapping[i];
                var id = Mode.prototype.$id;
                var mode = config.$modes[id];
                if (!mode)
                    config.$modes[id] = mode = new Mode();
                if (!config.$modes[i])
                    config.$modes[i] = mode;
                this.$embeds.push(i);
                this.$modes[i] = mode;
            }
        }

        var delegations = ["toggleBlockComment", "toggleCommentLines", "getNextLineIndent",
            "checkOutdent", "autoOutdent", "transformAction", "getCompletions"];

        for (let i = 0; i < delegations.length; i++) {
            (function(scope) {
              var functionName = delegations[i];
              var defaultHandler = scope[functionName];
              scope[delegations[i]] =
                  /** @this {import("../../ace-internal").Ace.SyntaxMode} */
                  function () {
                      return this.$delegator(functionName, arguments, defaultHandler);
                  };
            }(this));
        }
    };

    /**
     * @this {SyntaxMode}
     */
    this.$delegator = function(method, args, defaultHandler) {
        var state = args[0] || "start";
        if (typeof state != "string") {
            if (Array.isArray(state[2])) {
                var language = state[2][state[2].length - 1];
                var mode = this.$modes[language];
                if (mode)
                    return mode[method].apply(mode, [state[1]].concat([].slice.call(args, 1)));
            }
            state = state[0] || "start";
        }

        for (var i = 0; i < this.$embeds.length; i++) {
            if (!this.$modes[this.$embeds[i]]) continue;

            var split = state.split(this.$embeds[i]);
            if (!split[0] && split[1]) {
                args[0] = split[1];
                var mode = this.$modes[this.$embeds[i]];
                return mode[method].apply(mode, args);
            }
        }
        var ret = defaultHandler.apply(this, args);
        return defaultHandler ? ret : undefined;
    };

    /**
     * @this {SyntaxMode}
     */
    this.transformAction = function(state, action, editor, session, param) {
        if (this.$behaviour) {
            var behaviours = this.$behaviour.getBehaviours();
            for (var key in behaviours) {
                if (behaviours[key][action]) {
                    var ret = behaviours[key][action].apply(this, arguments);
                    if (ret) {
                        return ret;
                    }
                }
            }
        }
    };

    /**
     * @this {SyntaxMode}
     */
    this.getKeywords = function(append) {
        // this is for autocompletion to pick up regexp'ed keywords
        if (!this.completionKeywords) {
            var rules = this.$tokenizer["rules"];
            var completionKeywords = [];
            for (var rule in rules) {
                var ruleItr = rules[rule];
                for (var r = 0, l = ruleItr.length; r < l; r++) {
                    if (typeof ruleItr[r].token === "string") {
                        if (/keyword|support|storage/.test(ruleItr[r].token))
                            completionKeywords.push(ruleItr[r].regex);
                    }
                    else if (typeof ruleItr[r].token === "object") {
                        for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {
                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                                // drop surrounding parens
                                var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                                completionKeywords.push(rule.substr(1, rule.length - 2));
                            }
                        }
                    }
                }
            }
            this.completionKeywords = completionKeywords;
        }
        // this is for highlighting embed rules, like HAML/Ruby or Obj-C/C
        if (!append)
            return this.$keywordList;
        return completionKeywords.concat(this.$keywordList || []);
    };

    /**
     * @this {SyntaxMode}
     */
    this.$createKeywordList = function() {
        if (!this.$highlightRules)
            this.getTokenizer();
        return this.$keywordList = this.$highlightRules.$keywordList || [];
    };

    /**
     * @this {SyntaxMode}
     */
    this.getCompletions = function(state, session, pos, prefix) {
        var keywords = this.$keywordList || this.$createKeywordList();
        return keywords.map(function(word) {
            return {
                name: word,
                value: word,
                score: 0,
                meta: "keyword"
            };
        });
    };

    this.$id = "ace/mode/text";
}).call(Mode.prototype);

exports.Mode = Mode;


/***/ }),

/***/ 50311:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


var oop = __webpack_require__(2645);
var dom = __webpack_require__(71435);
var event = __webpack_require__(19631);
var EventEmitter = (__webpack_require__(87366).EventEmitter);

dom.importCssString(`.ace_editor>.ace_sb-v div, .ace_editor>.ace_sb-h div{
  position: absolute;
  background: rgba(128, 128, 128, 0.6);
  -moz-box-sizing: border-box;
  box-sizing: border-box;
  border: 1px solid #bbb;
  border-radius: 2px;
  z-index: 8;
}
.ace_editor>.ace_sb-v, .ace_editor>.ace_sb-h {
  position: absolute;
  z-index: 6;
  background: none;
  overflow: hidden!important;
}
.ace_editor>.ace_sb-v {
  z-index: 6;
  right: 0;
  top: 0;
  width: 12px;
}
.ace_editor>.ace_sb-v div {
  z-index: 8;
  right: 0;
  width: 100%;
}
.ace_editor>.ace_sb-h {
  bottom: 0;
  left: 0;
  height: 12px;
}
.ace_editor>.ace_sb-h div {
  bottom: 0;
  height: 100%;
}
.ace_editor>.ace_sb_grabbed {
  z-index: 8;
  background: #000;
}`, "ace_scrollbar.css", false);

/**
 * An abstract class representing a native scrollbar control.
 **/
class ScrollBar {
    /**
     * Creates a new `ScrollBar`. `parent` is the owner of the scroll bar.
     * @param {Element} parent A DOM element
     * @param {string} classSuffix
     **/
    constructor(parent, classSuffix) {
        this.element = dom.createElement("div");
        this.element.className = "ace_sb" + classSuffix;
        this.inner = dom.createElement("div");
        this.inner.className = "";
        this.element.appendChild(this.inner);
        this.VScrollWidth = 12;
        this.HScrollHeight = 12;

        parent.appendChild(this.element);
        this.setVisible(false);
        this.skipEvent = false;

        event.addMultiMouseDownListener(this.element, [500, 300, 300], this, "onMouseDown");
    }

    setVisible(isVisible) {
        this.element.style.display = isVisible ? "" : "none";
        this.isVisible = isVisible;
        this.coeff = 1;
    }
}

oop.implement(ScrollBar.prototype, EventEmitter);
/**
 * Represents a vertical scroll bar.
 * @class VScrollBar
 **/

/**
 * Creates a new `VScrollBar`. `parent` is the owner of the scroll bar.
 * @param {Element} parent A DOM element
 * @param {Object} renderer An editor renderer
 *
 * @constructor
 **/
class VScrollBar extends ScrollBar {

    constructor(parent, renderer) {
        super(parent, '-v');
        this.scrollTop = 0;
        this.scrollHeight = 0;
        this.parent = parent;
        this.width = this.VScrollWidth;
        this.renderer = renderer;
        this.inner.style.width = this.element.style.width = (this.width || 15) + "px";
        this.$minWidth = 0;
    }

    /**
     * Emitted when the scroll thumb dragged or scrollbar canvas clicked.
     * @internal
     **/
    onMouseDown(eType, e) {
        if (eType !== "mousedown") return;

        if (event.getButton(e) !== 0 || e.detail === 2) {
            return;
        }

        if (e.target === this.inner) {
            var self = this;
            var mousePageY = e.clientY;

            var onMouseMove = function (e) {
                mousePageY = e.clientY;
            };

            var onMouseUp = function () {
                clearInterval(timerId);
            };
            var startY = e.clientY;
            var startTop = this.thumbTop;

            var onScrollInterval = function () {
                if (mousePageY === undefined) return;
                var scrollTop = self.scrollTopFromThumbTop(startTop + mousePageY - startY);
                if (scrollTop === self.scrollTop) return;
                self._emit("scroll", {data: scrollTop});
            };

            event.capture(this.inner, onMouseMove, onMouseUp);
            var timerId = setInterval(onScrollInterval, 20);
            return event.preventDefault(e);
        }
        var top = e.clientY - this.element.getBoundingClientRect().top - this.thumbHeight / 2;
        this._emit("scroll", {data: this.scrollTopFromThumbTop(top)});
        return event.preventDefault(e);
    }

    getHeight() {
        return this.height;
    }

    /**
     * Returns new top for scroll thumb
     * @param {Number}thumbTop
     * @returns {Number}
     **/
    scrollTopFromThumbTop(thumbTop) {
        var scrollTop = thumbTop * (this.pageHeight - this.viewHeight) / (this.slideHeight - this.thumbHeight);
        scrollTop = scrollTop >> 0;
        if (scrollTop < 0) {
            scrollTop = 0;
        }
        else if (scrollTop > this.pageHeight - this.viewHeight) {
            scrollTop = this.pageHeight - this.viewHeight;
        }
        return scrollTop;
    }

    /**
     * Returns the width of the scroll bar.
     * @returns {Number}
     **/
    getWidth() {
        return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
    }

    /**
     * Sets the height of the scroll bar, in pixels.
     * @param {Number} height The new height
     **/
    setHeight(height) {
        this.height = Math.max(0, height);
        this.slideHeight = this.height;
        this.viewHeight = this.height;

        this.setScrollHeight(this.pageHeight, true);
    }

    /**
     * Sets the inner and scroll height of the scroll bar, in pixels.
     * @param {Number} height The new inner height
     *
     * @param {boolean} force Forcely update height
     **/
    setScrollHeight(height, force) {
        if (this.pageHeight === height && !force) return;
        this.pageHeight = height;
        this.thumbHeight = this.slideHeight * this.viewHeight / this.pageHeight;

        if (this.thumbHeight > this.slideHeight) this.thumbHeight = this.slideHeight;
        if (this.thumbHeight < 15) this.thumbHeight = 15;

        this.inner.style.height = this.thumbHeight + "px";

        if (this.scrollTop > (this.pageHeight - this.viewHeight)) {
            this.scrollTop = (this.pageHeight - this.viewHeight);
            if (this.scrollTop < 0) this.scrollTop = 0;
            this._emit("scroll", {data: this.scrollTop});
        }
    }

    /**
     * Sets the scroll top of the scroll bar.
     * @param {Number} scrollTop The new scroll top
     **/
    setScrollTop(scrollTop) {
        this.scrollTop = scrollTop;
        if (scrollTop < 0) scrollTop = 0;
        this.thumbTop = scrollTop * (this.slideHeight - this.thumbHeight) / (this.pageHeight - this.viewHeight);
        this.inner.style.top = this.thumbTop + "px";
    }
}

VScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;

/**
 * Represents a horizontal scroll bar.
 **/
class HScrollBar extends ScrollBar {
    /**
     * Creates a new `HScrollBar`. `parent` is the owner of the scroll bar.
     * @param {Element} parent A DOM element
     * @param {Object} renderer An editor renderer
     **/
    constructor(parent, renderer) {
        super(parent, '-h');
        this.scrollLeft = 0;
        this.scrollWidth = 0;
        this.height = this.HScrollHeight;
        this.inner.style.height = this.element.style.height = (this.height || 12) + "px";
        this.renderer = renderer;
    }

    /**
     * Emitted when the scroll thumb dragged or scrollbar canvas clicked.
     * @internal
     **/
    onMouseDown(eType, e) {
        if (eType !== "mousedown") return;

        if (event.getButton(e) !== 0 || e.detail === 2) {
            return;
        }


        if (e.target === this.inner) {
            var self = this;
            var mousePageX = e.clientX;

            var onMouseMove = function (e) {
                mousePageX = e.clientX;
            };

            var onMouseUp = function () {
                clearInterval(timerId);
            };
            var startX = e.clientX;
            var startLeft = this.thumbLeft;

            var onScrollInterval = function () {
                if (mousePageX === undefined) return;
                var scrollLeft = self.scrollLeftFromThumbLeft(startLeft + mousePageX - startX);
                if (scrollLeft === self.scrollLeft) return;
                self._emit("scroll", {data: scrollLeft});
            };

            event.capture(this.inner, onMouseMove, onMouseUp);
            var timerId = setInterval(onScrollInterval, 20);
            return event.preventDefault(e);
        }

        var left = e.clientX - this.element.getBoundingClientRect().left - this.thumbWidth / 2;
        this._emit("scroll", {data: this.scrollLeftFromThumbLeft(left)});
        return event.preventDefault(e);
    }

    /**
     * Returns the height of the scroll bar.
     * @returns {Number}
     **/
    getHeight() {
        return this.isVisible ? this.height : 0;
    }

    /**
     * Returns new left for scroll thumb
     * @param {Number} thumbLeft
     * @returns {Number}
     **/
    scrollLeftFromThumbLeft(thumbLeft) {
        var scrollLeft = thumbLeft * (this.pageWidth - this.viewWidth) / (this.slideWidth - this.thumbWidth);
        scrollLeft = scrollLeft >> 0;
        if (scrollLeft < 0) {
            scrollLeft = 0;
        }
        else if (scrollLeft > this.pageWidth - this.viewWidth) {
            scrollLeft = this.pageWidth - this.viewWidth;
        }
        return scrollLeft;
    }

    /**
     * Sets the width of the scroll bar, in pixels.
     * @param {Number} width The new width
     **/
    setWidth(width) {
        this.width = Math.max(0, width);
        this.element.style.width = this.width + "px";
        this.slideWidth = this.width;
        this.viewWidth = this.width;

        this.setScrollWidth(this.pageWidth, true);
    }

    /**
     * Sets the inner and scroll width of the scroll bar, in pixels.
     * @param {Number} width The new inner width
     * @param {boolean} force Forcely update width
     **/
     setScrollWidth(width, force) {
        if (this.pageWidth === width && !force) return;
        this.pageWidth = width;
        this.thumbWidth = this.slideWidth * this.viewWidth / this.pageWidth;

        if (this.thumbWidth > this.slideWidth) this.thumbWidth = this.slideWidth;
        if (this.thumbWidth < 15) this.thumbWidth = 15;
        this.inner.style.width = this.thumbWidth + "px";

        if (this.scrollLeft > (this.pageWidth - this.viewWidth)) {
            this.scrollLeft = (this.pageWidth - this.viewWidth);
            if (this.scrollLeft < 0) this.scrollLeft = 0;
            this._emit("scroll", {data: this.scrollLeft});
        }
    }


    /**
     * Sets the scroll left of the scroll bar.
     * @param {Number} scrollLeft The new scroll left
     **/
    setScrollLeft(scrollLeft) {
        this.scrollLeft = scrollLeft;
        if (scrollLeft < 0) scrollLeft = 0;
        this.thumbLeft = scrollLeft * (this.slideWidth - this.thumbWidth) / (this.pageWidth - this.viewWidth);
        this.inner.style.left = (this.thumbLeft) + "px";
    }

}

HScrollBar.prototype.setInnerWidth = HScrollBar.prototype.setScrollWidth;

__webpack_unused_export__ = VScrollBar; // backward compatibility
__webpack_unused_export__ = VScrollBar; // backward compatibility
__webpack_unused_export__ = HScrollBar; // backward compatibility

exports.vB = VScrollBar;
exports.V1 = HScrollBar;


/***/ }),

/***/ 50643:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("../edit_session").EditSession} EditSession
 */
var dom = __webpack_require__(71435);


class Cursor {
    /**
     * @param {HTMLElement} parentEl
     */
    constructor(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_cursor-layer";
        parentEl.appendChild(this.element);

        this.isVisible = false;
        this.isBlinking = true;
        this.blinkInterval = 1000;
        this.smoothBlinking = false;

        this.cursors = [];
        this.cursor = this.addCursor();
        dom.addCssClass(this.element, "ace_hidden-cursors");
        this.$updateCursors = this.$updateOpacity.bind(this);
    }

    /**
     * @param {boolean} [val]
     */
    $updateOpacity(val) {
        var cursors = this.cursors;
        for (var i = cursors.length; i--; )
            dom.setStyle(cursors[i].style, "opacity", val ? "" : "0");
    }

    $startCssAnimation() {
        var cursors = this.cursors;
        for (var i = cursors.length; i--; )
            cursors[i].style.animationDuration = this.blinkInterval + "ms";

        this.$isAnimating = true;
        setTimeout(function() {
            if (this.$isAnimating) {
                dom.addCssClass(this.element, "ace_animate-blinking");
            }
        }.bind(this));
    }
    
    $stopCssAnimation() {
        this.$isAnimating = false;
        dom.removeCssClass(this.element, "ace_animate-blinking");
    }

    /**
     * @param {number} padding
     */
    setPadding(padding) {
        this.$padding = padding;
    }

    /**
     * @param {EditSession} session
     */
    setSession(session) {
        this.session = session;
    }

    /**
     * @param {boolean} blinking
     */
    setBlinking(blinking) {
        if (blinking != this.isBlinking) {
            this.isBlinking = blinking;
            this.restartTimer();
        }
    }

    /**
     * @param {number} blinkInterval
     */
    setBlinkInterval(blinkInterval) {
        if (blinkInterval != this.blinkInterval) {
            this.blinkInterval = blinkInterval;
            this.restartTimer();
        }
    }

    /**
     * @param {boolean} smoothBlinking
     */
    setSmoothBlinking(smoothBlinking) {
        if (smoothBlinking != this.smoothBlinking) {
            this.smoothBlinking = smoothBlinking;
            dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
            this.$updateCursors(true);
            this.restartTimer();
        }
    }

    addCursor() {
        var el = dom.createElement("div");
        el.className = "ace_cursor";
        this.element.appendChild(el);
        this.cursors.push(el);
        return el;
    }

    removeCursor() {
        if (this.cursors.length > 1) {
            var el = this.cursors.pop();
            el.parentNode.removeChild(el);
            return el;
        }
    }

    hideCursor() {
        this.isVisible = false;
        dom.addCssClass(this.element, "ace_hidden-cursors");
        this.restartTimer();
    }

    showCursor() {
        this.isVisible = true;
        dom.removeCssClass(this.element, "ace_hidden-cursors");
        this.restartTimer();
    }

    restartTimer() {
        var update = this.$updateCursors;
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
        this.$stopCssAnimation();

        if (this.smoothBlinking) {
            this.$isSmoothBlinking = false;
            dom.removeCssClass(this.element, "ace_smooth-blinking");
        }
        
        update(true);

        if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {
            this.$stopCssAnimation();
            return;
        }

        if (this.smoothBlinking) {
            this.$isSmoothBlinking = true;
            setTimeout(function() {
                if (this.$isSmoothBlinking) {
                    dom.addCssClass(this.element, "ace_smooth-blinking");
                }
            }.bind(this));
        }
        
        if (dom.HAS_CSS_ANIMATION) {
            this.$startCssAnimation();
        } else {
            var blink = /**@this{Cursor}*/function(){
                /**@type{ReturnType<typeof setTimeout>}*/
                this.timeoutId = setTimeout(function() {
                    update(false);
                }, 0.6 * this.blinkInterval);
            }.bind(this);

            /**@type{ReturnType<typeof setInterval>}*/
            this.intervalId = setInterval(function() {
                update(true);
                blink();
            }, this.blinkInterval);
            blink();
        }
    }

    /**
     * @param {import("../../ace-internal").Ace.Point} [position]
     * @param {boolean} [onScreen]
     */
    getPixelPosition(position, onScreen) {
        if (!this.config || !this.session)
            return {left : 0, top : 0};

        if (!position)
            position = this.session.selection.getCursor();
        var pos = this.session.documentToScreenPosition(position);
        var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row)
            ? this.session.$bidiHandler.getPosLeft(pos.column)
            : pos.column * this.config.characterWidth);

        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *
            this.config.lineHeight;

        return {left : cursorLeft, top : cursorTop};
    }

    isCursorInView(pixelPos, config) {
        return pixelPos.top >= 0 && pixelPos.top < config.maxHeight;
    }

    update(config) {
        this.config = config;

        var selections = this.session.$selectionMarkers;
        var i = 0, cursorIndex = 0;

        if (selections === undefined || selections.length === 0){
            selections = [{cursor: null}];
        }

        for (var i = 0, n = selections.length; i < n; i++) {
            var pixelPos = this.getPixelPosition(selections[i].cursor, true);
            if ((pixelPos.top > config.height + config.offset ||
                 pixelPos.top < 0) && i > 1) {
                continue;
            }

            var element = this.cursors[cursorIndex++] || this.addCursor();
            var style = element.style;
            
            if (!this.drawCursor) {
                if (!this.isCursorInView(pixelPos, config)) {
                    dom.setStyle(style, "display", "none");
                } else {
                    dom.setStyle(style, "display", "block");
                    dom.translate(element, pixelPos.left, pixelPos.top);
                    dom.setStyle(style, "width", Math.round(config.characterWidth) + "px");
                    dom.setStyle(style, "height", config.lineHeight + "px");
                }
            } else {
                this.drawCursor(element, pixelPos, config, selections[i], this.session);
            }
        }
        while (this.cursors.length > cursorIndex)
            this.removeCursor();

        var overwrite = this.session.getOverwrite();
        this.$setOverwrite(overwrite);

        // cache for textarea and gutter highlight
        this.$pixelPos = pixelPos;
        this.restartTimer();
    }

    /**
     * @param {boolean} overwrite
     */
    $setOverwrite(overwrite) {
        if (overwrite != this.overwrite) {
            this.overwrite = overwrite;
            if (overwrite)
                dom.addCssClass(this.element, "ace_overwrite-cursors");
            else
                dom.removeCssClass(this.element, "ace_overwrite-cursors");
        }
    }

    destroy() {
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
    }

}

Cursor.prototype.$padding = 0;
Cursor.prototype.drawCursor = null;


exports.b = Cursor;


/***/ }),

/***/ 50973:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var ArabicAlefBetIntervalsBegine = (/* unused pure expression or super */ null && (['\u0621', '\u0641']));
var ArabicAlefBetIntervalsEnd = (/* unused pure expression or super */ null && (['\u063A', '\u064a']));
var dir = 0, hiLevel = 0;
var lastArabic = false, hasUBAT_AL = false,  hasUBAT_B = false,  hasUBAT_S = false, hasBlockSep = false, hasSegSep = false;

var impTab_LTR = [
				/*		L,		R,		EN,		AN,		N,		IL,		Cond */
/* 0 LTR text	*/	[	0,		3,		0,		1,		0,		0,		0	],
/* 1 LTR+AN		*/	[	0,		3,		0,		1,		2,		2,		0	],
/* 2 LTR+AN+N	*/	[	0,		3,		0,		0x11,		2,		0,		1	],
/* 3 RTL text	*/	[	0,		3,		5,		5,		4,		1,		0	],
/* 4 RTL cont	*/	[	0,		3,		0x15,		0x15,		4,		0,		1	],
/* 5 RTL+EN/AN	*/	[	0,		3,		5,		5,		4,		2,		0	]
];

var impTab_RTL = [
		/*		L,		R,		EN,		AN,		N,		IL,		Cond */
/* 0 RTL text	*/	[	2,		0,		1,		1,		0,		1,		0	],
/* 1 RTL+EN/AN	*/	[	2,		0,		1,		1,		0,		2,		0	],
/* 2 LTR text	*/	[	2,		0,		2,		1,		3,		2,		0	],
/* 3 LTR+cont	*/	[	2,		0,		2,		0x21,		3,		1,		1	]
];

var LTR = 0, RTL = 1;

var L = 0; /* left to right */
var R = 1; /* right to left */
var EN = 2; /* European digit */
var AN = 3; /* Arabic-Indic digit */
var ON = 4; /* neutral */
var B = 5; /* block separator */
var S = 6; /* segment separator */
var AL = 7; /* Arabic Letter */
var WS = 8; /* white space */
var CS = 9; /* common digit separator */
var ES = 10; /* European digit separator */
var ET = 11; /* European digit terminator */
var NSM = 12; /* Non Spacing Mark */
var LRE = 13; /* LRE */
var RLE = 14; /* RLE */
var PDF = 15; /* PDF */
var LRO = 16; /* LRO */
var RLO = 17; /* RLO */
var BN = 18; /* Boundary Neutral */

var UnicodeTBL00 = [
BN,BN,BN,BN,BN,BN,BN,BN,BN,S,B,S,WS,B,BN,BN,
BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,B,B,B,S,
WS,ON,ON,ET,ET,ET,ON,ON,ON,ON,ON,ES,CS,ES,CS,CS,
EN,EN,EN,EN,EN,EN,EN,EN,EN,EN,CS,ON,ON,ON,ON,ON,
ON,L,L,L,L,L,L,L,L,L,L,L,L,L,L,L,
L,L,L,L,L,L,L,L,L,L,L,ON,ON,ON,ON,ON,
ON,L,L,L,L,L,L,L,L,L,L,L,L,L,L,L,
L,L,L,L,L,L,L,L,L,L,L,ON,ON,ON,ON,BN,
BN,BN,BN,BN,BN,B,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,
BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,
CS,ON,ET,ET,ET,ET,ON,ON,ON,ON,L,ON,ON,BN,ON,ON,
ET,ET,EN,EN,ON,L,ON,ON,ON,EN,L,ON,ON,ON,ON,ON
];

var UnicodeTBL20 = [
WS,WS,WS,WS,WS,WS,WS,WS,WS,WS,WS,BN,BN,BN,L,R	,
ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,
ON,ON,ON,ON,ON,ON,ON,ON,WS,B,LRE,RLE,PDF,LRO,RLO,CS,
ET,ET,ET,ET,ET,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,
ON,ON,ON,ON,CS,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,
ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,WS
];

function _computeLevels(chars, levels, len, charTypes) {
	var impTab = dir ? impTab_RTL : impTab_LTR
		, prevState = null, newClass = null, newLevel = null, newState = 0
		, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];

	if (!charTypes) {
		for (i = 0, charTypes = []; i < len; i++) {
			charTypes[i] = _getCharacterType(chars[i]);
		}
	}
	hiLevel = dir;
	lastArabic = false;
	hasUBAT_AL = false;
	hasUBAT_B = false;
	hasUBAT_S = false;
	for (ix = 0; ix < len; ix++){
		prevState = newState;
		classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);
		newState = impTab[prevState][newClass];
		action = newState & 0xF0;
		newState &= 0x0F;
		levels[ix] = newLevel = impTab[newState][5];
		if (action > 0){
			if (action == 0x10){
				for(i = condPos; i < ix; i++){
					levels[i] = 1;
				}
				condPos = -1;
			} else {
				condPos = -1;
			}
		}
		cond = impTab[newState][6];
		if (cond){
			if(condPos == -1){
				condPos = ix;
			}
		}else{
			if (condPos > -1){
				for(i = condPos; i < ix; i++){
					levels[i] = newLevel;
				}
				condPos = -1;
			}
		}
		if (charTypes[ix] == B){
			levels[ix] = 0;
		}
		hiLevel |= newLevel;
	}
	if (hasUBAT_S){
		for(i = 0; i < len; i++){
			if(charTypes[i] == S){
				levels[i] = dir;
				for(var j = i - 1; j >= 0; j--){
					if(charTypes[j] == WS){
						levels[j] = dir;
					}else{
						break;
					}
				}
			}
		}
	}
}

function _invertLevel(lev, levels, _array) {
	if (hiLevel < lev){
		return;
	}
	if (lev == 1 && dir == RTL && !hasUBAT_B){
		_array.reverse();
		return;
	}
	var len = _array.length, start = 0, end, lo, hi, tmp;
	while(start < len){
		if (levels[start] >= lev){
			end = start + 1;
		while(end < len && levels[end] >= lev){
			end++;
		}
		for(lo = start, hi = end - 1 ; lo < hi; lo++, hi--){
			tmp = _array[lo];
			_array[lo] = _array[hi];
			_array[hi] = tmp;
		}
		start = end;
	}
	start++;
	}
}

function _getCharClass(chars, types, classes, ix) {			
	var cType = types[ix], wType, nType, len, i;
	switch(cType){
		case L:
		case R:
			lastArabic = false;
		case ON:
		case AN:
			return cType;
		case EN:
			return lastArabic ? AN : EN;
		case AL:
			lastArabic = true;
			hasUBAT_AL = true;
			return R;
		case WS:
			return ON;
		case CS:
			if (ix < 1 || (ix + 1) >= types.length ||
				((wType = classes[ix - 1]) != EN && wType != AN) ||
				((nType = types[ix + 1]) != EN && nType != AN)){
				return ON;
			}
			if (lastArabic){nType = AN;}
			return nType == wType ? nType : ON;
		case ES:
			wType = ix > 0 ? classes[ix - 1] : B;
			if (wType == EN && (ix + 1) < types.length && types[ix + 1] == EN){
				return EN;
			}
			return ON;
		case ET:
			if (ix > 0 && classes[ix - 1] == EN){
				return EN;
			}
			if (lastArabic){
				return ON;
			}
			i = ix + 1;
			len = types.length;
			while (i < len && types[i] == ET){
				i++;
			}
			if (i < len && types[i] == EN){
				return EN;
			}
			return ON;
		case NSM:
			len = types.length;
			i = ix + 1;
			while (i < len && types[i] == NSM){
				i++;
			}
			if (i < len){
				var c = chars[ix], rtlCandidate = (c >= 0x0591 && c <= 0x08FF) || c == 0xFB1E;
				
				wType = types[i];
				if (rtlCandidate && (wType == R || wType == AL)){
					return R;
				}
			}

			if (ix < 1 || (wType = types[ix - 1]) == B){
				return ON;
			}
			return classes[ix - 1];
		case B:
			lastArabic = false;
			hasUBAT_B = true;
			return dir;
		case S:
			hasUBAT_S = true;
			return ON;
		case LRE:
		case RLE:
		case LRO:
		case RLO:
		case PDF:
			lastArabic = false;
		case BN:
			return ON;
	}
}

function _getCharacterType( ch ) {		
	var uc = ch.charCodeAt(0), hi = uc >> 8;
	
	if (hi == 0) {		
		return ((uc > 0x00BF) ? L : UnicodeTBL00[uc]);
	} else if (hi == 5) {
		return (/[\u0591-\u05f4]/.test(ch) ? R : L);
	} else if (hi == 6) {
		if (/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(ch))
			return NSM;
		else if (/[\u0660-\u0669\u066b-\u066c]/.test(ch))
			return AN;
		else if (uc == 0x066A)
			return ET;
		else if (/[\u06f0-\u06f9]/.test(ch))
			return EN;			
		else
			return AL;
	} else if (hi == 0x20 && uc <= 0x205F) {
		return UnicodeTBL20[uc & 0xFF];
	} else if (hi == 0xFE) {
		return (uc >= 0xFE70 ? AL : ON);
	}		
	return ON;	
}

function _isArabicDiacritics( ch ) {
	return (ch >= '\u064b' && ch <= '\u0655');
}

/* Strong LTR character (0 - even), regular width */
exports.L = L;
/* Strong RTL character (1 - odd), Bidi width */
exports.R = R;
/* European digit (2 - even), regular width */
exports.EN = EN;
/* Neutral RTL-by-context character (3 - odd), regular width */
exports.ON_R = 3;
/* Hindi (Arabic) digit (4 - even), Bidi width */
exports.AN = 4;
/* Arabic LamAlef (5 - odd), Half Bidi width */
exports.R_H = 5;
/* invisible EOL (6 - even), zero width */
exports.B = 6;
/* invisible RLE (7 - odd), zero width */
exports.RLE = 7;

exports.DOT = "\xB7";

/**
 * Performs text reordering by implementing Unicode Bidi algorithm
 * with aim to produce logical<->visual map and Bidi levels
 * @param {String} text string to be reordered
 * @param {Array} textCharTypes unicode character types produced by call to 'hasBidiCharacters'
 * @param {Boolean} isRtl 'true' for right-to-left text direction, otherwise 'false'
 *
 * @return {Object} An object containing logicalFromVisual map and Bidi levels
 **/
exports.doBidiReorder = function(text, textCharTypes, isRtl) {
	if (text.length < 2)
		return {};
		
	var chars = text.split(""), logicalFromVisual = new Array(chars.length),
		bidiLevels = new Array(chars.length), levels = []; 

	dir = isRtl ? RTL : LTR;

	_computeLevels(chars, levels, chars.length, textCharTypes);

	for (var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++);

	_invertLevel(2, levels, logicalFromVisual);
	_invertLevel(1, levels, logicalFromVisual);

	for (var i = 0; i < logicalFromVisual.length - 1; i++) { //fix levels to reflect character width
		if (textCharTypes[i] === AN) {
			levels[i] = exports.AN;
		} else if (levels[i] === R && ((textCharTypes[i] > AL && textCharTypes[i] < LRE) 
			|| textCharTypes[i] === ON || textCharTypes[i] === BN)) {
			levels[i] = exports.ON_R;
		} else if ((i > 0 && chars[i - 1] === '\u0644') && /\u0622|\u0623|\u0625|\u0627/.test(chars[i])) {
			levels[i - 1] = levels[i] = exports.R_H;
			i++;
		}
	}
	/* fix level to mark zero length EOL */
	if (chars[chars.length - 1] === exports.DOT)
		levels[chars.length - 1] = exports.B;
				
	if (chars[0] === '\u202B')
		levels[0] = exports.RLE;
				
	for (var i = 0; i < logicalFromVisual.length; i++) {
		bidiLevels[i] = levels[logicalFromVisual[i]];
	}

	return {'logicalFromVisual': logicalFromVisual, 'bidiLevels': bidiLevels};
};	

/**
 * Performs character classification, to be used in Unicode Bidi algorithm.
 * @param {String} text string to be reordered
 * @param {Array} textCharTypes unicode character types (to be filled by this method)
 *
 * @return {Boolean} 'true' if text contains Bidi characters, otherwise 'false' 
 **/
exports.hasBidiCharacters = function(text, textCharTypes){
	var ret = false;
	for (var i = 0; i < text.length; i++){
		textCharTypes[i] = _getCharacterType(text.charAt(i));
		if (!ret && (textCharTypes[i] == R || textCharTypes[i] == AL || textCharTypes[i] == AN))
			ret = true;
	}
	return ret;
};

/**
 * Returns visual index corresponding to logical index basing on logicalFromvisual 
 * map provided by Unicode Bidi algorithm.
 * @param {Number} logIdx logical index of character in text buffer
 * @param {Object} rowMap object containing logicalFromVisual map
 *
 * @return {Number} visual index (on display) corresponding to logical index
 **/	
exports.getVisualFromLogicalIdx = function(logIdx, rowMap) {
	for (var i = 0; i < rowMap.logicalFromVisual.length; i++) {
		if (rowMap.logicalFromVisual[i] == logIdx)
			return i;
	}
	return 0;
};


/***/ }),

/***/ 51358:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Range = (__webpack_require__(91902)/* .Range */ .Q);

var FoldMode = exports.FoldMode = function() {};

(function() {

    this.foldingStartMarker = null;
    this.foldingStopMarker = null;

    // must return "" if there's no fold, to enable caching
    this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);
        if (this.foldingStartMarker.test(line))
            return "start";
        if (foldStyle == "markbeginend"
                && this.foldingStopMarker
                && this.foldingStopMarker.test(line))
            return "end";
        return "";
    };

    this.getFoldWidgetRange = function(session, foldStyle, row) {
        return null;
    };

    this.indentationBlock = function(session, row, column) {
        var re = /\S/;
        var line = session.getLine(row);
        var startLevel = line.search(re);
        if (startLevel == -1)
            return;

        var startColumn = column || line.length;
        var maxRow = session.getLength();
        var startRow = row;
        var endRow = row;

        while (++row < maxRow) {
            var level = session.getLine(row).search(re);

            if (level == -1)
                continue;

            if (level <= startLevel) {
                var token = session.getTokenAt(row, 0);
                if (!token || token.type !== "string")
                    break;
            }

            endRow = row;
        }

        if (endRow > startRow) {
            var endColumn = session.getLine(endRow).length;
            return new Range(startRow, startColumn, endRow, endColumn);
        }
    };

    this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
        var start = {row: row, column: column + 1};
        var end = session.$findClosingBracket(bracket, start, typeRe);
        if (!end)
            return;

        var fw = session.foldWidgets[end.row];
        if (fw == null)
            fw = session.getFoldWidget(end.row);

        if (fw == "start" && end.row > start.row) {
            end.row --;
            end.column = session.getLine(end.row).length;
        }
        return Range.fromPoints(start, end);
    };

    this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
        var end = {row: row, column: column};
        var start = session.$findOpeningBracket(bracket, end);

        if (!start)
            return;

        start.column++;
        end.column--;

        return  Range.fromPoints(start, end);
    };
}).call(FoldMode.prototype);


/***/ }),

/***/ 51509:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef Snippet
 * @property {string} [content]
 * @property {string} [replaceBefore]
 * @property {string} [replaceAfter]
 * @property {RegExp} [startRe]
 * @property {RegExp} [endRe]
 * @property {RegExp} [triggerRe]
 * @property {RegExp} [endTriggerRe]
 * @property {string} [trigger]
 * @property {string} [endTrigger]
 * @property {string[]} [matchBefore]
 * @property {string[]} [matchAfter]
 * @property {string} [name]
 * @property {string} [tabTrigger]
 * @property {string} [guard]
 * @property {string} [endGuard]
 */
var dom = __webpack_require__(71435);
var oop = __webpack_require__(2645);
var EventEmitter = (__webpack_require__(87366).EventEmitter);
var lang = __webpack_require__(39955);
var Range = (__webpack_require__(91902)/* .Range */ .Q);
var RangeList = (__webpack_require__(53509)/* .RangeList */ .U);
var HashHandler = (__webpack_require__(93050).HashHandler);
var Tokenizer = (__webpack_require__(32934).Tokenizer);
var clipboard = __webpack_require__(65217);

var VARIABLES = {
    CURRENT_WORD: function(editor) {
        return editor.session.getTextRange(editor.session.getWordRange());
    },
    SELECTION: function(editor, name, indentation) {
        var text = editor.session.getTextRange();
        if (indentation)
            return text.replace(/\n\r?([ \t]*\S)/g, "\n" + indentation + "$1");
        return text;
    },
    CURRENT_LINE: function(editor) {
        return editor.session.getLine(editor.getCursorPosition().row);
    },
    PREV_LINE: function(editor) {
        return editor.session.getLine(editor.getCursorPosition().row - 1);
    },
    LINE_INDEX: function(editor) {
        return editor.getCursorPosition().row;
    },
    LINE_NUMBER: function(editor) {
        return editor.getCursorPosition().row + 1;
    },
    SOFT_TABS: function(editor) {
        return editor.session.getUseSoftTabs() ? "YES" : "NO";
    },
    TAB_SIZE: function(editor) {
        return editor.session.getTabSize();
    },
    CLIPBOARD: function(editor) {
        return clipboard.getText && clipboard.getText();
    },
    // filenames
    FILENAME: function(editor) {
        return /[^/\\]*$/.exec(this.FILEPATH(editor))[0];
    },
    FILENAME_BASE: function(editor) {
        return /[^/\\]*$/.exec(this.FILEPATH(editor))[0].replace(/\.[^.]*$/, "");
    },
    DIRECTORY: function(editor) {
        return this.FILEPATH(editor).replace(/[^/\\]*$/, "");
    },
    FILEPATH: function(editor) { return "/not implemented.txt"; },
    WORKSPACE_NAME: function() { return "Unknown"; },
    FULLNAME: function() { return "Unknown"; },
    // comments
    BLOCK_COMMENT_START: function(editor) {
        var mode = editor.session.$mode || {};
        return mode.blockComment && mode.blockComment.start || "";
    },
    BLOCK_COMMENT_END: function(editor) {
        var mode = editor.session.$mode || {};
        return mode.blockComment && mode.blockComment.end || "";
    },
    LINE_COMMENT: function(editor) {
        var mode = editor.session.$mode || {};
        return mode.lineCommentStart || "";
    },
    // dates
    CURRENT_YEAR: date.bind(null, {year: "numeric"}),
    CURRENT_YEAR_SHORT: date.bind(null, {year: "2-digit"}),
    CURRENT_MONTH: date.bind(null, {month: "numeric"}),
    CURRENT_MONTH_NAME: date.bind(null, {month: "long"}),
    CURRENT_MONTH_NAME_SHORT: date.bind(null, {month: "short"}),
    CURRENT_DATE: date.bind(null, {day: "2-digit"}),
    CURRENT_DAY_NAME: date.bind(null, {weekday: "long"}),
    CURRENT_DAY_NAME_SHORT: date.bind(null, {weekday: "short"}),
    CURRENT_HOUR: date.bind(null, {hour: "2-digit", hour12: false}),
    CURRENT_MINUTE: date.bind(null, {minute: "2-digit"}),
    CURRENT_SECOND: date.bind(null, {second: "2-digit"})
};

VARIABLES.SELECTED_TEXT = VARIABLES.SELECTION;

function date(dateFormat) {
    var str = new Date().toLocaleString("en-us", dateFormat);
    return str.length == 1 ? "0" + str : str;
}

class SnippetManager {
    constructor() {
        this.snippetMap = {};
        this.snippetNameMap = {};
        this.variables = VARIABLES;
    }


    /**
     * @return {Tokenizer}
     */
    getTokenizer() {
        return SnippetManager["$tokenizer"] || this.createTokenizer();
    }

    createTokenizer() {
        function TabstopToken(str) {
            str = str.substr(1);
            if (/^\d+$/.test(str))
                return [{tabstopId: parseInt(str, 10)}];
            return [{text: str}];
        }
        function escape(ch) {
            return "(?:[^\\\\" + ch + "]|\\\\.)";
        }
        var formatMatcher = {
            regex: "/(" + escape("/") + "+)/",
            onMatch: function(val, state, stack) {
                var ts = stack[0];
                ts.fmtString = true;
                ts.guard = val.slice(1, -1);
                ts.flag = "";
                return "";
            },
            next: "formatString"
        };

        SnippetManager["$tokenizer"] = new Tokenizer({
            start: [
                {regex: /\\./, onMatch: function(val, state, stack) {
                    var ch = val[1];
                    if (ch == "}" && stack.length) {
                        val = ch;
                    } else if ("`$\\".indexOf(ch) != -1) {
                        val = ch;
                    }
                    return [val];
                }},
                {regex: /}/, onMatch: function(val, state, stack) {
                    return [stack.length ? stack.shift() : val];
                }},
                {regex: /\$(?:\d+|\w+)/, onMatch: TabstopToken},
                {regex: /\$\{[\dA-Z_a-z]+/, onMatch: function(str, state, stack) {
                    var t = TabstopToken(str.substr(1));
                    stack.unshift(t[0]);
                    return t;
                }, next: "snippetVar"},
                {regex: /\n/, token: "newline", merge: false}
            ],
            snippetVar: [
                {regex: "\\|" + escape("\\|") + "*\\|", onMatch: function(val, state, stack) {
                    var choices = val.slice(1, -1).replace(/\\[,|\\]|,/g, function(operator) {
                        return operator.length == 2 ? operator[1] : "\x00";
                    }).split("\x00").map(function(value){
                        return {value: value};
                    });
                    stack[0].choices = choices;
                    return [choices[0]];
                }, next: "start"},
                formatMatcher,
                {regex: "([^:}\\\\]|\\\\.)*:?", token: "", next: "start"}
            ],
            formatString: [
                {regex: /:/, onMatch: function(val, state, stack) {
                    if (stack.length && stack[0].expectElse) {
                        stack[0].expectElse = false;
                        stack[0].ifEnd = {elseEnd: stack[0]};
                        return [stack[0].ifEnd];
                    }
                    return ":";
                }},
                {regex: /\\./, onMatch: function(val, state, stack) {
                    var ch = val[1];
                    if (ch == "}" && stack.length)
                        val = ch;
                    else if ("`$\\".indexOf(ch) != -1)
                        val = ch;
                    else if (ch == "n")
                        val = "\n";
                    else if (ch == "t")
                        val = "\t";
                    else if ("ulULE".indexOf(ch) != -1)
                        val = {changeCase: ch, local: ch > "a"};
                    return [val];
                }},
                {regex: "/\\w*}", onMatch: function(val, state, stack) {
                    var next = stack.shift();
                    if (next)
                        next.flag = val.slice(1, -1);
                    this.next = next && next.tabstopId ? "start" : "";
                    return [next || val];
                }, next: "start"},
                {regex: /\$(?:\d+|\w+)/, onMatch: function(val, state, stack) {
                    return [{text: val.slice(1)}];
                }},
                {regex: /\${\w+/, onMatch: function(val, state, stack) {
                    var token = {text: val.slice(2)};
                    stack.unshift(token);
                    return [token];
                }, next: "formatStringVar"},
                {regex: /\n/, token: "newline", merge: false},
                {regex: /}/, onMatch: function(val, state, stack) {
                    var next = stack.shift();
                    this.next = next && next.tabstopId ? "start" : "";
                    return [next || val];
                }, next: "start"}
            ],
            formatStringVar: [
                {regex: /:\/\w+}/, onMatch: function(val, state, stack) {
                    var ts = stack[0];
                    ts.formatFunction = val.slice(2, -1);
                    return [stack.shift()];
                }, next: "formatString"},
                formatMatcher,
                {regex: /:[\?\-+]?/, onMatch: function(val, state, stack) {
                    if (val[1] == "+")
                        stack[0].ifEnd = stack[0];
                    if (val[1] == "?")
                        stack[0].expectElse = true;
                }, next: "formatString"},
                {regex: "([^:}\\\\]|\\\\.)*:?", token: "", next: "formatString"}
            ]
        });
        return SnippetManager["$tokenizer"];
    }

    tokenizeTmSnippet(str, startState) {
        return this.getTokenizer().getLineTokens(str, startState).tokens.map(function(x) {
            return x.value || x;
        });
    }

    getVariableValue(editor, name, indentation) {
        if (/^\d+$/.test(name))
            return (this.variables.__ || {})[name] || "";
        if (/^[A-Z]\d+$/.test(name))
            return (this.variables[name[0] + "__"] || {})[name.substr(1)] || "";

        name = name.replace(/^TM_/, "");
        if (!this.variables.hasOwnProperty(name))
            return "";
        var value = this.variables[name];
        if (typeof value == "function")
            value = this.variables[name](editor, name, indentation);
        return value == null ? "" : value;
    }

    // returns string formatted according to http://manual.macromates.com/en/regular_expressions#replacement_string_syntax_format_strings
    tmStrFormat(str, ch, editor) {
        if (!ch.fmt) return str;
        var flag = ch.flag || "";
        var re = ch.guard;
        re = new RegExp(re, flag.replace(/[^gim]/g, ""));
        var fmtTokens = typeof ch.fmt == "string" ? this.tokenizeTmSnippet(ch.fmt, "formatString") : ch.fmt;
        var _self = this;
        var formatted = str.replace(re, function() {
            var oldArgs = _self.variables.__;
            _self.variables.__ = [].slice.call(arguments);
            var fmtParts = _self.resolveVariables(fmtTokens, editor);
            var gChangeCase = "E";
            for (var i  = 0; i < fmtParts.length; i++) {
                var ch = fmtParts[i];
                if (typeof ch == "object") {
                    fmtParts[i] = "";
                    if (ch.changeCase && ch.local) {
                        var next = fmtParts[i + 1];
                        if (next && typeof next == "string") {
                            if (ch.changeCase == "u")
                                fmtParts[i] = next[0].toUpperCase();
                            else
                                fmtParts[i] = next[0].toLowerCase();
                            fmtParts[i + 1] = next.substr(1);
                        }
                    } else if (ch.changeCase) {
                        gChangeCase = ch.changeCase;
                    }
                } else if (gChangeCase == "U") {
                    fmtParts[i] = ch.toUpperCase();
                } else if (gChangeCase == "L") {
                    fmtParts[i] = ch.toLowerCase();
                }
            }
            _self.variables.__ = oldArgs;
            return fmtParts.join("");
        });
        return formatted;
    }

    tmFormatFunction(str, ch, editor) {
        if (ch.formatFunction == "upcase")
            return str.toUpperCase();
        if (ch.formatFunction == "downcase")
            return str.toLowerCase();
        return str;
    }

    resolveVariables(snippet, editor) {
        var result = [];
        var indentation = "";
        var afterNewLine = true;
        for (var i = 0; i < snippet.length; i++) {
            var ch = snippet[i];
            if (typeof ch == "string") {
                result.push(ch);
                if (ch == "\n") {
                    afterNewLine = true;
                    indentation = "";
                }
                else if (afterNewLine) {
                    indentation = /^\t*/.exec(ch)[0];
                    afterNewLine = /\S/.test(ch);
                }
                continue;
            }
            if (!ch)  continue;
            afterNewLine = false;

            if (ch.fmtString) {
                var j = snippet.indexOf(ch, i + 1);
                if (j == -1) j = snippet.length;
                ch.fmt = snippet.slice(i + 1, j);
                i = j;
            }

            if (ch.text) {
                var value = this.getVariableValue(editor, ch.text, indentation) + "";
                if (ch.fmtString)
                    value = this.tmStrFormat(value, ch, editor);
                if (ch.formatFunction)
                    value = this.tmFormatFunction(value, ch, editor);

                if (value && !ch.ifEnd) {
                    result.push(value);
                    gotoNext(ch);
                } else if (!value && ch.ifEnd) {
                    gotoNext(ch.ifEnd);
                }
            } else if (ch.elseEnd) {
                gotoNext(ch.elseEnd);
            } else if (ch.tabstopId != null) {
                result.push(ch);
            } else if (ch.changeCase != null) {
                result.push(ch);
            }
        }
        function gotoNext(ch) {
            var i1 = snippet.indexOf(ch, i + 1);
            if (i1 != -1)
                i = i1;
        }
        return result;
    }

    getDisplayTextForSnippet(editor, snippetText) {
        var processedSnippet = processSnippetText.call(this, editor, snippetText);
        return processedSnippet.text;
    }

    insertSnippetForSelection(editor, snippetText, options={}) {
        var processedSnippet = processSnippetText.call(this, editor, snippetText, options);

        var range = editor.getSelectionRange();
        var end = editor.session.replace(range, processedSnippet.text);

        var tabstopManager = new TabstopManager(editor);
        var selectionId = editor.inVirtualSelectionMode && editor.selection.index;
        //@ts-expect-error TODO: potential wrong arguments
        tabstopManager.addTabstops(processedSnippet.tabstops, range.start, end, selectionId);
    }
    insertSnippet(editor, snippetText, options={}) {
        var self = this;
        if (editor.inVirtualSelectionMode)
            return self.insertSnippetForSelection(editor, snippetText, options);

        editor.forEachSelection(function() {
            self.insertSnippetForSelection(editor, snippetText, options);
        }, null, {keepOrder: true});

        if (editor.tabstopManager)
            editor.tabstopManager.tabNext();
    }

    $getScope(editor) {
        var scope = editor.session.$mode.$id || "";
        scope = scope.split("/").pop();
        if (scope === "html" || scope === "php") {
            // PHP is actually HTML
            if (scope === "php" && !editor.session.$mode.inlinePhp)
                scope = "html";
            var c = editor.getCursorPosition();
            var state = editor.session.getState(c.row);
            if (typeof state === "object") {
                state = state[0];
            }
            if (state.substring) {
                if (state.substring(0, 3) == "js-")
                    scope = "javascript";
                else if (state.substring(0, 4) == "css-")
                    scope = "css";
                else if (state.substring(0, 4) == "php-")
                    scope = "php";
            }
        }

        return scope;
    }

    getActiveScopes(editor) {
        var scope = this.$getScope(editor);
        var scopes = [scope];
        var snippetMap = this.snippetMap;
        if (snippetMap[scope] && snippetMap[scope].includeScopes) {
            scopes.push.apply(scopes, snippetMap[scope].includeScopes);
        }
        scopes.push("_");
        return scopes;
    }

    expandWithTab(editor, options) {
        var self = this;
        var result = editor.forEachSelection(function() {
            return self.expandSnippetForSelection(editor, options);
        }, null, {keepOrder: true});
        if (result && editor.tabstopManager)
            editor.tabstopManager.tabNext();
        return result;
    }

    expandSnippetForSelection(editor, options) {
        var cursor = editor.getCursorPosition();
        var line = editor.session.getLine(cursor.row);
        var before = line.substring(0, cursor.column);
        var after = line.substr(cursor.column);

        var snippetMap = this.snippetMap;
        /**@type {Snippet}*/
        var snippet;
        this.getActiveScopes(editor).some(function(scope) {
            var snippets = snippetMap[scope];
            if (snippets)
                snippet = this.findMatchingSnippet(snippets, before, after);
            return !!snippet;
        }, this);
        if (!snippet)
            return false;
        if (options && options.dryRun)
            return true;
        editor.session.doc.removeInLine(cursor.row,
            cursor.column - snippet.replaceBefore.length,
            cursor.column + snippet.replaceAfter.length
        );

        this.variables.M__ = snippet.matchBefore;
        this.variables.T__ = snippet.matchAfter;
        this.insertSnippetForSelection(editor, snippet.content);

        this.variables.M__ = this.variables.T__ = null;
        return true;
    }

    /**
     * @param {Snippet[]} snippetList
     * @param {string} before
     * @param {string} after
     * @return {Snippet}
     */
    findMatchingSnippet(snippetList, before, after) {
        for (var i = snippetList.length; i--;) {
            var s = snippetList[i];
            if (s.startRe && !s.startRe.test(before))
                continue;
            if (s.endRe && !s.endRe.test(after))
                continue;
            if (!s.startRe && !s.endRe)
                continue;

            s.matchBefore = s.startRe ? s.startRe.exec(before) : [""];
            s.matchAfter = s.endRe ? s.endRe.exec(after) : [""];
            s.replaceBefore = s.triggerRe ? s.triggerRe.exec(before)[0] : "";
            s.replaceAfter = s.endTriggerRe ? s.endTriggerRe.exec(after)[0] : "";
            return s;
        }
    }


    /**
     * @param {any[]} snippets
     * @param {string} scope
     */
    register(snippets, scope) {
        var snippetMap = this.snippetMap;
        var snippetNameMap = this.snippetNameMap;
        var self = this;

        if (!snippets)
            snippets = [];

        function wrapRegexp(src) {
            if (src && !/^\^?\(.*\)\$?$|^\\b$/.test(src))
                src = "(?:" + src + ")";

            return src || "";
        }
        function guardedRegexp(re, guard, opening) {
            re = wrapRegexp(re);
            guard = wrapRegexp(guard);
            if (opening) {
                re = guard + re;
                if (re && re[re.length - 1] != "$")
                    re = re + "$";
            } else {
                re = re + guard;
                if (re && re[0] != "^")
                    re = "^" + re;
            }
            return new RegExp(re);
        }

        function addSnippet(s) {
            if (!s.scope)
                s.scope = scope || "_";
            scope = s.scope;
            if (!snippetMap[scope]) {
                snippetMap[scope] = [];
                snippetNameMap[scope] = {};
            }

            var map = snippetNameMap[scope];
            if (s.name) {
                var old = map[s.name];
                if (old)
                    self.unregister(old);
                map[s.name] = s;
            }
            snippetMap[scope].push(s);

            if (s.prefix)
                s.tabTrigger = s.prefix;

            if (!s.content && s.body)
                s.content = Array.isArray(s.body) ? s.body.join("\n") : s.body;

            if (s.tabTrigger && !s.trigger) {
                if (!s.guard && /^\w/.test(s.tabTrigger))
                    s.guard = "\\b";
                s.trigger = lang.escapeRegExp(s.tabTrigger);
            }

            if (!s.trigger && !s.guard && !s.endTrigger && !s.endGuard)
                return;

            s.startRe = guardedRegexp(s.trigger, s.guard, true);
            s.triggerRe = new RegExp(s.trigger);

            s.endRe = guardedRegexp(s.endTrigger, s.endGuard, true);
            s.endTriggerRe = new RegExp(s.endTrigger);
        }

        if (Array.isArray(snippets)) {
            snippets.forEach(addSnippet);
        } else {
            Object.keys(snippets).forEach(function(key) {
                addSnippet(snippets[key]);
            });
        }

        // @ts-ignore
        this._signal("registerSnippets", {scope: scope});
    }
    unregister(snippets, scope) {
        var snippetMap = this.snippetMap;
        var snippetNameMap = this.snippetNameMap;

        function removeSnippet(s) {
            var nameMap = snippetNameMap[s.scope||scope];
            if (nameMap && nameMap[s.name]) {
                delete nameMap[s.name];
                var map = snippetMap[s.scope||scope];
                var i = map && map.indexOf(s);
                if (i >= 0)
                    map.splice(i, 1);
            }
        }
        if (snippets.content)
            removeSnippet(snippets);
        else if (Array.isArray(snippets))
            snippets.forEach(removeSnippet);
    }
    parseSnippetFile(str) {
        str = str.replace(/\r/g, "");
        var list = [], /**@type{Snippet}*/snippet = {};
        var re = /^#.*|^({[\s\S]*})\s*$|^(\S+) (.*)$|^((?:\n*\t.*)+)/gm;
        var m;
        while (m = re.exec(str)) {
            if (m[1]) {
                try {
                    snippet = JSON.parse(m[1]);
                    list.push(snippet);
                } catch (e) {}
            } if (m[4]) {
                snippet.content = m[4].replace(/^\t/gm, "");
                list.push(snippet);
                snippet = {};
            } else {
                var key = m[2], val = m[3];
                if (key == "regex") {
                    var guardRe = /\/((?:[^\/\\]|\\.)*)|$/g;
                    snippet.guard = guardRe.exec(val)[1];
                    snippet.trigger = guardRe.exec(val)[1];
                    snippet.endTrigger = guardRe.exec(val)[1];
                    snippet.endGuard = guardRe.exec(val)[1];
                } else if (key == "snippet") {
                    snippet.tabTrigger = val.match(/^\S*/)[0];
                    if (!snippet.name)
                        snippet.name = val;
                } else if (key) {
                    snippet[key] = val;
                }
            }
        }
        return list;
    }
    getSnippetByName(name, editor) {
        var snippetMap = this.snippetNameMap;
        var snippet;
        this.getActiveScopes(editor).some(function(scope) {
            var snippets = snippetMap[scope];
            if (snippets)
                snippet = snippets[name];
            return !!snippet;
        }, this);
        return snippet;
    }
}

oop.implement(SnippetManager.prototype, EventEmitter);

var processSnippetText = function(editor, snippetText, options={}) {
    var cursor = editor.getCursorPosition();
    var line = editor.session.getLine(cursor.row);
    var tabString = editor.session.getTabString();
    var indentString = line.match(/^\s*/)[0];

    if (cursor.column < indentString.length)
        indentString = indentString.slice(0, cursor.column);

    snippetText = snippetText.replace(/\r/g, "");
    var tokens = this.tokenizeTmSnippet(snippetText);
    tokens = this.resolveVariables(tokens, editor);
    // indent
    tokens = tokens.map(function(x) {
        if (x == "\n" && !options.excludeExtraIndent)
            return x + indentString;
        if (typeof x == "string")
            return x.replace(/\t/g, tabString);
        return x;
    });
    // tabstop values
    var tabstops = [];
    tokens.forEach(function(p, i) {
        if (typeof p != "object")
            return;
        var id = p.tabstopId;
        var ts = tabstops[id];
        if (!ts) {
            ts = tabstops[id] = [];
            ts.index = id;
            ts.value = "";
            ts.parents = {};
        }
        if (ts.indexOf(p) !== -1)
            return;
        if (p.choices && !ts.choices)
            ts.choices = p.choices;
        ts.push(p);
        var i1 = tokens.indexOf(p, i + 1);
        if (i1 === -1)
            return;

        var value = tokens.slice(i + 1, i1);
        var isNested = value.some(function(t) {return typeof t === "object";});
        if (isNested && !ts.value) {
            ts.value = value;
        } else if (value.length && (!ts.value || typeof ts.value !== "string")) {
            ts.value = value.join("");
        }
    });

    // expand tabstop values
    tabstops.forEach(function(ts) {ts.length = 0;});
    var expanding = {};
    function copyValue(val) {
        var copy = [];
        for (var i = 0; i < val.length; i++) {
            var p = val[i];
            if (typeof p == "object") {
                if (expanding[p.tabstopId])
                    continue;
                var j = val.lastIndexOf(p, i - 1);
                p = copy[j] || {tabstopId: p.tabstopId};
            }
            copy[i] = p;
        }
        return copy;
    }
    for (var i = 0; i < tokens.length; i++) {
        var p = tokens[i];
        if (typeof p != "object")
            continue;
        var id = p.tabstopId;
        var ts = tabstops[id];
        var i1 = tokens.indexOf(p, i + 1);
        if (expanding[id]) {
            // if reached closing bracket clear expanding state
            if (expanding[id] === p) {
                delete expanding[id];
                Object.keys(expanding).forEach(function(parentId) {
                    ts.parents[parentId] = true;
                });
            }
            // otherwise just ignore recursive tabstop
            continue;
        }
        expanding[id] = p;
        var value = ts.value;
        if (typeof value !== "string")
            value = copyValue(value);
        else if (p.fmt)
            value = this.tmStrFormat(value, p, editor);
        tokens.splice.apply(tokens, [i + 1, Math.max(0, i1 - i)].concat(value, p));

        if (ts.indexOf(p) === -1)
            ts.push(p);
    }

    // convert to plain text
    var row = 0, column = 0;
    var text = "";
    tokens.forEach(function(t) {
        if (typeof t === "string") {
            var lines = t.split("\n");
            if (lines.length > 1){
                column = lines[lines.length - 1].length;
                row += lines.length - 1;
            } else
                column += t.length;
            text += t;
        } else if (t) {
            if (!t.start)
                t.start = {row: row, column: column};
            else
                t.end = {row: row, column: column};
        }
    });

    return {
        text,
        tabstops,
        tokens
    };
};

class TabstopManager {
    constructor(editor) {
        this.index = 0;
        this.ranges = [];
        this.tabstops = [];
        if (editor.tabstopManager)
            return editor.tabstopManager;
        editor.tabstopManager = this;
        this.$onChange = this.onChange.bind(this);
        this.$onChangeSelection = lang.delayedCall(this.onChangeSelection.bind(this)).schedule;
        this.$onChangeSession = this.onChangeSession.bind(this);
        this.$onAfterExec = this.onAfterExec.bind(this);
        this.attach(editor);
    }

    attach(editor) {
        this.$openTabstops = null;
        this.selectedTabstop = null;

        this.editor = editor;
        this.session = editor.session;
        this.editor.on("change", this.$onChange);
        this.editor.on("changeSelection", this.$onChangeSelection);
        this.editor.on("changeSession", this.$onChangeSession);
        this.editor.commands.on("afterExec", this.$onAfterExec);
        this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
    }
    detach() {
        this.tabstops.forEach(this.removeTabstopMarkers, this);
        this.ranges.length = 0;
        this.tabstops.length = 0;
        this.selectedTabstop = null;
        this.editor.off("change", this.$onChange);
        this.editor.off("changeSelection", this.$onChangeSelection);
        this.editor.off("changeSession", this.$onChangeSession);
        this.editor.commands.off("afterExec", this.$onAfterExec);
        this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
        this.editor.tabstopManager = null;
        this.session = null;
        this.editor = null;
    }
    /**
     * @internal
     */
    onChange(delta) {
        var isRemove = delta.action[0] == "r";
        var selectedTabstop = this.selectedTabstop || {};
        var parents = selectedTabstop.parents || {};
        var tabstops = this.tabstops.slice();
        for (var i = 0; i < tabstops.length; i++) {
            var ts = tabstops[i];
            var active = ts == selectedTabstop || parents[ts.index];
            ts.rangeList.$bias = active ? 0 : 1;

            if (delta.action == "remove" && ts !== selectedTabstop) {
                var parentActive = ts.parents && ts.parents[selectedTabstop.index];
                var startIndex = ts.rangeList.pointIndex(delta.start, parentActive);
                startIndex = startIndex < 0 ? -startIndex - 1 : startIndex + 1;
                var endIndex = ts.rangeList.pointIndex(delta.end, parentActive);
                endIndex = endIndex < 0 ? -endIndex - 1 : endIndex - 1;
                var toRemove = ts.rangeList.ranges.slice(startIndex, endIndex);
                for (var j = 0; j < toRemove.length; j++)
                    this.removeRange(toRemove[j]);
            }
            ts.rangeList.$onChange(delta);
        }
        var session = this.session;
        if (!this.$inChange && isRemove && session.getLength() == 1 && !session.getValue())
            this.detach();
    }
    updateLinkedFields() {
        var ts = this.selectedTabstop;
        if (!ts || !ts.hasLinkedRanges || !ts.firstNonLinked)
            return;
        this.$inChange = true;
        var session = this.session;
        var text = session.getTextRange(ts.firstNonLinked);
        for (var i = 0; i < ts.length; i++) {
            var range = ts[i];
            if (!range.linked)
                continue;
            var original = range.original;
            var fmt = exports.N.tmStrFormat(text, original, this.editor);
            session.replace(range, fmt);
        }
        this.$inChange = false;
    }
    /**
     * @internal
     */
    onAfterExec(e) {
        if (e.command && !e.command.readOnly)
            this.updateLinkedFields();
    }
    /**
     * @internal
     */
    onChangeSelection() {
        if (!this.editor)
            return;
        var lead = this.editor.selection.lead;
        var anchor = this.editor.selection.anchor;
        var isEmpty = this.editor.selection.isEmpty();
        for (var i = 0; i < this.ranges.length; i++) {
            if (this.ranges[i].linked)
                continue;
            var containsLead = this.ranges[i].contains(lead.row, lead.column);
            var containsAnchor = isEmpty || this.ranges[i].contains(anchor.row, anchor.column);
            if (containsLead && containsAnchor)
                return;
        }
        this.detach();
    }
    /**
     * @internal
     */
    onChangeSession() {
        this.detach();
    }
    tabNext(dir) {
        var max = this.tabstops.length;
        var index = this.index + (dir || 1);
        index = Math.min(Math.max(index, 1), max);
        if (index == max)
            index = 0;
        this.selectTabstop(index);
        this.updateTabstopMarkers();
        if (index === 0) {
            this.detach();
        }
    }
    selectTabstop(index) {
        this.$openTabstops = null;
        var ts = this.tabstops[this.index];
        if (ts)
            this.addTabstopMarkers(ts);
        this.index = index;
        ts = this.tabstops[this.index];
        if (!ts || !ts.length)
            return;

        this.selectedTabstop = ts;
        var range = ts.firstNonLinked || ts;
        if (ts.choices) range.cursor = range.start;
        if (!this.editor.inVirtualSelectionMode) {
            var sel = this.editor.multiSelect;
            sel.toSingleRange(range);
            for (var i = 0; i < ts.length; i++) {
                if (ts.hasLinkedRanges && ts[i].linked)
                    continue;
                sel.addRange(ts[i].clone(), true);
            }
        } else {
            this.editor.selection.fromOrientedRange(range);
        }

        this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
        if (this.selectedTabstop && this.selectedTabstop.choices)
            this.editor.execCommand("startAutocomplete", {matches: this.selectedTabstop.choices});
    }
    addTabstops(tabstops, start, end) {
        var useLink = this.useLink || !this.editor.getOption("enableMultiselect");

        if (!this.$openTabstops)
            this.$openTabstops = [];
        // add final tabstop if missing
        if (!tabstops[0]) {
            var p = Range.fromPoints(end, end);
            moveRelative(p.start, start);
            moveRelative(p.end, start);
            tabstops[0] = [p];
            tabstops[0].index = 0;
        }

        var i = this.index;
        var arg = [i + 1, 0];
        var ranges = this.ranges;
        var snippetId = this.snippetId = (this.snippetId || 0) + 1;
        tabstops.forEach(function(ts, index) {
            var dest = this.$openTabstops[index] || ts;
            dest.snippetId = snippetId;
            for (var i = 0; i < ts.length; i++) {
                var p = ts[i];
                /**@type {Range & {original?: Range, tabstop?: any, linked?: boolean}}}*/
                var range = Range.fromPoints(p.start, p.end || p.start);
                movePoint(range.start, start);
                movePoint(range.end, start);
                range.original = p;
                range.tabstop = dest;
                ranges.push(range);
                if (dest != ts)
                    dest.unshift(range);
                else
                    dest[i] = range;
                if (p.fmtString || (dest.firstNonLinked && useLink)) {
                    range.linked = true;
                    dest.hasLinkedRanges = true;
                } else if (!dest.firstNonLinked)
                    dest.firstNonLinked = range;
            }
            if (!dest.firstNonLinked)
                dest.hasLinkedRanges = false;
            if (dest === ts) {
                arg.push(dest);
                this.$openTabstops[index] = dest;
            }
            this.addTabstopMarkers(dest);
            dest.rangeList = dest.rangeList || new RangeList();
            dest.rangeList.$bias = 0;
            dest.rangeList.addList(dest);
        }, this);

        if (arg.length > 2) {
            // when adding new snippet inside existing one, make sure 0 tabstop is at the end
            if (this.tabstops.length)
                arg.push(arg.splice(2, 1)[0]);
            this.tabstops.splice.apply(this.tabstops, arg);
        }
    }

    addTabstopMarkers(ts) {
        var session = this.session;
        ts.forEach(function(range) {
            if  (!range.markerId)
                range.markerId = session.addMarker(range, "ace_snippet-marker", "text");
        });
    }
    removeTabstopMarkers(ts) {
        var session = this.session;
        ts.forEach(function(range) {
            session.removeMarker(range.markerId);
            range.markerId = null;
        });
    }
    updateTabstopMarkers() {
        if (!this.selectedTabstop) return;
        var currentSnippetId =  this.selectedTabstop.snippetId;
        // back to the parent snippet tabstops if $0
        if ( this.selectedTabstop.index === 0) {
            currentSnippetId--;
        }
        this.tabstops.forEach(function(ts) {
            // show marker only for the tabstops of the currently active snippet
            if (ts.snippetId === currentSnippetId) this.addTabstopMarkers(ts);
            else this.removeTabstopMarkers(ts);
        }, this);
    }
    removeRange(range) {
        var i = range.tabstop.indexOf(range);
        if (i != -1) range.tabstop.splice(i, 1);
        i = this.ranges.indexOf(range);
        if (i != -1) this.ranges.splice(i, 1);
        i = range.tabstop.rangeList.ranges.indexOf(range);
        if (i != -1) range.tabstop.splice(i, 1);
        this.session.removeMarker(range.markerId);
        if (!range.tabstop.length) {
            i = this.tabstops.indexOf(range.tabstop);
            if (i != -1)
                this.tabstops.splice(i, 1);
            if (!this.tabstops.length)
                this.detach();
        }
    }
}


TabstopManager.prototype.keyboardHandler = new HashHandler();
TabstopManager.prototype.keyboardHandler.bindKeys({
    "Tab": function(editor) {
        if (exports.N && exports.N.expandWithTab(editor))
            return;
        editor.tabstopManager.tabNext(1);
        editor.renderer.scrollCursorIntoView();
    },
    "Shift-Tab": function(editor) {
        editor.tabstopManager.tabNext(-1);
        editor.renderer.scrollCursorIntoView();
    },
    "Esc": function(editor) {
        editor.tabstopManager.detach();
    }
});


var movePoint = function(point, diff) {
    if (point.row == 0)
        point.column += diff.column;
    point.row += diff.row;
};

var moveRelative = function(point, start) {
    if (point.row == start.row)
        point.column -= start.column;
    point.row -= start.row;
};


dom.importCssString(`
.ace_snippet-marker {
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    background: rgba(194, 193, 208, 0.09);
    border: 1px dotted rgba(211, 208, 235, 0.62);
    position: absolute;
}`, "snippets.css", false);

exports.N = new SnippetManager();


var Editor = (__webpack_require__(27258).Editor);
(function() {
    this.insertSnippet = function(content, options) {
        return exports.N.insertSnippet(this, content, options);
    };
    this.expandSnippet = function(options) {
        return exports.N.expandWithTab(this, options);
    };
}).call(Editor.prototype);


/***/ }),

/***/ 51826:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Renderer = (__webpack_require__(21016).VirtualRenderer);
var Editor = (__webpack_require__(27258).Editor);
var Range = (__webpack_require__(91902)/* .Range */ .Q);
var event = __webpack_require__(19631);
var lang = __webpack_require__(39955);
var dom = __webpack_require__(71435);
var nls = (__webpack_require__(76321).nls);
var userAgent = __webpack_require__(74943);

var getAriaId = function (index) {
    return `suggest-aria-id:${index}`;
};

// Safari requires different ARIA A11Y attributes compared to other browsers
var popupAriaRole = userAgent.isSafari ? "menu" : "listbox";
var optionAriaRole = userAgent.isSafari ? "menuitem" : "option";
var ariaActiveState = userAgent.isSafari ? "aria-current" : "aria-selected";

/**
 *
 * @param {HTMLElement} [el]
 * @return {Editor}
 */
var $singleLineEditor = function(el) {
    var renderer = new Renderer(el);

    renderer.$maxLines = 4;
    var editor = new Editor(renderer);

    editor.setHighlightActiveLine(false);
    editor.setShowPrintMargin(false);
    editor.renderer.setShowGutter(false);
    editor.renderer.setHighlightGutterLine(false);

    editor.$mouseHandler.$focusTimeout = 0;
    editor.$highlightTagPending = true;

    return editor;
};

/**
 * This object is used in some places where needed to show popups - like prompt; autocomplete etc.
 */
class AcePopup {
    /**
     * Creates and renders single line editor in popup window. If `parentNode` param is isset, then attaching it to this element.
     * @param {Element} [parentNode]
     */
    constructor(parentNode) {
        var el = dom.createElement("div");
        /**@type {AcePopup}*/
        // @ts-ignore
        var popup = $singleLineEditor(el);

        if (parentNode) {
            parentNode.appendChild(el);
        }
        el.style.display = "none";
        popup.renderer.content.style.cursor = "default";
        popup.renderer.setStyle("ace_autocomplete");

        // Set aria attributes for the popup
        popup.renderer.$textLayer.element.setAttribute("role", popupAriaRole);
        popup.renderer.$textLayer.element.setAttribute("aria-roledescription", nls("autocomplete.popup.aria-roledescription", "Autocomplete suggestions"));
        popup.renderer.$textLayer.element.setAttribute("aria-label", nls("autocomplete.popup.aria-label", "Autocomplete suggestions"));
        popup.renderer.textarea.setAttribute("aria-hidden", "true");

        popup.setOption("displayIndentGuides", false);
        popup.setOption("dragDelay", 150);

        var noop = function(){};

        popup.focus = noop;
        popup.$isFocused = true;

        popup.renderer.$cursorLayer.restartTimer = noop;
        popup.renderer.$cursorLayer.element.style.opacity = "0";

        popup.renderer.$maxLines = 8;
        popup.renderer.$keepTextAreaAtCursor = false;

        popup.setHighlightActiveLine(false);
        // set default highlight color
        // @ts-ignore
        popup.session.highlight("");
        popup.session.$searchHighlight.clazz = "ace_highlight-marker";

        popup.on("mousedown", function(e) {
            var pos = e.getDocumentPosition();
            popup.selection.moveToPosition(pos);
            selectionMarker.start.row = selectionMarker.end.row = pos.row;
            e.stop();
        });

        var lastMouseEvent;
        var hoverMarker = new Range(-1, 0, -1, Infinity);
        var selectionMarker = new Range(-1, 0, -1, Infinity);
        selectionMarker.id = popup.session.addMarker(selectionMarker, "ace_active-line", "fullLine");
        popup.setSelectOnHover = function (val) {
            if (!val) {
                hoverMarker.id = popup.session.addMarker(hoverMarker, "ace_line-hover", "fullLine");
            } else if (hoverMarker.id) {
                popup.session.removeMarker(hoverMarker.id);
                hoverMarker.id = null;
            }
        };
        popup.setSelectOnHover(false);
        popup.on("mousemove", function(e) {
            if (!lastMouseEvent) {
                lastMouseEvent = e;
                return;
            }
            if (lastMouseEvent.x == e.x && lastMouseEvent.y == e.y) {
                return;
            }
            lastMouseEvent = e;
            lastMouseEvent.scrollTop = popup.renderer.scrollTop;
            popup.isMouseOver = true;
            var row = lastMouseEvent.getDocumentPosition().row;
            if (hoverMarker.start.row != row) {
                if (!hoverMarker.id)
                    popup.setRow(row);
                setHoverMarker(row);
            }
        });
        popup.renderer.on("beforeRender", function() {
            if (lastMouseEvent && hoverMarker.start.row != -1) {
                lastMouseEvent.$pos = null;
                var row = lastMouseEvent.getDocumentPosition().row;
                if (!hoverMarker.id)
                    popup.setRow(row);
                setHoverMarker(row, true);
            }
        });
        // set aria attributes on all visible elements of the popup
        popup.renderer.on("afterRender", function () {
            var t = popup.renderer.$textLayer;
            for (var row = t.config.firstRow, l = t.config.lastRow; row <= l; row++) {
                const popupRowElement = /** @type {HTMLElement|null} */(t.element.childNodes[row - t.config.firstRow]);

                popupRowElement.setAttribute("role", optionAriaRole);
                popupRowElement.setAttribute("aria-roledescription", nls("autocomplete.popup.item.aria-roledescription", "item"));
                popupRowElement.setAttribute("aria-setsize", popup.data.length);
                popupRowElement.setAttribute("aria-describedby", "doc-tooltip");
                popupRowElement.setAttribute("aria-posinset", row + 1);

                const rowData = popup.getData(row);
                if (rowData) {
                    const ariaLabel = `${rowData.caption || rowData.value}${rowData.meta ? `, ${rowData.meta}` : ''}`;
                    popupRowElement.setAttribute("aria-label", ariaLabel);
                }

                const highlightedSpans = popupRowElement.querySelectorAll(".ace_completion-highlight");
                highlightedSpans.forEach(span => {
                    span.setAttribute("role", "mark");
                });
            }
        });
        popup.renderer.on("afterRender", function () {
            var row = popup.getRow();
            var t = popup.renderer.$textLayer;
            var selected = /** @type {HTMLElement|null} */(t.element.childNodes[row - t.config.firstRow]);
            var el = document.activeElement; // Active element is textarea of main editor
            if (selected !== popup.selectedNode && popup.selectedNode) {
                dom.removeCssClass(popup.selectedNode, "ace_selected");
                popup.selectedNode.removeAttribute(ariaActiveState);
                popup.selectedNode.removeAttribute("id");
            }
            el.removeAttribute("aria-activedescendant");

            popup.selectedNode = selected;
            if (selected) {
                var ariaId = getAriaId(row);
                dom.addCssClass(selected, "ace_selected");
                selected.id = ariaId;
                t.element.setAttribute("aria-activedescendant", ariaId);
                el.setAttribute("aria-activedescendant", ariaId);
                selected.setAttribute(ariaActiveState, "true");
            }
        });
        var hideHoverMarker = function() { setHoverMarker(-1); };
        var setHoverMarker = function(row, suppressRedraw) {
            if (row !== hoverMarker.start.row) {
                hoverMarker.start.row = hoverMarker.end.row = row;
                if (!suppressRedraw)
                    popup.session._emit("changeBackMarker");
                popup._emit("changeHoverMarker");
            }
        };
        popup.getHoveredRow = function() {
            return hoverMarker.start.row;
        };

        event.addListener(popup.container, "mouseout", function() {
            popup.isMouseOver = false;
            hideHoverMarker();
        });
        popup.on("hide", hideHoverMarker);
        popup.on("changeSelection", hideHoverMarker);

        popup.session.doc.getLength = function() {
            return popup.data.length;
        };
        popup.session.doc.getLine = function(i) {
            var data = popup.data[i];
            if (typeof data == "string")
                return data;
            return (data && data.value) || "";
        };

        var bgTokenizer = popup.session.bgTokenizer;
        bgTokenizer.$tokenizeRow = function(row) {
            /**@type {import("../../ace-internal").Ace.Completion &{name?, className?, matchMask?, message?}}*/
            var data = popup.data[row];
            var tokens = [];
            if (!data)
                return tokens;
            if (typeof data == "string")
                data = {value: data};
            var caption = data.caption || data.value || data.name;

            function addToken(value, className) {
                value && tokens.push({
                    type: (data.className || "") + (className || ""),
                    value: value
                });
            }

            var lower = caption.toLowerCase();
            var filterText = (popup.filterText || "").toLowerCase();
            var lastIndex = 0;
            var lastI = 0;
            for (var i = 0; i <= filterText.length; i++) {
                if (i != lastI && (data.matchMask & (1 << i) || i == filterText.length)) {
                    var sub = filterText.slice(lastI, i);
                    lastI = i;
                    var index = lower.indexOf(sub, lastIndex);
                    if (index == -1) continue;
                    addToken(caption.slice(lastIndex, index), "");
                    lastIndex = index + sub.length;
                    addToken(caption.slice(index, lastIndex), "completion-highlight");
                }
            }
            addToken(caption.slice(lastIndex, caption.length), "");

            tokens.push({type: "completion-spacer", value: " "});
            if (data.meta)
                tokens.push({type: "completion-meta", value: data.meta});
            if (data.message)
                tokens.push({type: "completion-message", value: data.message});

            return tokens;
        };
        bgTokenizer.$updateOnChange = noop;
        bgTokenizer.start = noop;

        popup.session.$computeWidth = function() {
            return this.screenWidth = 0;
        };

        // public
        popup.isOpen = false;
        popup.isTopdown = false;
        popup.autoSelect = true;
        popup.filterText = "";
        popup.isMouseOver = false;

        popup.data = [];
        popup.setData = function(list, filterText) {
            popup.filterText = filterText || "";
            popup.setValue(lang.stringRepeat("\n", list.length), -1);
            popup.data = list || [];
            popup.setRow(0);
        };
        popup.getData = function(row) {
            return popup.data[row];
        };

        popup.getRow = function() {
            return selectionMarker.start.row;
        };
        popup.setRow = function(line) {
            line = Math.max(this.autoSelect ? 0 : -1, Math.min(this.data.length - 1, line));
            if (selectionMarker.start.row != line) {
                popup.selection.clearSelection();
                selectionMarker.start.row = selectionMarker.end.row = line || 0;
                popup.session._emit("changeBackMarker");
                popup.moveCursorTo(line || 0, 0);
                if (popup.isOpen)
                    popup._signal("select");
            }
        };

        popup.on("changeSelection", function() {
            if (popup.isOpen)
                popup.setRow(popup.selection.lead.row);
            popup.renderer.scrollCursorIntoView();
        });

        popup.hide = function() {
            this.container.style.display = "none";
            popup.anchorPos = null;
            popup.anchor = null;
            if (popup.isOpen) {
                popup.isOpen = false;
                this._signal("hide");
            }
        };

        /**
         * Tries to show the popup anchored to the given position and anchors.
         * If the anchor is not specified it tries to align to bottom and right as much as possible.
         * If the popup does not have enough space to be rendered with the given anchors, it returns false without rendering the popup.
         * The forceShow flag can be used to render the popup in these cases, which slides the popup so it entirely fits on the screen.
         * @param {{top: number, left: number}} pos
         * @param {number} lineHeight
         * @param {"top" | "bottom" | undefined} anchor
         * @param {boolean} forceShow
         * @returns {boolean}
         */
        popup.tryShow = function(pos, lineHeight, anchor, forceShow) {
            if (!forceShow && popup.isOpen && popup.anchorPos && popup.anchor &&
                popup.anchorPos.top === pos.top && popup.anchorPos.left === pos.left &&
                popup.anchor === anchor
            ) {
                return true;
            }

            var el = this.container;
            var scrollBarSize = this.renderer.scrollBar.width || 10;
            var screenHeight = window.innerHeight - scrollBarSize;
            var screenWidth = window.innerWidth - scrollBarSize;
            var renderer = this.renderer;
            // var maxLines = Math.min(renderer.$maxLines, this.session.getLength());
            var maxH = renderer.$maxLines * lineHeight * 1.4;
            var dims = { top: 0, bottom: 0, left: 0 };

            var spaceBelow = screenHeight - pos.top - 3 * this.$borderSize - lineHeight;
            var spaceAbove = pos.top - 3 * this.$borderSize;
            if (!anchor) {
                if (spaceAbove <= spaceBelow || spaceBelow >= maxH) {
                    anchor = "bottom";
                } else {
                    anchor = "top";
                }
            }

            if (anchor === "top") {
                dims.bottom = pos.top - this.$borderSize;
                dims.top = dims.bottom - maxH;
            } else if (anchor === "bottom") {
                dims.top = pos.top + lineHeight + this.$borderSize;
                dims.bottom = dims.top + maxH;
            }

            var fitsX = dims.top >= 0 && dims.bottom <= screenHeight;

            if (!forceShow && !fitsX) {
                return false;
            }

            if (!fitsX) {
                if (anchor === "top") {
                    renderer.$maxPixelHeight = spaceAbove;
                } else {
                    renderer.$maxPixelHeight = spaceBelow;
                }
            } else {
                renderer.$maxPixelHeight = null;
            }


            if (anchor === "top") {
                el.style.top = "";
                el.style.bottom = (screenHeight + scrollBarSize - dims.bottom) + "px";
                popup.isTopdown = false;
            } else {
                el.style.top = dims.top + "px";
                el.style.bottom = "";
                popup.isTopdown = true;
            }

            el.style.display = "";

            var left = pos.left;
            if (left + el.offsetWidth > screenWidth)
                left = screenWidth - el.offsetWidth;

            el.style.left = left + "px";
            el.style.right = "";
            dom.$fixPositionBug(el);

            if (!popup.isOpen) {
                popup.isOpen = true;
                this._signal("show");
                lastMouseEvent = null;
            }

            popup.anchorPos = pos;
            popup.anchor = anchor;
            

            return true;
        };

        popup.show = function(pos, lineHeight, topdownOnly) {
            this.tryShow(pos, lineHeight, topdownOnly ? "bottom" : undefined, true);
        };

        popup.goTo = function(where) {
            var row = this.getRow();
            var max = this.session.getLength() - 1;

            switch(where) {
                case "up": row = row <= 0 ? max : row - 1; break;
                case "down": row = row >= max ? -1 : row + 1; break;
                case "start": row = 0; break;
                case "end": row = max; break;
            }

            this.setRow(row);
        };


        popup.getTextLeftOffset = function() {
            return this.$borderSize + this.renderer.$padding + this.$imageSize;
        };

        popup.$imageSize = 0;
        popup.$borderSize = 1;

        return popup;
    }
}

dom.importCssString(`
.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {
    background-color: #CAD6FA;
    z-index: 1;
}
.ace_dark.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {
    background-color: #3a674e;
}
.ace_editor.ace_autocomplete .ace_line-hover {
    border: 1px solid #abbffe;
    margin-top: -1px;
    background: rgba(233,233,253,0.4);
    position: absolute;
    z-index: 2;
}
.ace_dark.ace_editor.ace_autocomplete .ace_line-hover {
    border: 1px solid rgba(109, 150, 13, 0.8);
    background: rgba(58, 103, 78, 0.62);
}
.ace_completion-meta {
    opacity: 0.5;
    margin-left: 0.9em;
}
.ace_completion-message {
    margin-left: 0.9em;
    color: blue;
}
.ace_editor.ace_autocomplete .ace_completion-highlight{
    color: #2d69c7;
}
.ace_dark.ace_editor.ace_autocomplete .ace_completion-highlight{
    color: #93ca12;
}
.ace_editor.ace_autocomplete {
    width: 300px;
    z-index: 200000;
    border: 1px lightgray solid;
    position: fixed;
    box-shadow: 2px 3px 5px rgba(0,0,0,.2);
    line-height: 1.4;
    background: #fefefe;
    color: #111;
}
.ace_dark.ace_editor.ace_autocomplete {
    border: 1px #484747 solid;
    box-shadow: 2px 3px 5px rgba(0, 0, 0, 0.51);
    line-height: 1.4;
    background: #25282c;
    color: #c1c1c1;
}
.ace_autocomplete .ace_text-layer  {
    width: calc(100% - 8px);
}
.ace_autocomplete .ace_line {
    display: flex;
    align-items: center;
}
.ace_autocomplete .ace_line > * {
    min-width: 0;
    flex: 0 0 auto;
}
.ace_autocomplete .ace_line .ace_ {
    flex: 0 1 auto;
    overflow: hidden;
    text-overflow: ellipsis;
}
.ace_autocomplete .ace_completion-spacer {
    flex: 1;
}
.ace_autocomplete.ace_loading:after  {
    content: "";
    position: absolute;
    top: 0px;
    height: 2px;
    width: 8%;
    background: blue;
    z-index: 100;
    animation: ace_progress 3s infinite linear;
    animation-delay: 300ms;
    transform: translateX(-100%) scaleX(1);
}
@keyframes ace_progress {
    0% { transform: translateX(-100%) scaleX(1) }
    50% { transform: translateX(625%) scaleX(2) } 
    100% { transform: translateX(1500%) scaleX(3) } 
}
@media (prefers-reduced-motion) {
    .ace_autocomplete.ace_loading:after {
        transform: translateX(625%) scaleX(2);
        animation: none;
     }
}
`, "autocompletion.css", false);

exports.AcePopup = AcePopup;
exports.$singleLineEditor = $singleLineEditor;
exports.getAriaId = getAriaId;


/***/ }),

/***/ 53092:
/***/ ((__unused_webpack_module, exports) => {


exports.N = function reportError(msg, data) {
    var e = new Error(msg);
    e["data"] = data;
    if (typeof console == "object" && console.error)
        console.error(e);
    setTimeout(function() { throw e; });
};


/***/ }),

/***/ 53120:
/***/ ((module) => {

/*
styles = []
for (var i = 1; i < 16; i++) {
    styles.push(".ace_br" + i + "{" + (
        ["top-left", "top-right", "bottom-right", "bottom-left"]
    ).map(function(x, j) {
        return i & (1<<j) ? "border-" + x + "-radius: 3px;" : "" 
    }).filter(Boolean).join(" ") + "}")
}
styles.join("\\n")
*/
module.exports = `
.ace_br1 {border-top-left-radius    : 3px;}
.ace_br2 {border-top-right-radius   : 3px;}
.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}
.ace_br4 {border-bottom-right-radius: 3px;}
.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}
.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}
.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}
.ace_br8 {border-bottom-left-radius : 3px;}
.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}
.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}
.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}
.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}


.ace_editor {
    position: relative;
    overflow: hidden;
    padding: 0;
    font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Source Code Pro', 'source-code-pro', monospace;
    direction: ltr;
    text-align: left;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    forced-color-adjust: none;
}

.ace_scroller {
    position: absolute;
    overflow: hidden;
    top: 0;
    bottom: 0;
    background-color: inherit;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    cursor: text;
}

.ace_content {
    position: absolute;
    box-sizing: border-box;
    min-width: 100%;
    contain: style size layout;
    font-variant-ligatures: no-common-ligatures;
}
.ace_invisible {
    font-variant-ligatures: none;
}

.ace_keyboard-focus:focus {
    box-shadow: inset 0 0 0 2px #5E9ED6;
    outline: none;
}

.ace_dragging .ace_scroller:before{
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    content: '';
    background: rgba(250, 250, 250, 0.01);
    z-index: 1000;
}
.ace_dragging.ace_dark .ace_scroller:before{
    background: rgba(0, 0, 0, 0.01);
}

.ace_gutter {
    position: absolute;
    overflow : hidden;
    width: auto;
    top: 0;
    bottom: 0;
    left: 0;
    cursor: default;
    z-index: 4;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    contain: style size layout;
}

.ace_gutter-active-line {
    position: absolute;
    left: 0;
    right: 0;
}

.ace_scroller.ace_scroll-left:after {
    content: "";
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;
    pointer-events: none;
}

.ace_gutter-cell, .ace_gutter-cell_svg-icons {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    padding-left: 19px;
    padding-right: 6px;
    background-repeat: no-repeat;
}

.ace_gutter-cell_svg-icons .ace_gutter_annotation {
    margin-left: -14px;
    float: left;
}

.ace_gutter-cell .ace_gutter_annotation {
    margin-left: -19px;
    float: left;
}

.ace_gutter-cell.ace_error, .ace_icon.ace_error, .ace_icon.ace_error_fold, .ace_gutter-cell.ace_security, .ace_icon.ace_security, .ace_icon.ace_security_fold {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_gutter-cell.ace_warning, .ace_icon.ace_warning, .ace_icon.ace_warning_fold {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_gutter-cell.ace_info, .ace_icon.ace_info, .ace_gutter-cell.ace_hint, .ace_icon.ace_hint {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_dark .ace_gutter-cell.ace_info, .ace_dark .ace_icon.ace_info, .ace_dark .ace_gutter-cell.ace_hint, .ace_dark .ace_icon.ace_hint {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC");
}

.ace_icon_svg.ace_error {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJyZWQiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KPGNpcmNsZSBmaWxsPSJub25lIiBjeD0iOCIgY3k9IjgiIHI9IjciIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPGxpbmUgeDE9IjExIiB5MT0iNSIgeDI9IjUiIHkyPSIxMSIvPgo8bGluZSB4MT0iMTEiIHkxPSIxMSIgeDI9IjUiIHkyPSI1Ii8+CjwvZz4KPC9zdmc+");
    background-color: crimson;
}
.ace_icon_svg.ace_security {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8ZyBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZT0iZGFya29yYW5nZSIgZmlsbD0ibm9uZSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgogICAgICAgIDxwYXRoIGNsYXNzPSJzdHJva2UtbGluZWpvaW4tcm91bmQiIGQ9Ik04IDE0LjgzMDdDOCAxNC44MzA3IDIgMTIuOTA0NyAyIDguMDg5OTJWMy4yNjU0OEM1LjMxIDMuMjY1NDggNy45ODk5OSAxLjM0OTE4IDcuOTg5OTkgMS4zNDkxOEM3Ljk4OTk5IDEuMzQ5MTggMTAuNjkgMy4yNjU0OCAxNCAzLjI2NTQ4VjguMDg5OTJDMTQgMTIuOTA0NyA4IDE0LjgzMDcgOCAxNC44MzA3WiIvPgogICAgICAgIDxwYXRoIGQ9Ik0yIDguMDg5OTJWMy4yNjU0OEM1LjMxIDMuMjY1NDggNy45ODk5OSAxLjM0OTE4IDcuOTg5OTkgMS4zNDkxOCIvPgogICAgICAgIDxwYXRoIGQ9Ik0xMy45OSA4LjA4OTkyVjMuMjY1NDhDMTAuNjggMy4yNjU0OCA4IDEuMzQ5MTggOCAxLjM0OTE4Ii8+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTggNFY5Ii8+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTggMTBWMTIiLz4KICAgIDwvZz4KPC9zdmc+");
    background-color: crimson;
}
.ace_icon_svg.ace_warning {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJkYXJrb3JhbmdlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+Cjxwb2x5Z29uIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGZpbGw9Im5vbmUiIHBvaW50cz0iOCAxIDE1IDE1IDEgMTUgOCAxIi8+CjxyZWN0IHg9IjgiIHk9IjEyIiB3aWR0aD0iMC4wMSIgaGVpZ2h0PSIwLjAxIi8+CjxsaW5lIHgxPSI4IiB5MT0iNiIgeDI9IjgiIHkyPSIxMCIvPgo8L2c+Cjwvc3ZnPg==");
    background-color: darkorange;
}
.ace_icon_svg.ace_info {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJibHVlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CjxjaXJjbGUgZmlsbD0ibm9uZSIgY3g9IjgiIGN5PSI4IiByPSI3IiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjxwb2x5bGluZSBwb2ludHM9IjggMTEgOCA4Ii8+Cjxwb2x5bGluZSBwb2ludHM9IjkgOCA2IDgiLz4KPGxpbmUgeDE9IjEwIiB5MT0iMTEiIHgyPSI2IiB5Mj0iMTEiLz4KPHJlY3QgeD0iOCIgeT0iNSIgd2lkdGg9IjAuMDEiIGhlaWdodD0iMC4wMSIvPgo8L2c+Cjwvc3ZnPg==");
    background-color: royalblue;
}
.ace_icon_svg.ace_hint {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8ZyBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZT0ic2lsdmVyIiBmaWxsPSJub25lIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTYgMTRIMTAiLz4KICAgICAgICA8cGF0aCBkPSJNOCAxMUg5QzkgOS40NzAwMiAxMiA4LjU0MDAyIDEyIDUuNzYwMDJDMTIuMDIgNC40MDAwMiAxMS4zOSAzLjM2MDAyIDEwLjQzIDIuNjcwMDJDOSAxLjY0MDAyIDcuMDAwMDEgMS42NDAwMiA1LjU3MDAxIDIuNjcwMDJDNC42MTAwMSAzLjM2MDAyIDMuOTggNC40MDAwMiA0IDUuNzYwMDJDNCA4LjU0MDAyIDcuMDAwMDEgOS40NzAwMiA3LjAwMDAxIDExSDhaIi8+CiAgICA8L2c+Cjwvc3ZnPg==");
    background-color: silver;
}

.ace_icon_svg.ace_error_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSI+CiAgPHBhdGggZD0ibSAxOC45Mjk4NTEsNy44Mjk4MDc2IGMgMC4xNDYzNTMsNi4zMzc0NjA0IC02LjMyMzE0Nyw3Ljc3Nzg0NDQgLTcuNDc3OTEyLDcuNzc3ODQ0NCAtMi4xMDcyNzI2LC0wLjEyODc1IDUuMTE3Njc4LDAuMzU2MjQ5IDUuMDUxNjk4LC03Ljg3MDA2MTggLTAuNjA0NjcyLC04LjAwMzk3MzQ5IC03LjA3NzI3MDYsLTcuNTYzMTE4OSAtNC44NTczLC03LjQzMDM5NTU2IDEuNjA2LC0wLjExNTE0MjI1IDYuODk3NDg1LDEuMjYyNTQ1OTYgNy4yODM1MTQsNy41MjI2MTI5NiB6IiBmaWxsPSJjcmltc29uIiBzdHJva2Utd2lkdGg9IjIiLz4KICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibSA4LjExNDc1NjIsMi4wNTI5ODI4IGMgMy4zNDkxNjk4LDAgNi4wNjQxMzI4LDIuNjc2ODYyNyA2LjA2NDEzMjgsNS45Nzg5NTMgMCwzLjMwMjExMjIgLTIuNzE0OTYzLDUuOTc4OTIwMiAtNi4wNjQxMzI4LDUuOTc4OTIwMiAtMy4zNDkxNDczLDAgLTYuMDY0MTc3MiwtMi42NzY4MDggLTYuMDY0MTc3MiwtNS45Nzg5MjAyIDAuMDA1MzksLTMuMjk5ODg2MSAyLjcxNzI2NTYsLTUuOTczNjQwOCA2LjA2NDE3NzIsLTUuOTc4OTUzIHogbSAwLC0xLjczNTgyNzE5IGMgLTQuMzIxNDgzNiwwIC03LjgyNDc0MDM4LDMuNDU0MDE4NDkgLTcuODI0NzQwMzgsNy43MTQ3ODAxOSAwLDQuMjYwNzI4MiAzLjUwMzI1Njc4LDcuNzE0NzQ1MiA3LjgyNDc0MDM4LDcuNzE0NzQ1MiA0LjMyMTQ0OTgsMCA3LjgyNDY5OTgsLTMuNDU0MDE3IDcuODI0Njk5OCwtNy43MTQ3NDUyIDAsLTIuMDQ2MDkxNCAtMC44MjQzOTIsLTQuMDA4MzY3MiAtMi4yOTE3NTYsLTUuNDU1MTc0NiBDIDEyLjE4MDIyNSwxLjEyOTk2NDggMTAuMTkwMDEzLDAuMzE3MTU1NjEgOC4xMTQ3NTYyLDAuMzE3MTU1NjEgWiBNIDYuOTM3NDU2Myw4LjI0MDU5ODUgNC42NzE4Njg1LDEwLjQ4NTg1MiA2LjAwODY4MTQsMTEuODc2NzI4IDguMzE3MDAzNSw5LjYwMDc5MTEgMTAuNjI1MzM3LDExLjg3NjcyOCAxMS45NjIxMzgsMTAuNDg1ODUyIDkuNjk2NTUwOCw4LjI0MDU5ODUgMTEuOTYyMTM4LDYuMDA2ODA2NiAxMC41NzMyNDYsNC42Mzc0MzM1IDguMzE3MDAzNSw2Ljg3MzQyOTcgNi4wNjA3NjA3LDQuNjM3NDMzNSA0LjY3MTg2ODUsNi4wMDY4MDY2IFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=");
    background-color: crimson;
}
.ace_icon_svg.ace_security_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMTcgMTQiIGZpbGw9Im5vbmUiPgogICAgPHBhdGggZD0iTTEwLjAwMDEgMTMuNjk5MkMxMC4wMDAxIDEzLjY5OTIgMTEuOTI0MSAxMy40NzYzIDEzIDEyLjY5OTJDMTQuNDEzOSAxMS42NzgxIDE2IDEwLjUgMTYuMTI1MSA2LjgxMTI2VjIuNTg5ODdDMTYuMTI1MSAyLjU0NzY4IDE2LjEyMjEgMi41MDYxOSAxNi4xMTY0IDIuNDY1NTlWMS43MTQ4NUgxNS4yNDE0TDE1LjIzMDcgMS43MTQ4NEwxNC42MjUxIDEuNjk5MjJWNi44MTEyM0MxNC42MjUxIDguNTEwNjEgMTQuNjI1MSA5LjQ2NDYxIDEyLjc4MjQgMTEuNzIxQzEyLjE1ODYgMTIuNDg0OCAxMC4wMDAxIDEzLjY5OTIgMTAuMDAwMSAxMy42OTkyWiIgZmlsbD0iY3JpbXNvbiIgc3Ryb2tlLXdpZHRoPSIyIi8+CiAgICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTcuMzM2MDkgMC4zNjc0NzVDNy4wMzIxNCAwLjE1MjY1MiA2LjYyNTQ4IDAuMTUzNjE0IDYuMzIyNTMgMC4zNjk5OTdMNi4zMDg2OSAwLjM3OTU1NEM2LjI5NTUzIDAuMzg4NTg4IDYuMjczODggMC40MDMyNjYgNi4yNDQxNyAwLjQyMjc4OUM2LjE4NDcxIDAuNDYxODYgNi4wOTMyMSAwLjUyMDE3MSA1Ljk3MzEzIDAuNTkxMzczQzUuNzMyNTEgMC43MzQwNTkgNS4zNzk5IDAuOTI2ODY0IDQuOTQyNzkgMS4xMjAwOUM0LjA2MTQ0IDEuNTA5NyAyLjg3NTQxIDEuODgzNzcgMS41ODk4NCAxLjg4Mzc3SDAuNzE0ODQ0VjIuNzU4NzdWNi45ODAxNUMwLjcxNDg0NCA5LjQ5Mzc0IDIuMjg4NjYgMTEuMTk3MyAzLjcwMjU0IDEyLjIxODVDNC40MTg0NSAxMi43MzU1IDUuMTI4NzQgMTMuMTA1MyA1LjY1NzMzIDEzLjM0NTdDNS45MjI4NCAxMy40NjY0IDYuMTQ1NjYgMTMuNTU1OSA2LjMwNDY1IDEzLjYxNjFDNi4zODQyMyAxMy42NDYyIDYuNDQ4MDUgMTMuNjY5IDYuNDkzNDkgMTMuNjg0OEM2LjUxNjIyIDEzLjY5MjcgNi41MzQzOCAxMy42OTg5IDYuNTQ3NjQgMTMuNzAzM0w2LjU2MzgyIDEzLjcwODdMNi41NjkwOCAxMy43MTA0TDYuNTcwOTkgMTMuNzExTDYuODM5ODQgMTMuNzUzM0w2LjU3MjQyIDEzLjcxMTVDNi43NDYzMyAxMy43NjczIDYuOTMzMzUgMTMuNzY3MyA3LjEwNzI3IDEzLjcxMTVMNy4xMDg3IDEzLjcxMUw3LjExMDYxIDEzLjcxMDRMNy4xMTU4NyAxMy43MDg3TDcuMTMyMDUgMTMuNzAzM0M3LjE0NTMxIDEzLjY5ODkgNy4xNjM0NiAxMy42OTI3IDcuMTg2MTkgMTMuNjg0OEM3LjIzMTY0IDEzLjY2OSA3LjI5NTQ2IDEzLjY0NjIgNy4zNzUwMyAxMy42MTYxQzcuNTM0MDMgMTMuNTU1OSA3Ljc1Njg1IDEzLjQ2NjQgOC4wMjIzNiAxMy4zNDU3QzguNTUwOTUgMTMuMTA1MyA5LjI2MTIzIDEyLjczNTUgOS45NzcxNSAxMi4yMTg1QzExLjM5MSAxMS4xOTczIDEyLjk2NDggOS40OTM3NyAxMi45NjQ4IDYuOTgwMThWMi43NTg4QzEyLjk2NDggMi43MTY2IDEyLjk2MTkgMi42NzUxMSAxMi45NTYxIDIuNjM0NTFWMS44ODM3N0gxMi4wODExQzEyLjA3NzUgMS44ODM3NyAxMi4wNzQgMS44ODM3NyAxMi4wNzA0IDEuODgzNzdDMTAuNzk3OSAxLjg4MDA0IDkuNjE5NjIgMS41MTEwMiA4LjczODk0IDEuMTI0ODZDOC43MzUzNCAxLjEyMzI3IDguNzMxNzQgMS4xMjE2OCA4LjcyODE0IDEuMTIwMDlDOC4yOTEwMyAwLjkyNjg2NCA3LjkzODQyIDAuNzM0MDU5IDcuNjk3NzkgMC41OTEzNzNDNy41Nzc3MiAwLjUyMDE3MSA3LjQ4NjIyIDAuNDYxODYgNy40MjY3NiAwLjQyMjc4OUM3LjM5NzA1IDAuNDAzMjY2IDcuMzc1MzkgMC4zODg1ODggNy4zNjIyNCAwLjM3OTU1NEw3LjM0ODk2IDAuMzcwMzVDNy4zNDg5NiAwLjM3MDM1IDcuMzQ4NDcgMC4zNzAwMiA3LjM0NTYzIDAuMzc0MDU0TDcuMzM3NzkgMC4zNjg2NTlMNy4zMzYwOSAwLjM2NzQ3NVpNOC4wMzQ3MSAyLjcyNjkxQzguODYwNCAzLjA5MDYzIDkuOTYwNjYgMy40NjMwOSAxMS4yMDYxIDMuNTg5MDdWNi45ODAxNUgxMS4yMTQ4QzExLjIxNDggOC42Nzk1MyAxMC4xNjM3IDkuOTI1MDcgOC45NTI1NCAxMC43OTk4QzguMzU1OTUgMTEuMjMwNiA3Ljc1Mzc0IDExLjU0NTQgNy4yOTc5NiAxMS43NTI3QzcuMTE2NzEgMTEuODM1MSA2Ljk2MDYyIDExLjg5OTYgNi44Mzk4NCAxMS45NDY5QzYuNzE5MDYgMTEuODk5NiA2LjU2Mjk3IDExLjgzNTEgNi4zODE3MyAxMS43NTI3QzUuOTI1OTUgMTEuNTQ1NCA1LjMyMzczIDExLjIzMDYgNC43MjcxNSAxMC43OTk4QzMuNTE2MDMgOS45MjUwNyAyLjQ2NDg0IDguNjc5NTUgMi40NjQ4NCA2Ljk4MDE4VjMuNTg5MDlDMy43MTczOCAzLjQ2MjM5IDQuODIzMDggMy4wODYzOSA1LjY1MDMzIDIuNzIwNzFDNi4xNDIyOCAyLjUwMzI0IDYuNTQ0ODUgMi4yODUzNyA2LjgzMjU0IDIuMTE2MjRDNy4xMjE4MSAyLjI4NTM1IDcuNTI3IDIuNTAzNTIgOC4wMjE5NiAyLjcyMTMxQzguMDI2MiAyLjcyMzE3IDguMDMwNDUgMi43MjUwNCA4LjAzNDcxIDIuNzI2OTFaTTUuOTY0ODQgMy40MDE0N1Y3Ljc3NjQ3SDcuNzE0ODRWMy40MDE0N0g1Ljk2NDg0Wk01Ljk2NDg0IDEwLjQwMTVWOC42NTE0N0g3LjcxNDg0VjEwLjQwMTVINS45NjQ4NFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=");
    background-color: crimson;
}
.ace_icon_svg.ace_warning_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC43NzY5IDE0LjczMzdMOC42NTE5MiAyLjQ4MzY5QzguMzI5NDYgMS44Mzg3NyA3LjQwOTEzIDEuODM4NzcgNy4wODY2NyAyLjQ4MzY5TDAuOTYxNjY5IDE0LjczMzdDMC42NzA3NzUgMTUuMzE1NSAxLjA5MzgzIDE2IDEuNzQ0MjkgMTZIMTMuOTk0M0MxNC42NDQ4IDE2IDE1LjA2NzggMTUuMzE1NSAxNC43NzY5IDE0LjczMzdaTTMuMTYwMDcgMTQuMjVMNy44NjkyOSA0LjgzMTU2TDEyLjU3ODUgMTQuMjVIMy4xNjAwN1pNOC43NDQyOSAxMS42MjVWMTMuMzc1SDYuOTk0MjlWMTEuNjI1SDguNzQ0MjlaTTYuOTk0MjkgMTAuNzVWNy4yNUg4Ljc0NDI5VjEwLjc1SDYuOTk0MjlaIiBmaWxsPSIjRUM3MjExIi8+CjxwYXRoIGQ9Ik0xMS4xOTkxIDIuOTUyMzhDMTAuODgwOSAyLjMxNDY3IDEwLjM1MzcgMS44MDUyNiA5LjcwNTUgMS41MDlMMTEuMDQxIDEuMDY5NzhDMTEuNjg4MyAwLjk0OTgxNCAxMi4zMzcgMS4yNzI2MyAxMi42MzE3IDEuODYxNDFMMTcuNjEzNiAxMS44MTYxQzE4LjM1MjcgMTMuMjkyOSAxNy41OTM4IDE1LjA4MDQgMTYuMDE4IDE1LjU3NDVDMTYuNDA0NCAxNC40NTA3IDE2LjMyMzEgMTMuMjE4OCAxNS43OTI0IDEyLjE1NTVMMTEuMTk5MSAyLjk1MjM4WiIgZmlsbD0iI0VDNzIxMSIvPgo8L3N2Zz4=");
    background-color: darkorange;
}

.ace_scrollbar {
    contain: strict;
    position: absolute;
    right: 0;
    bottom: 0;
    z-index: 6;
}

.ace_scrollbar-inner {
    position: absolute;
    cursor: text;
    left: 0;
    top: 0;
}

.ace_scrollbar-v{
    overflow-x: hidden;
    overflow-y: scroll;
    top: 0;
}

.ace_scrollbar-h {
    overflow-x: scroll;
    overflow-y: hidden;
    left: 0;
}

.ace_print-margin {
    position: absolute;
    height: 100%;
}

.ace_text-input {
    position: absolute;
    z-index: 0;
    width: 0.5em;
    height: 1em;
    opacity: 0;
    background: transparent;
    -moz-appearance: none;
    appearance: none;
    border: none;
    resize: none;
    outline: none;
    overflow: hidden;
    font: inherit;
    padding: 0 1px;
    margin: 0 -1px;
    contain: strict;
    -ms-user-select: text;
    -moz-user-select: text;
    -webkit-user-select: text;
    user-select: text;
    /*with \`pre-line\` chrome inserts &nbsp; instead of space*/
    white-space: pre!important;
}
.ace_text-input.ace_composition {
    background: transparent;
    color: inherit;
    z-index: 1000;
    opacity: 1;
}
.ace_composition_placeholder { color: transparent }
.ace_composition_marker { 
    border-bottom: 1px solid;
    position: absolute;
    border-radius: 0;
    margin-top: 1px;
}

[ace_nocontext=true] {
    transform: none!important;
    filter: none!important;
    clip-path: none!important;
    mask : none!important;
    contain: none!important;
    perspective: none!important;
    mix-blend-mode: initial!important;
    z-index: auto;
}

.ace_layer {
    z-index: 1;
    position: absolute;
    overflow: hidden;
    /* workaround for chrome bug https://github.com/ajaxorg/ace/issues/2312*/
    word-wrap: normal;
    white-space: pre;
    height: 100%;
    width: 100%;
    box-sizing: border-box;
    /* setting pointer-events: auto; on node under the mouse, which changes
        during scroll, will break mouse wheel scrolling in Safari */
    pointer-events: none;
}

.ace_gutter-layer {
    position: relative;
    width: auto;
    text-align: right;
    pointer-events: auto;
    height: 1000000px;
    contain: style size layout;
}

.ace_text-layer {
    font: inherit !important;
    position: absolute;
    height: 1000000px;
    width: 1000000px;
    contain: style size layout;
}

.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {
    contain: style size layout;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
}

.ace_hidpi .ace_text-layer,
.ace_hidpi .ace_gutter-layer,
.ace_hidpi .ace_content,
.ace_hidpi .ace_gutter {
    contain: strict;
}
.ace_hidpi .ace_text-layer > .ace_line, 
.ace_hidpi .ace_text-layer > .ace_line_group {
    contain: strict;
}

.ace_cjk {
    display: inline-block;
    text-align: center;
}

.ace_cursor-layer {
    z-index: 4;
}

.ace_cursor {
    z-index: 4;
    position: absolute;
    box-sizing: border-box;
    border-left: 2px solid;
    /* workaround for smooth cursor repaintng whole screen in chrome */
    transform: translatez(0);
}

.ace_multiselect .ace_cursor {
    border-left-width: 1px;
}

.ace_slim-cursors .ace_cursor {
    border-left-width: 1px;
}

.ace_overwrite-cursors .ace_cursor {
    border-left-width: 0;
    border-bottom: 1px solid;
}

.ace_hidden-cursors .ace_cursor {
    opacity: 0.2;
}

.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {
    opacity: 0;
}

.ace_smooth-blinking .ace_cursor {
    transition: opacity 0.18s;
}

.ace_animate-blinking .ace_cursor {
    animation-duration: 1000ms;
    animation-timing-function: step-end;
    animation-name: blink-ace-animate;
    animation-iteration-count: infinite;
}

.ace_animate-blinking.ace_smooth-blinking .ace_cursor {
    animation-duration: 1000ms;
    animation-timing-function: ease-in-out;
    animation-name: blink-ace-animate-smooth;
}
    
@keyframes blink-ace-animate {
    from, to { opacity: 1; }
    60% { opacity: 0; }
}

@keyframes blink-ace-animate-smooth {
    from, to { opacity: 1; }
    45% { opacity: 1; }
    60% { opacity: 0; }
    85% { opacity: 0; }
}

.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {
    position: absolute;
    z-index: 3;
}

.ace_marker-layer .ace_selection {
    position: absolute;
    z-index: 5;
}

.ace_marker-layer .ace_bracket {
    position: absolute;
    z-index: 6;
}

.ace_marker-layer .ace_error_bracket {
    position: absolute;
    border-bottom: 1px solid #DE5555;
    border-radius: 0;
}

.ace_marker-layer .ace_active-line {
    position: absolute;
    z-index: 2;
}

.ace_marker-layer .ace_selected-word {
    position: absolute;
    z-index: 4;
    box-sizing: border-box;
}

.ace_line .ace_fold {
    box-sizing: border-box;

    display: inline-block;
    height: 11px;
    margin-top: -2px;
    vertical-align: middle;

    background-image:
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=");
    background-repeat: no-repeat, repeat-x;
    background-position: center center, top left;
    color: transparent;

    border: 1px solid black;
    border-radius: 2px;

    cursor: pointer;
    pointer-events: auto;
}

.ace_dark .ace_fold {
}

.ace_fold:hover{
    background-image:
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC");
}

.ace_tooltip {
    background-color: #f5f5f5;
    border: 1px solid gray;
    border-radius: 1px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    color: black;
    padding: 3px 4px;
    position: fixed;
    z-index: 999999;
    box-sizing: border-box;
    cursor: default;
    white-space: pre-wrap;
    word-wrap: break-word;
    line-height: normal;
    font-style: normal;
    font-weight: normal;
    letter-spacing: normal;
    pointer-events: none;
    overflow: auto;
    max-width: min(33em, 66vw);
    overscroll-behavior: contain;
}
.ace_tooltip pre {
    white-space: pre-wrap;
}

.ace_tooltip.ace_dark {
    background-color: #636363;
    color: #fff;
}

.ace_tooltip:focus {
    outline: 1px solid #5E9ED6;
}

.ace_icon {
    display: inline-block;
    width: 18px;
    vertical-align: top;
}

.ace_icon_svg {
    display: inline-block;
    width: 12px;
    vertical-align: top;
    -webkit-mask-repeat: no-repeat;
    -webkit-mask-size: 12px;
    -webkit-mask-position: center;
}

.ace_folding-enabled > .ace_gutter-cell, .ace_folding-enabled > .ace_gutter-cell_svg-icons {
    padding-right: 13px;
}

.ace_fold-widget, .ace_custom-widget {
    box-sizing: border-box;

    margin: 0 -12px 0 1px;
    display: none;
    width: 11px;
    vertical-align: top;

    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: center;

    border-radius: 3px;
    
    border: 1px solid transparent;
    cursor: pointer;
    pointer-events: auto;
}

.ace_custom-widget {
    background: none;
}

.ace_folding-enabled .ace_fold-widget {
    display: inline-block;   
}

.ace_fold-widget.ace_end {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==");
}

.ace_fold-widget.ace_closed {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==");
}

.ace_fold-widget:hover {
    border: 1px solid rgba(0, 0, 0, 0.3);
    background-color: rgba(255, 255, 255, 0.2);
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);
}

.ace_fold-widget:active {
    border: 1px solid rgba(0, 0, 0, 0.4);
    background-color: rgba(0, 0, 0, 0.05);
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
}
/**
 * Dark version for fold widgets
 */
.ace_dark .ace_fold-widget {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC");
}
.ace_dark .ace_fold-widget.ace_end {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==");
}
.ace_dark .ace_fold-widget.ace_closed {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==");
}
.ace_dark .ace_fold-widget:hover {
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
    background-color: rgba(255, 255, 255, 0.1);
}
.ace_dark .ace_fold-widget:active {
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
}

.ace_inline_button {
    border: 1px solid lightgray;
    display: inline-block;
    margin: -1px 8px;
    padding: 0 5px;
    pointer-events: auto;
    cursor: pointer;
}
.ace_inline_button:hover {
    border-color: gray;
    background: rgba(200,200,200,0.2);
    display: inline-block;
    pointer-events: auto;
}

.ace_fold-widget.ace_invalid {
    background-color: #FFB4B4;
    border-color: #DE5555;
}

.ace_fade-fold-widgets .ace_fold-widget {
    transition: opacity 0.4s ease 0.05s;
    opacity: 0;
}

.ace_fade-fold-widgets:hover .ace_fold-widget {
    transition: opacity 0.05s ease 0.05s;
    opacity:1;
}

.ace_underline {
    text-decoration: underline;
}

.ace_bold {
    font-weight: bold;
}

.ace_nobold .ace_bold {
    font-weight: normal;
}

.ace_italic {
    font-style: italic;
}


.ace_error-marker {
    background-color: rgba(255, 0, 0,0.2);
    position: absolute;
    z-index: 9;
}

.ace_highlight-marker {
    background-color: rgba(255, 255, 0,0.2);
    position: absolute;
    z-index: 8;
}

.ace_mobile-menu {
    position: absolute;
    line-height: 1.5;
    border-radius: 4px;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    background: white;
    box-shadow: 1px 3px 2px grey;
    border: 1px solid #dcdcdc;
    color: black;
}
.ace_dark > .ace_mobile-menu {
    background: #333;
    color: #ccc;
    box-shadow: 1px 3px 2px grey;
    border: 1px solid #444;

}
.ace_mobile-button {
    padding: 2px;
    cursor: pointer;
    overflow: hidden;
}
.ace_mobile-button:hover {
    background-color: #eee;
    opacity:1;
}
.ace_mobile-button:active {
    background-color: #ddd;
}

.ace_placeholder {
    position: relative;
    font-family: arial;
    transform: scale(0.9);
    transform-origin: left;
    white-space: pre;
    opacity: 0.7;
    margin: 0 10px;
    z-index: 1;
}

.ace_ghost_text {
    opacity: 0.5;
    font-style: italic;
}

.ace_ghost_text_container > div {
    white-space: pre;
}

.ghost_text_line_wrapped::after {
    content: "";
    position: absolute;
}

.ace_lineWidgetContainer.ace_ghost_text {
    margin: 0px 4px
}

.ace_screenreader-only {
    position:absolute;
    left:-10000px;
    top:auto;
    width:1px;
    height:1px;
    overflow:hidden;
}

.ace_hidden_token {
    display: none;
}`;


/***/ }),

/***/ 53509:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./edit_session").EditSession} EditSession
 * @typedef {import("../ace-internal").Ace.Point} Point
 */
var Range = (__webpack_require__(91902)/* .Range */ .Q);
var comparePoints = Range.comparePoints;

class RangeList {
    
    constructor() {
        this.ranges = [];
        this.$bias = 1;
    }

    /**
     * @param {Point} pos
     * @param {boolean} [excludeEdges]
     * @param {number} [startIndex]
     * @return {number}
     */
    pointIndex(pos, excludeEdges, startIndex) {
        var list = this.ranges;

        for (var i = startIndex || 0; i < list.length; i++) {
            var range = list[i];
            var cmpEnd = comparePoints(pos, range.end);
            if (cmpEnd > 0)
                continue;
            var cmpStart = comparePoints(pos, range.start);
            if (cmpEnd === 0)
                return excludeEdges && cmpStart !== 0 ? -i-2 : i;
            if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))
                return i;

            return -i-1;
        }
        return -i - 1;
    }

    /**
     * @param {Range} range
     */
    add(range) {
        var excludeEdges = !range.isEmpty();
        var startIndex = this.pointIndex(range.start, excludeEdges);
        if (startIndex < 0)
            startIndex = -startIndex - 1;

        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);

        if (endIndex < 0)
            endIndex = -endIndex - 1;
        else
            endIndex++;
        return this.ranges.splice(startIndex, endIndex - startIndex, range);
    }

    /**
     * @param {Range[]} list
     */
    addList(list) {
        var removed = [];
        for (var i = list.length; i--; ) {
            removed.push.apply(removed, this.add(list[i]));
        }
        return removed;
    }

    /**
     * @param {Point} pos
     */
    substractPoint(pos) {
        var i = this.pointIndex(pos);

        if (i >= 0)
            return this.ranges.splice(i, 1);
    }

    // merge overlapping ranges
    merge() {
        var removed = [];
        var list = this.ranges;
        
        list = list.sort(function(a, b) {
            return comparePoints(a.start, b.start);
        });
        
        var next = list[0], range;
        for (var i = 1; i < list.length; i++) {
            range = next;
            next = list[i];
            var cmp = comparePoints(range.end, next.start);
            if (cmp < 0)
                continue;

            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
                continue;

            if (comparePoints(range.end, next.end) < 0) {
                range.end.row = next.end.row;
                range.end.column = next.end.column;
            }

            list.splice(i, 1);
            removed.push(next);
            next = range;
            i--;
        }
        
        this.ranges = list;

        return removed;
    }

    /**
     * @param {number} row
     * @param {number} column
     */
    contains(row, column) {
        return this.pointIndex({row: row, column: column}) >= 0;
    }

    /**
     * @param {Point} pos
     */
    containsPoint(pos) {
        return this.pointIndex(pos) >= 0;
    }

    /**
     * @param {Point} pos
     */
    rangeAtPoint(pos) {
        var i = this.pointIndex(pos);
        if (i >= 0)
            return this.ranges[i];
    }


    /**
     * @param {number} startRow
     * @param {number} endRow
     */
    clipRows(startRow, endRow) {
        var list = this.ranges;
        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
            return [];

        var startIndex = this.pointIndex({row: startRow, column: 0});
        if (startIndex < 0)
            startIndex = -startIndex - 1;
        //@ts-expect-error TODO: potential wrong argument
        var endIndex = this.pointIndex({row: endRow, column: 0}, startIndex);
        if (endIndex < 0)
            endIndex = -endIndex - 1;

        var clipped = [];
        for (var i = startIndex; i < endIndex; i++) {
            clipped.push(list[i]);
        }
        return clipped;
    }

    removeAll() {
        return this.ranges.splice(0, this.ranges.length);
    }

    /**
     * @param {EditSession} session
     */
    attach(session) {
        if (this.session)
            this.detach();

        this.session = session;
        this.onChange = this.$onChange.bind(this);

        this.session.on('change', this.onChange);
    }

    detach() {
        if (!this.session)
            return;
        this.session.removeListener('change', this.onChange);
        this.session = null;
    }

    /**
     * @param {import("../ace-internal").Ace.Delta} delta
     */
    $onChange(delta) {
        var start = delta.start;
        var end = delta.end;
        var startRow = start.row;
        var endRow = end.row;
        var ranges = this.ranges;
        for (var i = 0, n = ranges.length; i < n; i++) {
            var r = ranges[i];
            if (r.end.row >= startRow)
                break;
        }
        
        if (delta.action == "insert") {
            var lineDif = endRow - startRow;
            var colDiff = -start.column + end.column;
            for (; i < n; i++) {
                var r = ranges[i];
                if (r.start.row > startRow)
                    break;
    
                if (r.start.row == startRow && r.start.column >= start.column) {
                    if (r.start.column == start.column && this.$bias <= 0) {
                        // do nothing
                    } else {
                        r.start.column += colDiff;
                        r.start.row += lineDif;
                    }
                }
                if (r.end.row == startRow && r.end.column >= start.column) {
                    if (r.end.column == start.column && this.$bias < 0) {
                        continue;
                    }
                    // special handling for the case when two ranges share an edge
                    if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
                        if (r.end.column > r.start.column && r.end.column == ranges[i+1].start.column)
                            r.end.column -= colDiff;
                    }
                    r.end.column += colDiff;
                    r.end.row += lineDif;
                }
            }
        } else {
            var lineDif = startRow - endRow;
            var colDiff = start.column - end.column;
            for (; i < n; i++) {
                var r = ranges[i];
                
                if (r.start.row > endRow)
                    break;
                    
                if (r.end.row < endRow
                    && (
                        startRow < r.end.row 
                        || startRow == r.end.row && start.column < r.end.column
                    )
                ) {
                    r.end.row = startRow;
                    r.end.column = start.column;
                }
                else if (r.end.row == endRow) {
                    if (r.end.column <= end.column) {
                        if (lineDif || r.end.column > start.column) {
                            r.end.column = start.column;
                            r.end.row = start.row;
                        }
                    }
                    else {
                        r.end.column += colDiff;
                        r.end.row += lineDif;
                    }
                }
                else if (r.end.row > endRow) {
                    r.end.row += lineDif;
                }
                
                if (r.start.row < endRow
                    && (
                        startRow < r.start.row 
                        || startRow == r.start.row && start.column < r.start.column
                    )
                ) {
                    r.start.row = startRow;
                    r.start.column = start.column;
                }
                else if (r.start.row == endRow) {
                    if (r.start.column <= end.column) {
                        if (lineDif || r.start.column > start.column) {
                            r.start.column = start.column;
                            r.start.row = start.row;
                        }
                    }
                    else {
                        r.start.column += colDiff;
                        r.start.row += lineDif;
                    }
                }
                else if (r.start.row > endRow) {
                    r.start.row += lineDif;
                }
            }
        }

        if (lineDif != 0 && i < n) {
            for (; i < n; i++) {
                var r = ranges[i];
                r.start.row += lineDif;
                r.end.row += lineDif;
            }
        }
    }

}

RangeList.prototype.comparePoints = comparePoints;

exports.U = RangeList;


/***/ }),

/***/ 55119:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var MouseEvent = (__webpack_require__(85519)/* .MouseEvent */ .C);
var event = __webpack_require__(19631);
var dom = __webpack_require__(71435);

exports.A = function(el, editor) {
    var mode = "scroll";
    var startX;
    var startY;
    var touchStartT;
    var lastT;
    var longTouchTimer;
    var animationTimer;
    var animationSteps = 0;
    var pos;
    var clickCount = 0;
    var vX = 0;
    var vY = 0;
    var pressed;
    var contextMenu;
    
    function createContextMenu() {
        var clipboard = window.navigator && window.navigator.clipboard;
        var isOpen = false;
        var updateMenu = function() {
            var selected = editor.getCopyText();
            var hasUndo = editor.session.getUndoManager().hasUndo();
            contextMenu.replaceChild(
                dom.buildDom(isOpen ? ["span",
                    !selected && canExecuteCommand("selectall") && ["span", { class: "ace_mobile-button", action: "selectall" }, "Select All"],
                    selected && canExecuteCommand("copy") && ["span", { class: "ace_mobile-button", action: "copy" }, "Copy"],
                    selected && canExecuteCommand("cut") && ["span", { class: "ace_mobile-button", action: "cut" }, "Cut"],
                    clipboard && canExecuteCommand("paste") && ["span", { class: "ace_mobile-button", action: "paste" }, "Paste"],
                    hasUndo && canExecuteCommand("undo") && ["span", { class: "ace_mobile-button", action: "undo" }, "Undo"],
                    canExecuteCommand("find") && ["span", { class: "ace_mobile-button", action: "find" }, "Find"],
                    canExecuteCommand("openCommandPalette") && ["span", { class: "ace_mobile-button", action: "openCommandPalette" }, "Palette"]
                ] : ["span"]),
                contextMenu.firstChild
            );
        };
        
        var canExecuteCommand = function (/** @type {string} */ cmd) {
            return editor.commands.canExecute(cmd, editor);
        };
        
        var handleClick = function(e) {
            var action = e.target.getAttribute("action");

            if (action == "more" || !isOpen) {
                isOpen = !isOpen;
                return updateMenu();
            }
            if (action == "paste") {
                clipboard.readText().then(function (text) {
                    editor.execCommand(action, text);
                });
            }
            else if (action) {
                if (action == "cut" || action == "copy") {
                    if (clipboard)
                        clipboard.writeText(editor.getCopyText());
                    else
                        document.execCommand("copy");
                }
                editor.execCommand(action);
            }
            contextMenu.firstChild.style.display = "none";
            isOpen = false;
            if (action != "openCommandPalette")
                editor.focus();
        };
        contextMenu = dom.buildDom(["div",
            {
                class: "ace_mobile-menu",
                ontouchstart: function(e) {
                    mode = "menu";
                    e.stopPropagation();
                    e.preventDefault();
                    editor.textInput.focus();
                },
                ontouchend: function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    handleClick(e);
                },
                onclick: handleClick
            },
            ["span"],
            ["span", { class: "ace_mobile-button", action: "more" }, "..."]
        ], editor.container);
    }
    function showContextMenu() {
        if (!editor.getOption("enableMobileMenu")) {
            if (contextMenu) {
                hideContextMenu();
            }
            return;
        }
        if (!contextMenu) createContextMenu();
        var cursor = editor.selection.cursor;
        var pagePos = editor.renderer.textToScreenCoordinates(cursor.row, cursor.column);
        var leftOffset = editor.renderer.textToScreenCoordinates(0, 0).pageX;
        var scrollLeft = editor.renderer.scrollLeft;
        var rect = editor.container.getBoundingClientRect();
        contextMenu.style.top = pagePos.pageY - rect.top - 3 + "px";
        if (pagePos.pageX - rect.left < rect.width - 70) {
            contextMenu.style.left = "";
            contextMenu.style.right = "10px";
        } else {
            contextMenu.style.right = "";
            contextMenu.style.left = leftOffset + scrollLeft - rect.left + "px";
        }
        contextMenu.style.display = "";
        contextMenu.firstChild.style.display = "none";
        editor.on("input", hideContextMenu);
    }
    function hideContextMenu(e) {
        if (contextMenu)
            contextMenu.style.display = "none";
        editor.off("input", hideContextMenu);
    }

    function handleLongTap() {
        longTouchTimer = null;
        clearTimeout(longTouchTimer);
        var range = editor.selection.getRange();
        var inSelection = range.contains(pos.row, pos.column);
        if (range.isEmpty() || !inSelection) {
            editor.selection.moveToPosition(pos);
            editor.selection.selectWord();
        }
        mode = "wait";
        showContextMenu();
    }
    function switchToSelectionMode() {
        longTouchTimer = null;
        clearTimeout(longTouchTimer);
        editor.selection.moveToPosition(pos);
        var range = clickCount >= 2
            ? editor.selection.getLineRange(pos.row)
            : editor.session.getBracketRange(pos);
        if (range && !range.isEmpty()) {
            editor.selection.setRange(range);
        } else {
            editor.selection.selectWord();
        }
        mode = "wait";
    }
    event.addListener(el, "contextmenu", function(e) {
        if (!pressed) return;
        var textarea = editor.textInput.getElement();
        textarea.focus();
    }, editor);
    event.addListener(el, "touchstart", function (e) {
        var touches = e.touches;
        if (longTouchTimer || touches.length > 1) {
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
            touchStartT = -1;
            mode = "zoom";
            return;
        }
        
        pressed = editor.$mouseHandler.isMousePressed = true;
        var h = editor.renderer.layerConfig.lineHeight;
        var w = editor.renderer.layerConfig.lineHeight;
        var t = e.timeStamp;
        lastT = t;
        var touchObj = touches[0];
        var x = touchObj.clientX;
        var y = touchObj.clientY;
        // reset clickCount if the new touch is far from the old one
        if (Math.abs(startX - x) + Math.abs(startY - y) > h)
            touchStartT = -1;
        
        startX = e.clientX = x;
        startY = e.clientY = y;
        vX = vY = 0;
        
        var ev = new MouseEvent(e, editor);
        pos = ev.getDocumentPosition();

        if (t - touchStartT < 500 && touches.length == 1 && !animationSteps) {
            clickCount++;
            e.preventDefault();
            e.button = 0;
            switchToSelectionMode();
        } else {
            clickCount = 0;
            var cursor = editor.selection.cursor;
            var anchor = editor.selection.isEmpty() ? cursor : editor.selection.anchor;
            
            var cursorPos = editor.renderer.$cursorLayer.getPixelPosition(cursor, true);
            var anchorPos = editor.renderer.$cursorLayer.getPixelPosition(anchor, true);
            var rect = editor.renderer.scroller.getBoundingClientRect();
            var offsetTop = editor.renderer.layerConfig.offset;
            var offsetLeft = editor.renderer.scrollLeft;
            var weightedDistance = function(x, y) {
                x = x / w;
                y = y / h - 0.75;
                return x * x + y * y;
            };
            
            if (e.clientX < rect.left) {
                mode = "zoom";
                return;
            }
            
            var diff1 = weightedDistance(
                e.clientX - rect.left - cursorPos.left + offsetLeft,
                e.clientY - rect.top - cursorPos.top + offsetTop
            );
            var diff2 = weightedDistance(
                e.clientX - rect.left - anchorPos.left + offsetLeft,
                e.clientY - rect.top - anchorPos.top + offsetTop
            );
            if (diff1 < 3.5 && diff2 < 3.5)
                mode = diff1 > diff2 ? "cursor" : "anchor";
                
            if (diff2 < 3.5)
                mode = "anchor";
            else if (diff1 < 3.5)
                mode = "cursor";
            else
                mode = "scroll";
            longTouchTimer = setTimeout(handleLongTap, 450);
        }
        touchStartT = t;
    }, editor);

    event.addListener(el, "touchend", function (e) {
        pressed = editor.$mouseHandler.isMousePressed = false;
        if (animationTimer) clearInterval(animationTimer);
        if (mode == "zoom") {
            mode = "";
            animationSteps = 0;
        } else if (longTouchTimer) {
            editor.selection.moveToPosition(pos);
            animationSteps = 0;
            showContextMenu();
        } else if (mode == "scroll") {
            animate();
            hideContextMenu();
        } else {
            showContextMenu();
        }
        clearTimeout(longTouchTimer);
        longTouchTimer = null;
    }, editor);
    event.addListener(el, "touchmove", function (e) {
        if (longTouchTimer) {
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
        }
        var touches = e.touches;
        if (touches.length > 1 || mode == "zoom") return;

        var touchObj = touches[0];

        var wheelX = startX - touchObj.clientX;
        var wheelY = startY - touchObj.clientY;

        if (mode == "wait") {
            if (wheelX * wheelX + wheelY * wheelY > 4)
                mode = "cursor";
            else
                return e.preventDefault();
        }

        startX = touchObj.clientX;
        startY = touchObj.clientY;

        e.clientX = touchObj.clientX;
        e.clientY = touchObj.clientY;

        var t = e.timeStamp;
        var dt = t - lastT;
        lastT = t;
        if (mode == "scroll") {
            var mouseEvent = new MouseEvent(e, editor);
            mouseEvent.speed = 1;
            mouseEvent.wheelX = wheelX;
            mouseEvent.wheelY = wheelY;
            if (10 * Math.abs(wheelX) < Math.abs(wheelY)) wheelX = 0;
            if (10 * Math.abs(wheelY) < Math.abs(wheelX)) wheelY = 0;
            if (dt != 0) {
                vX = wheelX / dt;
                vY = wheelY / dt;
            }
            editor._emit("mousewheel", mouseEvent);
            if (!mouseEvent.propagationStopped) {
                vX = vY = 0;
            }
        }
        else {
            var ev = new MouseEvent(e, editor);
            var pos = ev.getDocumentPosition();
            if (mode == "cursor")
                editor.selection.moveCursorToPosition(pos);
            else if (mode == "anchor")
                editor.selection.setSelectionAnchor(pos.row, pos.column);
            editor.renderer.scrollCursorIntoView(pos);
            e.preventDefault();
        }
    }, editor);

    function animate() {
        animationSteps += 60;
        animationTimer = setInterval(function() {
            if (animationSteps-- <= 0) {
                clearInterval(animationTimer);
                animationTimer = null;
            }
            if (Math.abs(vX) < 0.01) vX = 0;
            if (Math.abs(vY) < 0.01) vY = 0;
            if (animationSteps < 20) vX = 0.9 * vX;
            if (animationSteps < 20) vY = 0.9 * vY;
            var oldScrollTop = editor.session.getScrollTop();
            editor.renderer.scrollBy(10 * vX, 10 * vY);
            if (oldScrollTop == editor.session.getScrollTop())
                animationSteps = 0;
        }, 10);
    }
};


/***/ }),

/***/ 58298:
/***/ ((__unused_webpack_module, exports) => {

exports.K = function preventParentScroll(event) {
    event.stopPropagation();
    var target = event.currentTarget;
    var contentOverflows = target.scrollHeight > target.clientHeight;
    if (!contentOverflows) {
        event.preventDefault();
    }
};

/***/ }),

/***/ 59781:
/***/ ((module) => {

module.exports = `.ace-tm .ace_gutter {
  background: #f0f0f0;
  color: #333;
}

.ace-tm .ace_print-margin {
  width: 1px;
  background: #e8e8e8;
}

.ace-tm .ace_fold {
    background-color: #6B72E6;
}

.ace-tm {
  background-color: #FFFFFF;
  color: black;
}

.ace-tm .ace_cursor {
  color: black;
}
        
.ace-tm .ace_invisible {
  color: rgb(191, 191, 191);
}

.ace-tm .ace_storage,
.ace-tm .ace_keyword {
  color: blue;
}

.ace-tm .ace_constant {
  color: rgb(197, 6, 11);
}

.ace-tm .ace_constant.ace_buildin {
  color: rgb(88, 72, 246);
}

.ace-tm .ace_constant.ace_language {
  color: rgb(88, 92, 246);
}

.ace-tm .ace_constant.ace_library {
  color: rgb(6, 150, 14);
}

.ace-tm .ace_invalid {
  background-color: rgba(255, 0, 0, 0.1);
  color: red;
}

.ace-tm .ace_support.ace_function {
  color: rgb(60, 76, 114);
}

.ace-tm .ace_support.ace_constant {
  color: rgb(6, 150, 14);
}

.ace-tm .ace_support.ace_type,
.ace-tm .ace_support.ace_class {
  color: rgb(109, 121, 222);
}

.ace-tm .ace_keyword.ace_operator {
  color: rgb(104, 118, 135);
}

.ace-tm .ace_string {
  color: rgb(3, 106, 7);
}

.ace-tm .ace_comment {
  color: rgb(76, 136, 107);
}

.ace-tm .ace_comment.ace_doc {
  color: rgb(0, 102, 255);
}

.ace-tm .ace_comment.ace_doc.ace_tag {
  color: rgb(128, 159, 191);
}

.ace-tm .ace_constant.ace_numeric {
  color: rgb(0, 0, 205);
}

.ace-tm .ace_variable {
  color: rgb(49, 132, 149);
}

.ace-tm .ace_xml-pe {
  color: rgb(104, 104, 91);
}

.ace-tm .ace_entity.ace_name.ace_function {
  color: #0000A2;
}


.ace-tm .ace_heading {
  color: rgb(12, 7, 255);
}

.ace-tm .ace_list {
  color:rgb(185, 6, 144);
}

.ace-tm .ace_meta.ace_tag {
  color:rgb(0, 22, 142);
}

.ace-tm .ace_string.ace_regex {
  color: rgb(255, 0, 0)
}

.ace-tm .ace_marker-layer .ace_selection {
  background: rgb(181, 213, 255);
}
.ace-tm.ace_multiselect .ace_selection.ace_start {
  box-shadow: 0 0 3px 0px white;
}
.ace-tm .ace_marker-layer .ace_step {
  background: rgb(252, 255, 0);
}

.ace-tm .ace_marker-layer .ace_stack {
  background: rgb(164, 229, 101);
}

.ace-tm .ace_marker-layer .ace_bracket {
  margin: -1px 0 0 -1px;
  border: 1px solid rgb(192, 192, 192);
}

.ace-tm .ace_marker-layer .ace_active-line {
  background: rgba(0, 0, 0, 0.07);
}

.ace-tm .ace_gutter-active-line {
    background-color : #dcdcdc;
}

.ace-tm .ace_marker-layer .ace_selected-word {
  background: rgb(250, 250, 255);
  border: 1px solid rgb(200, 200, 250);
}

.ace-tm .ace_indent-guide {
  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;
}

.ace-tm .ace_indent-guide-active {
  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;
}
`;


/***/ }),

/***/ 59864:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

/**
 * @typedef {import("./editor").Editor} Editor
 * @typedef {import("./mouse/mouse_event").MouseEvent} MouseEvent
 * @typedef {import("./edit_session").EditSession} EditSession
 */

var dom = __webpack_require__(71435);
var event = __webpack_require__(19631);
var Range = (__webpack_require__(91902)/* .Range */ .Q);
var preventParentScroll = (__webpack_require__(58298)/* .preventParentScroll */ .K);

var CLASSNAME = "ace_tooltip";

class Tooltip {
    /**
     * @param {Element} parentNode
     **/
    constructor(parentNode) {
        this.isOpen = false;
        this.$element = null;
        this.$parentNode = parentNode;
    }

    $init() {
        this.$element = dom.createElement("div");
        this.$element.className = CLASSNAME;
        this.$element.style.display = "none";
        this.$parentNode.appendChild(this.$element);
        return this.$element;
    }

    /**
     * @returns {HTMLElement}
     **/
    getElement() {
        return this.$element || this.$init();
    }

    /**
     * @param {String} text
     **/
    setText(text) {
        this.getElement().textContent = text;
    }

    /**
     * @param {String} html
     **/
    setHtml(html) {
        this.getElement().innerHTML = html;
    }

    /**
     * @param {Number} x
     * @param {Number} y
     **/
    setPosition(x, y) {
        this.getElement().style.left = x + "px";
        this.getElement().style.top = y + "px";
    }

    /**
     * @param {String} className
     **/
    setClassName(className) {
        dom.addCssClass(this.getElement(), className);
    }

    /**
     * @param {import("../ace-internal").Ace.Theme} theme
     */
    setTheme(theme) {
        if (this.theme) {
            this.theme.isDark && dom.removeCssClass(this.getElement(), "ace_dark");
            this.theme.cssClass && dom.removeCssClass(this.getElement(), this.theme.cssClass);
        }
        if (theme.isDark) {
            dom.addCssClass(this.getElement(), "ace_dark");
        }
        if (theme.cssClass) {
            dom.addCssClass(this.getElement(), theme.cssClass);
        }
        this.theme = {
            isDark: theme.isDark,
            cssClass: theme.cssClass
        };
    }

    /**
     * @param {String} [text]
     * @param {Number} [x]
     * @param {Number} [y]
     **/
    show(text, x, y) {
        if (text != null)
            this.setText(text);
        if (x != null && y != null)
            this.setPosition(x, y);
        if (!this.isOpen) {
            this.getElement().style.display = "block";
            this.isOpen = true;
        }
    }

    hide(e) {
        if (this.isOpen) {
            this.getElement().style.display = "none";
            this.getElement().className = CLASSNAME;
            this.isOpen = false;
        }
    }

    /**
     * @returns {Number}
     **/
    getHeight() {
        return this.getElement().offsetHeight;
    }

    /**
     * @returns {Number}
     **/
    getWidth() {
        return this.getElement().offsetWidth;
    }

    destroy() {
        this.isOpen = false;
        if (this.$element && this.$element.parentNode) {
            this.$element.parentNode.removeChild(this.$element);
        }
    }

}

class PopupManager {
    constructor () {
        /**@type{Tooltip[]} */
        this.popups = [];
    }

    /**
     * @param {Tooltip} popup
     */
    addPopup(popup) {
        this.popups.push(popup);
        this.updatePopups();
    }

    /**
     * @param {Tooltip} popup
     */
    removePopup(popup) {
        var index = this.popups.indexOf(popup);
        if (index !== -1) {
            this.popups.splice(index, 1);
            this.updatePopups();
        }
    }

    updatePopups() {
        // @ts-expect-error TODO: could be actually an error
        this.popups.sort((a, b) => b.priority - a.priority);
        let visiblepopups = [];

        for (let popup of this.popups) {
            let shouldDisplay = true;
            for (let visiblePopup of visiblepopups) {
                if (this.doPopupsOverlap(visiblePopup, popup)) {
                    shouldDisplay = false;
                    break;
                }
            }

            if (shouldDisplay) {
                visiblepopups.push(popup);
            } else {
                popup.hide();
            }
        }
    }

    /**
     * @param {Tooltip} popupA
     * @param {Tooltip} popupB
     * @return {boolean}
     */
    doPopupsOverlap(popupA, popupB) {
        var rectA = popupA.getElement().getBoundingClientRect();
        var rectB = popupB.getElement().getBoundingClientRect();

        return (rectA.left < rectB.right && rectA.right > rectB.left && rectA.top < rectB.bottom && rectA.bottom
            > rectB.top);
    }
}

var popupManager = new PopupManager();
__webpack_unused_export__ = popupManager;

exports.m_ = Tooltip;


class HoverTooltip extends Tooltip {
    constructor(parentNode=document.body) {
        super(parentNode);

        /**@type{ReturnType<typeof setTimeout> | undefined}*/
        this.timeout = undefined;
        this.lastT = 0;
        this.idleTime = 350;
        this.lastEvent = undefined;

        this.onMouseOut = this.onMouseOut.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.waitForHover = this.waitForHover.bind(this);
        this.hide = this.hide.bind(this);

        var el = this.getElement();
        el.style.whiteSpace = "pre-wrap";
        el.style.pointerEvents = "auto";
        el.addEventListener("mouseout", this.onMouseOut);
        el.tabIndex = -1;

        el.addEventListener("blur", function() {
            if (!el.contains(document.activeElement)) this.hide();
        }.bind(this));

        el.addEventListener("wheel", preventParentScroll);
    }

    /**
     * @param {Editor} editor
     */
    addToEditor(editor) {
        editor.on("mousemove", this.onMouseMove);
        editor.on("mousedown", this.hide);
        var target = editor.renderer.getMouseEventTarget();
        if (target && typeof target.removeEventListener === "function") {
            target.addEventListener("mouseout", this.onMouseOut, true);
        }

    }

    /**
     * @param {Editor} editor
     */
    removeFromEditor(editor) {
        editor.off("mousemove", this.onMouseMove);
        editor.off("mousedown", this.hide);
        var target = editor.renderer.getMouseEventTarget();
        if (target && typeof target.removeEventListener === "function") {
            target.removeEventListener("mouseout", this.onMouseOut, true);
        }
        if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
        }
    }

    /**
     * @param {MouseEvent} e
     * @param {Editor} editor
     * @internal
     */
    onMouseMove(e, editor) {
        this.lastEvent = e;
        this.lastT = Date.now();
        var isMousePressed = editor.$mouseHandler.isMousePressed;
        if (this.isOpen) {
            var pos = this.lastEvent && this.lastEvent.getDocumentPosition();
            if (
                !this.range
                || !this.range.contains(pos.row, pos.column)
                || isMousePressed
                || this.isOutsideOfText(this.lastEvent)
            ) {
                this.hide();
            }
        }
        if (this.timeout || isMousePressed) return;
        this.lastEvent = e;
        this.timeout = setTimeout(this.waitForHover, this.idleTime);
    }
    waitForHover() {
        if (this.timeout) clearTimeout(this.timeout);
        var dt = Date.now() - this.lastT;
        if (this.idleTime - dt > 10) {
            this.timeout = setTimeout(this.waitForHover, this.idleTime - dt);
            return;
        }

        this.timeout = null;
        if (this.lastEvent && !this.isOutsideOfText(this.lastEvent)) {
            this.$gatherData(this.lastEvent, this.lastEvent.editor);
        }
    }

    /**
     * @param {MouseEvent} e
     */
    isOutsideOfText(e) {
        var editor = e.editor;
        var docPos = e.getDocumentPosition();
        var line = editor.session.getLine(docPos.row);
        if (docPos.column == line.length) {
            var screenPos = editor.renderer.pixelToScreenCoordinates(e.clientX, e.clientY);
            var clippedPos = editor.session.documentToScreenPosition(docPos.row, docPos.column);
            if (
                clippedPos.column != screenPos.column
                || clippedPos.row != screenPos.row
            ) {
                return true;
            }
        }
        return false;
    }

    /**
     * @param {(event: MouseEvent, editor: Editor) => void} value
     */
    setDataProvider(value) {
        this.$gatherData = value;
    }

    /**
     * @param {Editor} editor
     * @param {Range} range
     * @param {HTMLElement} domNode
     * @param {MouseEvent} [startingEvent]
     */
    showForRange(editor, range, domNode, startingEvent) {
        if (startingEvent && startingEvent != this.lastEvent) return;
        if (this.isOpen && document.activeElement == this.getElement()) return;

        var renderer = editor.renderer;
        if (!this.isOpen) {
            popupManager.addPopup(this);
            this.$registerCloseEvents();
            this.setTheme(renderer.theme);
        }
        this.isOpen = true;

        this.range = Range.fromPoints(range.start, range.end);
        var position = renderer.textToScreenCoordinates(range.start.row, range.start.column);

        var rect = renderer.scroller.getBoundingClientRect();
        // clip position to visible area of the editor
        if (position.pageX < rect.left) position.pageX = rect.left;

        var element = this.getElement();
        element.innerHTML = "";
        element.appendChild(domNode);

        element.style.maxHeight = "";
        element.style.display = "block";

        this.$setPosition(editor, position, true, range);
        
        dom.$fixPositionBug(element);
    }

    /**
     * @param {Editor} editor
     * @param {{pageX: number;pageY: number;}} position
     * @param {boolean} withMarker
     * @param {Range} [range]
     */
    $setPosition(editor, position, withMarker, range) {
        var MARGIN = 10;

        withMarker && this.addMarker(range, editor.session);

        var renderer = editor.renderer;
        var element = this.getElement();

        // measure the size of tooltip, without constraints on its height
        var labelHeight = element.offsetHeight;
        var labelWidth = element.offsetWidth;
        var anchorTop = position.pageY;
        var anchorLeft = position.pageX;
        var spaceBelow = window.innerHeight - anchorTop - renderer.lineHeight;

        // if tooltip fits above the line, or space below the line is smaller, show tooltip above
        var isAbove = this.$shouldPlaceAbove(labelHeight, anchorTop, spaceBelow - MARGIN);

        element.style.maxHeight = (isAbove ? anchorTop : spaceBelow) - MARGIN + "px";
        element.style.top = isAbove ? "" : anchorTop + renderer.lineHeight + "px";
        element.style.bottom = isAbove ? window.innerHeight - anchorTop + "px" : "";

        // try to align tooltip left with the range, but keep it on screen
        element.style.left = Math.min(anchorLeft, window.innerWidth - labelWidth - MARGIN) + "px";
    }

    /**
     * @param {number} labelHeight
     * @param {number} anchorTop
     * @param {number} spaceBelow
     */
    $shouldPlaceAbove(labelHeight, anchorTop, spaceBelow) {
        return !(anchorTop - labelHeight < 0 && anchorTop < spaceBelow);
    }

    /**
     * @param {Range} range
     * @param {EditSession} [session]
     */
    addMarker(range, session) {
        if (this.marker) {
            this.$markerSession.removeMarker(this.marker);
        }
        this.$markerSession = session;
        this.marker = session && session.addMarker(range, "ace_highlight-marker", "text");
    }

    hide(e) {
        if (e && this.$fromKeyboard && e.type == "keydown") {
            if (e.code == "Escape") {
                return;
            }
        }

        if (!e && document.activeElement == this.getElement()) return;
        if (e && e.target && (e.type != "keydown" || e.ctrlKey || e.metaKey) && this.$element.contains(
            e.target)) return;
        this.lastEvent = null;
        if (this.timeout) clearTimeout(this.timeout);
        this.timeout = null;
        this.addMarker(null);
        if (this.isOpen) {
            this.$fromKeyboard = false;
            this.$removeCloseEvents();
            this.getElement().style.display = "none";
            this.isOpen = false;
            popupManager.removePopup(this);
        }
    }

    $registerCloseEvents() {
        window.addEventListener("keydown", this.hide, true);
        window.addEventListener("wheel", this.hide, true);
        window.addEventListener("mousedown", this.hide, true);
    }

    $removeCloseEvents() {
        window.removeEventListener("keydown", this.hide, true);
        window.removeEventListener("wheel", this.hide, true);
        window.removeEventListener("mousedown", this.hide, true);
    }

    /**
     * @internal
     */
    onMouseOut(e) {
        if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
        }
        this.lastEvent = null;
        if (!this.isOpen) return;

        if (!e.relatedTarget || this.getElement().contains(e.relatedTarget)) return;

        if (e && e.currentTarget.contains(e.relatedTarget)) return;
        if (!e.relatedTarget.classList.contains("ace_content")) this.hide();
    }
}

exports.sX = HoverTooltip;


/***/ }),

/***/ 60565:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var Range = (__webpack_require__(91902)/* .Range */ .Q);

var splitRegex = /[^a-zA-Z_0-9\$\-\u00C0-\u1FFF\u2C00-\uD7FF\w]+/;

function getWordIndex(doc, pos) {
    var textBefore = doc.getTextRange(Range.fromPoints({
        row: 0,
        column: 0
    }, pos));
    return textBefore.split(splitRegex).length - 1;
}

/**
 * Does a distance analysis of the word `prefix` at position `pos` in `doc`.
 * @return Map
 */
function wordDistance(doc, pos) {
    var prefixPos = getWordIndex(doc, pos);
    var words = doc.getValue().split(splitRegex);
    var wordScores = Object.create(null);

    var currentWord = words[prefixPos];

    words.forEach(function (word, idx) {
        if (!word || word === currentWord) return;

        var distance = Math.abs(prefixPos - idx);
        var score = words.length - distance;
        if (wordScores[word]) {
            wordScores[word] = Math.max(score, wordScores[word]);
        }
        else {
            wordScores[word] = score;
        }
    });
    return wordScores;
}

exports.id = "textCompleter";

exports.getCompletions = function (editor, session, pos, prefix, callback) {
    var wordScore = wordDistance(session, pos);
    var wordList = Object.keys(wordScore);
    callback(null, wordList.map(function (word) {
        return {
            caption: word,
            value: word,
            score: wordScore[word],
            meta: "local"
        };
    }));
};


/***/ }),

/***/ 61893:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * ## Language Tools extension for Ace Editor
 *
 * Provides autocompletion, snippets, and language intelligence features for the Ace code editor.
 * This extension integrates multiple completion providers including keyword completion, snippet expansion,
 * and text-based completion to enhance the coding experience with contextual suggestions and automated code generation.
 *
 * **Configuration Options:**
 * - `enableBasicAutocompletion`: Enable/disable basic completion functionality
 * - `enableLiveAutocompletion`: Enable/disable real-time completion suggestions
 * - `enableSnippets`: Enable/disable snippet expansion with Tab key
 * - `liveAutocompletionDelay`: Delay before showing live completion popup
 * - `liveAutocompletionThreshold`: Minimum prefix length to trigger completion
 *
 * **Usage:**
 * ```javascript
 * editor.setOptions({
 *   enableBasicAutocompletion: true,
 *   enableLiveAutocompletion: true,
 *   enableSnippets: true
 * });
 * ```
 *
 * @module
 */


/**@type{import("../snippets").snippetManager & {files?: {[key: string]: any}}}*/
var snippetManager = (__webpack_require__(51509)/* .snippetManager */ .N);
var Autocomplete = (__webpack_require__(26347)/* .Autocomplete */ .jT);
var config = __webpack_require__(76321);
var lang = __webpack_require__(39955);
var util = __webpack_require__(28630);

var MarkerGroup = (__webpack_require__(42393)/* .MarkerGroup */ .o);

var textCompleter = __webpack_require__(60565);
/**@type {import("../../ace-internal").Ace.Completer}*/
var keyWordCompleter = {
    getCompletions: function(editor, session, pos, prefix, callback) {
        if (session.$mode.completer) {
            return session.$mode.completer.getCompletions(editor, session, pos, prefix, callback);
        }
        var state = editor.session.getState(pos.row);
        var completions = session.$mode.getCompletions(state, session, pos, prefix);
        completions = completions.map((el) => {
            el.completerId = keyWordCompleter.id;
            return el;
        });
        callback(null, completions);
    },
    id: "keywordCompleter"
};

var transformSnippetTooltip = function(str) {
    var record = {};
    return str.replace(/\${(\d+)(:(.*?))?}/g, function(_, p1, p2, p3) {
        return (record[p1] = p3 || '');
    }).replace(/\$(\d+?)/g, function (_, p1) {
        return record[p1];
    });
};
/**@type {import("../../ace-internal").Ace.Completer} */
var snippetCompleter = {
    getCompletions: function(editor, session, pos, prefix, callback) {
        var scopes = [];

        // set scope to html-tag if we're inside an html tag
        var token = session.getTokenAt(pos.row, pos.column);
        if (token && token.type.match(/(tag-name|tag-open|tag-whitespace|attribute-name|attribute-value)\.xml$/))
            scopes.push('html-tag');
        else
            scopes = snippetManager.getActiveScopes(editor);

        var snippetMap = snippetManager.snippetMap;
        var completions = [];
        scopes.forEach(function(scope) {
            var snippets = snippetMap[scope] || [];
            for (var i = snippets.length; i--;) {
                var s = snippets[i];
                var caption = s.name || s.tabTrigger;
                if (!caption)
                    continue;
                completions.push({
                    caption: caption,
                    snippet: s.content,
                    meta: s.tabTrigger && !s.name ? s.tabTrigger + "\u21E5 " : "snippet",
                    completerId: snippetCompleter.id
                });
            }
        }, this);
        callback(null, completions);
    },
    getDocTooltip: function(item) {
        if (item.snippet && !item.docHTML) {
            item.docHTML = [
                "<b>", lang.escapeHTML(item.caption), "</b>", "<hr></hr>",
                lang.escapeHTML(transformSnippetTooltip(item.snippet))
            ].join("");
        }
    },
    id: "snippetCompleter"
};

var completers = [snippetCompleter, textCompleter, keyWordCompleter];
/**
 * Replaces the default list of completers with a new set of completers.
 *
 * @param {import("../../ace-internal").Ace.Completer[]} [val]
 *
 */
exports.setCompleters = function(val) {
    completers.length = 0;
    if (val) completers.push.apply(completers, val);
};
/**
 * Adds a new completer to the list of available completers.
 *
 * @param {import("../../ace-internal").Ace.Completer} completer - The completer object to be added to the completers array.
 */
exports.addCompleter = function(completer) {
    completers.push(completer);
};

// Exports existing completer so that user can construct his own set of completers.
exports.textCompleter = textCompleter;
exports.keyWordCompleter = keyWordCompleter;
exports.snippetCompleter = snippetCompleter;

var expandSnippet = {
    name: "expandSnippet",
    exec: function(editor) {
        return snippetManager.expandWithTab(editor);
    },
    bindKey: "Tab"
};

var onChangeMode = function(e, editor) {
    loadSnippetsForMode(editor.session.$mode);
};

var loadSnippetsForMode = function(mode) {
    if (typeof mode == "string")
        mode = config.$modes[mode];
    if (!mode)
        return;
    if (!snippetManager.files)
        snippetManager.files = {};
    
    loadSnippetFile(mode.$id, mode.snippetFileId);
    if (mode.modes)
        mode.modes.forEach(loadSnippetsForMode);
};

var loadSnippetFile = function(id, snippetFilePath) {
    if (!snippetFilePath || !id || snippetManager.files[id])
        return;
    snippetManager.files[id] = {};
    config.loadModule(snippetFilePath, function(m) {
        if (!m) return;
        snippetManager.files[id] = m;
        if (!m.snippets && m.snippetText)
            m.snippets = snippetManager.parseSnippetFile(m.snippetText);
        snippetManager.register(m.snippets || [], m.scope);
        if (m.includeScopes) {
            snippetManager.snippetMap[m.scope].includeScopes = m.includeScopes;
            m.includeScopes.forEach(function(x) {
                loadSnippetsForMode("ace/mode/" + x);
            });
        }
    });
};

var doLiveAutocomplete = function(e) {
    var editor = e.editor;
    var hasCompleter = editor.completer && editor.completer.activated;

    // We don't want to autocomplete with no prefix
    if (e.command.name === "backspace") {
        if (hasCompleter && !util.getCompletionPrefix(editor))
            editor.completer.detach();
    }
    else if (e.command.name === "insertstring" && !hasCompleter) {
        lastExecEvent = e;
        var delay = e.editor.$liveAutocompletionDelay;
        if (delay) {
            liveAutocompleteTimer.delay(delay);
        } else {
            showLiveAutocomplete(e);
        }
    }
};

var lastExecEvent;
var liveAutocompleteTimer = lang.delayedCall(function () {
    showLiveAutocomplete(lastExecEvent);
}, 0);

var showLiveAutocomplete = function(e) {
    var editor = e.editor;
    var prefix = util.getCompletionPrefix(editor);
    // Only autocomplete if there's a prefix that can be matched or previous char is trigger character 
    var previousChar = e.args;
    var triggerAutocomplete = util.triggerAutocomplete(editor, previousChar);
    if (prefix && prefix.length >= editor.$liveAutocompletionThreshold || triggerAutocomplete) {
        var completer = Autocomplete.for(editor);
        // Set a flag for auto shown
        completer.autoShown = true;
        completer.showPopup(editor);
    }
};

var Editor = (__webpack_require__(27258).Editor);
(__webpack_require__(76321).defineOptions)(Editor.prototype, "editor", {
    enableBasicAutocompletion: {
        /**
         * @param val
         * @this{Editor}
         */
        set: function(val) {
            if (val) {
                Autocomplete.for(this);

                if (!this.completers)
                    this.completers = Array.isArray(val)? val: completers;
                this.commands.addCommand(Autocomplete.startCommand);
            } else {
                this.commands.removeCommand(Autocomplete.startCommand);
            }
        },
        value: false
    },
    /**
     * Enable live autocompletion
     */
    enableLiveAutocompletion: {
        /**
         * @param {boolean} val
         * @this {Editor}
         */
        set: function(val) {
            if (val) {
                if (!this.completers)
                    this.completers = Array.isArray(val)? val: completers;
                // On each change automatically trigger the autocomplete
                this.commands.on('afterExec', doLiveAutocomplete);
            } else {
                this.commands.off('afterExec', doLiveAutocomplete);
            }
        },
        value: false
    },
    liveAutocompletionDelay: {
        initialValue: 0
    },
    liveAutocompletionThreshold: {
        initialValue: 0
    },
    enableSnippets: {
        set: function(val) {
            if (val) {
                this.commands.addCommand(expandSnippet);
                this.on("changeMode", onChangeMode);
                onChangeMode(null, this);
            } else {
                this.commands.removeCommand(expandSnippet);
                this.off("changeMode", onChangeMode);
            }
        },
        value: false
    }
});

exports.MarkerGroup = MarkerGroup;

/***/ }),

/***/ 62830:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// @ts-nocheck


var Range = (__webpack_require__(91902)/* .Range */ .Q);
var FoldLine = (__webpack_require__(70649)/* .FoldLine */ .M);
var Fold = (__webpack_require__(45816)/* .Fold */ .a);
var TokenIterator = (__webpack_require__(99339).TokenIterator);
var MouseEvent = (__webpack_require__(85519)/* .MouseEvent */ .C);

/**
 * @typedef {import("../edit_session").EditSession & import("../../ace-internal").Ace.Folding} IFolding
 * @typedef {import("../../ace-internal").Ace.Delta } Delta
 */

/**
 * @this {IFolding}
 * @type {IFolding}
 */
function Folding() {
    /**
     * Looks up a fold at a given row/column. Possible values for side:
     *   -1: ignore a fold if fold.start = row/column
     *   +1: ignore a fold if fold.end = row/column
     * @param {number} row
     * @param {number} column
     * @param {number} [side]
     * @return {Fold}
     **/
    this.getFoldAt = function(row, column, side) {
        var foldLine = this.getFoldLine(row);
        if (!foldLine)
            return null;

        var folds = foldLine.folds;
        for (var i = 0; i < folds.length; i++) {
            var range = folds[i].range;
            if (range.contains(row, column)) {
                if (side == 1 && range.isEnd(row, column) && !range.isEmpty()) {
                    continue;
                } else if (side == -1 && range.isStart(row, column) && !range.isEmpty()) {
                    continue;
                }
                return folds[i];
            }
        }
    };

    /**
     * Returns all folds in the given range. Note, that this will return folds
     * @param {Range| Delta} range
     * @returns {Fold[]}
     **/
    this.getFoldsInRange = function(range) {
        var start = range.start;
        var end = range.end;
        var foldLines = this.$foldData;
        var foundFolds = [];

        start.column += 1;
        end.column -= 1;

        for (var i = 0; i < foldLines.length; i++) {
            var cmp = foldLines[i].range.compareRange(range);
            if (cmp == 2) {
                // Range is before foldLine. No intersection. This means,
                // there might be other foldLines that intersect.
                continue;
            }
            else if (cmp == -2) {
                // Range is after foldLine. There can't be any other foldLines then,
                // so let's give up.
                break;
            }

            var folds = foldLines[i].folds;
            for (var j = 0; j < folds.length; j++) {
                var fold = folds[j];
                cmp = fold.range.compareRange(range);
                if (cmp == -2) {
                    break;
                } else if (cmp == 2) {
                    continue;
                } else
                // WTF-state: Can happen due to -1/+1 to start/end column.
                if (cmp == 42) {
                    break;
                }
                foundFolds.push(fold);
            }
        }
        start.column -= 1;
        end.column += 1;

        return foundFolds;
    };

    /**
     * 
     * @param {Range[]|Range}ranges
     * @returns {Fold[]}
     */
    this.getFoldsInRangeList = function(ranges) {
        if (Array.isArray(ranges)) {
            /**@type {Fold[]} */
            var folds = [];
            ranges.forEach(function(range) {
                folds = folds.concat(this.getFoldsInRange(range));
            }, this);
        } else {
            var folds = this.getFoldsInRange(ranges);
        }
        return folds;
    };
    
    /**
     * Returns all folds in the document
     * @returns {Fold[]}
     */
    this.getAllFolds = function() {
        var folds = [];
        var foldLines = this.$foldData;
        
        for (var i = 0; i < foldLines.length; i++)
            for (var j = 0; j < foldLines[i].folds.length; j++)
                folds.push(foldLines[i].folds[j]);

        return folds;
    };

    /**
     * Returns the string between folds at the given position.
     * E.g.
     *  foo<fold>b|ar<fold>wolrd -> "bar"
     *  foo<fold>bar<fold>wol|rd -> "world"
     *  foo<fold>bar<fo|ld>wolrd -> <null>
     *
     * where | means the position of row/column
     *
     * The trim option determs if the return string should be trimed according
     * to the "side" passed with the trim value:
     *
     * E.g.
     *  foo<fold>b|ar<fold>wolrd -trim=-1> "b"
     *  foo<fold>bar<fold>wol|rd -trim=+1> "rld"
     *  fo|o<fold>bar<fold>wolrd -trim=00> "foo"
     *  @param {number} row
     *  @param {number} column
     *  @param {number} [trim]
     *  @param {FoldLine} [foldLine]
     *  @returns {string | null}
     */
    this.getFoldStringAt = function(row, column, trim, foldLine) {
        foldLine = foldLine || this.getFoldLine(row);
        if (!foldLine)
            return null;

        var lastFold = {
            end: { column: 0 }
        };
        // TODO: Refactor to use getNextFoldTo function.
        var str, fold;
        for (var i = 0; i < foldLine.folds.length; i++) {
            fold = foldLine.folds[i];
            var cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                str = this
                    .getLine(fold.start.row)
                    .substring(lastFold.end.column, fold.start.column);
                break;
            }
            else if (cmp === 0) {
                return null;
            }
            lastFold = fold;
        }
        if (!str)
            str = this.getLine(fold.start.row).substring(lastFold.end.column);

        if (trim == -1)
            return str.substring(0, column - lastFold.end.column);
        else if (trim == 1)
            return str.substring(column - lastFold.end.column);
        else
            return str;
    };

    /**
     * 
     * @param {number} docRow
     * @param {FoldLine} [startFoldLine]
     * @returns {null|FoldLine}
     */
    this.getFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
                return foldLine;
            } else if (foldLine.end.row > docRow) {
                return null;
            }
        }
        return null;
    };

    /**
     * Returns the fold which starts after or contains docRow
     * @param {number} docRow
     * @param {FoldLine} [startFoldLine]
     * @returns {null|FoldLine}
     */
    this.getNextFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.end.row >= docRow) {
                return foldLine;
            }
        }
        return null;
    };

    /**
     * 
     * @param {number} first
     * @param {number} last
     * @return {number}
     */
    this.getFoldedRowCount = function(first, last) {
        var foldData = this.$foldData, rowCount = last-first+1;
        for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i],
                end = foldLine.end.row,
                start = foldLine.start.row;
            if (end >= last) {
                if (start < last) {
                    if (start >= first)
                        rowCount -= last-start;
                    else
                        rowCount = 0; // in one fold
                }
                break;
            } else if (end >= first){
                if (start >= first) // fold inside range
                    rowCount -=  end-start;
                else
                    rowCount -=  end-first+1;
            }
        }
        return rowCount;
    };

    /**
     * 
     * @param {FoldLine}foldLine
     * @return {FoldLine}
     */
    this.$addFoldLine = function(foldLine) {
        this.$foldData.push(foldLine);
        this.$foldData.sort(function(a, b) {
            return a.start.row - b.start.row;
        });
        return foldLine;
    };

    /**
     * Adds a new fold.
     *
     * @param {Fold|string} placeholder
     * @param {Range} [range]
     * @returns {Fold}
     *      The new created Fold object or an existing fold object in case the
     *      passed in range fits an existing fold exactly.
     * @this {IFolding}
     */
    this.addFold = function(placeholder, range) {
        var foldData = this.$foldData;
        var added = false;
        /**@type {Fold}*/
        var fold;
        
        if (placeholder instanceof Fold)
            fold = placeholder;
        else {
            fold = new Fold(range, placeholder);
            // @ts-ignore
            fold.collapseChildren = range.collapseChildren;
        }
        this.$clipRangeToDocument(fold.range);

        var startRow = fold.start.row;
        var startColumn = fold.start.column;
        var endRow = fold.end.row;
        var endColumn = fold.end.column;

        var startFold = this.getFoldAt(startRow, startColumn, 1);
        var endFold = this.getFoldAt(endRow, endColumn, -1);
        if (startFold && endFold == startFold)
            return startFold.addSubFold(fold);

        if (startFold && !startFold.range.isStart(startRow, startColumn))
            this.removeFold(startFold);
        
        if (endFold && !endFold.range.isEnd(endRow, endColumn))
            this.removeFold(endFold);
        
        // Check if there are folds in the range we create the new fold for.
        var folds = this.getFoldsInRange(fold.range);
        if (folds.length > 0) {
            // Remove the folds from fold data.
            this.removeFolds(folds);
            // Add the removed folds as subfolds on the new fold.
            if (!fold.collapseChildren) {
                folds.forEach(function(subFold) {
                    fold.addSubFold(subFold);
                });
            }
        }

        for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (endRow == foldLine.start.row) {
                foldLine.addFold(fold);
                added = true;
                break;
            } else if (startRow == foldLine.end.row) {
                foldLine.addFold(fold);
                added = true;
                if (!fold.sameRow) {
                    // Check if we might have to merge two FoldLines.
                    var foldLineNext = foldData[i + 1];
                    if (foldLineNext && foldLineNext.start.row == endRow) {
                        // We need to merge!
                        foldLine.merge(foldLineNext);
                        break;
                    }
                }
                break;
            } else if (endRow <= foldLine.start.row) {
                break;
            }
        }

        if (!added)
            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));

        if (this.$useWrapMode)
            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
        else
            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);

        // Notify that fold data has changed.
        this.$modified = true;
        this._signal("changeFold", { data: fold, action: "add" });

        return fold;
    };

    /**
     * @param {Fold[]} folds
     */
    this.addFolds = function(folds) {
        folds.forEach(function(fold) {
            this.addFold(fold);
        }, this);
    };

    /**
     * 
     * @param {Fold} fold
     */
    this.removeFold = function(fold) {
        var foldLine = fold.foldLine;
        var startRow = foldLine.start.row;
        var endRow = foldLine.end.row;

        var foldLines = this.$foldData;
        var folds = foldLine.folds;
        // Simple case where there is only one fold in the FoldLine such that
        // the entire fold line can get removed directly.
        if (folds.length == 1) {
            foldLines.splice(foldLines.indexOf(foldLine), 1);
        } else
        // If the fold is the last fold of the foldLine, just remove it.
        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
            folds.pop();
            foldLine.end.row = folds[folds.length - 1].end.row;
            foldLine.end.column = folds[folds.length - 1].end.column;
        } else
        // If the fold is the first fold of the foldLine, just remove it.
        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
            folds.shift();
            foldLine.start.row = folds[0].start.row;
            foldLine.start.column = folds[0].start.column;
        } else
        // We know there are more then 2 folds and the fold is not at the edge.
        // This means, the fold is somewhere in between.
        //
        // If the fold is in one row, we just can remove it.
        if (fold.sameRow) {
            folds.splice(folds.indexOf(fold), 1);
        } else
        // The fold goes over more then one row. This means remvoing this fold
        // will cause the fold line to get splitted up. newFoldLine is the second part
        {
            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
            folds = newFoldLine.folds;
            folds.shift();
            newFoldLine.start.row = folds[0].start.row;
            newFoldLine.start.column = folds[0].start.column;
        }

        if (!this.$updating) {
            if (this.$useWrapMode)
                this.$updateWrapData(startRow, endRow);
            else
                this.$updateRowLengthCache(startRow, endRow);
        }
        
        // Notify that fold data has changed.
        this.$modified = true;
        this._signal("changeFold", { data: fold, action: "remove" });
    };

    /**
     * 
     * @param {Fold[]} folds
     */
    this.removeFolds = function(folds) {
        // We need to clone the folds array passed in as it might be the folds
        // array of a fold line and as we call this.removeFold(fold), folds
        // are removed from folds and changes the current index.
        var cloneFolds = [];
        for (var i = 0; i < folds.length; i++) {
            cloneFolds.push(folds[i]);
        }

        cloneFolds.forEach(function(fold) {
            this.removeFold(fold);
        }, this);
        this.$modified = true;
    };

    /**
     * @param {Fold} fold
     */
    this.expandFold = function(fold) {
        this.removeFold(fold);
        fold.subFolds.forEach(function(subFold) {
            fold.restoreRange(subFold);
            this.addFold(subFold);
        }, this);
        if (fold.collapseChildren > 0) {
            this.foldAll(fold.start.row+1, fold.end.row, fold.collapseChildren-1);
        }
        fold.subFolds = [];
    };

    /**
     * @param {Fold[]}folds
     */
    this.expandFolds = function(folds) {
        folds.forEach(function(fold) {
            this.expandFold(fold);
        }, this);
    };

    /**
     * 
     * @param {number|null|import("../../ace-internal").Ace.Point|Range|Range[]} [location]
     * @param {boolean} [expandInner]
     * @return {Fold[]| undefined}
     */
    this.unfold = function(location, expandInner) {
        var range, folds;
        if (location == null) {
            range = new Range(0, 0, this.getLength(), 0);
            if (expandInner == null) expandInner = true;
        } else if (typeof location == "number") {
            range = new Range(location, 0, location, this.getLine(location).length);
        } else if ("row" in location) {
            range = Range.fromPoints(location, location);
        } else if (Array.isArray(location)) {
            folds = [];
            location.forEach(function(range) {
                folds = folds.concat(this.unfold(range));
            }, this);
            return folds;
        } else {
            range = location;
        }
        
        folds = this.getFoldsInRangeList(range);
        var outermostFolds = folds;
        // if range itself is in a fold, expand that fold instead of removing, 
        // to not accidentally remove sibling folds
        while (
            folds.length == 1
            && Range.comparePoints(folds[0].start, range.start) < 0 
            && Range.comparePoints(folds[0].end, range.end) > 0
        ) {
            this.expandFolds(folds);
            folds = this.getFoldsInRangeList(range);
        }
        
        if (expandInner != false) {
            this.removeFolds(folds);
        } else {
            this.expandFolds(folds);
        }
        if (outermostFolds.length)
            return outermostFolds;
    };

    /**
     * Checks if a given documentRow is folded. This is true if there are some
     * folded parts such that some parts of the line is still visible.
     * @param {number} docRow
     * @param {FoldLine} [startFoldRow]
     * @returns {boolean}
     **/
    this.isRowFolded = function(docRow, startFoldRow) {
        return !!this.getFoldLine(docRow, startFoldRow);
    };

    /**
     * 
     * @param {number} docRow
     * @param {FoldLine} [startFoldRow]
     * @return {number}
     */
    this.getRowFoldEnd = function(docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.end.row : docRow;
    };

    /**
     * 
     * @param {number} docRow
     * @param {FoldLine} [startFoldRow]
     * @returns {number}
     */
    this.getRowFoldStart = function(docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.start.row : docRow;
    };

    /**
     * 
     * @param {FoldLine} foldLine
     * @param {number | null} [endRow]
     * @param {number | null} [endColumn]
     * @param {number | null} [startRow]
     * @param {number | null} [startColumn]
     * @return {string}
     */
    this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
        if (startRow == null)
            startRow = foldLine.start.row;
        if (startColumn == null)
            startColumn = 0;
        if (endRow == null)
            endRow = foldLine.end.row;
        if (endColumn == null)
            endColumn = this.getLine(endRow).length;
        

        // Build the textline using the FoldLine walker.
        var doc = this.doc;
        var textLine = "";

        foldLine.walk(function(placeholder, row, column, lastColumn) {
            if (row < startRow)
                return;
            if (row == startRow) {
                if (column < startColumn)
                    return;
                lastColumn = Math.max(startColumn, lastColumn);
            }

            if (placeholder != null) {
                textLine += placeholder;
            } else {
                textLine += doc.getLine(row).substring(lastColumn, column);
            }
        }, endRow, endColumn);
        return textLine;
    };

    /**
     * 
     * @param {number} row
     * @param {number | null} endColumn
     * @param {number | null} startRow
     * @param {number | null} startColumn
     * @return {string}
     */
    this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
        var foldLine = this.getFoldLine(row);

        if (!foldLine) {
            var line;
            line = this.doc.getLine(row);
            return line.substring(startColumn || 0, endColumn || line.length);
        } else {
            return this.getFoldDisplayLine(
                foldLine, row, endColumn, startRow, startColumn);
        }
    };

    /**
     * @return {FoldLine[]}
     */
    this.$cloneFoldData = function() {
        var fd = [];
        fd = this.$foldData.map(function(foldLine) {
            var folds = foldLine.folds.map(function(fold) {
                return fold.clone();
            });
            return new FoldLine(fd, folds);
        });

        return fd;
    };

    /**
     * @param {boolean} [tryToUnfold]
     */
    this.toggleFold = function(tryToUnfold) {
        var selection = this.selection;
        var range = selection.getRange();
        var fold;
        var bracketPos;

        if (range.isEmpty()) {
            var cursor = range.start;
            fold = this.getFoldAt(cursor.row, cursor.column);

            if (fold) {
                this.expandFold(fold);
                return;
            } else if (tryToUnfold) {
                var foldLine = this.getFoldLine(cursor.row);
                if (foldLine)
                    this.expandFolds(foldLine.folds);
                return;
            } else if (bracketPos = this.findMatchingBracket(cursor)) {
                if (range.comparePoint(bracketPos) == 1) {
                    range.end = bracketPos;
                } else {
                    range.start = bracketPos;
                    range.start.column++;
                    range.end.column--;
                }
            } else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {
                if (range.comparePoint(bracketPos) == 1)
                    range.end = bracketPos;
                else
                    range.start = bracketPos;

                range.start.column++;
            } else {
                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
            }
        } else {
            var folds = this.getFoldsInRange(range);
            if (tryToUnfold && folds.length) {
                this.expandFolds(folds);
                return;
            } else if (folds.length == 1 ) {
                fold = folds[0];
            }
        }

        if (!fold)
            fold = this.getFoldAt(range.start.row, range.start.column);

        if (fold && fold.range.toString() == range.toString()) {
            this.expandFold(fold);
            return;
        }

        var placeholder = "...";
        if (!range.isMultiLine()) {
            placeholder = this.getTextRange(range);
            if (placeholder.length < 4)
                return;
            placeholder = placeholder.trim().substring(0, 2) + "..";
        }

        this.addFold(placeholder, range);
    };

    /**
     * 
     * @param {number} row
     * @param {number} column
     * @param {number} [dir]
     * @return {Range | undefined}
     */
    this.getCommentFoldRange = function(row, column, dir) {
        var iterator = new TokenIterator(this, row, column);
        var token = iterator.getCurrentToken();
        var type = token && token.type;
        if (token && /^comment|string/.test(type)) {
            type = type.match(/comment|string/)[0];
            if (type == "comment")
                type += "|doc-start|\\.doc";
            var re = new RegExp(type);
            var range = new Range();
            if (dir != 1) {
                do {
                    token = iterator.stepBackward();
                } while (token && re.test(token.type));
                token = iterator.stepForward();
            }
            
            range.start.row = iterator.getCurrentTokenRow();
            range.start.column = iterator.getCurrentTokenColumn() + token.value.length;

            iterator = new TokenIterator(this, row, column);
            var initState = this.getState(iterator.$row);
            
            if (dir != -1) {
                var lastRow = -1;
                do {
                    token = iterator.stepForward();
                    if (lastRow == -1) {
                        var state = this.getState(iterator.$row);
                        if (initState.toString() !== state.toString())
                            lastRow = iterator.$row;
                    } else if (iterator.$row > lastRow) {
                        break;
                    }
                } while (token && re.test(token.type));
                token = iterator.stepBackward();
            } else
                token = iterator.getCurrentToken();

            range.end.row = iterator.getCurrentTokenRow();
            range.end.column = iterator.getCurrentTokenColumn();
            if (range.start.row == range.end.row && range.start.column > range.end.column)
                return;
            return range;
        }
    };

    /**
     * 
     * @param {number | null} [startRow]
     * @param {number | null} [endRow]
     * @param {number | null} [depth]
     * @param {Function} [test]
     */
    this.foldAll = function(startRow, endRow, depth, test) {
        if (depth == undefined)
            depth = 100000; // JSON.stringify doesn't hanle Infinity
        var foldWidgets = this.foldWidgets;
        if (!foldWidgets)
            return; // mode doesn't support folding
        endRow = endRow || this.getLength();
        startRow = startRow || 0;
        for (var row = startRow; row < endRow; row++) {
            if (foldWidgets[row] == null)
                foldWidgets[row] = this.getFoldWidget(row);
            if (foldWidgets[row] != "start")
                continue;
            
            if (test && !test(row)) continue;

            var range = this.getFoldWidgetRange(row);
            if (range && range.isMultiLine()
                && range.end.row <= endRow
                && range.start.row >= startRow
            ) {
                row = range.end.row;
                range.collapseChildren = depth;
                // addFold can change the range
                this.addFold("...", range);
            }
        }
    };

    /**
     * 
     * @param {number} level
     */
    this.foldToLevel = function(level) {
        this.foldAll();
        while (level-- > 0)
            this.unfold(null, false);
    };

    /**
     *
     */
    this.foldAllComments = function() {
        var session = this;
        this.foldAll(null, null, null, function(row) {
            var tokens = session.getTokens(row);
            for (var i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                if (token.type == "text" && /^\s+$/.test(token.value))
                    continue;
                if (/comment/.test(token.type))
                    return true;
                return false;
            }
        });
    };
    
    // structured folding
    this.$foldStyles = {
        "manual": 1,
        "markbegin": 1,
        "markbeginend": 1
    };
    this.$foldStyle = "markbegin";
    
    /**
     * @param {string} style
     */
    this.setFoldStyle = function(style) {
        if (!this.$foldStyles[style])
            throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
        
        if (this.$foldStyle == style)
            return;

        this.$foldStyle = style;
        
        if (style == "manual")
            this.unfold();
        
        // reset folding
        var mode = this.$foldMode;
        this.$setFolding(null);
        this.$setFolding(mode);
    };

    /**
     * @param {import("../../ace-internal").Ace.FoldMode} foldMode
     */
    this.$setFolding = function(foldMode) {
        if (this.$foldMode == foldMode)
            return;


        this.$foldMode = foldMode;
        
        this.off('change', this.$updateFoldWidgets);
        this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
        this._signal("changeAnnotation");
        
        if (!foldMode || this.$foldStyle == "manual") {
            this.foldWidgets = null;
            return;
        }
        
        this.foldWidgets = [];
        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
        
        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
        this.on('change', this.$updateFoldWidgets);
        this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
    };
    /**
     * @param {number} row
     * @param {boolean} [ignoreCurrent]
     * @return {{range?: Range, firstRange?: Range}}
     */
    this.getParentFoldRangeData = function (row, ignoreCurrent) {
        var fw = this.foldWidgets;
        if (!fw || (ignoreCurrent && fw[row]))
            return {};

        var i = row - 1, firstRange;
        while (i >= 0) {
            var c = fw[i];
            if (c == null)
                c = fw[i] = this.getFoldWidget(i);

            if (c == "start") {
                var range = this.getFoldWidgetRange(i);
                if (!firstRange)
                    firstRange = range;
                if (range && range.end.row >= row)
                    break;
            }
            i--;
        }

        return {
            range: i !== -1 && range,
            firstRange: firstRange
        };
    };

    /**
     * 
     * @param {number} row
     * @param {any} e
     */
    this.onFoldWidgetClick = function(row, e) {
        if (e instanceof MouseEvent)
            e = e.domEvent;

        var options = {
            children: e.shiftKey,
            all: e.ctrlKey || e.metaKey,
            siblings: e.altKey
        };
        
        var range = this.$toggleFoldWidget(row, options);
        if (!range) {
            var el = (e.target || e.srcElement);
            if (el && /ace_fold-widget/.test(el.className))
                el.className += " ace_invalid";
        }
    };

    /**
     * 
     * @param {number} row
     * @param options
     * @return {Fold|*}
     */
    this.$toggleFoldWidget = function(row, options) {
        if (!this.getFoldWidget)
            return;
        var type = this.getFoldWidget(row);
        var line = this.getLine(row);

        var dir = type === "end" ? -1 : 1;
        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);

        if (fold) {
            if (options.children || options.all)
                this.removeFold(fold);
            else
                this.expandFold(fold);
            return fold;
        }

        var range = this.getFoldWidgetRange(row, true);
        // sometimes singleline folds can be missed by the code above
        if (range && !range.isMultiLine()) {
            fold = this.getFoldAt(range.start.row, range.start.column, 1);
            if (fold && range.isEqual(fold.range)) {
                this.removeFold(fold);
                return fold;
            }
        }
        
        if (options.siblings) {
            var data = this.getParentFoldRangeData(row);
            if (data.range) {
                var startRow = data.range.start.row + 1;
                var endRow = data.range.end.row;
            }
            this.foldAll(startRow, endRow, options.all ? 10000 : 0);
        } else if (options.children) {
            endRow = range ? range.end.row : this.getLength();
            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
        } else if (range) {
            if (options.all) 
                range.collapseChildren = 10000;
            this.addFold("...", range);
        }
        
        return range;
    };
    
    /**
     * 
     * @param {boolean} [toggleParent]
     */
    this.toggleFoldWidget = function(toggleParent) {
        var row = this.selection.getCursor().row;
        row = this.getRowFoldStart(row);
        var range = this.$toggleFoldWidget(row, {});
        
        if (range)
            return;
        // handle toggleParent
        var data = this.getParentFoldRangeData(row, true);
        range = data.range || data.firstRange;
        
        if (range) {
            row = range.start.row;
            var fold = this.getFoldAt(row, this.getLine(row).length, 1);

            if (fold) {
                this.removeFold(fold);
            } else {
                this.addFold("...", range);
            }
        }
    };

    /**
     * @param {Delta} delta
     */
    this.updateFoldWidgets = function(delta) {
        var firstRow = delta.start.row;
        var len = delta.end.row - firstRow;

        if (len === 0) {
            this.foldWidgets[firstRow] = null;
        } else if (delta.action == 'remove') {
            this.foldWidgets.splice(firstRow, len + 1, null);
        } else {
            var args = Array(len + 1);
            args.unshift(firstRow, 1);
            this.foldWidgets.splice.apply(this.foldWidgets, args);
        }
    };
    /**
     * @param e
     */
    this.tokenizerUpdateFoldWidgets = function(e) {
        var rows = e.data;
        if (rows.first != rows.last) {
            if (this.foldWidgets.length > rows.first)
                this.foldWidgets.splice(rows.first, this.foldWidgets.length);
        }
    };
}

exports.M = Folding;


/***/ }),

/***/ 63379:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *
 * @typedef {import("../editor").Editor} Editor
 */
var oop = __webpack_require__(2645);
var MultiHashHandler = (__webpack_require__(93050).MultiHashHandler);
var EventEmitter = (__webpack_require__(87366).EventEmitter);

class CommandManager extends MultiHashHandler{
    /**
     * new CommandManager(platform, commands)
     * @param {import("../keyboard/hash_handler").Platform} platform Identifier for the platform; must be either `"mac"` or `"win"`
     * @param {any[]} commands A list of commands
     **/
    constructor(platform, commands) {
        super(commands, platform);
        this.byName = this.commands;
        this.setDefaultHandler("exec", function(e) {
            if (!e.args) {
                return e.command.exec(e.editor, {}, e.event, true);
            }
            return e.command.exec(e.editor, e.args, e.event, false);
        });
    }

    /**
     * 
     * @param {string | string[] | import("../../ace-internal").Ace.Command} command
     * @param {Editor} editor
     * @param {any} args
     * @returns {boolean}
     */
    exec(command, editor, args) {
        if (Array.isArray(command)) {
            for (var i = command.length; i--; ) {
                if (this.exec(command[i], editor, args)) return true;
            }
            return false;
        }
        
        if (typeof command === "string")
            command = this.commands[command];

        var e = {editor: editor, command: command, args: args};
        
        if (!this.canExecute(command, editor)) {
            this._signal("commandUnavailable", e);
            return false; 
        }
        
        e.returnValue = this._emit("exec", e);
        this._signal("afterExec", e);

        return e.returnValue === false ? false : true;
    }

    /**
     *
     * @param {string | import("../../ace-internal").Ace.Command} command
     * @param {Editor} editor
     * @returns {boolean}
     */
    canExecute(command, editor) {
        if (typeof command === "string")
            command = this.commands[command];
        
        if (!command)
            return false;

        if (editor && editor.$readOnly && !command.readOnly)
            return false;

        if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor))
            return false;
        
        return true;
    }
    

    /**
     * @param {Editor} editor
     * @returns {boolean}
     */
    toggleRecording(editor) {
        if (this.$inReplay)
            return;

        editor && editor._emit("changeStatus");
        if (this.recording) {
            this.macro.pop();
            this.off("exec", this.$addCommandToMacro);

            if (!this.macro.length)
                this.macro = this.oldMacro;

            return this.recording = false;
        }
        if (!this.$addCommandToMacro) {
            this.$addCommandToMacro = function(e) {
                this.macro.push([e.command, e.args]);
            }.bind(this);
        }

        this.oldMacro = this.macro;
        this.macro = [];
        this.on("exec", this.$addCommandToMacro);
        return this.recording = true;
    }

    /**
     * @param {Editor} editor
     */
    replay(editor) {
        if (this.$inReplay || !this.macro)
            return;

        if (this.recording)
            return this.toggleRecording(editor);

        try {
            this.$inReplay = true;
            this.macro.forEach(function(x) {
                if (typeof x == "string")
                    this.exec(x, editor);
                else
                    this.exec(x[0], editor, x[1]);
            }, this);
        } finally {
            this.$inReplay = false;
        }
    }

    trimMacro(m) {
        return m.map(function(x){
            if (typeof x[0] != "string")
                x[0] = x[0].name;
            if (!x[1])
                x = x[0];
            return x;
        });
    }

}
oop.implement(CommandManager.prototype, EventEmitter);

exports.CommandManager = CommandManager;


/***/ }),

/***/ 63816:
/***/ ((__unused_webpack_module, exports) => {

var defaultEnglishMessages = {
    "autocomplete.popup.aria-roledescription": "Autocomplete suggestions",
    "autocomplete.popup.aria-label": "Autocomplete suggestions",
    "autocomplete.popup.item.aria-roledescription": "item",
    "autocomplete.loading": "Loading...",
    "editor.scroller.aria-roledescription": "editor",
    "editor.scroller.aria-label": "Editor content, press Enter to start editing, press Escape to exit",
    "editor.gutter.aria-roledescription": "editor gutter",
    "editor.gutter.aria-label": "Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit",
    "error-marker.good-state": "Looks good!",
    "prompt.recently-used": "Recently used",
    "prompt.other-commands": "Other commands",
    "prompt.no-matching-commands": "No matching commands",
    "search-box.find.placeholder": "Search for",
    "search-box.find-all.text": "All",
    "search-box.replace.placeholder": "Replace with",
    "search-box.replace-next.text": "Replace",
    "search-box.replace-all.text": "All",
    "search-box.toggle-replace.title": "Toggle Replace mode",
    "search-box.toggle-regexp.title": "RegExp Search",
    "search-box.toggle-case.title": "CaseSensitive Search",
    "search-box.toggle-whole-word.title": "Whole Word Search",
    "search-box.toggle-in-selection.title": "Search In Selection",
    "search-box.search-counter": "$0 of $1",
    "text-input.aria-roledescription": "editor",
    "text-input.aria-label": "Cursor at row $0",
    "gutter.code-folding.range.aria-label": "Toggle code folding, rows $0 through $1",
    "gutter.code-folding.closed.aria-label": "Toggle code folding, rows $0 through $1",
    "gutter.code-folding.open.aria-label": "Toggle code folding, row $0",
    "gutter.code-folding.closed.title": "Unfold code",
    "gutter.code-folding.open.title": "Fold code",
    "gutter.annotation.aria-label.error": "Error, read annotations row $0",
    "gutter.annotation.aria-label.warning": "Warning, read annotations row $0",
    "gutter.annotation.aria-label.info": "Info, read annotations row $0",
    "inline-fold.closed.title": "Unfold code",
    "gutter-tooltip.aria-label.error.singular": "error",
    "gutter-tooltip.aria-label.error.plural": "errors",
    "gutter-tooltip.aria-label.warning.singular": "warning",
    "gutter-tooltip.aria-label.warning.plural": "warnings",
    "gutter-tooltip.aria-label.info.singular": "information message",
    "gutter-tooltip.aria-label.info.plural": "information messages",
    "gutter.annotation.aria-label.security": "Security finding, read annotations row $0",
    "gutter.annotation.aria-label.hint": "Suggestion, read annotations row $0",
    "gutter-tooltip.aria-label.security.singular": "security finding",
    "gutter-tooltip.aria-label.security.plural": "security findings",
    "gutter-tooltip.aria-label.hint.singular": "suggestion",
    "gutter-tooltip.aria-label.hint.plural": "suggestions",
    "editor.tooltip.disable-editing": "Editing is disabled"
}

exports.q = defaultEnglishMessages;

/***/ }),

/***/ 65217:
/***/ ((module) => {

"use strict";


var $cancelT;
module.exports = { 
    /** @type {string|false} */
    lineMode: false,
    pasteCancelled: function() {
        if ($cancelT && $cancelT > Date.now() - 50)
            return true;
        return $cancelT = false;
    },
    cancel: function() {
        $cancelT = Date.now();
    }
};


/***/ }),

/***/ 67490:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./document").Document} Document
 */
var oop = __webpack_require__(2645);
var EventEmitter = (__webpack_require__(87366).EventEmitter);

/**
 * Defines a floating pointer in the document. Whenever text is inserted or deleted before the cursor, the position of the anchor is updated.
 **/
class Anchor {
    /**
     * Creates a new `Anchor` and associates it with a document.
     *
     * @param {Document} doc The document to associate with the anchor
     * @param {Number|import("../ace-internal").Ace.Point} row The starting row position
     * @param {Number} [column] The starting column position
     **/
    constructor(doc, row, column) {
        this.$onChange = this.onChange.bind(this);
        this.attach(doc);

        if (typeof row != "number")
            this.setPosition(row.row, row.column);
        else
            this.setPosition(row, column);
    }

    /**
     * Returns an object identifying the `row` and `column` position of the current anchor.
     * @returns {import("../ace-internal").Ace.Point}
     **/
    getPosition() {
        return this.$clipPositionToDocument(this.row, this.column);
    }

    /**
     *
     * Returns the current document.
     * @returns {Document}
     **/
    getDocument() {
        return this.document;
    }

    /**
     * Internal function called when `"change"` event fired.
     * @param {import("../ace-internal").Ace.Delta} delta
     * @internal
     */
    onChange(delta) {
        if (delta.start.row == delta.end.row && delta.start.row != this.row)
            return;

        if (delta.start.row > this.row)
            return;

        var point = $getTransformedPoint(delta, {row: this.row, column: this.column}, this.$insertRight);
        this.setPosition(point.row, point.column, true);
    }

    /**
     * Sets the anchor position to the specified row and column. If `noClip` is `true`, the position is not clipped.
     * @param {Number} row The row index to move the anchor to
     * @param {Number} column The column index to move the anchor to
     * @param {Boolean} [noClip] Identifies if you want the position to be clipped
     **/
    setPosition(row, column, noClip) {
        var pos;
        if (noClip) {
            pos = {
                row: row,
                column: column
            };
        } else {
            pos = this.$clipPositionToDocument(row, column);
        }

        if (this.row == pos.row && this.column == pos.column)
            return;

        var old = {
            row: this.row,
            column: this.column
        };

        this.row = pos.row;
        this.column = pos.column;
        this._signal("change", {
            old: old,
            value: pos
        });
    }

    /**
     * When called, the `"change"` event listener is removed.
     *
     **/
    detach() {
        this.document.off("change", this.$onChange);
    }

    /**
     * When called, the `"change"` event listener is appended.
     * @param {Document} doc The document to associate with
     *
     **/
    attach(doc) {
        /**@type{Document}*/
        this.document = doc || this.document;
        this.document.on("change", this.$onChange);
    }

    /**
     * Clips the anchor position to the specified row and column.
     * @param {Number} row The row index to clip the anchor to
     * @param {Number} column The column index to clip the anchor to
     * @returns {import("../ace-internal").Ace.Point}
     *
     **/
    $clipPositionToDocument(row, column) {
        var pos = {};

        if (row >= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
        }
        else if (row < 0) {
            pos.row = 0;
            pos.column = 0;
        }
        else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
        }

        if (column < 0)
            pos.column = 0;

        return pos;
    }
}

/**
 * experimental: allows anchor to stick to the next on the left
 */
Anchor.prototype.$insertRight = false;

oop.implement(Anchor.prototype, EventEmitter);

function $pointsInOrder(point1, point2, equalPointsInOrder) {
    var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
    return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);
}

function $getTransformedPoint(delta, point, moveIfEqual) {
    // Get delta info.
    var deltaIsInsert = delta.action == "insert";
    var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row    - delta.start.row);
    var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
    var deltaStart = delta.start;
    var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.

    // DELTA AFTER POINT: No change needed.
    if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
        return {
            row: point.row,
            column: point.column
        };
    }

    // DELTA BEFORE POINT: Move point by delta shift.
    if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
        return {
            row: point.row + deltaRowShift,
            column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
        };
    }

    // DELTA ENVELOPS POINT (delete only): Move point to delta start.
    // TODO warn if delta.action != "remove" ?

    return {
        row: deltaStart.row,
        column: deltaStart.column
    };
}

exports.M = Anchor;


/***/ }),

/***/ 69615:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./mouse_handler").MouseHandler} MouseHandler
 */
var dom = __webpack_require__(71435);
var event = __webpack_require__(19631);
var useragent = __webpack_require__(74943);

var AUTOSCROLL_DELAY = 200;
var SCROLL_CURSOR_DELAY = 200;
var SCROLL_CURSOR_HYSTERESIS = 5;

/**
 * @param {MouseHandler} mouseHandler
 */
function DragdropHandler(mouseHandler) {

    var editor = mouseHandler.editor;

    var dragImage = dom.createElement("div");
    dragImage.style.cssText = "top:-100px;position:absolute;z-index:2147483647;opacity:0.5";
    dragImage.textContent = "\xa0";

    var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];

    exports.forEach(function(x) {
        mouseHandler[x] = this[x];
    }, this);
    // @ts-ignore
    editor.on("mousedown", this.onMouseDown.bind(mouseHandler));

    var mouseTarget = editor.container;
    var dragSelectionMarker, x, y;
    var timerId, range;
    var dragCursor, counter = 0;
    var dragOperation;
    var isInternal;
    var autoScrollStartTime;
    var cursorMovedTime;
    var cursorPointOnCaretMoved;
    /**
     * @param e
     * @this {MouseHandler}
     * @return {*}
     */
    this.onDragStart = function(e) {
        // webkit workaround, see this.onMouseDown
        if (this.cancelDrag || !mouseTarget.draggable) {
            var self = this;
            setTimeout(function(){
                self.startSelect();
                self.captureMouse(e);
            }, 0);
            return e.preventDefault();
        }
        range = editor.getSelectionRange();

        var dataTransfer = e.dataTransfer;
        dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
        editor.container.appendChild(dragImage);

        dataTransfer.setDragImage && dataTransfer.setDragImage(dragImage, 0, 0);
        setTimeout(function() {
            editor.container.removeChild(dragImage);
        });
        // clear Opera garbage
        dataTransfer.clearData();
        dataTransfer.setData("Text", editor.session.getTextRange());

        isInternal = true;
        this.setState("drag");
    };
    /**
     * @param e
     * @this {MouseHandler}
     * @return {*}
     */
    this.onDragEnd = function(e) {
        mouseTarget.draggable = false;
        isInternal = false;
        this.setState(null);
        if (!editor.getReadOnly()) {
            var dropEffect = e.dataTransfer.dropEffect;
            if (!dragOperation && dropEffect == "move")
                // text was dragged outside the editor
                editor.session.remove(editor.getSelectionRange());
            editor.$resetCursorStyle();
        }
        this.editor.unsetStyle("ace_dragging");
        this.editor.renderer.setCursorStyle("");
    };
    /**
     * @param e
     * @this {MouseHandler}
     * @return {*}
     */
    this.onDragEnter = function(e) {
        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
        x = e.clientX;
        y = e.clientY;
        if (!dragSelectionMarker)
            addDragMarker();
        counter++;
        // dataTransfer object does not save dropEffect across events on IE, so we store it in dragOperation
        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
        return event.preventDefault(e);
    };
    /**
     * @param e
     * @this {MouseHandler}
     * @return {*}
     */
    this.onDragOver = function(e) {
        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
        x = e.clientX;
        y = e.clientY;
        // Opera doesn't trigger dragenter event on drag start
        if (!dragSelectionMarker) {
            addDragMarker();
            counter++;
        }
        if (onMouseMoveTimer !== null)
            onMouseMoveTimer = null;

        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
        return event.preventDefault(e);
    };

    this.onDragLeave = function(e) {
        counter--;
        if (counter <= 0 && dragSelectionMarker) {
            clearDragMarker();
            dragOperation = null;
            return event.preventDefault(e);
        }
    };
    /**
     * @param e
     * @this {MouseHandler}
     * @return {*}
     */
    this.onDrop = function(e) {
        if (!dragCursor)
            return;
        var dataTransfer = e.dataTransfer;
        if (isInternal) {
            switch (dragOperation) {
                case "move":
                    if (range.contains(dragCursor.row, dragCursor.column)) {
                        // clear selection
                        range = {
                            start: dragCursor,
                            end: dragCursor
                        };
                    } else {
                        // move text
                        range = editor.moveText(range, dragCursor);
                    }
                    break;
                case "copy":
                    // copy text
                    range = editor.moveText(range, dragCursor, true);
                    break;
            }
        } else {
            var dropData = dataTransfer.getData('Text');
            range = {
                start: dragCursor,
                end: editor.session.insert(dragCursor, dropData)
            };
            editor.focus();
            dragOperation = null;
        }
        clearDragMarker();
        return event.preventDefault(e);
    };

    event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler), editor);
    event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler), editor);
    event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler), editor);
    event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler), editor);
    event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler), editor);
    event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler), editor);

    function scrollCursorIntoView(cursor, prevCursor) {
        var now = Date.now();
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        var hMovement = !prevCursor || cursor.column != prevCursor.column;
        if (!cursorMovedTime || vMovement || hMovement) {
            editor.moveCursorToPosition(cursor);
            cursorMovedTime = now;
            cursorPointOnCaretMoved = {x: x, y: y};
        } else {
            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
            if (distance > SCROLL_CURSOR_HYSTERESIS) {
                cursorMovedTime = null;
            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
                editor.renderer.scrollCursorIntoView();
                cursorMovedTime = null;
            }
        }
    }

    function autoScroll(cursor, prevCursor) {
        var now = Date.now();
        var lineHeight = editor.renderer.layerConfig.lineHeight;
        var characterWidth = editor.renderer.layerConfig.characterWidth;
        var editorRect = editor.renderer.scroller.getBoundingClientRect();
        var offsets = {
           x: {
               left: x - editorRect.left,
               right: editorRect.right - x
           },
           y: {
               top: y - editorRect.top,
               bottom: editorRect.bottom - y
           }
        };
        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
        var scrollCursor = {row: cursor.row, column: cursor.column};
        if (nearestXOffset / characterWidth <= 2) {
            scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);
        }
        if (nearestYOffset / lineHeight <= 1) {
            scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);
        }
        var vScroll = cursor.row != scrollCursor.row;
        var hScroll = cursor.column != scrollCursor.column;
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        if (vScroll || (hScroll && !vMovement)) {
            if (!autoScrollStartTime)
                autoScrollStartTime = now;
            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
                editor.renderer.scrollCursorIntoView(scrollCursor);
        } else {
            autoScrollStartTime = null;
        }
    }

    function onDragInterval() {
        var prevCursor = dragCursor;
        dragCursor = editor.renderer.screenToTextCoordinates(x, y);
        scrollCursorIntoView(dragCursor, prevCursor);
        autoScroll(dragCursor, prevCursor);
    }

    function addDragMarker() {
        range = editor.selection.toOrientedRange();
        dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
        editor.clearSelection();
        if (editor.isFocused())
            editor.renderer.$cursorLayer.setBlinking(false);
        clearInterval(timerId);
        onDragInterval();
        timerId = setInterval(onDragInterval, 20);
        counter = 0;
        event.addListener(document, "mousemove", onMouseMove);
    }

    function clearDragMarker() {
        clearInterval(timerId);
        editor.session.removeMarker(dragSelectionMarker);
        dragSelectionMarker = null;
        editor.selection.fromOrientedRange(range);
        if (editor.isFocused() && !isInternal)
            editor.$resetCursorStyle();
        range = null;
        dragCursor = null;
        counter = 0;
        autoScrollStartTime = null;
        cursorMovedTime = null;
        event.removeListener(document, "mousemove", onMouseMove);
    }

    // sometimes other code on the page can stop dragleave event leaving editor stuck in the drag state
    var onMouseMoveTimer = null;
    function onMouseMove() {
        if (onMouseMoveTimer == null) {
            onMouseMoveTimer = setTimeout(function() {
                if (onMouseMoveTimer != null && dragSelectionMarker)
                    clearDragMarker();
            }, 20);
        }
    }

    function canAccept(dataTransfer) {
        var types = dataTransfer.types;
        return !types || Array.prototype.some.call(types, function(type) {
            return type == 'text/plain' || type == 'Text';
        });
    }

    function getDropEffect(e) {
        var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
        var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];

        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;

        // IE throws error while dragging from another app
        var effectAllowed = "uninitialized";
        try {
            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
        } catch (e) {}
        var dropEffect = "none";

        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
        else if (moveAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "move";
        else if (copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";

        return dropEffect;
    }
}

/**
 * @this {MouseHandler}
 */
(function() {

    /**
     * @this {MouseHandler & this}
     */
    this.dragWait = function() {
        var interval = Date.now() - this.mousedownEvent.time;
        if (interval > this.editor.getDragDelay())
            this.startDrag();
    };

    /**
     * @this {MouseHandler & this}
     */
    this.dragWaitEnd = function() {
        var target = this.editor.container;
        target.draggable = false;
        this.startSelect(this.mousedownEvent.getDocumentPosition());
        this.selectEnd();
    };

    /**
     * @this {MouseHandler & this}
     */
    this.dragReadyEnd = function(e) {
        this.editor.$resetCursorStyle();
        this.editor.unsetStyle("ace_dragging");
        this.editor.renderer.setCursorStyle("");
        this.dragWaitEnd();
    };

    /**
     * @this {MouseHandler & this}
     */
    this.startDrag = function(){
        this.cancelDrag = false;
        var editor = this.editor;
        var target = editor.container;
        target.draggable = true;
        editor.renderer.$cursorLayer.setBlinking(false);
        editor.setStyle("ace_dragging");
        var cursorStyle = useragent.isWin ? "default" : "move";
        editor.renderer.setCursorStyle(cursorStyle);
        this.setState("dragReady");
    };

    /**
     * @this {MouseHandler & this}
     */
    this.onMouseDrag = function(e) {
        var target = this.editor.container;
        if (useragent.isIE && this.state == "dragReady") {
            // IE does not handle [draggable] attribute set after mousedown
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 3)
                // @ts-ignore
                target.dragDrop();
        }
        if (this.state === "dragWait") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 0) {
                target.draggable = false;
                this.startSelect(this.mousedownEvent.getDocumentPosition());
            }
        }
    };

    /**
     * @this {MouseHandler & this}
     */
    this.onMouseDown = function(e) {
        if (!this.$dragEnabled)
            return;
        this.mousedownEvent = e;
        var editor = this.editor;

        var inSelection = e.inSelection();
        var button = e.getButton();
        var clickCount = e.domEvent.detail || 1;
        if (clickCount === 1 && button === 0 && inSelection) {
            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
                return;
            this.mousedownEvent.time = Date.now();
            var eventTarget = e.domEvent.target || e.domEvent.srcElement;
            if ("unselectable" in eventTarget)
                eventTarget.unselectable = "on";
            if (editor.getDragDelay()) {
                // https://code.google.com/p/chromium/issues/detail?id=286700
                if (useragent.isWebKit) {
                    this.cancelDrag = true;
                    var mouseTarget = editor.container;
                    mouseTarget.draggable = true;
                }
                this.setState("dragWait");
            } else {
                this.startDrag();
            }
            this.captureMouse(e, this.onMouseDrag.bind(this));
            // TODO: a better way to prevent default handler without preventing browser default action
            e.defaultPrevented = true;
        }
    };

}).call(DragdropHandler.prototype);


function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
}

exports.O = DragdropHandler;


/***/ }),

/***/ 69957:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("../editor").Editor} Editor
 * @typedef {import("../../ace-internal").Ace.KeyboardHandler} KeyboardHandler
 */
var keyUtil  = __webpack_require__(29451);
var event = __webpack_require__(19631);


class KeyBinding {
    /**
     * @param {Editor} editor
     */
    constructor(editor) {
        this.$editor = editor;
        this.$data = {editor: editor};
        /**@type {(KeyboardHandler)[]}*/
        this.$handlers = [];
        this.setDefaultHandler(editor.commands);
    }

    /**
     * @param {KeyboardHandler} kb
     */
    setDefaultHandler(kb) {
        this.removeKeyboardHandler(this.$defaultHandler);
        this.$defaultHandler = kb;
        this.addKeyboardHandler(kb, 0);
    }

    /**
     * @param {KeyboardHandler} kb
     */
    setKeyboardHandler(kb) {
        var h = this.$handlers;
        if (h[h.length - 1] == kb)
            return;

        while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
            this.removeKeyboardHandler(h[h.length - 1]);

        this.addKeyboardHandler(kb, 1);
    }

    /**
     * @param {KeyboardHandler & {attach?: (editor: any) => void, detach?: (editor: any) => void;}} [kb]
     * @param {number} [pos]
     */
    addKeyboardHandler(kb, pos) {
        if (!kb)
            return;
        // @ts-ignore
        if (typeof kb == "function" && !kb.handleKeyboard)
            // @ts-ignore
            kb.handleKeyboard = kb;
        var i = this.$handlers.indexOf(kb);
        if (i != -1)
            this.$handlers.splice(i, 1);

        if (pos == undefined)
            this.$handlers.push(kb);
        else
            this.$handlers.splice(pos, 0, kb);

        if (i == -1 && kb.attach)
            kb.attach(this.$editor);
    }

    /**
     * @param {KeyboardHandler & {attach?: (editor: any) => void, detach?: (editor: any) => void;}} kb
     * @returns {boolean}
     */
    removeKeyboardHandler(kb) {
        var i = this.$handlers.indexOf(kb);
        if (i == -1)
            return false;
        this.$handlers.splice(i, 1);
        kb.detach && kb.detach(this.$editor);
        return true;
    }

    /**
     * @return {KeyboardHandler}
     */
    getKeyboardHandler() {
        return this.$handlers[this.$handlers.length - 1];
    }

    getStatusText() {
        var data = this.$data;
        var editor = data.editor;
        return this.$handlers.map(function(h) {
            return h.getStatusText && h.getStatusText(editor, data) || "";
        }).filter(Boolean).join(" ");
    }

    $callKeyboardHandlers(hashId, keyString, keyCode, e) {
        var toExecute;
        var success = false;
        var commands = this.$editor.commands;

        for (var i = this.$handlers.length; i--;) {
            toExecute = this.$handlers[i].handleKeyboard(
                // @ts-expect-error TODO: could be wrong arguments amount
                this.$data, hashId, keyString, keyCode, e
            );
            if (!toExecute || !toExecute.command)
                continue;

            // allow keyboardHandler to consume keys
            if (toExecute.command == "null") {
                success = true;
            } else {
                // @ts-expect-error //TODO: potential wrong arguments amount
                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
            }
            // do not stop input events to not break repeating
            if (success && e && hashId != -1 &&
                toExecute["passEvent"] != true && toExecute.command["passEvent"] != true
            ) {
                event.stopEvent(e);
            }
            if (success)
                break;
        }

        if (!success && hashId == -1) {
            toExecute = {command: "insertstring"};
            success = commands.exec("insertstring", this.$editor, keyString);
        }

        if (success && this.$editor._signal)
            this.$editor._signal("keyboardActivity", toExecute);

        return success;
    }

    /**
     * @param {any} e
     * @param {number} hashId
     * @param {number} keyCode
     * @return {boolean}
     * @internal
     */
    onCommandKey(e, hashId, keyCode) {
        var keyString = keyUtil.keyCodeToString(keyCode);
        return this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
    }

    /**
     * @param {string} text
     * @return {boolean}
     * @internal
     */
    onTextInput(text) {
        return this.$callKeyboardHandlers(-1, text);
    }

}

exports.$ = KeyBinding;


/***/ }),

/***/ 70649:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./fold").Fold} Fold
 */
var Range = (__webpack_require__(91902)/* .Range */ .Q);

class FoldLine {
    /**
     * If an array is passed in, the folds are expected to be sorted already.
     * @param {FoldLine[]} foldData
     * @param {Fold[]|Fold} folds
     */
    constructor(foldData, folds) {
        this.foldData = foldData;
        if (Array.isArray(folds)) {
            /**@type {Fold[]} */
            this.folds = folds;
        } else {
            folds = this.folds = [ folds ];
        }

        var last = folds[folds.length - 1];
        this.range = new Range(folds[0].start.row, folds[0].start.column,
            last.end.row, last.end.column);
        this.start = this.range.start;
        this.end   = this.range.end;

        this.folds.forEach(function(fold) {
            fold.setFoldLine(this);
        }, this);
    }
    
    /**
     * Note: This doesn't update wrapData!
     * @param {number} shift
     */
    shiftRow(shift) {
        this.start.row += shift;
        this.end.row += shift;
        this.folds.forEach(function(fold) {
            fold.start.row += shift;
            fold.end.row += shift;
        });
    }

    /**
     * @param {Fold} fold
     */
    addFold(fold) {
        if (fold.sameRow) {
            // @ts-expect-error TODO: startRow, endRow are missing in Fold and FoldLine
            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                throw new Error("Can't add a fold to this FoldLine as it has no connection");
            }
            this.folds.push(fold);
            this.folds.sort(function(a, b) {
                return -a.range.compareEnd(b.start.row, b.start.column);
            });
            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                this.end.row = fold.end.row;
                this.end.column =  fold.end.column;
            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                this.start.row = fold.start.row;
                this.start.column = fold.start.column;
            }
        } else if (fold.start.row == this.end.row) {
            this.folds.push(fold);
            this.end.row = fold.end.row;
            this.end.column = fold.end.column;
        } else if (fold.end.row == this.start.row) {
            this.folds.unshift(fold);
            this.start.row = fold.start.row;
            this.start.column = fold.start.column;
        } else {
            throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
        }
        fold.foldLine = this;
    }

    /**
     * @param {number} row
     */
    containsRow(row) {
        return row >= this.start.row && row <= this.end.row;
    }

    /**
     * @param {Function} callback
     * @param {number} endRow
     * @param {number} endColumn
     */
    walk(callback, endRow, endColumn) {
        var lastEnd = 0,
            folds = this.folds,
            fold,
            cmp, stop, isNewRow = true;

        if (endRow == null) {
            endRow = this.end.row;
            endColumn = this.end.column;
        }

        for (var i = 0; i < folds.length; i++) {
            fold = folds[i];

            cmp = fold.range.compareStart(endRow, endColumn);
            // This fold is after the endRow/Column.
            if (cmp == -1) {
                callback(null, endRow, endColumn, lastEnd, isNewRow);
                return;
            }

            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);

            // If the user requested to stop the walk or endRow/endColumn is
            // inside of this fold (cmp == 0), then end here.
            if (stop || cmp === 0) {
                return;
            }

            // Note the new lastEnd might not be on the same line. However,
            // it's the callback's job to recognize this.
            isNewRow = !fold.sameRow;
            lastEnd = fold.end.column;
        }
        callback(null, endRow, endColumn, lastEnd, isNewRow);
    }

    /**
     * @param {number} row
     * @param {number} column
     * @return {{ fold: Fold, kind: string } | null}
     */
    getNextFoldTo(row, column) {
        var fold, cmp;
        for (var i = 0; i < this.folds.length; i++) {
            fold = this.folds[i];
            cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                return {
                    fold: fold,
                    kind: "after"
                };
            } else if (cmp === 0) {
                return {
                    fold: fold,
                    kind: "inside"
                };
            }
        }
        return null;
    }

    /**
     * @param {number} row
     * @param {number} column
     * @param {number} len
     */
    addRemoveChars(row, column, len) {
        var ret = this.getNextFoldTo(row, column),
            fold, folds;
        if (ret) {
            fold = ret.fold;
            if (ret.kind == "inside"
                && fold.start.column != column
                && fold.start.row != row)
            {
                //throwing here breaks whole editor
                //TODO: properly handle this
                window.console && window.console.log(row, column, fold);
            } else if (fold.start.row == row) {
                folds = this.folds;
                var i = folds.indexOf(fold);
                if (i === 0) {
                    this.start.column += len;
                }
                for (i; i < folds.length; i++) {
                    fold = folds[i];
                    fold.start.column += len;
                    if (!fold.sameRow) {
                        return;
                    }
                    fold.end.column += len;
                }
                this.end.column += len;
            }
        }
    }

    /**
     * @param {number} row
     * @param {number} column
     * @return {FoldLine | null}
     */
    split(row, column) {
        var pos = this.getNextFoldTo(row, column);
        
        if (!pos || pos.kind == "inside")
            return null;
            
        var fold = pos.fold;
        var folds = this.folds;
        var foldData = this.foldData;
        
        var i = folds.indexOf(fold);
        var foldBefore = folds[i - 1];
        this.end.row = foldBefore.end.row;
        this.end.column = foldBefore.end.column;

        // Remove the folds after row/column and create a new FoldLine
        // containing these removed folds.
        folds = folds.splice(i, folds.length - i);

        var newFoldLine = new FoldLine(foldData, folds);
        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
        return newFoldLine;
    }

    /**
     * @param {FoldLine} foldLineNext
     */
    merge(foldLineNext) {
        var folds = foldLineNext.folds;
        for (var i = 0; i < folds.length; i++) {
            this.addFold(folds[i]);
        }
        // Remove the foldLineNext - no longer needed, as
        // it's merged now with foldLineNext.
        var foldData = this.foldData;
        foldData.splice(foldData.indexOf(foldLineNext), 1);
    }

    toString() {
        var ret = [this.range.toString() + ": [" ];

        this.folds.forEach(function(fold) {
            ret.push("  " + fold.toString());
        });
        ret.push("]");
        return ret.join("\n");
    }

    /**
     * @param {number} idx
     * @return {import("../../ace-internal").Ace.Point}
     */
    idxToPosition(idx) {
        var lastFoldEndColumn = 0;

        for (var i = 0; i < this.folds.length; i++) {
            var fold = this.folds[i];

            idx -= fold.start.column - lastFoldEndColumn;
            if (idx < 0) {
                return {
                    row: fold.start.row,
                    column: fold.start.column + idx
                };
            }

            idx -= fold.placeholder.length;
            if (idx < 0) {
                return fold.start;
            }

            lastFoldEndColumn = fold.end.column;
        }

        return {
            row: this.end.row,
            column: this.end.column + idx
        };
    }
}

exports.M = FoldLine;


/***/ }),

/***/ 71435:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var useragent = __webpack_require__(74943); 
var XHTML_NS = "http://www.w3.org/1999/xhtml";

/**
 * @template {keyof HTMLElementTagNameMap} K
 * @overload
 * @param {[K, ...any[]]} arr
 * @param {HTMLElement} [parent]
 * @param {Record<string, Node>} [refs]
 * @returns {HTMLElementTagNameMap[K]} 
 */
/**
 * @overload
 * @param {any} arr
 * @param {HTMLElement} [parent]
 * @param [refs]
 * @returns {HTMLElement | Text | any[]} 
 */
exports.buildDom = function buildDom(arr, parent, refs) {
    if (typeof arr == "string" && arr) {
        var txt = document.createTextNode(arr);
        if (parent)
            parent.appendChild(txt);
        return txt;
    }
    
    if (!Array.isArray(arr)) {
        if (arr && arr.appendChild && parent)
            parent.appendChild(arr);
        return arr;
    }
    if (typeof arr[0] != "string" || !arr[0]) {
        var els = [];
        for (var i = 0; i < arr.length; i++) {
            var ch = buildDom(arr[i], parent, refs);
            ch && els.push(ch);
        }
        return els;
    }
    
    var el = document.createElement(arr[0]);
    var options = arr[1];
    var childIndex = 1;
    if (options && typeof options == "object" && !Array.isArray(options))
        childIndex = 2;
    for (var i = childIndex; i < arr.length; i++)
        buildDom(arr[i], el, refs);
    if (childIndex == 2) {
        Object.keys(options).forEach(function(n) {
            var val = options[n];
            if (n === "class") {
                el.className = Array.isArray(val) ? val.join(" ") : val;
            } else if (typeof val == "function" || n == "value" || n[0] == "$") {
                el[n] = val;
            } else if (n === "ref") {
                if (refs) refs[val] = el;
            } else if (n === "style") {
                if (typeof val == "string") el.style.cssText = val;
            } else if (val != null) {
                el.setAttribute(n, val);
            }
        });
    }
    if (parent)
        parent.appendChild(el);
    return el;
};

/**
 * 
 * @param {Document} [doc]
 * @returns {HTMLHeadElement|HTMLElement}
 */
exports.getDocumentHead = function(doc) {
    if (!doc)
        doc = document;
    return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
};


/**
 * @template {keyof HTMLElementTagNameMap} T
 * @param {T | string} tag
 * @param {string} [ns]
 * @returns {HTMLElementTagNameMap[T]}
 */
exports.createElement = function(tag, ns) {
    // @ts-expect-error
    return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
};

/**
 * @param {HTMLElement} element
 */
exports.removeChildren = function(element) {
    element.innerHTML = "";
};

/**
 * @param {string} textContent
 * @param {HTMLElement} [element]
 * @returns {Text}
 */
exports.createTextNode = function(textContent, element) {
    var doc = element ? element.ownerDocument : document;
    return doc.createTextNode(textContent);
};

/**
 * @param {HTMLElement} [element]
 * @returns {DocumentFragment}
 */
exports.createFragment = function(element) {
    var doc = element ? element.ownerDocument : document;
    return doc.createDocumentFragment();
};

/**
 * @param {HTMLElement} el
 * @param {string} name
 * @returns {boolean}
 */
exports.hasCssClass = function(el, name) {
    var classes = (el.className + "").split(/\s+/g);
    return classes.indexOf(name) !== -1;
};

/**
 * Add a CSS class to the list of classes on the given node
 * @param {HTMLElement} el
 * @param {string} name
*/
exports.addCssClass = function(el, name) {
    if (!exports.hasCssClass(el, name)) {
        el.className += " " + name;
    }
};

/**
 * Remove a CSS class from the list of classes on the given node
 * @param {HTMLElement} el
 * @param {string} name
 */
exports.removeCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g);
    while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
            break;
        }
        classes.splice(index, 1);
    }
    el.className = classes.join(" ");
};

/**
 * @param {HTMLElement} el
 * @param {string} name
 * @returns {boolean}
 */
exports.toggleCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g), add = true;
    while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
            break;
        }
        add = false;
        classes.splice(index, 1);
    }
    if (add)
        classes.push(name);

    el.className = classes.join(" ");
    return add;
};

/**
 * Add or remove a CSS class from the list of classes on the given node
 * depending on the value of <tt>include</tt>
 * @param {HTMLElement} node
 * @param {string} className
 * @param {boolean} include
 */
exports.setCssClass = function(node, className, include) {
    if (include) {
        exports.addCssClass(node, className);
    } else {
        exports.removeCssClass(node, className);
    }
};

/**
 * @param {string} id
 * @param {Document} [doc]
 * @returns {boolean}
 */
exports.hasCssString = function(id, doc) {
    var index = 0, sheets;
    doc = doc || document;
    if ((sheets = doc.querySelectorAll("style"))) {
        while (index < sheets.length) {
            if (sheets[index++].id === id) {
                return true;
            }
        }
    }
};

/**
 * @param {string} id
 * @param {Document} [doc]
 */
exports.removeElementById = function(id, doc) {
    doc = doc || document;
    if(doc.getElementById(id)) {
        doc.getElementById(id).remove();
    }
};

var strictCSP;
var cssCache = [];
exports.useStrictCSP = function(value) {
    strictCSP = value;
    if (value == false) insertPendingStyles();
    else if (!cssCache) cssCache = [];
};

function insertPendingStyles() {
    var cache = cssCache;
    cssCache = null;
    cache && cache.forEach(function(item) {
        importCssString(item[0], item[1]);
    });
}

/**
 * @param {string} cssText
 * @param {string} [id]
 * @param {any} [target]
 */
function importCssString(cssText, id, target) {
    if (typeof document == "undefined")
        return;
    if (cssCache) {
        if (target) {
            insertPendingStyles();
        } else if (target === false) {
            return cssCache.push([cssText, id]);
        }
    }
    if (strictCSP) return;

    var container = target;
    if (!target || !target.getRootNode) {
        container = document;
    } else {
        container = target.getRootNode();
        if (!container || container == target)
            container = document;
    }
    
    var doc = container.ownerDocument || container;
    
    // If style is already imported return immediately.
    if (id && exports.hasCssString(id, container))
        return null;
    
    if (id)
        cssText += "\n/*# sourceURL=ace/css/" + id + " */";
    
    var style = exports.createElement("style");
    style.appendChild(doc.createTextNode(cssText));
    if (id)
        style.id = id;

    if (container == doc)
        container = exports.getDocumentHead(doc);
    container.insertBefore(style, container.firstChild);
}
exports.importCssString = importCssString;

/**
 * @param {string} uri
 * @param {Document} [doc]
 */
exports.importCssStylsheet = function(uri, doc) {
    exports.buildDom(["link", {rel: "stylesheet", href: uri}], exports.getDocumentHead(doc));
};

/**
 * Due to bug in html specification fixed position elements are placed relative to 
 * ancestor with transform instead of screen, so we attempt to detect and compensate for that
 * @param {HTMLElement} el with position: fixed
 */
exports.$fixPositionBug = function(el) {
    var rect = el.getBoundingClientRect();
    if (el.style.left) {
        var target = parseFloat(el.style.left);
        var result = +rect.left;
        if (Math.abs(target - result) > 1) {
            el.style.left = 2 * target - result + "px";
        }
    }
    if (el.style.right) {
        var target = parseFloat(el.style.right);
        var result = window.innerWidth - rect.right;
        if (Math.abs(target - result) > 1) {
            el.style.right = 2 * target - result + "px";
        }
    }
    if (el.style.top) {
        var target = parseFloat(el.style.top);
        var result = +rect.top;
        if (Math.abs(target - result) > 1) {
            el.style.top = 2 * target - result + "px";
        }
    }
    if (el.style.bottom) {
        var target = parseFloat(el.style.bottom);
        var result = window.innerHeight - rect.bottom;
        if (Math.abs(target - result) > 1) {
            el.style.bottom = 2 * target - result + "px";
        }
    }
};

/**
 * @param {Document} [doc]
 * @returns {number}
 */
exports.scrollbarWidth = function(doc) {
    var inner = exports.createElement("ace_inner");
    inner.style.width = "100%";
    inner.style.minWidth = "0px";
    inner.style.height = "200px";
    inner.style.display = "block";

    var outer = exports.createElement("ace_outer");
    var style = outer.style;

    style.position = "absolute";
    style.left = "-10000px";
    style.overflow = "hidden";
    style.width = "200px";
    style.minWidth = "0px";
    style.height = "150px";
    style.display = "block";

    outer.appendChild(inner);

    var body = (doc && doc.documentElement) || (document && document.documentElement);
    if (!body) return 0;

    body.appendChild(outer);

    var noScrollbar = inner.offsetWidth;

    style.overflow = "scroll";
    var withScrollbar = inner.offsetWidth;

    if (noScrollbar === withScrollbar) {
        withScrollbar = outer.clientWidth;
    }

    body.removeChild(outer);

    return noScrollbar - withScrollbar;
};

/**
 * @param {Element} element
 * @param [style]
 * @returns {Partial<CSSStyleDeclaration>}
 */
exports.computedStyle = function(element, style) {
    return window.getComputedStyle(element, "") || {};
};

/**
 * 
 * @param {CSSStyleDeclaration} styles
 * @param {string} property
 * @param {string} value
 */
exports.setStyle = function(styles, property, value) {
    if (styles[property] !== value) {
        //console.log("set style", property, styles[property], value);
        styles[property] = value;
    }
};

exports.HAS_CSS_ANIMATION = false;
exports.HAS_CSS_TRANSFORMS = false;
exports.HI_DPI = useragent.isWin
    ? typeof window !== "undefined" && window.devicePixelRatio >= 1.5
    : true;

if (useragent.isChromeOS) exports.HI_DPI = false;

if (typeof document !== "undefined") {
    // detect CSS transformation support
    var div = document.createElement("div");
    if (exports.HI_DPI && div.style.transform  !== undefined)
        exports.HAS_CSS_TRANSFORMS = true;
    if (!useragent.isEdge && typeof div.style.animationName !== "undefined")
        exports.HAS_CSS_ANIMATION = true;
    div = null;
}

if (exports.HAS_CSS_TRANSFORMS) {
    exports.translate = function(element, tx, ty) {
        element.style.transform = "translate(" + Math.round(tx) + "px, " + Math.round(ty) +"px)";
    };
} else {
    exports.translate = function(element, tx, ty) {
        element.style.top = Math.round(ty) + "px";
        element.style.left = Math.round(tx) + "px";
    };
}


/***/ }),

/***/ 74943:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/*
 * I hate doing this, but we need some way to determine if the user is on a Mac
 * The reason is that users have different expectations of their key combinations.
 *
 * Take copy as an example, Mac people expect to use CMD or APPLE + C
 * Windows folks expect to use CTRL + C
 */
exports.OS = {
    LINUX: "LINUX",
    MAC: "MAC",
    WINDOWS: "WINDOWS"
};

/*
 * Return an exports.OS constant
 */
exports.getOS = function() {
    if (exports.isMac) {
        return exports.OS.MAC;
    } else if (exports.isLinux) {
        return exports.OS.LINUX;
    } else {
        return exports.OS.WINDOWS;
    }
};

// this can be called in non browser environments (e.g. from ace/requirejs/text)
var _navigator = typeof navigator == "object" ? navigator : {};

var os = (/mac|win|linux/i.exec(_navigator.platform) || ["other"])[0].toLowerCase();
var ua = _navigator.userAgent || "";
var appName = _navigator.appName || "";

// Is the user using a browser that identifies itself as Windows
exports.isWin = (os == "win");

// Is the user using a browser that identifies itself as Mac OS
exports.isMac = (os == "mac");

// Is the user using a browser that identifies itself as Linux
exports.isLinux = (os == "linux");

// Windows Store JavaScript apps (aka Metro apps written in HTML5 and JavaScript) do not use the "Microsoft Internet Explorer" string in their user agent, but "MSAppHost" instead.
exports.isIE = 
    (appName == "Microsoft Internet Explorer" || appName.indexOf("MSAppHost") >= 0)
    ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1])
    : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1]); // for ie
    
exports.isOldIE = exports.isIE && exports.isIE < 9;

// Is this Firefox or related?
exports.isGecko = exports.isMozilla = ua.match(/ Gecko\/\d+/);

// Is this Opera 
// @ts-expect-error
exports.isOpera = typeof opera == "object" && Object.prototype.toString.call(window["opera"]) == "[object Opera]";

// Is the user using a browser that identifies itself as WebKit 
exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;

exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;

exports.isSafari = parseFloat(ua.split(" Safari/")[1]) && !exports.isChrome || undefined;

exports.isEdge = parseFloat(ua.split(" Edge/")[1]) || undefined;

exports.isAIR = ua.indexOf("AdobeAIR") >= 0;

exports.isAndroid = ua.indexOf("Android") >= 0;

exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;

exports.isIOS = /iPad|iPhone|iPod/.test(ua) && !window["MSStream"];

if (exports.isIOS) exports.isMac = true;

exports.isMobile = exports.isIOS || exports.isAndroid;


/***/ }),

/***/ 75684:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var Behaviour;
Behaviour = function() {
   this.$behaviours = {};
};

(function () {

    /**
     * @this {Behaviour & this}
     */
    this.add = function (name, action, callback) {
        switch (undefined) {
          case this.$behaviours:
              this.$behaviours = {};
          case this.$behaviours[name]:
              this.$behaviours[name] = {};
        }
        this.$behaviours[name][action] = callback;
    };

    /**
     * @this {Behaviour & this}
     */
    this.addBehaviours = function (behaviours) {
        for (var key in behaviours) {
            for (var action in behaviours[key]) {
                this.add(key, action, behaviours[key][action]);
            }
        }
    };

    /**
     * @this {Behaviour & this}
     */
    this.remove = function (name) {
        if (this.$behaviours && this.$behaviours[name]) {
            delete this.$behaviours[name];
        }
    };

    /**
     * @this {Behaviour & this}
     */
    this.inherit = function (mode, filter) {
        if (typeof mode === "function") {
            var behaviours = new mode().getBehaviours(filter);
        } else {
            var behaviours = mode.getBehaviours(filter);
        }
        this.addBehaviours(behaviours);
    };

    /**
     *
     * @param [filter]
     * @returns {{}|*}
     * @this {Behaviour & this}
     */
    this.getBehaviours = function (filter) {
        if (!filter) {
            return this.$behaviours;
        } else {
            var ret = {};
            for (var i = 0; i < filter.length; i++) {
                if (this.$behaviours[filter[i]]) {
                    ret[filter[i]] = this.$behaviours[filter[i]];
                }
            }
            return ret;
        }
    };

}).call(Behaviour.prototype);

exports.Q = Behaviour;


/***/ }),

/***/ 76321:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
"no use strict";

var lang = __webpack_require__(39955);
var net = __webpack_require__(78552);
var dom = __webpack_require__(71435);
var AppConfig = (__webpack_require__(20845)/* .AppConfig */ .o);

module.exports = exports = new AppConfig();

/** @type {import("../ace-internal").Ace.ConfigOptions} */
var options = {
    packaged: false,
    workerPath: null,
    modePath: null,
    themePath: null,
    basePath: "",
    suffix: ".js",
    $moduleUrls: {},
    loadWorkerFromBlob: true,
    sharedPopups: false,
    useStrictCSP: null
};

/**
 * @template {keyof import("../ace-internal").Ace.ConfigOptions} K
 * @param {K} key - The key of the config option to retrieve.
 * @returns {import("../ace-internal").Ace.ConfigOptions[K]} - The value of the config option.
 */
exports.get = function(key) {
    if (!options.hasOwnProperty(key))
        throw new Error("Unknown config key: " + key);
    return options[key];
};

/**
 * @template {keyof import("../ace-internal").Ace.ConfigOptions} K
 * @param {K} key
 * @param {import("../ace-internal").Ace.ConfigOptions[K]} value
 */
exports.set = function(key, value) {
    if (options.hasOwnProperty(key))
        options[key] = value;
    else if (this.setDefaultValue("", key, value) == false)
        throw new Error("Unknown config key: " + key);
    if (key == "useStrictCSP")
        dom.useStrictCSP(value);
};
/**
 * @return {import("../ace-internal").Ace.ConfigOptions}
 */
exports.all = function() {
    return lang.copyObject(options);
};

exports.$modes = {};

/**
 * module loading
 * @param {string} name
 * @param {string} [component]
 * @returns {string}
 */
exports.moduleUrl = function(name, component) {
    if (options.$moduleUrls[name])
        return options.$moduleUrls[name];

    var parts = name.split("/");
    component = component || parts[parts.length - 2] || "";

    // todo make this configurable or get rid of '-'
    var sep = component == "snippets" ? "/" : "-";
    var base = parts[parts.length - 1];
    if (component == "worker" && sep == "-") {
        var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
        base = base.replace(re, "");
    }

    if ((!base || base == component) && parts.length > 1)
        base = parts[parts.length - 2];
    var path = options[component + "Path"];
    if (path == null) {
        path = options.basePath;
    } else if (sep == "/") {
        component = sep = "";
    }
    if (path && path.slice(-1) != "/")
        path += "/";
    return path + component + sep + base + this.get("suffix");
};
/**
 * @param {string} name
 * @param {string} subst
 * @returns {string}
 */
exports.setModuleUrl = function(name, subst) {
    return options.$moduleUrls[name] = subst;
};

var loader = function(moduleName, cb) {
    if (moduleName === "ace/theme/textmate" || moduleName === "./theme/textmate")
        return cb(null, __webpack_require__(87983));
    if (customLoader)
        return customLoader(moduleName, cb);
    console.error("loader is not configured");
};
var customLoader;

/** @arg {(name: string, callback: (error: any, module: any) => void) => void} cb */
exports.setLoader = function(cb) {
    customLoader = cb;
};

exports.dynamicModules = Object.create(null);
exports.$loading = {};
exports.$loaded = {};
/**
 * @param {string | [string, string]} moduleId
 * @param {(module: any) => void} onLoad
 */
exports.loadModule = function(moduleId, onLoad) {
    var loadedModule;
    if (Array.isArray(moduleId)) {
        var moduleType = moduleId[0];
        var moduleName = moduleId[1];
    } else if (typeof moduleId == "string") {
        var moduleName = moduleId;
    }
    var load = function (module) {
        // require(moduleName) can return empty object if called after require([moduleName], callback)
        if (module && !exports.$loading[moduleName]) return onLoad && onLoad(module);

        if (!exports.$loading[moduleName]) exports.$loading[moduleName] = [];

        exports.$loading[moduleName].push(onLoad);

        if (exports.$loading[moduleName].length > 1) return;

        var afterLoad = function() {
            loader(moduleName, function(err, module) {
                if (module) exports.$loaded[moduleName] = module;
                exports._emit("load.module", {name: moduleName, module: module});
                var listeners = exports.$loading[moduleName];
                exports.$loading[moduleName] = null;
                listeners.forEach(function(onLoad) {
                    onLoad && onLoad(module);
                });
            });
        };

        if (!exports.get("packaged")) return afterLoad();

        net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
        reportErrorIfPathIsNotConfigured();
    };

    if (exports.dynamicModules[moduleName]) {
        exports.dynamicModules[moduleName]().then(function (module) {
            if (module.default) {
                load(module.default);
            }
            else {
                load(module);
            }
        });
    } else {
        // backwards compatibility for node and packaged version
        try {
            loadedModule = this.$require(moduleName);
        } catch (e) {}
        load(loadedModule || exports.$loaded[moduleName]);
    }
};

exports.$require = function(moduleName) {
    if (typeof module["require"] == "function") {
        var req = "require";
        return module[req](moduleName);
    }
};

exports.setModuleLoader = function (moduleName, onLoad) {
    exports.dynamicModules[moduleName] = onLoad;
};

var reportErrorIfPathIsNotConfigured = function() {
    if (
        !options.basePath && !options.workerPath
        && !options.modePath && !options.themePath
        && !Object.keys(options.$moduleUrls).length
    ) {
        console.error(
            "Unable to infer path to ace from script src,",
            "use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes",
            "or with webpack use ace/webpack-resolver"
        );
        reportErrorIfPathIsNotConfigured = function() {};
    }
};

exports.version = "1.43.6";




/***/ }),

/***/ 76703:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("../editor").Editor} Editor
 */
var snippetManager = (__webpack_require__(51509)/* .snippetManager */ .N);
var AceInlineScreenReader = (__webpack_require__(88629)/* .AceInlineScreenReader */ ._);

/**
 * This object is used to manage inline code completions rendered into an editor with ghost text.
 */
class AceInline {
    /**
     * Creates the inline completion renderer which renders the inline code completions directly in the target editor.
     */
    constructor() {
        this.editor = null;
    }
    
    /**
     * Renders the completion as ghost text to the current cursor position
     * @param {Editor} editor
     * @param {import("../../ace-internal").Ace.Completion} completion
     * @param {string} prefix
     * @returns {boolean} True if the completion could be rendered to the editor, false otherwise
     */
    show(editor, completion, prefix) {
        prefix = prefix || "";
        if (editor && this.editor && this.editor !== editor) {
            this.hide();
            this.editor = null;
            this.inlineScreenReader = null;
        }
        if (!editor || !completion) {
            return false;
        }
        if (!this.inlineScreenReader) {
            this.inlineScreenReader = new AceInlineScreenReader(editor);
        }
        var displayText = completion.snippet ? snippetManager.getDisplayTextForSnippet(editor, completion.snippet) : completion.value;
        if (completion.hideInlinePreview || !displayText || !displayText.startsWith(prefix)) {
            return false;
        }
        this.editor = editor;

        this.inlineScreenReader.setScreenReaderContent(displayText);

        displayText = displayText.slice(prefix.length);
        if (displayText === "") {
            editor.removeGhostText();
        } else {
            editor.setGhostText(displayText);
        }
        return true;
    }

    isOpen() {
        if (!this.editor) {
            return false;
        }
        return !!this.editor.renderer.$ghostText;
    }

    hide() {
        if (!this.editor) {
            return false;
        }
        this.editor.removeGhostText();
        return true;
    }

    destroy() {
        this.hide();
        this.editor = null;
        if (this.inlineScreenReader) {
            this.inlineScreenReader.destroy();
            this.inlineScreenReader = null;
        }
    }
}


exports.V = AceInline;


/***/ }),

/***/ 77893:
/***/ ((__unused_webpack_module, exports) => {

exports.deepCopy = function deepCopy(obj) {
    if (typeof obj !== "object" || !obj)
        return obj;
    var copy;
    if (Array.isArray(obj)) {
        copy = [];
        for (let key = 0; key < obj.length; key++) {
            copy[key] = deepCopy(obj[key]);
        }
        return copy;
    }
    if (Object.prototype.toString.call(obj) !== "[object Object]")
        return obj;
    
    copy = {};
    for (let key in obj)
        copy[key] = deepCopy(obj[key]);
    return copy;
};


/***/ }),

/***/ 78552:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*
 * based on code from:
 *
 * @license RequireJS text 0.25.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */


var dom = __webpack_require__(71435);

exports.get = function (url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.onreadystatechange = function () {
        //Do not explicitly handle errors, those should be
        //visible via console output in the browser.
        if (xhr.readyState === 4) {
            callback(xhr.responseText);
        }
    };
    xhr.send(null);
};

exports.loadScript = function(path, callback) {
    var head = dom.getDocumentHead();
    /**@type {HTMLScriptElement & {onload?: Function, onreadystatechange?: Function, readyState?: string}}*/
    var s = document.createElement('script');

    s.src = path;
    head.appendChild(s);

    s.onload = s.onreadystatechange = function(_, isAbort) {
        if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
            s = s.onload = s.onreadystatechange = null;
            if (!isAbort)
                callback();
        }
    };
};

/*
 * Convert a url into a fully qualified absolute URL
 * This function does not work in IE6
 */
exports.qualifyURL = function(url) {
    var a = document.createElement('a');
    a.href = url;
    return a.href;
};


/***/ }),

/***/ 79870:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./edit_session").EditSession} EditSession
 * @typedef {import("../ace-internal").Ace.Delta} Delta
 * @typedef {import("../ace-internal").Ace.Point} Point
 * @typedef {import("../ace-internal").Ace.IRange} IRange
 */

/**
 * This object maintains the undo stack for an [[EditSession `EditSession`]].
 **/
class UndoManager {
    /**
     * Resets the current undo state and creates a new `UndoManager`.
     **/
    constructor() {
        /**@type {boolean}*/
        this.$keepRedoStack;
        this.$maxRev = 0;
        this.$fromUndo = false;
        this.$undoDepth = Infinity;
        this.reset();
    }

    /**
     * 
     * @param {EditSession} session
     */
    addSession(session) {
        this.$session = session;
    }
    /**
     * Provides a means for implementing your own undo manager. `options` has one property, `args`, an [[Array `Array`]], with two elements:
     *
     * - `args[0]` is an array of deltas
     * - `args[1]` is the document to associate with
     *
     * @param {import("../ace-internal").Ace.Delta} delta
     * @param {boolean} allowMerge
     * @param {EditSession} [session]
     **/
    add(delta, allowMerge, session) {
        if (this.$fromUndo) return;
        if (delta == this.$lastDelta) return;
        if (!this.$keepRedoStack) this.$redoStack.length = 0;
        if (allowMerge === false || !this.lastDeltas) {
            this.lastDeltas = [];
            var undoStackLength = this.$undoStack.length;
            if (undoStackLength > this.$undoDepth - 1) {
                this.$undoStack.splice(0, undoStackLength - this.$undoDepth + 1);
            }
            this.$undoStack.push(this.lastDeltas);
            delta.id = this.$rev = ++this.$maxRev;
        }
        if (delta.action == "remove" || delta.action == "insert")
            this.$lastDelta = delta;
        this.lastDeltas.push(delta);
    }

    /**
     * 
     * @param {any} selection
     * @param {number} [rev]
     */
    addSelection(selection, rev) {
        this.selections.push({
            value: selection,
            rev: rev || this.$rev
        });
    }
    
    startNewGroup() {
        this.lastDeltas = null;
        return this.$rev;
    }

    /**
     * 
     * @param {number} from
     * @param {number} [to]
     */
    markIgnored(from, to) {
        if (to == null) to = this.$rev + 1;
        var stack = this.$undoStack;
        for (var i = stack.length; i--;) {
            var delta = stack[i][0];
            if (delta.id <= from)
                break;
            if (delta.id < to)
                delta.ignore = true;
        }
        this.lastDeltas = null;
    }

    /**
     * 
     * @param {number} rev
     * @param {boolean} [after]
     * @return {{ value: string, rev: number }}
     */
    getSelection(rev, after) {
        var stack = this.selections;
        for (var i = stack.length; i--;) {
            var selection = stack[i];
            if (selection.rev < rev) {
                if (after)
                    selection = stack[i + 1];
                return selection;
            }
        }
    }

    /**
     * @return {number}
     */
    getRevision() {
        return this.$rev;
    }

    /**
     * 
     * @param {number} from
     * @param {number} [to]
     * @return {import("../ace-internal").Ace.Delta[]}
     */
    getDeltas(from, to) {
        if (to == null) to = this.$rev + 1;
        var stack = this.$undoStack;
        var end = null, start = 0;
        for (var i = stack.length; i--;) {
            var delta = stack[i][0];
            if (delta.id < to && !end)
                end = i+1;
            if (delta.id <= from) {
                start = i + 1;
                break;
            }
        }
        return stack.slice(start, end);
    }

    /**
     * 
     * @param {number} from
     * @param {number} [to]
     */
    getChangedRanges(from, to) {
        if (to == null) to = this.$rev + 1;
    }

    /**
     *
     * @param {number} from
     * @param {number} [to]
     */
    getChangedLines(from, to) {
        if (to == null) to = this.$rev + 1;
        
    }

    /**
     * [Perform an undo operation on the document, reverting the last change.]{: #UndoManager.undo}
     * @param {EditSession} session
     * @param {Boolean} [dontSelect] {:dontSelect}
     **/
    undo(session, dontSelect) {
        this.lastDeltas = null;
        var stack = this.$undoStack;
        
        if (!rearrangeUndoStack(stack, stack.length))
            return;
        
        if (!session)
            session = this.$session;
        
        if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length)
            this.$redoStack = [];
        
        this.$fromUndo = true;
        
        var deltaSet = stack.pop();
        var undoSelectionRange = null;
        if (deltaSet) {
            undoSelectionRange = session.undoChanges(deltaSet, dontSelect);
            this.$redoStack.push(deltaSet);
            this.$syncRev();
        }
        
        this.$fromUndo = false;

        return undoSelectionRange;
    }
    
    /**
     * [Perform a redo operation on the document, reimplementing the last change.]{: #UndoManager.redo}
     * @param {EditSession} session
     * @param {Boolean} [dontSelect] {:dontSelect}
     *
     **/
    redo(session, dontSelect) {
        this.lastDeltas = null;
        
        if (!session)
            session = this.$session;
        
        this.$fromUndo = true;
        if (this.$redoStackBaseRev != this.$rev) {
            var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);
            rebaseRedoStack(this.$redoStack, diff);
            this.$redoStackBaseRev = this.$rev;
            this.$redoStack.forEach(function(x) {
                x[0].id = ++this.$maxRev;
            }, this);
        }
        var deltaSet = this.$redoStack.pop();
        var redoSelectionRange = null;
        
        if (deltaSet) {
            redoSelectionRange = session.redoChanges(deltaSet, dontSelect);
            this.$undoStack.push(deltaSet);
            this.$syncRev();
        }
        this.$fromUndo = false;
        
        return redoSelectionRange;
    }
    
    $syncRev() {
        var stack = this.$undoStack;
        var nextDelta = stack[stack.length - 1];
        var id = nextDelta && nextDelta[0].id || 0;
        this.$redoStackBaseRev = id;
        this.$rev = id;
    }

    /**
     * Destroys the stack of undo and redo redo operations.
     **/
    reset() {
        this.lastDeltas = null;
        this.$lastDelta = null;
        this.$undoStack = [];
        this.$redoStack = [];
        this.$rev = 0;
        this.mark = 0;
        this.$redoStackBaseRev = this.$rev;
        this.selections = [];
    }

    
    /**
     * Returns `true` if there are undo operations left to perform.
     * @returns {Boolean}
     **/
    canUndo() {
        return this.$undoStack.length > 0;
    }

    /**
     * Returns `true` if there are redo operations left to perform.
     * @returns {Boolean}
     **/
    canRedo() {
        return this.$redoStack.length > 0;
    }

    /**
     * Marks the current status clean
     * @param {number} [rev]
     */
    bookmark(rev) {
        if (rev == undefined)
            rev = this.$rev;
        this.mark = rev;
    }

    /**
     * Returns if the current status is clean
     * @returns {Boolean}
     **/
    isAtBookmark() {
        return this.$rev === this.mark;
    }
    
    /**
     * Returns an object which can be safely stringified into JSON
     * @returns {object}
     */
    toJSON() {
        return {
            $redoStack: this.$redoStack,
            $undoStack: this.$undoStack
        };
    }

    // NOTE: The above and below function require you to JSON.stringify and JSON.parse externally.
    
    /**
     * Takes in an object which was returned from the toJSON method above,
     * and resets the current undoManager instance to use the previously exported
     * instance state.
     * @param {object} json 
     */
    fromJSON(json) {
        this.reset();
        this.$undoStack = json.$undoStack;
        this.$redoStack = json.$redoStack;
    }


    /**
     * @param {Delta} delta
     */
    $prettyPrint(delta) {
        if (delta) return stringifyDelta(delta);
        return stringifyDelta(this.$undoStack) + "\n---\n" + stringifyDelta(this.$redoStack);
    }
}


UndoManager.prototype.hasUndo = UndoManager.prototype.canUndo;
UndoManager.prototype.hasRedo = UndoManager.prototype.canRedo;
UndoManager.prototype.isClean = UndoManager.prototype.isAtBookmark;
UndoManager.prototype.markClean = UndoManager.prototype.bookmark;

/**
 * @param {any[]} stack
 * @param {number} pos
 */
function rearrangeUndoStack(stack, pos) {
    for (var i = pos; i--; ) {
        var deltaSet = stack[i];
        if (deltaSet && !deltaSet[0].ignore) {
            while(i < pos - 1) {
                var swapped = swapGroups(stack[i], stack[i + 1]);
                stack[i] = swapped[0];
                stack[i + 1] = swapped[1];
                i++;
            }
            return true;
        }
    }
}

var Range = (__webpack_require__(91902)/* .Range */ .Q);
var cmp = Range.comparePoints;
var comparePoints = Range.comparePoints;

/**
 * @param {Delta} delta
 */
function $updateMarkers(delta) {
    var isInsert = delta.action == "insert";
    var start = delta.start;
    var end = delta.end;
    var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);
    var colShift = (end.column - start.column) * (isInsert ? 1 : -1);
    if (isInsert) end = start;

    for (var i in this.marks) {
        var point = this.marks[i];
        var cmp = comparePoints(point, start);
        if (cmp < 0) {
            continue; // delta starts after the range
        }
        if (cmp === 0) {
            if (isInsert) {
                if (point.bias == 1) {
                    cmp = 1;
                }
                else {
                    point.bias == -1;
                    continue;
                }
            }
        }
        var cmp2 = isInsert ? cmp : comparePoints(point, end);
        if (cmp2 > 0) {
            point.row += rowShift;
            point.column += point.row == end.row ? colShift : 0;
            continue;
        }
        if (!isInsert && cmp2 <= 0) {
            point.row = start.row;
            point.column = start.column;
            if (cmp2 === 0)
                point.bias = 1;
        }
    }
}

/**
 * @param {Point} pos
 */
function clonePos(pos) {
    return {row: pos.row,column: pos.column};
}

/**
 * @param {Delta} d
 */
function cloneDelta(d) {
    return {
        start: clonePos(d.start),
        end: clonePos(d.end),
        action: d.action,
        lines: d.lines.slice()
    };
}
function stringifyDelta(d) {
    d = d || this;
    if (Array.isArray(d)) {
        return d.map(stringifyDelta).join("\n");
    }
    var type = "";
    if (d.action) {
        type = d.action == "insert" ? "+" : "-";
        type += "[" + d.lines + "]";
    } else if (d.value) {
        if (Array.isArray(d.value)) {
            type = d.value.map(stringifyRange).join("\n");
        } else {
            type = stringifyRange(d.value);
        }
    }
    if (d.start) {
        type += stringifyRange(d);
    }
    if (d.id || d.rev) {
        type += "\t(" + (d.id || d.rev) + ")";
    }
    return type;
}

/**
 * @param {Range} r
 * @return {string}
 */
function stringifyRange(r) {
    return r.start.row + ":" + r.start.column 
        + "=>" + r.end.row + ":" + r.end.column;
}
/*
 * i i  d1  d2
 *      |/  |/  d2.s >= d1.e shift(d2, d1, -1)
 *              d2.s <= d1.s shift(d1, d2, +1)
 *       d1.s < d2.s < d1.e // can split
 * 
 * i r  d1  d2
 *      |/  |\  d2.s >= d1.e shift(d2, d1, -1)
 *              d2.e <= d1.s shift(d1, d2, -1)
 *       else // can't swap
 * 
 * r i  d1  d2
 *      |\  |/  d2.s >= d1.s shift(d2, d1, +1)
 *              d2.s <= d1.s shift(d1, d2, +1)
 *       // no else
 * 
 * r r  d1  d2
 *      |\  |\  d2.s >= d1.s shift(d2, d1, +1)
 *              d2.e <= d1.s shift(d1, d2, -1)
 *       d2.s < d1.s < d2.e // can split
 */

/**
 * @param {Delta} d1
 * @param {Delta} d2
 */
function swap(d1, d2) {
    var i1 = d1.action == "insert";
    var i2 = d2.action == "insert";
    
    if (i1 && i2) {
        if (cmp(d2.start, d1.end) >= 0) {
            shift(d2, d1, -1);
        } else if (cmp(d2.start, d1.start) <= 0) {
            shift(d1, d2, +1);
        } else {
            return null;
        }
    } else if (i1 && !i2) {
        if (cmp(d2.start, d1.end) >= 0) {
            shift(d2, d1, -1);
        } else if (cmp(d2.end, d1.start) <= 0) {
            shift(d1, d2, -1);
        } else {
            return null;
        }
    } else if (!i1 && i2) {
        if (cmp(d2.start, d1.start) >= 0) {
            shift(d2, d1, +1);
        } else if (cmp(d2.start, d1.start) <= 0) {
            shift(d1, d2, +1);
        } else {
            return null;
        }
    } else if (!i1 && !i2) {
        if (cmp(d2.start, d1.start) >= 0) {
            shift(d2, d1, +1);
        } else if (cmp(d2.end, d1.start) <= 0) {
            shift(d1, d2, -1);
        } else {
            return null;
        }
    }
    return [d2, d1];
}
function swapGroups(ds1, ds2) {
    for (var i = ds1.length; i--; ) {
        for (var j = 0; j < ds2.length; j++) {
            if (!swap(ds1[i], ds2[j])) {
                // rollback, we have to undo ds2 first
                while (i < ds1.length) {
                    while (j--) {
                        swap(ds2[j], ds1[i]);
                    }
                    j = ds2.length;
                    i++;
                }                
                return [ds1, ds2];
            }
        }
    }
    ds1.selectionBefore = ds2.selectionBefore = 
    ds1.selectionAfter = ds2.selectionAfter = null;
    return [ds2, ds1];
}

/*
      d2          xform(d1, c1) = [d2, c2]
    o<---o        xform(c1, d1) = [c2, d2]
 c2 |    | d1     
    o<---o
      c1
*/
/**
 * 
 * @param {Delta} d1
 * @param {Delta} c1
 */
function xform(d1, c1) {
    var i1 = d1.action == "insert";
    var i2 = c1.action == "insert";
    
    if (i1 && i2) {
        if (cmp(d1.start, c1.start) < 0) {
            shift(c1, d1, 1);
        } else {
            shift(d1, c1, 1);
        }
    } else if (i1 && !i2) {
        if (cmp(d1.start, c1.end) >= 0) {
            shift(d1, c1, -1);
        } else if (cmp(d1.start, c1.start) <= 0) {
            shift(c1, d1, +1);
        } else {
            shift(d1, Range.fromPoints(c1.start, d1.start), -1);
            shift(c1, d1, +1);
        }
    } else if (!i1 && i2) {
        if (cmp(c1.start, d1.end) >= 0) {
            shift(c1, d1, -1);
        } else if (cmp(c1.start, d1.start) <= 0) {
            shift(d1, c1, +1);
        } else {
            shift(c1, Range.fromPoints(d1.start, c1.start), -1);
            shift(d1, c1, +1);
        }
    } else if (!i1 && !i2) {
        if (cmp(c1.start, d1.end) >= 0) {
            shift(c1, d1, -1);
        } else if (cmp(c1.end, d1.start) <= 0) {
            shift(d1, c1, -1);
        } else {
            var before, after;
            if (cmp(d1.start, c1.start) < 0) {
                before = d1;
                d1 = splitDelta(d1, c1.start);
            }
            if (cmp(d1.end, c1.end) > 0) {
                after = splitDelta(d1, c1.end);
            }

            shiftPos(c1.end, d1.start, d1.end, -1);
            if (after && !before) {
                d1.lines = after.lines;
                d1.start = after.start;
                d1.end = after.end;
                after = d1;
            }

            return [c1, before, after].filter(Boolean);
        }
    }
    return [c1, d1];
}

/**
 * 
 * @param {IRange} d1
 * @param {IRange} d2
 * @param {number} dir
 */
function shift(d1, d2, dir) {
    shiftPos(d1.start, d2.start, d2.end, dir);
    shiftPos(d1.end, d2.start, d2.end, dir);
}

/**
 * 
 * @param {Point} pos
 * @param {Point} start
 * @param {Point} end
 * @param {number} dir
 */
function shiftPos(pos, start, end, dir) {
    if (pos.row == (dir == 1 ? start : end).row) {
        pos.column += dir * (end.column - start.column);
    }
    pos.row += dir * (end.row - start.row);
}

/**
 * 
 * @param {Delta} c
 * @param {Point} pos
 * @return {Delta}
 */
function splitDelta(c, pos) {
    var lines = c.lines;
    var end = c.end;
    c.end = clonePos(pos);    
    var rowsBefore = c.end.row - c.start.row;
    var otherLines = lines.splice(rowsBefore, lines.length);
    
    var col = rowsBefore ? pos.column : pos.column - c.start.column;
    lines.push(otherLines[0].substring(0, col));
    otherLines[0] = otherLines[0].substr(col)   ; 
    var rest = {
        start: clonePos(pos),
        end: end,
        lines: otherLines,
        action: c.action
    };
    return rest;
}

/**
 * @param {any[]} redoStack
 * @param {Delta} d
 */
function moveDeltasByOne(redoStack, d) {
    d = cloneDelta(d);
    for (var j = redoStack.length; j--;) {
        var deltaSet = redoStack[j];
        for (var i = 0; i < deltaSet.length; i++) {
            var x = deltaSet[i];
            var xformed = xform(x, d);
            d = xformed[0];
            if (xformed.length != 2) {
                if (xformed[2]) {
                    deltaSet.splice(i + 1, 1, xformed[1], xformed[2]);
                    i++;
                } else if (!xformed[1]) {
                    deltaSet.splice(i, 1);
                    i--;
                }
            }
        }
        if (!deltaSet.length) {
            redoStack.splice(j, 1); 
        }
    }
    return redoStack;
}

function rebaseRedoStack(redoStack, deltaSets) {
    for (var i = 0; i < deltaSets.length; i++) {
        var deltas = deltaSets[i];
        for (var j = 0; j < deltas.length; j++) {
            moveDeltasByOne(redoStack, deltas[j]);
        }
    }
}
exports.a = UndoManager;


/***/ }),

/***/ 80820:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * The main class required to set up an Ace instance in the browser.
 *
 * @namespace Ace
 **/

"include loader_build";

var dom = __webpack_require__(71435);

var Range = (__webpack_require__(91902)/* .Range */ .Q);
var Editor = (__webpack_require__(27258).Editor);
var EditSession = (__webpack_require__(33464)/* .EditSession */ .f);
var UndoManager = (__webpack_require__(79870)/* .UndoManager */ .a);
var Renderer = (__webpack_require__(21016).VirtualRenderer);

// The following require()s are for inclusion in the built ace file
__webpack_require__(28402);
__webpack_require__(93050);
__webpack_require__(30214);
__webpack_require__(48369);
__webpack_require__(51358);
__webpack_require__(87983);
__webpack_require__(4126);

exports.config = __webpack_require__(76321);


/**
 * Embeds the Ace editor into the DOM, at the element provided by `el`.
 * @param {String | HTMLElement & {env?: any, value?: any} | null} [el] Either the id of an element, or the element itself
 * @param {Partial<import("../ace-internal").Ace.EditorOptions> } [options] Options for the editor
 * @returns {Editor}
 **/
exports.edit = function(el, options) {
    if (typeof el == "string") {
        var _id = el;
        el = document.getElementById(_id);
        if (!el)
            throw new Error("ace.edit can't find div #" + _id);
    }

    if (el && el.env && el.env.editor instanceof Editor)
        return el.env.editor;

    var value = "";
    if (el && /input|textarea/i.test(el.tagName)) {
        var oldNode = el;
        value = oldNode.value;
        el = dom.createElement("pre");
        oldNode.parentNode.replaceChild(el, oldNode);
    } else if (el) {
        value = el.textContent;
        el.innerHTML = "";
    }

    var doc = exports.createEditSession(value);
    var editor = new Editor(new Renderer(el), doc, options);

    var env = {
        document: doc,
        editor: editor,
        onResize: editor.resize.bind(editor, null)
    };
    if (oldNode) env.textarea = oldNode;
    editor.on("destroy", function() {
        env.editor.container.env = null; // prevent memory leak on old ie
    });
    editor.container.env = editor.env = env;
    return editor;
};

/**
 * Creates a new [[EditSession]], and returns the associated [[Document]].
 * @param {import('./document').Document | String} text {:textParam}
 * @param {import("../ace-internal").Ace.SyntaxMode} [mode] {:modeParam}
 * @returns {EditSession}
 **/
exports.createEditSession = function(text, mode) {
    var doc = new EditSession(text, mode);
    doc.setUndoManager(new UndoManager());
    return doc;
};
exports.Range = Range;
exports.Editor = Editor;
exports.EditSession = EditSession;
exports.UndoManager = UndoManager;
exports.VirtualRenderer = Renderer;
var version = exports.config.version;
exports.version = version;


/***/ }),

/***/ 82984:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


var event = __webpack_require__(19631);
var nls = (__webpack_require__(76321).nls);
var useragent = __webpack_require__(74943);
var dom = __webpack_require__(71435);
var lang = __webpack_require__(39955);
var clipboard = __webpack_require__(65217);
var BROKEN_SETDATA = useragent.isChrome < 18;
var USE_IE_MIME_TYPE =  useragent.isIE;
var HAS_FOCUS_ARGS = useragent.isChrome > 63;
var MAX_LINE_LENGTH = 400;

/**
 *
 * @type {{[key: string]: any}}
 */
var KEYS = __webpack_require__(29451);
var MODS = KEYS.KEY_MODS;
var isIOS = useragent.isIOS;
var valueResetRegex = isIOS ? /\s/ : /\n/;
var isMobile = useragent.isMobile;

class TextInput {
    /**
     * @param {HTMLElement} parentNode
     * @param {import("../editor").Editor} host
     */
    constructor(parentNode, host) {
        this.host = host;
        /**@type {HTMLTextAreaElement & {msGetInputContext?: () => {compositionStartOffset: number}, getInputContext?: () => {compositionStartOffset: number}}}*/
        this.text = dom.createElement("textarea");
        this.text.className = "ace_text-input";

        this.text.setAttribute("wrap", "off");
        this.text.setAttribute("autocomplete", "off");
        this.text.setAttribute("autocorrect", "off");
        this.text.setAttribute("autocapitalize", "off");
        this.text.setAttribute("spellcheck", "false");

        this.text.style.opacity = "0";
        parentNode.insertBefore(this.text, parentNode.firstChild);

        /**@type{boolean|string}*/this.copied = false;
        this.pasted = false;
        /**@type {(boolean|Object) & {context?: any, useTextareaForIME?: boolean, selectionStart?: number, markerRange?: any}}} */
        this.inComposition = false;
        this.sendingText = false;
        this.tempStyle = '';

        if (!isMobile) this.text.style.fontSize = "1px";

        this.commandMode = false;
        this.ignoreFocusEvents = false;

        this.lastValue = "";
        this.lastSelectionStart = 0;
        this.lastSelectionEnd = 0;
        this.lastRestoreEnd = 0;
        this.rowStart = Number.MAX_SAFE_INTEGER;
        this.rowEnd = Number.MIN_SAFE_INTEGER;
        this.numberOfExtraLines = 0;

        // FOCUS
        // ie9 throws error if document.activeElement is accessed too soon
        try {
            this.$isFocused = document.activeElement === this.text;
        } catch (e) {
        }

        this.cancelComposition = this.cancelComposition.bind(this);

        this.setAriaOptions({role: "textbox"});

        event.addListener(this.text, "blur", (e) => {
            if (this.ignoreFocusEvents) return;
            host.onBlur(e);
            this.$isFocused = false;
        }, host);
        event.addListener(this.text, "focus", (e) => {
            if (this.ignoreFocusEvents) return;
            this.$isFocused = true;
            if (useragent.isEdge) {
                // on edge focus event is fired even if document itself is not focused
                try {
                    if (!document.hasFocus()) return;
                } catch (e) {
                }
            }
            host.onFocus(e);
            if (useragent.isEdge) setTimeout(this.resetSelection.bind(this)); else this.resetSelection();
        }, host);

        /**@type {boolean | string}*/this.$focusScroll = false;

        host.on("beforeEndOperation", () => {
            var curOp = host.curOp;
            var commandName = curOp && curOp.command && curOp.command.name;
            if (commandName == "insertstring") return;
            var isUserAction = commandName && (curOp.docChanged || curOp.selectionChanged);
            if (this.inComposition && isUserAction) {
                // exit composition from commands other than insertstring
                this.lastValue = this.text.value = "";
                this.onCompositionEnd();
            }
            // sync value of textarea
            this.resetSelection();
        });

        // if cursor changes position, we need to update the label with the correct row
        host.on("changeSelection", this.setAriaLabel.bind(this));

        this.resetSelection = isIOS ? this.$resetSelectionIOS : this.$resetSelection;

        if (this.$isFocused) host.onFocus();

        this.inputHandler = null;
        this.afterContextMenu = false;

        event.addCommandKeyListener(this.text, (e, hashId, keyCode) => {
            // ignore command events during composition as they will
            // either be handled by ime itself or fired again after ime end
            if (this.inComposition) return;
            return host.onCommandKey(e, hashId, keyCode);
        }, host);

        event.addListener(this.text, "select", this.onSelect.bind(this), host);
        event.addListener(this.text, "input", this.onInput.bind(this), host);

        event.addListener(this.text, "cut", this.onCut.bind(this), host);
        event.addListener(this.text, "copy", this.onCopy.bind(this), host);
        event.addListener(this.text, "paste", this.onPaste.bind(this), host);


        // Opera has no clipboard events
        if (!('oncut' in this.text) || !('oncopy' in this.text) || !('onpaste' in this.text)) {
            event.addListener(parentNode, "keydown", (e) => {
                if ((useragent.isMac && !e.metaKey) || !e.ctrlKey) return;

                switch (e.keyCode) {
                    case 67:
                        this.onCopy(e);
                        break;
                    case 86:
                        this.onPaste(e);
                        break;
                    case 88:
                        this.onCut(e);
                        break;
                }
            }, host);
        }

        this.syncComposition = lang.delayedCall(this.onCompositionUpdate.bind(this), 50).schedule.bind(null, null); //TODO: check this

        event.addListener(this.text, "compositionstart", this.onCompositionStart.bind(this), host);
        event.addListener(this.text, "compositionupdate", this.onCompositionUpdate.bind(this), host);
        event.addListener(this.text, "keyup", this.onKeyup.bind(this), host);
        event.addListener(this.text, "keydown", this.syncComposition.bind(this), host);
        event.addListener(this.text, "compositionend", this.onCompositionEnd.bind(this), host);

        this.closeTimeout;

        event.addListener(this.text, "mouseup", this.$onContextMenu.bind(this), host);
        event.addListener(this.text, "mousedown", (e) => {
            e.preventDefault();
            this.onContextMenuClose();
        }, host);
        event.addListener(host.renderer.scroller, "contextmenu", this.$onContextMenu.bind(this), host);
        event.addListener(this.text, "contextmenu", this.$onContextMenu.bind(this), host);

        if (isIOS) this.addIosSelectionHandler(parentNode, host, this.text);
    }

    /**
     * @internal
     * @param {HTMLElement} parentNode
     * @param {import("../editor").Editor} host
     * @param {HTMLTextAreaElement} text
     */
    addIosSelectionHandler(parentNode, host, text) {
        var typingResetTimeout = null;
        var typing = false;

        text.addEventListener("keydown", function (e) {
            if (typingResetTimeout) clearTimeout(typingResetTimeout);
            typing = true;
        }, true);

        text.addEventListener("keyup", function (e) {
            typingResetTimeout = setTimeout(function () {
                typing = false;
            }, 100);
        }, true);

        // IOS doesn't fire events for arrow keys, but this unique hack changes everything!
        var detectArrowKeys = (e) => {
            if (document.activeElement !== text) return;
            if (typing || this.inComposition || host.$mouseHandler.isMousePressed) return;

            if (this.copied) {
                return;
            }
            var selectionStart = text.selectionStart;
            var selectionEnd = text.selectionEnd;

            var key = null;
            var modifier = 0;
            // console.log(selectionStart, selectionEnd);
            if (selectionStart == 0) {
                key = KEYS.up;
            }
            else if (selectionStart == 1) {
                key = KEYS.home;
            }
            else if (selectionEnd > this.lastSelectionEnd && this.lastValue[selectionEnd] == "\n") {
                key = KEYS.end;
            }
            else if (selectionStart < this.lastSelectionStart && this.lastValue[selectionStart - 1] == " ") {
                key = KEYS.left;
                modifier = MODS.option;
            }
            else if (selectionStart < this.lastSelectionStart || (selectionStart == this.lastSelectionStart
                && this.lastSelectionEnd != this.lastSelectionStart && selectionStart == selectionEnd)) {
                key = KEYS.left;
            }
            else if (selectionEnd > this.lastSelectionEnd && this.lastValue.slice(0, selectionEnd).split(
                "\n").length > 2) {
                key = KEYS.down;
            }
            else if (selectionEnd > this.lastSelectionEnd && this.lastValue[selectionEnd - 1] == " ") {
                key = KEYS.right;
                modifier = MODS.option;
            }
            else if (selectionEnd > this.lastSelectionEnd || (selectionEnd == this.lastSelectionEnd
                && this.lastSelectionEnd != this.lastSelectionStart && selectionStart == selectionEnd)) {
                key = KEYS.right;
            }

            if (selectionStart !== selectionEnd) modifier |= MODS.shift;

            if (key) {
                var result = host.onCommandKey({}, modifier, key);
                if (!result && host.commands) {
                    key = KEYS.keyCodeToString(key);
                    var command = host.commands.findKeyCommand(modifier, key);
                    if (command) host.execCommand(command);
                }
                this.lastSelectionStart = selectionStart;
                this.lastSelectionEnd = selectionEnd;
                this.resetSelection("");
            }
        };
        // On iOS, "selectionchange" can only be attached to the document object...
        document.addEventListener("selectionchange", detectArrowKeys);
        host.on("destroy", function () {
            document.removeEventListener("selectionchange", detectArrowKeys);
        });
    }

    onContextMenuClose() {
        clearTimeout(this.closeTimeout);
        this.closeTimeout = setTimeout(() => {
            if (this.tempStyle) {
                this.text.style.cssText = this.tempStyle;
                this.tempStyle = '';
            }
            this.host.renderer.$isMousePressed = false;
            if (this.host.renderer.$keepTextAreaAtCursor) this.host.renderer.$moveTextAreaToCursor();
        }, 0);
    }

    $onContextMenu(e) {
        this.host.textInput.onContextMenu(e);
        this.onContextMenuClose();
    }

    /**
     * @internal
     * @param e
     */
    onKeyup(e) {
        // workaround for a bug in ie where pressing esc silently moves selection out of textarea
        if (e.keyCode == 27 && this.text.value.length < this.text.selectionStart) {
            if (!this.inComposition) this.lastValue = this.text.value;
            this.lastSelectionStart = this.lastSelectionEnd = -1;
            this.resetSelection();
        }
        this.syncComposition();
    }

    // COMPOSITION

    /**
     * @internal
     */
    cancelComposition() {
        // force end composition
        this.ignoreFocusEvents = true;
        this.text.blur();
        this.text.focus();
        this.ignoreFocusEvents = false;
    }

    /**
     * @internal
     */
    onCompositionStart(e) {
        if (this.inComposition || !this.host.onCompositionStart || this.host.$readOnly) return;

        this.inComposition = {};

        if (this.commandMode) return;

        if (e.data) this.inComposition.useTextareaForIME = false;

        setTimeout(this.onCompositionUpdate.bind(this), 0);
        this.host._signal("compositionStart");
        this.host.on("mousedown", this.cancelComposition); //TODO:

        var range = this.host.getSelectionRange();
        range.end.row = range.start.row;
        range.end.column = range.start.column;
        this.inComposition.markerRange = range;
        this.inComposition.selectionStart = this.lastSelectionStart;
        this.host.onCompositionStart(this.inComposition);

        if (this.inComposition.useTextareaForIME) {
            this.lastValue = this.text.value = "";
            this.lastSelectionStart = 0;
            this.lastSelectionEnd = 0;
        }
        else {
            if (this.text.msGetInputContext) this.inComposition.context = this.text.msGetInputContext();
            if (this.text.getInputContext) this.inComposition.context = this.text.getInputContext();
        }
    }

    /**
     * @internal
     */
    onCompositionUpdate() {
        if (!this.inComposition || !this.host.onCompositionUpdate || this.host.$readOnly) return;
        if (this.commandMode) return this.cancelComposition();

        if (this.inComposition.useTextareaForIME) {
            this.host.onCompositionUpdate(this.text.value);
        }
        else {
            var data = this.text.value;
            this.sendText(data);
            if (this.inComposition.markerRange) {
                if (this.inComposition.context) {
                    this.inComposition.markerRange.start.column = this.inComposition.selectionStart = this.inComposition.context.compositionStartOffset;
                }
                this.inComposition.markerRange.end.column = this.inComposition.markerRange.start.column
                    + this.lastSelectionEnd - this.inComposition.selectionStart + this.lastRestoreEnd;
            }
        }
    }

    /**
     * @internal
     */
    onCompositionEnd(e) {
        if (!this.host.onCompositionEnd || this.host.$readOnly) return;
        this.inComposition = false;
        this.host.onCompositionEnd();
        this.host.off("mousedown", this.cancelComposition);
        // note that resetting value of textarea at this point doesn't always work
        // because textarea value can be silently restored
        if (e) this.onInput();
    }

    /**
     * @internal
     */
    onCut(e) {
        this.doCopy(e, true);
    }

    /**
     * @internal
     */
    onCopy(e) {
        this.doCopy(e, false);
    }

    /**
     * @internal
     */
    onPaste(e) {
        var data = this.handleClipboardData(e);
        if (clipboard.pasteCancelled()) return;
        if (typeof data == "string") {
            if (data) this.host.onPaste(data, e);
            if (useragent.isIE) setTimeout(this.resetSelection);
            event.preventDefault(e);
        }
        else {
            this.text.value = "";
            this.pasted = true;
        }
    }

    /**
     * @internal
     * @param {ClipboardEvent} e
     * @param {boolean} isCut
     */
    doCopy(e, isCut) {
        var data = this.host.getCopyText();
        if (!data) return event.preventDefault(e);

        if (this.handleClipboardData(e, data)) {
            if (isIOS) {
                this.resetSelection(data);
                this.copied = data;
                setTimeout(() => {
                    this.copied = false;
                }, 10);
            }
            isCut ? this.host.onCut() : this.host.onCopy();
            event.preventDefault(e);
        }
        else {
            this.copied = true;
            this.text.value = data;
            this.text.select();
            setTimeout(() => {
                this.copied = false;
                this.resetSelection();
                isCut ? this.host.onCut() : this.host.onCopy();
            });
        }
    }

    /**
     *
     * @internal
     * @param {ClipboardEvent} e
     * @param {string} [data]
     * @param {boolean} [forceIEMime]
     */
    handleClipboardData(e, data, forceIEMime) {
        var clipboardData = e.clipboardData || window["clipboardData"];
        if (!clipboardData || BROKEN_SETDATA) return;
        // using "Text" doesn't work on old webkit but ie needs it
        var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
        try {
            if (data) {
                // Safari 5 has clipboardData object, but does not handle setData()
                return clipboardData.setData(mime, data) !== false;
            }
            else {
                return clipboardData.getData(mime);
            }
        } catch (e) {
            if (!forceIEMime) return this.handleClipboardData(e, data, true);
        }
    }

    /**
     * @internal
     * @param e
     */
    onInput(e) {
        if (this.inComposition) return this.onCompositionUpdate();
        if (e && e.inputType) {
            if (e.inputType == "historyUndo") return this.host.execCommand("undo");
            if (e.inputType == "historyRedo") return this.host.execCommand("redo");
        }
        var data = this.text.value;
        var inserted = this.sendText(data, true);
        if (data.length > MAX_LINE_LENGTH + 100 || valueResetRegex.test(inserted) || isMobile && this.lastSelectionStart
            < 1 && this.lastSelectionStart == this.lastSelectionEnd) {
            this.resetSelection();
        }
    }

    /**
     * @internal
     * @param {string} value
     * @param {boolean} [fromInput]
     * @return {string}
     */
    sendText(value, fromInput) {
        if (this.afterContextMenu) this.afterContextMenu = false;
        if (this.pasted) {
            this.resetSelection();
            if (value) this.host.onPaste(value);
            this.pasted = false;
            return "";
        }
        else {
            var selectionStart = this.text.selectionStart;
            var selectionEnd = this.text.selectionEnd;

            var extendLeft = this.lastSelectionStart;
            var extendRight = this.lastValue.length - this.lastSelectionEnd;

            var inserted = value;
            var restoreStart = value.length - selectionStart;
            var restoreEnd = value.length - selectionEnd;

            var i = 0;
            while (extendLeft > 0 && this.lastValue[i] == value[i]) {
                i++;
                extendLeft--;
            }
            inserted = inserted.slice(i);
            i = 1;
            while (extendRight > 0 && this.lastValue.length - i > this.lastSelectionStart - 1
            && this.lastValue[this.lastValue.length - i] == value[value.length - i]) {
                i++;
                extendRight--;
            }
            restoreStart -= i - 1;
            restoreEnd -= i - 1;
            var endIndex = inserted.length - i + 1;
            if (endIndex < 0) {
                extendLeft = -endIndex;
                endIndex = 0;
            }
            inserted = inserted.slice(0, endIndex);

            // composition update can be called without any change
            if (!fromInput && !inserted && !restoreStart && !extendLeft && !extendRight && !restoreEnd) return "";
            this.sendingText = true;

            // some android keyboards converts two spaces into sentence end, which is not useful for code
            var shouldReset = false;
            if (useragent.isAndroid && inserted == ". ") {
                inserted = "  ";
                shouldReset = true;
            }

            if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || this.commandMode) {
                this.host.onTextInput(inserted);
            }
            else {
                this.host.onTextInput(inserted, {
                    extendLeft: extendLeft,
                    extendRight: extendRight,
                    restoreStart: restoreStart,
                    restoreEnd: restoreEnd
                });
            }
            this.sendingText = false;

            this.lastValue = value;
            this.lastSelectionStart = selectionStart;
            this.lastSelectionEnd = selectionEnd;
            this.lastRestoreEnd = restoreEnd;
            return shouldReset ? "\n" : inserted;
        }
    }

    /**
     * @internal
     * @param e
     */
    onSelect(e) {
        if (this.inComposition) return;

        var isAllSelected = (text) => {
            return text.selectionStart === 0 && text.selectionEnd >= this.lastValue.length && text.value
                === this.lastValue && this.lastValue && text.selectionEnd !== this.lastSelectionEnd;
        };

        if (this.copied) {
            this.copied = false;
        }
        else if (isAllSelected(this.text)) {
            this.host.selectAll();
            this.resetSelection();
        }
        else if (isMobile && this.text.selectionStart != this.lastSelectionStart) {
            this.resetSelection();
        }
    }

    $resetSelectionIOS(value) {
        if (!this.$isFocused || (this.copied && !value) || this.sendingText) return;
        if (!value) value = "";
        var newValue = "\n ab" + value + "cde fg\n";
        if (newValue != this.text.value) this.text.value = this.lastValue = newValue;

        var selectionStart = 4;
        var selectionEnd = 4 + (value.length || (this.host.selection.isEmpty() ? 0 : 1));

        if (this.lastSelectionStart != selectionStart || this.lastSelectionEnd != selectionEnd) {
            this.text.setSelectionRange(selectionStart, selectionEnd);
        }
        this.lastSelectionStart = selectionStart;
        this.lastSelectionEnd = selectionEnd;
    }

    $resetSelection() {
        if (this.inComposition || this.sendingText) return;
        // modifying selection of blured textarea can focus it (chrome mac/linux)
        if (!this.$isFocused && !this.afterContextMenu) return;
        // see https://github.com/ajaxorg/ace/issues/2114
        // this prevents infinite recursion on safari 8
        this.inComposition = true;

        var selectionStart = 0;
        var selectionEnd = 0;
        var line = "";

        // Convert from row,column position to the linear position with respect to the current
        // block of lines in the textarea.
        var positionToSelection = (row, column) => {
            var selection = column;

            for (var i = 1; i <= row - this.rowStart && i < 2 * this.numberOfExtraLines + 1; i++) {
                selection += this.host.session.getLine(row - i).length + 1;
            }
            return selection;
        };

        if (this.host.session) {
            var selection = this.host.selection;
            var range = selection.getRange();
            var row = selection.cursor.row;

            // We keep 2*numberOfExtraLines + 1 lines in the textarea, if the new active row
            // is within the current block of lines in the textarea we do nothing. If the new row
            // is one row above or below the current block, move up or down to the next block of lines.
            // If the new row is further than 1 row away from the current block grab a new block centered
            // around the new row.
            if (row === this.rowEnd + 1) {
                this.rowStart = this.rowEnd + 1;
                this.rowEnd = this.rowStart + 2 * this.numberOfExtraLines;
            }
            else if (row === this.rowStart - 1) {
                this.rowEnd = this.rowStart - 1;
                this.rowStart = this.rowEnd - 2 * this.numberOfExtraLines;
            }
            else if (row < this.rowStart - 1 || row > this.rowEnd + 1) {
                this.rowStart = row > this.numberOfExtraLines ? row - this.numberOfExtraLines : 0;
                this.rowEnd = row > this.numberOfExtraLines ? row + this.numberOfExtraLines : 2
                    * this.numberOfExtraLines;
            }

            var lines = [];

            for (var i = this.rowStart; i <= this.rowEnd; i++) {
                lines.push(this.host.session.getLine(i));
            }

            line = lines.join('\n');

            selectionStart = positionToSelection(range.start.row, range.start.column);
            selectionEnd = positionToSelection(range.end.row, range.end.column);

            if (range.start.row < this.rowStart) {
                var prevLine = this.host.session.getLine(this.rowStart - 1);
                selectionStart = range.start.row < this.rowStart - 1 ? 0 : selectionStart;
                selectionEnd += prevLine.length + 1;
                line = prevLine + "\n" + line;
            }
            else if (range.end.row > this.rowEnd) {
                var nextLine = this.host.session.getLine(this.rowEnd + 1);
                selectionEnd = range.end.row > this.rowEnd + 1 ? nextLine.length : range.end.column;
                selectionEnd += line.length + 1;
                line = line + "\n" + nextLine;
            }
            else if (isMobile && row > 0) {
                line = "\n" + line;
                selectionEnd += 1;
                selectionStart += 1;
            }

            if (line.length > MAX_LINE_LENGTH) {
                if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {
                    line = line.slice(0, MAX_LINE_LENGTH);
                }
                else {
                    line = "\n";
                    if (selectionStart == selectionEnd) {
                        selectionStart = selectionEnd = 0;
                    }
                    else {
                        selectionStart = 0;
                        selectionEnd = 1;
                    }
                }
            }

            var newValue = line + "\n\n";
            if (newValue != this.lastValue) {
                this.text.value = this.lastValue = newValue;
                this.lastSelectionStart = this.lastSelectionEnd = newValue.length;
            }
        }

        // contextmenu on mac may change the selection
        if (this.afterContextMenu) {
            this.lastSelectionStart = this.text.selectionStart;
            this.lastSelectionEnd = this.text.selectionEnd;
        }
        // on firefox this throws if textarea is hidden
        if (this.lastSelectionEnd != selectionEnd || this.lastSelectionStart != selectionStart || this.text.selectionEnd
            != this.lastSelectionEnd // on ie edge selectionEnd changes silently after the initialization
        ) {
            try {
                this.text.setSelectionRange(selectionStart, selectionEnd);
                this.lastSelectionStart = selectionStart;
                this.lastSelectionEnd = selectionEnd;
            } catch (e) {
            }
        }
        this.inComposition = false;
    }

    /**
     * @param {import("../editor").Editor} newHost
     */
    setHost(newHost) {
        this.host = newHost;
    }

    /**
     * Sets the number of extra lines in the textarea to improve screen reader compatibility.
     * Extra lines can help screen readers perform better when reading text.
     *
     * @param {number} number - The number of extra lines to add. Must be non-negative.
     */
    setNumberOfExtraLines(number) {
        this.rowStart = Number.MAX_SAFE_INTEGER;
        this.rowEnd = Number.MIN_SAFE_INTEGER;

        if (number < 0) {
            this.numberOfExtraLines = 0;
            return;
        }

        this.numberOfExtraLines = number;
    }


    setAriaLabel() {
        var ariaLabel = "";
        if (this.host.$textInputAriaLabel) {
            ariaLabel += `${this.host.$textInputAriaLabel}, `;
        }
        if (this.host.session) {
            var row = this.host.session.selection.cursor.row;
            ariaLabel += nls("text-input.aria-label", "Cursor at row $0", [row + 1]);
        }
        this.text.setAttribute("aria-label", ariaLabel);
    }

    /**
     * @param {import("../../ace-internal").Ace.TextInputAriaOptions} options
     */
    setAriaOptions(options) {
        if (options.activeDescendant) {
            this.text.setAttribute("aria-haspopup", "true");
            this.text.setAttribute("aria-autocomplete", options.inline ? "both" : "list");
            this.text.setAttribute("aria-activedescendant", options.activeDescendant);
        }
        else {
            this.text.setAttribute("aria-haspopup", "false");
            this.text.setAttribute("aria-autocomplete", "both");
            this.text.removeAttribute("aria-activedescendant");
        }
        if (options.role) {
            this.text.setAttribute("role", options.role);
        }
        if (options.setLabel) {
            this.text.setAttribute("aria-roledescription", nls("text-input.aria-roledescription", "editor"));
            this.setAriaLabel();
        }
    }

    focus() {
        // On focusing on the textarea, read active row number to assistive tech.
        this.setAriaOptions({
            setLabel: this.host.renderer.enableKeyboardAccessibility
        });

        if (this.tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == "browser") return this.text.focus(
            {preventScroll: true});

        var top = this.text.style.top;
        this.text.style.position = "fixed";
        this.text.style.top = "0px";
        try {
            var isTransformed = this.text.getBoundingClientRect().top != 0;
        } catch (e) {
            // getBoundingClientRect on IE throws error if element is not in the dom tree
            return;
        }
        var ancestors = [];
        if (isTransformed) {
            var t = this.text.parentElement;
            while (t && t.nodeType == 1) {
                ancestors.push(t);
                t.setAttribute("ace_nocontext", "true");
                if (!t.parentElement && t.getRootNode) t = t.getRootNode()["host"]; else t = t.parentElement;
            }
        }
        this.text.focus({preventScroll: true});
        if (isTransformed) {
            ancestors.forEach(function (p) {
                p.removeAttribute("ace_nocontext");
            });
        }
        setTimeout(() => {
            this.text.style.position = "";
            if (this.text.style.top == "0px") this.text.style.top = top;
        }, 0);
    }

    blur() {
        this.text.blur();
    }

    isFocused() {
        return this.$isFocused;
    }

    setInputHandler(cb) {
        this.inputHandler = cb;
    }

    getInputHandler() {
        return this.inputHandler;
    }

    getElement() {
        return this.text;
    }

    /**
     * allows to ignore composition (used by vim keyboard handler in the normal mode)
     * this is useful on mac, where with some keyboard layouts (e.g swedish) ^ starts composition
     * @param {boolean} value
     */
    setCommandMode(value) {
        this.commandMode = value;
        this.text.readOnly = false;
    }

    setReadOnly(readOnly) {
        if (!this.commandMode) this.text.readOnly = readOnly;
    }

    setCopyWithEmptySelection(value) {
    }

    onContextMenu(e) {
        this.afterContextMenu = true;
        this.resetSelection();
        this.host._emit("nativecontextmenu", {
            target: this.host,
            domEvent: e
        });
        this.moveToMouse(e, true);
    }

    /**
     * @param e
     * @param {boolean} bringToFront
     */
    moveToMouse(e, bringToFront) {
        if (!this.tempStyle) this.tempStyle = this.text.style.cssText;
        this.text.style.cssText = (bringToFront ? "z-index:100000;" : "") + (useragent.isIE ? "opacity:0.1;" : "")
            + "text-indent: -" + (this.lastSelectionStart + this.lastSelectionEnd) * this.host.renderer.characterWidth
            * 0.5 + "px;";

        var rect = this.host.container.getBoundingClientRect();
        var style = dom.computedStyle(this.host.container);
        var top = rect.top + (parseInt(style.borderTopWidth) || 0);
        var left = rect.left + (parseInt(style.borderLeftWidth) || 0);
        var maxTop = rect.bottom - top - this.text.clientHeight - 2;
        var move = (e) => {
            dom.translate(this.text, e.clientX - left - 2, Math.min(e.clientY - top - 2, maxTop));
        };
        move(e);

        if (e.type != "mousedown") return;

        this.host.renderer.$isMousePressed = true;

        clearTimeout(this.closeTimeout);
        // on windows context menu is opened after mouseup
        if (useragent.isWin) event.capture(this.host.container, move, this.onContextMenuClose.bind(this));
    }

    destroy() {
        if (this.text.parentElement) this.text.parentElement.removeChild(this.text);
    }
}

exports.k = TextInput;
__webpack_unused_export__ = function (_isMobile, _isIOS) {
    isMobile = _isMobile;
    isIOS = _isIOS;
};


/***/ }),

/***/ 83229:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

/**
 * @typedef {import("./mouse_handler").MouseHandler} MouseHandler
 */
var dom = __webpack_require__(71435);
var MouseEvent = (__webpack_require__(85519)/* .MouseEvent */ .C);
var HoverTooltip = (__webpack_require__(59864)/* .HoverTooltip */ .sX);
var nls = (__webpack_require__(76321).nls);
var Range = (__webpack_require__(91902)/* .Range */ .Q);

/**
 * @param {MouseHandler} mouseHandler
 * @this {MouseHandler}
 */
function GutterHandler(mouseHandler) {
    var editor = mouseHandler.editor;
    var gutter = editor.renderer.$gutterLayer;
    mouseHandler.$tooltip = new GutterTooltip(editor);
    mouseHandler.$tooltip.addToEditor(editor);

    mouseHandler.$tooltip.setDataProvider(function(e, editor) {
        var row = e.getDocumentPosition().row;
        mouseHandler.$tooltip.showTooltip(row);
    });

    mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
        if (!editor.isFocused() || e.getButton() != 0)
            return;
        var gutterRegion = gutter.getRegion(e);

        if (gutterRegion == "foldWidgets")
            return;

        var row = e.getDocumentPosition().row;
        var selection = editor.session.selection;

        if (e.getShiftKey())
            selection.selectTo(row, 0);
        else {
            if (e.domEvent.detail == 2) {
                editor.selectAll();
                return e.preventDefault();
            }
            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
        }
        mouseHandler.setState("selectByLines");
        mouseHandler.captureMouse(e);
        return e.preventDefault();
    });
}

exports.Y = GutterHandler;


class GutterTooltip extends HoverTooltip {
    /**
     * @param {import("../editor").Editor} editor
     */
    constructor(editor) {
        super(editor.container);
        this.id = "gt" + (++GutterTooltip.$uid);
        this.editor = editor;
        /**@type {Number | Undefined}*/
        this.visibleTooltipRow;
        var el = this.getElement();
        el.setAttribute("role", "tooltip");
        el.setAttribute("id", this.id);
        el.style.pointerEvents = "auto";
        this.idleTime = 50;

        this.onDomMouseMove = this.onDomMouseMove.bind(this);
        this.onDomMouseOut = this.onDomMouseOut.bind(this);

        this.setClassName("ace_gutter-tooltip");
    }
    
    onDomMouseMove(domEvent) {
        var aceEvent = new MouseEvent(domEvent, this.editor);
        this.onMouseMove(aceEvent, this.editor);
    }
    
    onDomMouseOut(domEvent) {
        var aceEvent = new MouseEvent(domEvent, this.editor);
        this.onMouseOut(aceEvent);
    }

    addToEditor(editor) {
        var gutter = editor.renderer.$gutter;
        gutter.addEventListener("mousemove", this.onDomMouseMove);
        gutter.addEventListener("mouseout", this.onDomMouseOut);
        super.addToEditor(editor);
    }

    removeFromEditor(editor) {
        var gutter = editor.renderer.$gutter;
        gutter.removeEventListener("mousemove", this.onDomMouseMove);
        gutter.removeEventListener("mouseout", this.onDomMouseOut);
        super.removeFromEditor(editor);
    }

    destroy() {
        if (this.editor) {
            this.removeFromEditor(this.editor);
        }
        super.destroy();
    }

    static get annotationLabels() {
        return {
            error: {
                singular: nls("gutter-tooltip.aria-label.error.singular", "error"),
                plural: nls("gutter-tooltip.aria-label.error.plural", "errors")
            },
            security: {
                singular: nls("gutter-tooltip.aria-label.security.singular", "security finding"),
                plural: nls("gutter-tooltip.aria-label.security.plural", "security findings")
            },
            warning: {
                singular: nls("gutter-tooltip.aria-label.warning.singular", "warning"),
                plural: nls("gutter-tooltip.aria-label.warning.plural", "warnings")
            },
            info: {
                singular: nls("gutter-tooltip.aria-label.info.singular", "information message"),
                plural: nls("gutter-tooltip.aria-label.info.plural", "information messages")
            },
            hint: {
                singular: nls("gutter-tooltip.aria-label.hint.singular", "suggestion"),
                plural: nls("gutter-tooltip.aria-label.hint.plural", "suggestions")
            }
        };
    }

    /**
     * @param {number} row
     */
    showTooltip(row) {
        var gutter = this.editor.renderer.$gutterLayer;
        var annotationsInRow = gutter.$annotations[row];
        var annotation;

        if (annotationsInRow)
            annotation = {
                displayText: Array.from(annotationsInRow.displayText),
                type: Array.from(annotationsInRow.type)
            };
        else annotation = {displayText: [], type: []};

        // If the tooltip is for a row which has a closed fold, check whether there are
        // annotations in the folded lines. If so, add a summary to the list of annotations.
        var fold = gutter.session.getFoldLine(row);
        if (fold && gutter.$showFoldedAnnotations) {
            var annotationsInFold = {error: [], security: [], warning: [], info: [], hint: []};
            var severityRank = {error: 1, security: 2, warning: 3, info: 4, hint: 5};
            var mostSevereAnnotationTypeInFold;

            for (var i = row + 1; i <= fold.end.row; i++) {
                if (!gutter.$annotations[i]) continue;

                for (var j = 0; j < gutter.$annotations[i].text.length; j++) {
                    var annotationType = gutter.$annotations[i].type[j];
                    annotationsInFold[annotationType].push(gutter.$annotations[i].text[j]);

                    if (
                        !mostSevereAnnotationTypeInFold ||
                        severityRank[annotationType] < severityRank[mostSevereAnnotationTypeInFold]
                    ) {
                        mostSevereAnnotationTypeInFold = annotationType;
                    }
                }
            }

            if (["error", "security", "warning"].includes(mostSevereAnnotationTypeInFold)) {
                var summaryFoldedAnnotations = `${GutterTooltip.annotationsToSummaryString(
                    annotationsInFold
                )} in folded code.`;

                annotation.displayText.push(summaryFoldedAnnotations);
                annotation.type.push(mostSevereAnnotationTypeInFold + "_fold");
            }
        }

        if (annotation.displayText.length === 0) return this.hide();

        var annotationMessages = {error: [], security: [], warning: [], info: [], hint: []};
        var iconClassName = gutter.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon";

        // Construct the contents of the tooltip.
        for (var i = 0; i < annotation.displayText.length; i++) {
            var lineElement = dom.createElement("span");

            var iconElement = dom.createElement("span");
            iconElement.classList.add(...[`ace_${annotation.type[i]}`, iconClassName]);
            iconElement.setAttribute(
                "aria-label",
                `${GutterTooltip.annotationLabels[annotation.type[i].replace("_fold", "")].singular}`
            );
            iconElement.setAttribute("role", "img");
            // Set empty content to the img span to get it to show up
            iconElement.appendChild(dom.createTextNode(" "));

            lineElement.appendChild(iconElement);
            lineElement.appendChild(dom.createTextNode(annotation.displayText[i]));
            lineElement.appendChild(dom.createElement("br"));

            annotationMessages[annotation.type[i].replace("_fold", "")].push(lineElement);
        }

        var tooltipElement = dom.createElement("span");

        // Update the tooltip content
        annotationMessages.error.forEach((el) => tooltipElement.appendChild(el));
        annotationMessages.security.forEach((el) => tooltipElement.appendChild(el));
        annotationMessages.warning.forEach((el) => tooltipElement.appendChild(el));
        annotationMessages.info.forEach((el) => tooltipElement.appendChild(el));
        annotationMessages.hint.forEach((el) => tooltipElement.appendChild(el));

        tooltipElement.setAttribute("aria-live", "polite");

        var annotationNode = this.$findLinkedAnnotationNode(row);
        if (annotationNode) {
            annotationNode.setAttribute("aria-describedby", this.id);
        }

        var range = Range.fromPoints({row, column: 0}, {row, column: 0});
        this.showForRange(this.editor, range, tooltipElement);
        this.visibleTooltipRow = row;
        this.editor._signal("showGutterTooltip", this);
    }

    $setPosition(editor, _ignoredPosition, _withMarker, range) {
        var gutterCell = this.$findCellByRow(range.start.row);
        if (!gutterCell) return;
        var el = gutterCell && gutterCell.element;
        var anchorEl = el && (el.querySelector(".ace_gutter_annotation"));
        if (!anchorEl) return;
        var r = anchorEl.getBoundingClientRect();
        if (!r) return;
        var position = {
            pageX: r.right,
            pageY: r.top
        };
        //we don't need marker for gutter
        return super.$setPosition(editor, position, false, range);
    }

    $shouldPlaceAbove(labelHeight, anchorTop, spaceBelow) {
        return spaceBelow < labelHeight;
    }

    $findLinkedAnnotationNode(row) {
        var cell = this.$findCellByRow(row);
        if (cell) {
            var element = cell.element;
            if (element.childNodes.length > 2) {
                return element.childNodes[2];
            }
        }
    }

    $findCellByRow(row) {
        return this.editor.renderer.$gutterLayer.$lines.cells.find((el) => el.row === row);
    }

    hide(e) {
        if(!this.isOpen){
            return;
        }
        this.$element.removeAttribute("aria-live");

        if (this.visibleTooltipRow != undefined) {
            var annotationNode = this.$findLinkedAnnotationNode(this.visibleTooltipRow);
            if (annotationNode) {
                annotationNode.removeAttribute("aria-describedby");
            }
        }
        this.visibleTooltipRow = undefined;
        this.editor._signal("hideGutterTooltip", this);
        super.hide(e);
    }

    static annotationsToSummaryString(annotations) {
        var summary = [];
        var annotationTypes = ["error", "security", "warning", "info", "hint"];
        for (var annotationType of annotationTypes) {
            if (!annotations[annotationType].length) continue;
            var label = annotations[annotationType].length === 1 ? GutterTooltip.annotationLabels[annotationType].singular : GutterTooltip.annotationLabels[annotationType].plural;
            summary.push(`${annotations[annotationType].length} ${label}`);
        }
        return summary.join(", ");
    }

    /**
     * Check if cursor is outside gutter
     * @param e
     * @return {boolean}
     */
    isOutsideOfText(e) {
        var editor = e.editor;
        var rect = editor.renderer.$gutter.getBoundingClientRect();
        return !(e.clientX >= rect.left && e.clientX <= rect.right &&
               e.clientY >= rect.top && e.clientY <= rect.bottom);
    }
}

GutterTooltip.$uid = 0;

__webpack_unused_export__ = GutterTooltip;


/***/ }),

/***/ 85519:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var event = __webpack_require__(19631);
var useragent = __webpack_require__(74943);

/*
 * Custom Ace mouse event
 */
class MouseEvent {
    constructor(domEvent, editor) {
        /** @type {number} */this.speed;
        /** @type {number} */this.wheelX;
        /** @type {number} */this.wheelY;
        this.domEvent = domEvent;
        this.editor = editor;

        this.x = this.clientX = domEvent.clientX;
        this.y = this.clientY = domEvent.clientY;

        this.$pos = null;
        this.$inSelection = null;

        this.propagationStopped = false;
        this.defaultPrevented = false;
    }
    
    stopPropagation() {
        event.stopPropagation(this.domEvent);
        this.propagationStopped = true;
    }
    
    preventDefault() {
        event.preventDefault(this.domEvent);
        this.defaultPrevented = true;
    }
    
    stop() {
        this.stopPropagation();
        this.preventDefault();
    }

    /**
     * Get the document position below the mouse cursor
     * 
     * @return {Object} 'row' and 'column' of the document position
     */
    getDocumentPosition() {
        if (this.$pos)
            return this.$pos;
        
        this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
        return this.$pos;
    }

    /**
     * Get the relative position within the gutter.
     * 
     * @return {Number} 'row' within the gutter. 
     */
    getGutterRow() {
        var documentRow = this.getDocumentPosition().row;
        var screenRow = this.editor.session.documentToScreenRow(documentRow, 0);
        var screenTopRow = this.editor.session.documentToScreenRow(this.editor.renderer.$gutterLayer.$lines.get(0).row, 0);
        return screenRow - screenTopRow;
    }
    
    /**
     * Check if the mouse cursor is inside of the text selection
     * 
     * @return {Boolean} whether the mouse cursor is inside of the selection
     */
    inSelection() {
        if (this.$inSelection !== null)
            return this.$inSelection;
            
        var editor = this.editor;
        

        var selectionRange = editor.getSelectionRange();
        if (selectionRange.isEmpty())
            this.$inSelection = false;
        else {
            var pos = this.getDocumentPosition();
            this.$inSelection = selectionRange.contains(pos.row, pos.column);
        }

        return this.$inSelection;
    }
    
    /**
     * Get the clicked mouse button
     * 
     * @return {Number} 0 for left button, 1 for middle button, 2 for right button
     */
    getButton() {
        return event.getButton(this.domEvent);
    }
    
    /**
     * @return {Boolean} whether the shift key was pressed when the event was emitted
     */
    getShiftKey() {
        return this.domEvent.shiftKey;
    }

    getAccelKey() {
        return useragent.isMac ? this.domEvent.metaKey : this.domEvent.ctrlKey;
    }
}

exports.C = MouseEvent;


/***/ }),

/***/ 87366:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**@type {any}*/
var EventEmitter = {};
var stopPropagation = function() { this.propagationStopped = true; };
var preventDefault = function() { this.defaultPrevented = true; };

EventEmitter._emit =
EventEmitter._dispatchEvent = function(eventName, e) {
    this._eventRegistry || (this._eventRegistry = {});
    this._defaultHandlers || (this._defaultHandlers = {});

    var listeners = this._eventRegistry[eventName] || [];
    var defaultHandler = this._defaultHandlers[eventName];
    if (!listeners.length && !defaultHandler)
        return;

    if (typeof e != "object" || !e)
        e = {};

    if (!e.type)
        e.type = eventName;
    if (!e.stopPropagation)
        e.stopPropagation = stopPropagation;
    if (!e.preventDefault)
        e.preventDefault = preventDefault;

    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++) {
        listeners[i](e, this);
        if (e.propagationStopped)
            break;
    }
    
    if (defaultHandler && !e.defaultPrevented)
        return defaultHandler(e, this);
};


EventEmitter._signal = function(eventName, e) {
    var listeners = (this._eventRegistry || {})[eventName];
    if (!listeners)
        return;
    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++)
        listeners[i](e, this);
};

EventEmitter.once = function(eventName, callback) {
    var _self = this;
    this.on(eventName, function newCallback() {
        _self.off(eventName, newCallback);
        callback.apply(null, arguments);
    });
    if (!callback) {
        /*global Promise*/
        return new Promise(function(resolve) {
            callback = resolve;
        });
    }
};


EventEmitter.setDefaultHandler = function(eventName, callback) {
    /**@type {any}*/
    var handlers = this._defaultHandlers;
    if (!handlers)
        handlers = this._defaultHandlers = {_disabled_: {}};
    
    if (handlers[eventName]) {
        var old = handlers[eventName];
        var disabled = handlers._disabled_[eventName];
        if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
        disabled.push(old);
        var i = disabled.indexOf(callback);
        if (i != -1) 
            disabled.splice(i, 1);
    }
    handlers[eventName] = callback;
};
EventEmitter.removeDefaultHandler = function(eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers)
        return;
    var disabled = handlers._disabled_[eventName];
    
    if (handlers[eventName] == callback) {
        if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
    } else if (disabled) {
        var i = disabled.indexOf(callback);
        if (i != -1)
            disabled.splice(i, 1);
    }
};

EventEmitter.on =
EventEmitter.addEventListener = function(eventName, callback, capturing) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        listeners = this._eventRegistry[eventName] = [];

    if (listeners.indexOf(callback) == -1)
        listeners[capturing ? "unshift" : "push"](callback);
    return callback;
};

EventEmitter.off =
EventEmitter.removeListener =
EventEmitter.removeEventListener = function(eventName, callback) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        return;

    var index = listeners.indexOf(callback);
    if (index !== -1)
        listeners.splice(index, 1);
};
/**
 * @this {EventEmitter}
 */
EventEmitter.removeAllListeners = function(eventName) {
    if (!eventName) this._eventRegistry = this._defaultHandlers = undefined;
    if (this._eventRegistry) this._eventRegistry[eventName] = undefined;
    if (this._defaultHandlers) this._defaultHandlers[eventName] = undefined;
};

exports.EventEmitter = EventEmitter;


/***/ }),

/***/ 87983:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.isDark = false;
exports.cssClass = "ace-tm";
exports.cssText = __webpack_require__(59781);
exports.$id = "ace/theme/textmate";

var dom = __webpack_require__(71435);
dom.importCssString(exports.cssText, exports.cssClass, false);


/***/ }),

/***/ 88416:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./mouse_handler").MouseHandler} MouseHandler
 * @typedef {import("./mouse_event").MouseEvent} MouseEvent
 */
var useragent = __webpack_require__(74943);

var DRAG_OFFSET = 0; // pixels
var SCROLL_COOLDOWN_T = 550; // milliseconds

class DefaultHandlers {
    /**
     * @param {MouseHandler} mouseHandler
     */
    constructor(mouseHandler) {
        mouseHandler.$clickSelection = null;

        var editor = mouseHandler.editor;
        editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
        editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
        editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
        editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
        editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));

        var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd",
            "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];

        exports.forEach(function(x) {
            mouseHandler[x] = this[x];
        }, this);

        mouseHandler["selectByLines"] = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
        mouseHandler["selectByWords"] = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
    }

    /**
     * @param {MouseEvent} ev
     * @this {MouseHandler}
     */
    onMouseDown(ev) {
        var inSelection = ev.inSelection();
        var pos = ev.getDocumentPosition();
        this.mousedownEvent = ev;
        var editor = this.editor;

        var button = ev.getButton();
        if (button !== 0) {
            var selectionRange = editor.getSelectionRange();
            var selectionEmpty = selectionRange.isEmpty();
            if (selectionEmpty || button == 1)
                editor.selection.moveToPosition(pos);
            // 2: contextmenu, 1: linux paste
            if (button == 2) {
                editor.textInput.onContextMenu(ev.domEvent);
                if (!useragent.isMozilla)
                    ev.preventDefault();
            }
            // stopping event here breaks contextmenu on ff mac
            // not stoping breaks it on chrome mac
            return;
        }

        this.mousedownEvent.time = Date.now();
        // if this click caused the editor to be focused should not clear the
        // selection
        if (inSelection && !editor.isFocused()) {
            editor.focus();
            if (this.$focusTimeout && !this.$clickSelection && !editor.inMultiSelectMode) {
                this.setState("focusWait");
                this.captureMouse(ev);
                return;
            }
        }

        this.captureMouse(ev);
        this.startSelect(pos, ev.domEvent._clicks > 1);
        return ev.preventDefault();
    }

    /**
     * 
     * @param {import("../../ace-internal").Ace.Position} [pos]
     * @param {boolean} [waitForClickSelection]
     * @this {MouseHandler}
     */
    startSelect(pos, waitForClickSelection) {
        pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
        var editor = this.editor;
        if (!this.mousedownEvent) return;
        // allow double/triple click handlers to change selection
        if (this.mousedownEvent.getShiftKey())
            editor.selection.selectToPosition(pos);
        else if (!waitForClickSelection)
            editor.selection.moveToPosition(pos);
        if (!waitForClickSelection)
            this.select();
        editor.setStyle("ace_selecting");
        this.setState("select");
    }

    /**
     * @this {MouseHandler}
     */
    select() {
        var anchor, editor = this.editor;
        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
        if (this.$clickSelection) {
            var cmp = this.$clickSelection.comparePoint(cursor);

            if (cmp == -1) {
                anchor = this.$clickSelection.end;
            } else if (cmp == 1) {
                anchor = this.$clickSelection.start;
            } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor, editor.session);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);
        editor.renderer.scrollCursorIntoView();
    }

    /**
     * @param {string | number} unitName
     * @this {MouseHandler}
     */
    extendSelectionBy(unitName) {
        var anchor, editor = this.editor;
        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
        var range = editor.selection[unitName](cursor.row, cursor.column);
        if (this.$clickSelection) {
            var cmpStart = this.$clickSelection.comparePoint(range.start);
            var cmpEnd = this.$clickSelection.comparePoint(range.end);

            if (cmpStart == -1 && cmpEnd <= 0) {
                anchor = this.$clickSelection.end;
                if (range.end.row != cursor.row || range.end.column != cursor.column)
                    cursor = range.start;
            } else if (cmpEnd == 1 && cmpStart >= 0) {
                anchor = this.$clickSelection.start;
                if (range.start.row != cursor.row || range.start.column != cursor.column)
                    cursor = range.end;
            } else if (cmpStart == -1 && cmpEnd == 1) {
                cursor = range.end;
                anchor = range.start;
            } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor, editor.session);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);
        editor.renderer.scrollCursorIntoView();
    }

    /**
     * @this {MouseHandler}
     */
    selectByLinesEnd() {
        this.$clickSelection = null;
        this.editor.unsetStyle("ace_selecting");
    }

    /**
     * @this {MouseHandler}
     */
    focusWait() {
        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
        var time = Date.now();

        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimeout)
            this.startSelect(this.mousedownEvent.getDocumentPosition());
    }
    
    /**
     * @param {MouseEvent} ev
     * @this {MouseHandler}
     */
    onDoubleClick(ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;
        var session = editor.session;

        var range = session.getBracketRange(pos);
        if (range) {
            if (range.isEmpty()) {
                range.start.column--;
                range.end.column++;
            }
            this.setState("select");
        } else {
            range = editor.selection.getWordRange(pos.row, pos.column);
            this.setState("selectByWords");
        }
        this.$clickSelection = range;
        this.select();
    }

    /**
     * @param {MouseEvent} ev
     * @this {MouseHandler}
     */
    onTripleClick(ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;

        this.setState("selectByLines");
        var range = editor.getSelectionRange();
        if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
            this.$clickSelection = editor.selection.getLineRange(range.start.row);
            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
        } else {
            this.$clickSelection = editor.selection.getLineRange(pos.row);
        }
        this.select();
    }

    /**
     * @param {MouseEvent} ev
     * @this {MouseHandler}
     */
    onQuadClick(ev) {
        var editor = this.editor;

        editor.selectAll();
        this.$clickSelection = editor.getSelectionRange();
        this.setState("selectAll");
    }

    /**
     * @param {MouseEvent} ev
     * @this {MouseHandler}
     */
    onMouseWheel(ev) {
        if (ev.getAccelKey())
            return;

        // shift wheel to horizontal scroll
        if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
            ev.wheelX = ev.wheelY;
            ev.wheelY = 0;
        }
        
        var editor = this.editor;
        
        if (!this.$lastScroll)
            this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 };
        
        var prevScroll = this.$lastScroll;
        var t = ev.domEvent.timeStamp;
        var dt = t - prevScroll.t;
        var vx = dt ? ev.wheelX / dt : prevScroll.vx;
        var vy = dt ? ev.wheelY / dt : prevScroll.vy;
        
        // touchbar keeps sending scroll events after touchend, if we do not stop these events,
        // users can't scrol editor without scrolling the parent node
        if (dt < SCROLL_COOLDOWN_T) {
            vx = (vx + prevScroll.vx) / 2;
            vy = (vy + prevScroll.vy) / 2;
        }
        
        var direction = Math.abs(vx / vy);
        
        var canScroll = false;
        if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))
            canScroll = true;
        if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed))
            canScroll = true;
            
        if (canScroll) {
            prevScroll.allowed = t;
        } else if (t - prevScroll.allowed < SCROLL_COOLDOWN_T) {
            var isSlower = Math.abs(vx) <= 1.5 * Math.abs(prevScroll.vx)
                && Math.abs(vy) <= 1.5 * Math.abs(prevScroll.vy);
            if (isSlower) {
                canScroll = true;
                prevScroll.allowed = t;
            }
            else {
                prevScroll.allowed = 0;
            }
        }
        
        prevScroll.t = t;
        prevScroll.vx = vx;
        prevScroll.vy = vy;

        if (canScroll) {
            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
            return ev.stop();
        }
    }

}
DefaultHandlers.prototype.selectEnd = DefaultHandlers.prototype.selectByLinesEnd;
DefaultHandlers.prototype.selectAllEnd = DefaultHandlers.prototype.selectByLinesEnd;
DefaultHandlers.prototype.selectByWordsEnd = DefaultHandlers.prototype.selectByLinesEnd;

exports.J = DefaultHandlers;

function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
}

function calcRangeOrientation(range, cursor, session) {
    if (range.start.row == range.end.row)
        var cmp = 2 * cursor.column - range.start.column - range.end.column;
    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
        var cmp = 3 * cursor.column - 2 * session.getLine(range.start.row).length;
    else
        var cmp = 2 * cursor.row - range.start.row - range.end.row;

    if (cmp < 0)
        return {cursor: range.start, anchor: range.end};
    else
        return {cursor: range.end, anchor: range.start};
}


/***/ }),

/***/ 88629:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * This object is used to communicate inline code completions rendered into an editor with ghost text to screen reader users.
 */
class AceInlineScreenReader {
    /**
     * Creates the off-screen div in which the ghost text content in redered and which the screen reader reads.
     * @param {import("../editor").Editor} editor
     */
    constructor(editor) {
        this.editor = editor;

        this.screenReaderDiv = document.createElement("div");
        this.screenReaderDiv.classList.add("ace_screenreader-only");
        this.editor.container.appendChild(this.screenReaderDiv);
    }

    /**
     * Set the ghost text content to the screen reader div
     * @param {string} content
     */
    setScreenReaderContent(content) {
        // Path for when inline preview is used with 'normal' completion popup.
        if (!this.popup && this.editor.completer && /**@type{import("../autocomplete").Autocomplete}*/(this.editor.completer).popup) {
            this.popup = /**@type{import("../autocomplete").Autocomplete}*/(this.editor.completer).popup;

            this.popup.renderer.on("afterRender", function() {
                let row = this.popup.getRow();
                let t = this.popup.renderer.$textLayer;
                let selected = t.element.childNodes[row - t.config.firstRow];
                if (selected) {
                    let idString = "doc-tooltip ";
                    for (let lineIndex = 0; lineIndex < this._lines.length; lineIndex++) {
                        idString += `ace-inline-screenreader-line-${lineIndex} `;
                    }
                    selected.setAttribute("aria-describedby", idString);      
                }
            }.bind(this));
        }

        // TODO: Path for when special inline completion popup is used.
        // https://github.com/ajaxorg/ace/issues/5348

        // Remove all children of the div
        while (this.screenReaderDiv.firstChild) {
            this.screenReaderDiv.removeChild(this.screenReaderDiv.firstChild);
        }
        this._lines = content.split(/\r\n|\r|\n/);
        const codeElement = this.createCodeBlock();
        this.screenReaderDiv.appendChild(codeElement);
    }

    destroy() {
        this.screenReaderDiv.remove();
    }

    /**
     * Take this._lines, render it as <code> blocks and add those to the screen reader div.
     */
    createCodeBlock() {
        const container = document.createElement("pre");
        container.setAttribute("id", "ace-inline-screenreader");

        for (let lineIndex = 0; lineIndex < this._lines.length; lineIndex++) {
            const codeElement = document.createElement("code");
            codeElement.setAttribute("id", `ace-inline-screenreader-line-${lineIndex}`);
            const line = document.createTextNode(this._lines[lineIndex]);

            codeElement.appendChild(line);
            container.appendChild(codeElement);
        }

        return container;
    }
}

exports._ = AceInlineScreenReader;


/***/ }),

/***/ 90563:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./edit_session").EditSession} EditSession
 * @typedef {import("./editor").Editor} Editor
 * @typedef {import("./virtual_renderer").VirtualRenderer} VirtualRenderer
 * @typedef {import("../ace-internal").Ace.LineWidget} LineWidget
 */

var dom = __webpack_require__(71435);


class LineWidgets {
    /**
     * @param {EditSession} session
     */
    constructor(session) {
        this.session = session;
        this.session.widgetManager = this;
        this.session.getRowLength = this.getRowLength;
        this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
        this.updateOnChange = this.updateOnChange.bind(this);
        this.renderWidgets = this.renderWidgets.bind(this);
        this.measureWidgets = this.measureWidgets.bind(this);
        this.session._changedWidgets = [];
        this.$onChangeEditor = this.$onChangeEditor.bind(this);

        this.session.on("change", this.updateOnChange);
        this.session.on("changeFold", this.updateOnFold);
        this.session.on("changeEditor", this.$onChangeEditor);
    }

    /**
     * @param {number} row
     * @return {number}
     */
    getRowLength(row) {
        var h;
        if (this.lineWidgets)
            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
        else
            h = 0;
        if (!this["$useWrapMode"] || !this["$wrapData"][row]) {
            return 1 + h;
        } else {
            return this["$wrapData"][row].length + 1 + h;
        }
    }

    /**
     * @return {number}
     */
    $getWidgetScreenLength() {
        var screenRows = 0;
        this.lineWidgets.forEach(function(w){
            if (w && w.rowCount && !w.hidden)
                screenRows += w.rowCount;
        });
        return screenRows;
    }

    $onChangeEditor(e) {
        this.attach(e.editor);
    }

    /**
     *
     * @param {Editor} editor
     */
    attach(editor) {
        if (editor  && editor.widgetManager && editor.widgetManager != this)
            editor.widgetManager.detach();

        if (this.editor == editor)
            return;

        this.detach();
        /**@type {Editor} */
        this.editor = editor;

        if (editor) {
            editor.widgetManager = this;
            editor.renderer.on("beforeRender", this.measureWidgets);
            editor.renderer.on("afterRender", this.renderWidgets);
        }
    }
    detach(e) {
        var editor = this.editor;
        if (!editor)
            return;

        this.editor = null;
        editor.widgetManager = null;

        editor.renderer.off("beforeRender", this.measureWidgets);
        editor.renderer.off("afterRender", this.renderWidgets);
        var lineWidgets = this.session.lineWidgets;
        lineWidgets && lineWidgets.forEach(function(w) {
            if (w && w.el && w.el.parentNode) {
                w._inDocument = false;
                w.el.parentNode.removeChild(w.el);
            }
        });
    }

    /**
     *
     * @param e
     * @param {EditSession} session
     */
    updateOnFold(e, session) {
        var lineWidgets = session.lineWidgets;
        if (!lineWidgets || !e.action)
            return;
        var fold = e.data;
        var start = fold.start.row;
        var end = fold.end.row;
        var hide = e.action == "add";
        for (var i = start + 1; i < end; i++) {
            if (lineWidgets[i])
                lineWidgets[i].hidden = hide;
        }
        if (lineWidgets[end]) {
            if (hide) {
                if (!lineWidgets[start])
                    lineWidgets[start] = lineWidgets[end];
                else
                    lineWidgets[end].hidden = hide;
            } else {
                if (lineWidgets[start] == lineWidgets[end])
                    lineWidgets[start] = undefined;
                lineWidgets[end].hidden = hide;
            }
        }
    }

    /**
     *
     * @param {import("../ace-internal").Ace.Delta} delta
     */
    updateOnChange(delta) {
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets) return;

        var startRow = delta.start.row;
        var len = delta.end.row - startRow;

        if (len === 0) {
            // return
        } else if (delta.action == "remove") {
            var removed = lineWidgets.splice(startRow + 1, len);
            if (!lineWidgets[startRow] && removed[removed.length - 1]) {
                lineWidgets[startRow] = removed.pop();
            }
            removed.forEach(function(w) {
                w && this.removeLineWidget(w);
            }, this);
            this.$updateRows();
        } else {
            var args = new Array(len);
            if (lineWidgets[startRow] && lineWidgets[startRow].column != null) {
                if (delta.start.column > lineWidgets[startRow].column)
                    startRow++;
            }
            args.unshift(startRow, 0);
            lineWidgets.splice.apply(lineWidgets, args);
            this.$updateRows();
        }
    }

    $updateRows() {
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets) return;
        var noWidgets = true;
        lineWidgets.forEach(function(w, i) {
            if (w) {
                noWidgets = false;
                w.row = i;
                while (w.$oldWidget) {
                    w.$oldWidget.row = i;
                    w = w.$oldWidget;
                }
            }
        });
        if (noWidgets)
            this.session.lineWidgets = null;
    }

    /**
     *
     * @param {LineWidget} w
     * @return {LineWidget}
     */
    $registerLineWidget(w) {
        if (!this.session.lineWidgets)
            this.session.lineWidgets = new Array(this.session.getLength());

        var old = this.session.lineWidgets[w.row];
        if (old) {
            w.$oldWidget = old;
            if (old.el && old.el.parentNode) {
                old.el.parentNode.removeChild(old.el);
                old._inDocument = false;
            }
        }

        this.session.lineWidgets[w.row] = w;
        return w;
    }

    /**
     *
     * @param {LineWidget} w
     * @return {LineWidget}
     */
    addLineWidget(w) {
        this.$registerLineWidget(w);
        w.session = this.session;

        if (!this.editor) return w;

        var renderer = this.editor.renderer;
        if (w.html && !w.el) {
            w.el = dom.createElement("div");
            w.el.innerHTML = w.html;
        }
        if (w.text && !w.el) {
            w.el = dom.createElement("div");
            w.el.textContent = w.text;
        }
        if (w.el) {
            dom.addCssClass(w.el, "ace_lineWidgetContainer");
            if (w.className) {
                dom.addCssClass(w.el, w.className);
            }
            w.el.style.position = "absolute";
            w.el.style.zIndex = "5";
            renderer.container.appendChild(w.el);
            w._inDocument = true;

            if (!w.coverGutter) {
                w.el.style.zIndex = "3";
            }
            if (w.pixelHeight == null) {
                w.pixelHeight = w.el.offsetHeight;
            }
        }
        if (w.rowCount == null) {
            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
        }

        var fold = this.session.getFoldAt(w.row, 0);
        w.$fold = fold;
        if (fold) {
            var lineWidgets = this.session.lineWidgets;
            if (w.row == fold.end.row && !lineWidgets[fold.start.row])
                lineWidgets[fold.start.row] = w;
            else
                w.hidden = true;
        }

        this.session._emit("changeFold", {data:{start:{row: w.row}}});

        this.$updateRows();
        this.renderWidgets(null, renderer);
        this.onWidgetChanged(w);
        return w;
    }

    /**
     * @param {LineWidget} w
     */
    removeLineWidget(w) {
        w._inDocument = false;
        w.session = null;
        if (w.el && w.el.parentNode)
            w.el.parentNode.removeChild(w.el);
        if (w.editor && w.editor.destroy) try {
            w.editor.destroy();
        } catch(e){}
        if (this.session.lineWidgets) {
            var w1 = this.session.lineWidgets[w.row];
            if (w1 == w) {
                this.session.lineWidgets[w.row] = w.$oldWidget;
                if (w.$oldWidget)
                    this.onWidgetChanged(w.$oldWidget);
            } else {
                while (w1) {
                    if (w1.$oldWidget == w) {
                        w1.$oldWidget = w.$oldWidget;
                        break;
                    }
                    w1 = w1.$oldWidget;
                }
            }
        }
        this.session._emit("changeFold", {data:{start:{row: w.row}}});
        this.$updateRows();
    }

    /**
     *
     * @param {number} row
     * @return {LineWidget[]}
     */
    getWidgetsAtRow(row) {
        var lineWidgets = this.session.lineWidgets;
        var w = lineWidgets && lineWidgets[row];
        var list = [];
        while (w) {
            list.push(w);
            w = w.$oldWidget;
        }
        return list;
    }

    /**
     * @param {LineWidget} w
     * @internal
     */
    onWidgetChanged(w) {
        this.session._changedWidgets.push(w);
        this.editor && this.editor.renderer.updateFull();
    }

    /**
     * @param {any} e
     * @param {VirtualRenderer} renderer
     */
    measureWidgets(e, renderer) {
        var changedWidgets = this.session._changedWidgets;
        var config = renderer.layerConfig;

        if (!changedWidgets || !changedWidgets.length) return;
        var min = Infinity;
        for (var i = 0; i < changedWidgets.length; i++) {
            var w = changedWidgets[i];
            if (!w || !w.el) continue;
            if (w.session != this.session) continue;
            if (!w._inDocument) {
                if (this.session.lineWidgets[w.row] != w)
                    continue;
                w._inDocument = true;
                renderer.container.appendChild(w.el);
            }

            w.h = w.el.offsetHeight;

            if (!w.fixedWidth) {
                w.w = w.el.offsetWidth;
                w.screenWidth = Math.ceil(w.w / config.characterWidth);
            }

            var rowCount = w.h / config.lineHeight;
            if (w.coverLine) {
                rowCount -= this.session.getRowLineCount(w.row);
                if (rowCount < 0)
                    rowCount = 0;
            }
            if (w.rowCount != rowCount) {
                w.rowCount = rowCount;
                if (w.row < min)
                    min = w.row;
            }
        }
        if (min != Infinity) {
            this.session._emit("changeFold", {data:{start:{row: min}}});
            this.session.lineWidgetWidth = null;
        }
        this.session._changedWidgets = [];
    }

    /**
     * @param {any} e
     * @param {VirtualRenderer} renderer
     */
    renderWidgets(e, renderer) {
        var config = renderer.layerConfig;
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets)
            return;
        var first = Math.min(this.firstRow, config.firstRow);
        var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);

        while (first > 0 && !lineWidgets[first])
            first--;

        this.firstRow = config.firstRow;
        this.lastRow = config.lastRow;

        renderer.$cursorLayer.config = config;
        for (var i = first; i <= last; i++) {
            /**@type{LineWidget}*/
            var w = lineWidgets[i];
            if (!w || !w.el) continue;
            if (w.hidden) {
                w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
                continue;
            }
            if (!w._inDocument) {
                w._inDocument = true;
                renderer.container.appendChild(w.el);
            }
            var top = renderer.$cursorLayer.getPixelPosition({row: i, column:0}, true).top;
            if (!w.coverLine)
                top += config.lineHeight * this.session.getRowLineCount(w.row);
            w.el.style.top = top - config.offset + "px";

            var left = w.coverGutter ? 0 : renderer.gutterWidth;
            if (!w.fixedWidth)
                left -= renderer.scrollLeft;
            w.el.style.left = left + "px";

            if (w.fullWidth && w.screenWidth) {
                w.el.style.minWidth = config.width + 2 * config.padding + "px";
            }

            if (w.fixedWidth) {
                w.el.style.right = renderer.scrollBar.getWidth() + "px";
            } else {
                w.el.style.right = "";
            }
        }
    }

}


exports.G = LineWidgets;


/***/ }),

/***/ 91772:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * ## File mode detection utility
 *
 * Provides automatic detection of editor syntax modes based on file paths and extensions. Maps file extensions to
 * appropriate Ace Editor syntax highlighting modes for over 100 programming languages and file formats including
 * JavaScript, TypeScript, HTML, CSS, Python, Java, C++, and many others. Supports complex extension patterns and
 * provides fallback mechanisms for unknown file types.
 *
 * @module
 */



/**
 * Represents an array to store various syntax modes.
 *
 * @type {Mode[]}
 */
var modes = [];
/**
 * Suggests a mode based on the file extension present in the given path
 * @param {string} path The path to the file
 * @returns {Mode} Returns an object containing information about the
 *  suggested mode.
 */
function getModeForPath(path) {
    var mode = modesByName.text;
    var fileName = path.split(/[\/\\]/).pop();
    for (var i = 0; i < modes.length; i++) {
        if (modes[i].supportsFile(fileName)) {
            mode = modes[i];
            break;
        }
    }
    return mode;
}

class Mode {
    /**
     * @param {string} name
     * @param {string} caption
     * @param {string} extensions
     */
    constructor(name, caption, extensions) {
        this.name = name;
        this.caption = caption;
        this.mode = "ace/mode/" + name;
        this.extensions = extensions;
        var re;
        if (/\^/.test(extensions)) {
            re = extensions.replace(/\|(\^)?/g, function (a, b) {
                return "$|" + (b ? "^" : "^.*\\.");
            }) + "$";
        }
        else {
            re = "\\.(" + extensions + ")$";
        }

        this.extRe = new RegExp(re, "gi");
    }

    /**
     * @param {string} filename
     * @returns {RegExpMatchArray | null}
     */
    supportsFile(filename) {
        return filename.match(this.extRe);
    }
}

// todo firstlinematch
var supportedModes = {
    ABAP:        ["abap"],
    ABC:         ["abc"],
    ActionScript:["as"],
    ADA:         ["ada|adb"],
    Alda:        ["alda"],
    Apache_Conf: ["^htaccess|^htgroups|^htpasswd|^conf|htaccess|htgroups|htpasswd"],
    Apex:        ["apex|cls|trigger|tgr"],
    AQL:         ["aql"],
    AsciiDoc:    ["asciidoc|adoc"],
    ASL:         ["dsl|asl|asl.json"],
    Assembly_ARM32:["s"],
    Assembly_x86:["asm|a"],
    Astro:       ["astro"],
    AutoHotKey:  ["ahk"],
    Basic:       ["bas|bak"],
    BatchFile:   ["bat|cmd"],
    BibTeX:      ["bib"],
    C_Cpp:       ["cpp|c|cc|cxx|h|hh|hpp|ino"],
    C9Search:    ["c9search_results"],
    Cirru:       ["cirru|cr"],
    Clojure:     ["clj|cljs"],
    Clue:        ["clue"],
    Cobol:       ["CBL|COB"],
    coffee:      ["coffee|cf|cson|^Cakefile"],
    ColdFusion:  ["cfm|cfc"],
    Crystal:     ["cr"],
    CSharp:      ["cs"],
    Csound_Document: ["csd"],
    Csound_Orchestra: ["orc"],
    Csound_Score: ["sco"],
    CSS:         ["css"],
    CSV:         ["csv"],
    Curly:       ["curly"],
    Cuttlefish:  ["conf"],
    D:           ["d|di"],
    Dart:        ["dart"],
    Diff:        ["diff|patch"],
    Django:      ["djt|html.djt|dj.html|djhtml"],
    Dockerfile:  ["^Dockerfile"],
    Dot:         ["dot"],
    Drools:      ["drl"],
    Edifact:     ["edi"],
    Eiffel:      ["e|ge"],
    EJS:         ["ejs"],
    Elixir:      ["ex|exs"],
    Elm:         ["elm"],
    Erlang:      ["erl|hrl"],
    Flix:        ["flix"],
    Forth:       ["frt|fs|ldr|fth|4th"],
    Fortran:     ["f|f90"],
    FSharp:      ["fsi|fs|ml|mli|fsx|fsscript"],
    FSL:         ["fsl"],
    FTL:         ["ftl"],
    Gcode:       ["gcode"],
    Gherkin:     ["feature"],
    Gitignore:   ["^.gitignore"],
    Glsl:        ["glsl|frag|vert"],
    Gobstones:   ["gbs"],
    golang:      ["go"],
    GraphQLSchema: ["gql"],
    Groovy:      ["groovy"],
    HAML:        ["haml"],
    Handlebars:  ["hbs|handlebars|tpl|mustache"],
    Haskell:     ["hs"],
    Haskell_Cabal: ["cabal"],
    haXe:        ["hx"],
    Hjson:       ["hjson"],
    HTML: ["html|htm|xhtml|we|wpy"],
    HTML_Elixir: ["eex|html.eex"],
    HTML_Ruby:   ["erb|rhtml|html.erb"],
    INI:         ["ini|conf|cfg|prefs"],
    Io:          ["io"],
    Ion:         ["ion"],
    Jack:        ["jack"],
    Jade:        ["jade|pug"],
    Java:        ["java"],
    JavaScript:  ["js|jsm|cjs|mjs"],
    JEXL:        ["jexl"],
    JSON:        ["json"],
    JSON5:       ["json5"],
    JSONiq:      ["jq"],
    JSP:         ["jsp"],
    JSSM:        ["jssm|jssm_state"],
    JSX:         ["jsx"],
    Julia:       ["jl"],
    Kotlin:      ["kt|kts"],
    LaTeX:       ["tex|latex|ltx|bib"],
    Latte:       ["latte"],
    LESS:        ["less"],
    Liquid:      ["liquid"],
    Lisp:        ["lisp"],
    LiveScript:  ["ls"],
    Log:         ["log"],
    LogiQL:      ["logic|lql"],
    Logtalk:     ["lgt"],
    LSL:         ["lsl"],
    Lua:         ["lua"],
    LuaPage:     ["lp"],
    Lucene:      ["lucene"],
    Makefile:    ["^Makefile|^GNUmakefile|^makefile|^OCamlMakefile|make"],
    Markdown:    ["md|markdown"],
    Mask:        ["mask"],
    MATLAB:      ["matlab"],
    Maze:        ["mz"],
    MediaWiki:   ["wiki|mediawiki"],
    MEL:         ["mel"],
    MIPS:        ["s|asm"],
    MIXAL:       ["mixal"],
    MUSHCode:    ["mc|mush"],
    MySQL:       ["mysql"],
    Nasal:       ["nas"],
    Nginx:       ["nginx|conf"],
    Nim:         ["nim"],
    Nix:         ["nix"],
    NSIS:        ["nsi|nsh"],
    Nunjucks:    ["nunjucks|nunjs|nj|njk"],
    ObjectiveC:  ["m|mm"],
    OCaml:       ["ml|mli"],
    Odin:        ["odin"],
    PartiQL:     ["partiql|pql"],
    Pascal:      ["pas|p"],
    Perl:        ["pl|pm"],
    pgSQL:       ["pgsql"],
    PHP:         ["php|inc|phtml|shtml|php3|php4|php5|phps|phpt|aw|ctp|module"],
    PHP_Laravel_blade: ["blade.php"],
    Pig:         ["pig"],
    PLSQL:       ["plsql"],
    Powershell:  ["ps1"],
    Praat:       ["praat|praatscript|psc|proc"],
    Prisma:      ["prisma"],
    Prolog:      ["plg|prolog"],
    Properties:  ["properties"],
    Protobuf:    ["proto"],
    PRQL:        ["prql"],
    Puppet:      ["epp|pp"],
    Python:      ["py"],
    QML:         ["qml"],
    R:           ["r"],
    Raku:        ["raku|rakumod|rakutest|p6|pl6|pm6"],
    Razor:       ["cshtml|asp"],
    RDoc:        ["Rd"],
    Red:         ["red|reds"],
    RHTML:       ["Rhtml"],
    Robot:       ["robot|resource"],
    RST:         ["rst"],
    Ruby:        ["rb|ru|gemspec|rake|^Guardfile|^Rakefile|^Gemfile"],
    Rust:        ["rs"],
    SaC:         ["sac"],
    SASS:        ["sass"],
    SCAD:        ["scad"],
    Scala:       ["scala|sbt"],
    Scheme:      ["scm|sm|rkt|oak|scheme"],
    Scrypt:      ["scrypt"],
    SCSS:        ["scss"],
    SH:          ["sh|bash|^.bashrc"],
    SJS:         ["sjs"],
    Slim:        ["slim|skim"],
    Smarty:      ["smarty|tpl"],
    Smithy:      ["smithy"],
    snippets:    ["snippets"],
    Soy_Template:["soy"],
    Space:       ["space"],
    SPARQL:      ["rq"],
    SQL:         ["sql"],
    SQLServer:   ["sqlserver"],
    Stylus:      ["styl|stylus"],
    SVG:         ["svg"],
    Swift:       ["swift"],
    Tcl:         ["tcl"],
    Terraform:   ["tf", "tfvars", "terragrunt"],
    Tex:         ["tex"],
    Text:        ["txt"],
    Textile:     ["textile"],
    Toml:        ["toml"],
    TSV:         ["tsv"],
    TSX:         ["tsx"],
    Turtle:      ["ttl"],
    Twig:        ["twig|swig"],
    Typescript:  ["ts|mts|cts|typescript|str"],
    Vala:        ["vala"],
    VBScript:    ["vbs|vb"],
    Velocity:    ["vm"],
    Verilog:     ["v|vh|sv|svh"],
    VHDL:        ["vhd|vhdl"],
    Visualforce: ["vfp|component|page"],
    Vue: ["vue"],
    Wollok:      ["wlk|wpgm|wtest"],
    XML:         ["xml|rdf|rss|wsdl|xslt|atom|mathml|mml|xul|xbl|xaml"],
    XQuery:      ["xq"],
    YAML:        ["yaml|yml"],
    Zeek:        ["zeek|bro"],
    Zig:         ["zig"]
};

var nameOverrides = {
    ObjectiveC: "Objective-C",
    CSharp: "C#",
    golang: "Go",
    C_Cpp: "C and C++",
    Csound_Document: "Csound Document",
    Csound_Orchestra: "Csound",
    Csound_Score: "Csound Score",
    coffee: "CoffeeScript",
    HTML_Ruby: "HTML (Ruby)",
    HTML_Elixir: "HTML (Elixir)",
    FTL: "FreeMarker",
    PHP_Laravel_blade: "PHP (Blade Template)",
    Perl6: "Perl 6",
    AutoHotKey: "AutoHotkey / AutoIt"
};

/**
 * An object that serves as a mapping of mode names to their corresponding mode data.
 * The keys of this object are mode names (as strings), and the values are expected
 * to represent data associated with each mode.
 *
 * This structure can be used for quick lookups of mode information by name.
 * @type {Record<string, Mode>}
 */
var modesByName = {};
for (var name in supportedModes) {
    var data = supportedModes[name];
    var displayName = (nameOverrides[name] || name).replace(/_/g, " ");
    var filename = name.toLowerCase();
    var mode = new Mode(filename, displayName, data[0]);
    modesByName[filename] = mode;
    modes.push(mode);
}

exports.getModeForPath = getModeForPath;
exports.modes = modes;
exports.modesByName = modesByName;

/***/ }),

/***/ 91902:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * @typedef {import("./edit_session").EditSession} EditSession
 * @typedef {import("../ace-internal").Ace.IRange} IRange
 * @typedef {import("../ace-internal").Ace.Point} Point
 */
/**
 * This object is used in various places to indicate a region within the editor. To better visualize how this works, imagine a rectangle. Each quadrant of the rectangle is analogous to a range, as ranges contain a starting row and starting column, and an ending row, and ending column.
 **/
class Range {
    /**
     * Creates a new `Range` object with the given starting and ending rows and columns.
     * @param {Number} [startRow] The starting row
     * @param {Number} [startColumn] The starting column
     * @param {Number} [endRow] The ending row
     * @param {Number} [endColumn] The ending column
     * @constructor
     **/
    constructor(startRow, startColumn, endRow, endColumn) {
        /**@type {Point}*/
        this.start = {
            row: startRow,
            column: startColumn
        };
        /**@type {Point}*/
        this.end = {
            row: endRow,
            column: endColumn
        };
    }
    
    /**
     * Returns `true` if and only if the starting row and column, and ending row and column, are equivalent to those given by `range`.
     * @param {IRange} range A range to check against
     * @return {Boolean}
     **/
    isEqual(range) {
        return this.start.row === range.start.row &&
            this.end.row === range.end.row &&
            this.start.column === range.start.column &&
            this.end.column === range.end.column;
    }

    /**
     * Returns a string containing the range's row and column information, given like this:
     * ```
     *    [start.row/start.column] -> [end.row/end.column]
     * ```
     * @return {String}
     **/
    toString() {
        return ("Range: [" + this.start.row + "/" + this.start.column +
            "] -> [" + this.end.row + "/" + this.end.column + "]");
    }

    /**
     * Returns `true` if the `row` and `column` provided are within the given range. This can better be expressed as returning `true` if:
     * ```javascript
     *    this.start.row <= row <= this.end.row &&
     *    this.start.column <= column <= this.end.column
     * ```
     * @param {Number} row A row to check for
     * @param {Number} column A column to check for
     * @returns {Boolean}
     * @related [[Range.compare]]
     **/

    contains(row, column) {
        return this.compare(row, column) == 0;
    }

    /**
     * Compares `this` range (A) with another range (B).
     * @param {IRange} range A range to compare with
     * @related [[Range.compare]]
     * @returns {Number} This method returns one of the following numbers:
     * * `-2`: (B) is in front of (A), and doesn't intersect with (A)
     * * `-1`: (B) begins before (A) but ends inside of (A)
     * * `0`: (B) is completely inside of (A)
     * * `+1`: (B) begins inside of (A) but ends outside of (A)
     * * `+2`: (B) is after (A) and doesn't intersect with (A)
     * * `42`: FTW state: (B) ends in (A) but starts outside of (A)
     **/
    compareRange(range) {
        var cmp,
            end = range.end,
            start = range.start;

        cmp = this.compare(end.row, end.column);
        if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
                return 2;
            } else if (cmp == 0) {
                return 1;
            } else {
                return 0;
            }
        } else if (cmp == -1) {
            return -2;
        } else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
                return -1;
            } else if (cmp == 1) {
                return 42;
            } else {
                return 0;
            }
        }
    }

    /**
     * Compares the row and column of `p` with the starting and ending [[Point]]'s of the calling range (by calling [[Range.compare]]).
     * @param {Point} p A point to compare with
     * @related [[Range.compare]]
     * @returns {Number}
     **/
    comparePoint(p) {
        return this.compare(p.row, p.column);
    }

    /**
     * Checks the start and end [[Point]]'s of `range` and compares them to the calling range. Returns `true` if the `range` is contained within the caller's range.
     * @param {IRange} range A range to compare with
     * @returns {Boolean}
     * @related [[Range.comparePoint]]
     **/
    containsRange(range) {
        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
    }

    /**
     * Returns `true` if passed in `range` intersects with the one calling this method.
     * @param {IRange} range A range to compare with
     * @returns {Boolean}
     **/
    intersects(range) {
        var cmp = this.compareRange(range);
        return (cmp == -1 || cmp == 0 || cmp == 1);
    }

    /**
     * Returns `true` if the caller's ending row is the same as `row`, and if the caller's ending column is the same as `column`.
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Boolean}
     **/
    isEnd(row, column) {
        return this.end.row == row && this.end.column == column;
    }

    /**
     * Returns `true` if the caller's starting row is the same as `row`, and if the caller's starting column is the same as `column`.
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Boolean}
     **/
    isStart(row, column) {
        return this.start.row == row && this.start.column == column;
    }

    /**
     * Sets the starting row and column for the range.
     * @param {Number|Point} row A row to set
     * @param {Number} [column] A column to set
     *
     **/
    setStart(row, column) {
        if (typeof row == "object") {
            this.start.column = row.column;
            this.start.row = row.row;
        } else {
            this.start.row = row;
            this.start.column = column;
        }
    }

    /**
     * Sets the starting row and column for the range.
     * @param {Number|Point} row A row to set
     * @param {Number} [column] A column to set
     *
     **/
    setEnd(row, column) {
        if (typeof row == "object") {
            this.end.column = row.column;
            this.end.row = row.row;
        } else {
            this.end.row = row;
            this.end.column = column;
        }
    }

    /**
     * Returns `true` if the `row` and `column` are within the given range.
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Boolean}
     * @related [[Range.compare]]
     **/
    inside(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns `true` if the `row` and `column` are within the given range's starting [[Point]].
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Boolean}
     * @related [[Range.compare]]
     **/
    insideStart(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns `true` if the `row` and `column` are within the given range's ending [[Point]].
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Boolean}
     * @related [[Range.compare]]
     *
     **/
    insideEnd(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    }

    /**
     * Compares the `row` and `column` with the starting and ending [[Point]]'s of the calling range.
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Number} This method returns one of the following numbers:
     * * `1` if `row` is greater than the calling range
     * * `-1` if `row` is less then the calling range
     * * `0` otherwise
     *
     * If the starting row of the calling range is equal to `row`, and:
     * * `column` is greater than or equal to the calling range's starting column, this returns `0`
     * * Otherwise, it returns -1
     *
     * If the ending row of the calling range is equal to `row`, and:
     * * `column` is less than or equal to the calling range's ending column, this returns `0`
     * * Otherwise, it returns 1
     **/
    compare(row, column) {
        if (!this.isMultiLine()) {
            if (row === this.start.row) {
                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
            }
        }

        if (row < this.start.row)
            return -1;

        if (row > this.end.row)
            return 1;

        if (this.start.row === row)
            return column >= this.start.column ? 0 : -1;

        if (this.end.row === row)
            return column <= this.end.column ? 0 : 1;

        return 0;
    }

    /**
     * Compares the `row` and `column` with the starting and ending [[Point]]'s of the calling range.
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Number} This method returns one of the following numbers:
     * * `-1` if calling range's starting column and calling range's starting row are equal `row` and `column`
     * * Otherwise, it returns the value after calling [[Range.compare `compare()`]].
     **/
    compareStart(row, column) {
        if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    }

    /**
     * Compares the `row` and `column` with the starting and ending [[Point]]'s of the calling range.
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Number} This method returns one of the following numbers:
     * * `1` if calling range's ending column and calling range's ending row are equal `row` and `column`.
     * * Otherwise, it returns the value after calling [[Range.compare `compare()`]].
     */
    compareEnd(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else {
            return this.compare(row, column);
        }
    }

    /**
     * Compares the `row` and `column` with the start and end [[Point]]'s of the calling range.
     * @param {Number} row A row to compare with
     * @param {Number} column A column to compare with
     * @returns {Number} This method returns one of the following numbers:
     * * `1` if the ending row of the calling range is equal to `row`, and the ending column of the calling range is equal to `column`
     * * `-1` if the starting row of the calling range is equal to `row`, and the starting column of the calling range is equal to `column`
     * * Otherwise, it returns the value after calling [[Range.compare `compare()`]].
     **/
    compareInside(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    }

    /**
     * Returns the part of the current `Range` that occurs within the boundaries of `firstRow` and `lastRow` as a new `Range` object.
     * @param {Number} firstRow The starting row
     * @param {Number} lastRow The ending row
     * @returns {Range}
    **/
    clipRows(firstRow, lastRow) {
        if (this.end.row > lastRow)
            var end = {row: lastRow + 1, column: 0};
        else if (this.end.row < firstRow)
            var end = {row: firstRow, column: 0};

        if (this.start.row > lastRow)
            var start = {row: lastRow + 1, column: 0};
        else if (this.start.row < firstRow)
            var start = {row: firstRow, column: 0};

        return Range.fromPoints(start || this.start, end || this.end);
    }

    /**
     * Changes the `row` and `column` for the calling range for both the starting and ending [[Point]]'s.
     * @param {Number} row A new row to extend to
     * @param {Number} column A new column to extend to
     * @returns {Range} The original range with the new row
    **/
    extend(row, column) {
        var cmp = this.compare(row, column);

        if (cmp == 0)
            return this;
        else if (cmp == -1)
            var start = {row: row, column: column};
        else
            var end = {row: row, column: column};

        return Range.fromPoints(start || this.start, end || this.end);
    }

    /**
     * Returns `true` if the calling range is empty (starting [[Point]] == ending [[Point]]).
     * @returns {Boolean}
     **/
    isEmpty() {
        return (this.start.row === this.end.row && this.start.column === this.end.column);
    }

    /**
     * Returns `true` if the range spans across multiple lines.
     * @returns {Boolean}
    **/
    isMultiLine() {
        return (this.start.row !== this.end.row);
    }

    /**
     * Returns a duplicate of the calling range.
     * @returns {Range}
    **/
    clone() {
        return Range.fromPoints(this.start, this.end);
    }

    /**
     * Returns a range containing the starting and ending rows of the original range, but with a column value of `0`.
     * @returns {Range}
    **/
    collapseRows() {
        if (this.end.column == 0)
            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0);
        else
            return new Range(this.start.row, 0, this.end.row, 0);
    }

    /**
     * Given the current `Range`, this function converts those starting and ending [[Point]]'s into screen positions, and then returns a new `Range` object.
     * @param {EditSession} session The `EditSession` to retrieve coordinates from
     * @returns {Range}
    **/
    toScreenRange(session) {
        var screenPosStart = session.documentToScreenPosition(this.start);
        var screenPosEnd = session.documentToScreenPosition(this.end);

        return new Range(
            screenPosStart.row, screenPosStart.column,
            screenPosEnd.row, screenPosEnd.column
        );
    }

    /**
     * Shift the calling range by `row` and `column` values.
     * @param {Number} row
     * @param {Number} column
     * @experimental
     */
    moveBy(row, column) {
        this.start.row += row;
        this.start.column += column;
        this.end.row += row;
        this.end.column += column;
    }

}

/**
 * Creates and returns a new `Range` based on the `start` [[Point]] and `end` [[Point]] of the given parameters.
 * @param {Point} start A starting point to use
 * @param {Point} end An ending point to use
 * @returns {Range}
**/
Range.fromPoints = function(start, end) {
    return new Range(start.row, start.column, end.row, end.column);
};

/**
 * Compares `p1` and `p2` [[Point]]'s, useful for sorting
 * @param {Point} p1
 * @param {Point} p2
 * @returns {Number}
 */
Range.comparePoints = function(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};

exports.Q = Range;


/***/ }),

/***/ 93050:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


/**
 * @typedef {import("../../ace-internal").Ace.Command} Command
 * @typedef {import("../../ace-internal").Ace.CommandLike} CommandLike
*/

/** @type {any} */var keyUtil = __webpack_require__(29451);
var useragent = __webpack_require__(74943);
var KEY_MODS = keyUtil.KEY_MODS;

/**
 * @typedef {"win" | "mac"} Platform
 */

class MultiHashHandler {
    /**
     * @param {Record<string, CommandLike> | Command[]} [config]
     * @param {Platform} [platform]
     */
    constructor(config, platform) {
        this.$init(config, platform, false);
    }

    /**
     * @param {Record<string, CommandLike> | Command[]} config
     * @param {Platform} [platform]
     * @param {boolean} [$singleCommand]
     */
    $init(config, platform, $singleCommand) {
        this.platform = platform || (useragent.isMac ? "mac" : "win");
        /**@type {Record<string, Command>}*/
        this.commands = {};
        this.commandKeyBinding = {};
        this.addCommands(config);
        this.$singleCommand = $singleCommand;
    }

    /**
     * @param {Command} command
     */
    addCommand(command) {
        if (this.commands[command.name])
            this.removeCommand(command);

        this.commands[command.name] = command;

        if (command.bindKey)
            this._buildKeyHash(command);
    }

    /**
     * @param {Command | string} command
     * @param {boolean} [keepCommand]
     */
    removeCommand(command, keepCommand) {
        var name = command && (typeof command === 'string' ? command : command.name);
        command = this.commands[name];
        if (!keepCommand)
            delete this.commands[name];

        // exhaustive search is brute force but since removeCommand is
        // not a performance critical operation this should be OK
        var ckb = this.commandKeyBinding;
        for (var keyId in ckb) {
            var cmdGroup = ckb[keyId];
            if (cmdGroup == command) {
                delete ckb[keyId];
            } else if (Array.isArray(cmdGroup)) {
                var i = cmdGroup.indexOf(command);
                if (i != -1) {
                    cmdGroup.splice(i, 1);
                    if (cmdGroup.length == 1)
                        ckb[keyId] = cmdGroup[0];
                }
            }
        }
    }

    /**
     * @param {string | { win?: string; mac?: string; position?:number}} key
     * @param {CommandLike | string} command
     * @param {number} [position]
     */
    bindKey(key, command, position) {
        if (typeof key == "object" && key) {
            if (position == undefined)
                position = key.position;
            key = key[this.platform];
        }
        if (!key)
            return;
        if (typeof command == "function")
            return this.addCommand({exec: command, bindKey: key, name: command.name || /**@type{string}*/(key)});
        
        /**@type{string}*/(key).split("|").forEach(function(keyPart) {
            var chain = "";
            if (keyPart.indexOf(" ") != -1) {
                var parts = keyPart.split(/\s+/);
                keyPart = parts.pop();
                parts.forEach(function(keyPart) {
                    var binding = this.parseKeys(keyPart);
                    var id = KEY_MODS[binding.hashId] + binding.key;
                    chain += (chain ? " " : "") + id;
                    this._addCommandToBinding(chain, "chainKeys");
                }, this);
                chain += " ";
            }
            var binding = this.parseKeys(keyPart);
            var id = KEY_MODS[binding.hashId] + binding.key;
            this._addCommandToBinding(chain + id, command, position);
        }, this);
    }

    /**
     * @param {string} keyId
     * @param {any} command
     * @param {number} position
     */
    _addCommandToBinding(keyId, command, position) {
        var ckb = this.commandKeyBinding, i;
        if (!command) {
            delete ckb[keyId];
        } else if (!ckb[keyId] || this.$singleCommand) {
            ckb[keyId] = command;
        } else {
            if (!Array.isArray(ckb[keyId])) {
                ckb[keyId] = [ckb[keyId]];
            } else if ((i = ckb[keyId].indexOf(command)) != -1) {
                ckb[keyId].splice(i, 1);
            }
            
            if (typeof position != "number") {
                position = getPosition(command);
            }

            var commands = ckb[keyId];
            for (i = 0; i < commands.length; i++) {
                var other = commands[i];
                var otherPos = getPosition(other);
                if (otherPos > position)
                    break;
            }
            commands.splice(i, 0, command);
        }
    }

    /**
     * @param {Record<string, CommandLike> | Command[]} [commands]
     */
    addCommands(commands) {
        commands && Object.keys(commands).forEach(function(name) {
            var command = commands[name];
            if (!command)
                return;
            
            if (typeof command === "string")
                return this.bindKey(command, name);

            if (typeof command === "function")
                command = { exec: command };

            if (typeof command !== "object")
                return;

            if (!command.name)
                command.name = name;

            this.addCommand(command);
        }, this);
    }

    /**
     * @param {Record<string, CommandLike | string>} commands
     */
    removeCommands(commands) {
        Object.keys(commands).forEach(function(name) {
            this.removeCommand(commands[name]);
        }, this);
    }

    /**
     * @param {Record<string, CommandLike | string>} keyList
     */
    bindKeys(keyList) {
        Object.keys(keyList).forEach(function(key) {
            this.bindKey(key, keyList[key]);
        }, this);
    }

    _buildKeyHash(command) {
        this.bindKey(command.bindKey, command);
    }

    /**
     * Accepts keys in the form ctrl+Enter or ctrl-Enter
     * keys without modifiers or shift only
     * @param {string} keys
     * @returns {{key: string, hashId: number} | false}
     */
    parseKeys(keys) {
        var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x){return x;});
        var key = parts.pop();

        var keyCode = keyUtil[key];
        if (keyUtil.FUNCTION_KEYS[keyCode])
            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
        else if (!parts.length)
            return {key: key, hashId: -1};
        else if (parts.length == 1 && parts[0] == "shift")
            return {key: key.toUpperCase(), hashId: -1};

        var hashId = 0;
        for (var i = parts.length; i--;) {
            var modifier = keyUtil.KEY_MODS[parts[i]];
            if (modifier == null) {
                if (typeof console != "undefined")
                    console.error("invalid modifier " + parts[i] + " in " + keys);
                return false;
            }
            hashId |= modifier;
        }
        return {key: key, hashId: hashId};
    }

    /**
     * @param {number} hashId
     * @param {string} keyString
     * @returns {Command}
     */
    findKeyCommand(hashId, keyString) {
        var key = KEY_MODS[hashId] + keyString;
        return this.commandKeyBinding[key];
    }

    /**
     * @param {any} data
     * @param {number} hashId
     * @param {string} keyString
     * @param {number} keyCode
     * @returns {{command: string} | void}
     */
    handleKeyboard(data, hashId, keyString, keyCode) {
        if (keyCode < 0) return;
        var key = KEY_MODS[hashId] + keyString;
        var command = this.commandKeyBinding[key];
        if (data.$keyChain) {
            data.$keyChain += " " + key;
            command = this.commandKeyBinding[data.$keyChain] || command;
        }
        
        if (command) {
            if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                data.$keyChain = data.$keyChain || key;
                return {command: "null"};
            }
        }
        
        if (data.$keyChain) {
            if ((!hashId || hashId == 4) && keyString.length == 1)
                data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
            else if (hashId == -1 || keyCode > 0)
                data.$keyChain = ""; // reset keyChain
        }
        return {command: command};
    }

    /**
     * @param {any} [editor]
     * @param {any} [data]
     * @returns {string}
     */
    getStatusText(editor, data) {
        return data.$keyChain || "";
    }

}

function getPosition(command) {
    return typeof command == "object" && command.bindKey
        && command.bindKey.position 
        || (command.isDefault ? -100 : 0);
}

class HashHandler extends MultiHashHandler {
    /**
     * @param {Record<string, CommandLike> | Command[]} [config]
     * @param {Platform} [platform]
     */
    constructor(config, platform) {
        super(config, platform);
        this.$singleCommand = true;
    }
}

HashHandler.call = function(thisArg, config, platform) {
    MultiHashHandler.prototype.$init.call(thisArg, config, platform, true);
};
MultiHashHandler.call = function(thisArg, config, platform) {
    MultiHashHandler.prototype.$init.call(thisArg, config, platform, false);
};

exports.HashHandler = HashHandler;
exports.MultiHashHandler = MultiHashHandler;


/***/ }),

/***/ 93857:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./document").Document} Document
 * @typedef {import("./edit_session").EditSession} EditSession
 * @typedef {import("./tokenizer").Tokenizer} Tokenizer
 */
var oop = __webpack_require__(2645);
var EventEmitter = (__webpack_require__(87366).EventEmitter);

/**
 * Tokenizes the current [[Document `Document`]] in the background, and caches the tokenized rows for future use. 
 * 
 * If a certain row is changed, everything below that row is re-tokenized.
 **/
class BackgroundTokenizer {
    
    /**
     * Creates a new `BackgroundTokenizer` object.
     * @param {Tokenizer} tokenizer The tokenizer to use
     * @param {EditSession} [session] The editor session to associate with
     **/
    constructor(tokenizer, session) {
        /**@type {false | ReturnType<typeof setTimeout>}*/
        this.running = false;
        this.lines = [];
        /**@type {string[]|string[][]}*/
        this.states = [];
        this.currentLine = 0;
        this.tokenizer = tokenizer;

        var self = this;

        this.$worker = function() {
            if (!self.running) { return; }

            var workerStart = new Date();
            var currentLine = self.currentLine;
            var endLine = -1;
            var doc = self.doc;

            var startLine = currentLine;
            while (self.lines[currentLine])
                currentLine++;

            var len = doc.getLength();
            var processedLines = 0;
            self.running = false;
            while (currentLine < len) {
                self.$tokenizeRow(currentLine);
                endLine = currentLine;
                do {
                    currentLine++;
                } while (self.lines[currentLine]);

                // only check every 5 lines
                processedLines ++;
                // @ts-ignore
                if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {
                    self.running = setTimeout(self.$worker, 20);
                    break;
                }
            }
            self.currentLine = currentLine;

            if (endLine == -1)
                endLine = currentLine;

            if (startLine <= endLine)
                self.fireUpdateEvent(startLine, endLine);
        };
    }
    
    /**
     * Sets a new tokenizer for this object.
     * @param {Tokenizer} tokenizer The new tokenizer to use
     **/
    setTokenizer(tokenizer) {
        this.tokenizer = tokenizer;
        this.lines = [];
        this.states = [];

        this.start(0);
    }

    /**
     * Sets a new document to associate with this object.
     * @param {Document} doc The new document to associate with
     **/
    setDocument(doc) {
        this.doc = doc;
        this.lines = [];
        this.states = [];

        this.stop();
    }


    /**
     * Emits the `'update'` event. `firstRow` and `lastRow` are used to define the boundaries of the region to be updated.
     * @param {Number} firstRow The starting row region
     * @param {Number} lastRow The final row region
     **/
    fireUpdateEvent(firstRow, lastRow) {
        var data = {
            first: firstRow,
            last: lastRow
        };
        this._signal("update", {data: data});
    }

    /**
     * Starts tokenizing at the row indicated.
     * @param {Number} startRow The row to start at
     **/
    start(startRow) {
        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());

        // remove all cached items below this line
        this.lines.splice(this.currentLine, this.lines.length);
        this.states.splice(this.currentLine, this.states.length);

        this.stop();
        // pretty long delay to prevent the tokenizer from interfering with the user
        this.running = setTimeout(this.$worker, 700);
    }

    /**
     * Sets pretty long delay to prevent the tokenizer from interfering with the user
     */
    scheduleStart() {
        if (!this.running)
            this.running = setTimeout(this.$worker, 700);
    }

    /**
     * @param {import("../ace-internal").Ace.Delta} delta
     */
    $updateOnChange(delta) {
        var startRow = delta.start.row;
        var len = delta.end.row - startRow;

        if (len === 0) {
            this.lines[startRow] = null;
        } else if (delta.action == "remove") {
            this.lines.splice(startRow, len + 1, null);
            this.states.splice(startRow, len + 1, null);
        } else {
            var args = Array(len + 1);
            args.unshift(startRow, 1);
            this.lines.splice.apply(this.lines, args);
            this.states.splice.apply(this.states, args);
        }

        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());

        this.stop();
    }

    /**
     * Stops tokenizing.
     **/
    stop() {
        if (this.running)
            clearTimeout(this.running);
        this.running = false;
    }

    /**
     * Gives list of [[Token]]'s of the row. (tokens are cached)
     * @param {Number} row The row to get tokens at
     * @returns {import("../ace-internal").Ace.Token[]}
     **/
    getTokens(row) {
        return this.lines[row] || this.$tokenizeRow(row);
    }

    /**
     * Returns the state of tokenization at the end of a row.
     * @param {Number} row The row to get state at
     * @returns {string | string[]}
     **/
    getState(row) {
        if (this.currentLine == row)
            this.$tokenizeRow(row);
        return this.states[row] || "start";
    }

    /**
     * @param {number} row
     */
    $tokenizeRow(row) {
        var line = this.doc.getLine(row);
        var state = this.states[row - 1];
        // @ts-expect-error TODO: potential wrong argument
        var data = this.tokenizer.getLineTokens(line, state, row);

        if (this.states[row] + "" !== data.state + "") {
            this.states[row] = data.state;
            this.lines[row + 1] = null;
            if (this.currentLine > row + 1)
                this.currentLine = row + 1;
        } else if (this.currentLine == row) {
            this.currentLine = row + 1;
        }

        return this.lines[row] = data.tokens;
    }

    cleanup() {
        this.running = false;
        this.lines = [];
        this.states = [];
        this.currentLine = 0;
        this.removeAllListeners();
    }

}

oop.implement(BackgroundTokenizer.prototype, EventEmitter);

exports.K = BackgroundTokenizer;


/***/ }),

/***/ 95862:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(19631), __webpack_require__(29451), __webpack_require__(93050), __webpack_require__(74943), __webpack_require__(51826), __webpack_require__(10776), __webpack_require__(27258), __webpack_require__(21016), __webpack_require__(91772), __webpack_require__(61893), __webpack_require__(2645), __webpack_require__(87366));
	else { var i, a; }
})(self, (__WEBPACK_EXTERNAL_MODULE__517__, __WEBPACK_EXTERNAL_MODULE__863__, __WEBPACK_EXTERNAL_MODULE__736__, __WEBPACK_EXTERNAL_MODULE__493__, __WEBPACK_EXTERNAL_MODULE__910__, __WEBPACK_EXTERNAL_MODULE__444__, __WEBPACK_EXTERNAL_MODULE__254__, __WEBPACK_EXTERNAL_MODULE__748__, __WEBPACK_EXTERNAL_MODULE__292__, __WEBPACK_EXTERNAL_MODULE__685__, __WEBPACK_EXTERNAL_MODULE__387__, __WEBPACK_EXTERNAL_MODULE__540__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 286:
/***/ ((module, __nested_webpack_exports__, __nested_webpack_require_2643__) => {

"use strict";
/* harmony export */ __nested_webpack_require_2643__.d(__nested_webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_2643__(1);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_2643__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_2643__(935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_2643__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.toggle-block {
    position: absolute;
    /*border: 1px solid black;*/
}


.toggle-bar {
    display:flex;
    background: #cecece;
    color: #111;
    align-items: stretch;
    justify-content: stretch;
    overflow: hidden;
    position: absolute;
    user-select: none;
    cursor: pointer;
}
.toggleBlockDragging {
    pointer-events: none;
    overflow-y: hidden;
}
.toggleBlockDragging  .title{
    pointer-events: none;
}

.toggle-bar .title {
    position: absolute;
    top: auto;
    left: auto;
    width: auto;
    height: auto;
}

.toggle-bar-h {
    width: 20px;
    height: 100%;
}

.toggle-bar-v {
    height: 20px;
    width: 100%;
}
.toggle-bar-h div {
    margin-left: -2px;
    width: 5px;
    height: 100%
}
.toggle-bar-v div {
    margin-top: -2px;
    height: 5px;
}`, "",{"version":3,"sources":["webpack://./assets/styles/accordion.css"],"names":[],"mappings":"AAAA;IACI,kBAAkB;IAClB,2BAA2B;AAC/B;;;AAGA;IACI,YAAY;IACZ,mBAAmB;IACnB,WAAW;IACX,oBAAoB;IACpB,wBAAwB;IACxB,gBAAgB;IAChB,kBAAkB;IAClB,iBAAiB;IACjB,eAAe;AACnB;AACA;IACI,oBAAoB;IACpB,kBAAkB;AACtB;AACA;IACI,oBAAoB;AACxB;;AAEA;IACI,kBAAkB;IAClB,SAAS;IACT,UAAU;IACV,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,YAAY;IACZ,WAAW;AACf;AACA;IACI,iBAAiB;IACjB,UAAU;IACV;AACJ;AACA;IACI,gBAAgB;IAChB,WAAW;AACf","sourcesContent":[".toggle-block {\r\n    position: absolute;\r\n    /*border: 1px solid black;*/\r\n}\r\n\r\n\r\n.toggle-bar {\r\n    display:flex;\r\n    background: #cecece;\r\n    color: #111;\r\n    align-items: stretch;\r\n    justify-content: stretch;\r\n    overflow: hidden;\r\n    position: absolute;\r\n    user-select: none;\r\n    cursor: pointer;\r\n}\r\n.toggleBlockDragging {\r\n    pointer-events: none;\r\n    overflow-y: hidden;\r\n}\r\n.toggleBlockDragging  .title{\r\n    pointer-events: none;\r\n}\r\n\r\n.toggle-bar .title {\r\n    position: absolute;\r\n    top: auto;\r\n    left: auto;\r\n    width: auto;\r\n    height: auto;\r\n}\r\n\r\n.toggle-bar-h {\r\n    width: 20px;\r\n    height: 100%;\r\n}\r\n\r\n.toggle-bar-v {\r\n    height: 20px;\r\n    width: 100%;\r\n}\r\n.toggle-bar-h div {\r\n    margin-left: -2px;\r\n    width: 5px;\r\n    height: 100%\r\n}\r\n.toggle-bar-v div {\r\n    margin-top: -2px;\r\n    height: 5px;\r\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 216:
/***/ ((module, __nested_webpack_exports__, __nested_webpack_require_6324__) => {

"use strict";
/* harmony export */ __nested_webpack_require_6324__.d(__nested_webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_6324__(1);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_6324__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_6324__(935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_6324__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.ace-tree-wrapper {
    height: 100%;
}`, "",{"version":3,"sources":["webpack://./assets/styles/ace-tree.css"],"names":[],"mappings":"AAAA;IACI,YAAY;AAChB","sourcesContent":[".ace-tree-wrapper {\r\n    height: 100%;\r\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 382:
/***/ ((module, __nested_webpack_exports__, __nested_webpack_require_7912__) => {

"use strict";
/* harmony export */ __nested_webpack_require_7912__.d(__nested_webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_7912__(1);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_7912__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_7912__(935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_7912__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.blackbutton {
    background-image: linear-gradient(to bottom, #4c4c4c 0%, #434343 52%, #333333 52%, #454545 100%);
    box-shadow: 0 1px 0 rgba(255, 255, 255, 0.125) inset, 0px 1px rgba(255, 255, 255, 0.125);
    border: 1px solid #042440;
    border-radius: 3px;
    color: #d0e3ce;
    text-shadow: 0;
    height: 27px;
    line-height: 27px;
    padding: 0 11px;
    text-align: center;
    cursor: default;
    font-weight: normal;
    -webkit-font-smoothing: antialiased;-moz-osx-font-smoothing: grayscale;
}
.blackbuttonDisabled {
    color: rgba(220, 235, 219, 0.5);
}
.blackbuttonFocus {
    box-shadow: 0 1px 0 rgba(255, 255, 255, 0.125) inset, 0px 1px rgba(255, 255, 255, 0.125), 0 0 6px 1px rgba(255, 255, 255, 0.1) inset;
}
.blackbuttonOver {
    box-shadow: 0 1px 0 rgba(255, 255, 255, 0.125) inset, 0px 1px rgba(255, 255, 255, 0.125), 0 0 0 1000px rgba(158, 169, 156, 0.08) inset;
}
.blackbuttonDown {
    box-shadow: 0 0 3px 2px #343434 inset;
}`, "",{"version":3,"sources":["webpack://./assets/styles/button.css"],"names":[],"mappings":"AAAA;IACI,gGAAgG;IAChG,wFAAwF;IACxF,yBAAyB;IACzB,kBAAkB;IAClB,cAAc;IACd,cAAc;IACd,YAAY;IACZ,iBAAiB;IACjB,eAAe;IACf,kBAAkB;IAClB,eAAe;IACf,mBAAmB;IACnB,mCAAmC,CAAC,kCAAkC;AAC1E;AACA;IACI,+BAA+B;AACnC;AACA;IACI,oIAAoI;AACxI;AACA;IACI,sIAAsI;AAC1I;AACA;IACI,qCAAqC;AACzC","sourcesContent":[".blackbutton {\r\n    background-image: linear-gradient(to bottom, #4c4c4c 0%, #434343 52%, #333333 52%, #454545 100%);\r\n    box-shadow: 0 1px 0 rgba(255, 255, 255, 0.125) inset, 0px 1px rgba(255, 255, 255, 0.125);\r\n    border: 1px solid #042440;\r\n    border-radius: 3px;\r\n    color: #d0e3ce;\r\n    text-shadow: 0;\r\n    height: 27px;\r\n    line-height: 27px;\r\n    padding: 0 11px;\r\n    text-align: center;\r\n    cursor: default;\r\n    font-weight: normal;\r\n    -webkit-font-smoothing: antialiased;-moz-osx-font-smoothing: grayscale;\r\n}\r\n.blackbuttonDisabled {\r\n    color: rgba(220, 235, 219, 0.5);\r\n}\r\n.blackbuttonFocus {\r\n    box-shadow: 0 1px 0 rgba(255, 255, 255, 0.125) inset, 0px 1px rgba(255, 255, 255, 0.125), 0 0 6px 1px rgba(255, 255, 255, 0.1) inset;\r\n}\r\n.blackbuttonOver {\r\n    box-shadow: 0 1px 0 rgba(255, 255, 255, 0.125) inset, 0px 1px rgba(255, 255, 255, 0.125), 0 0 0 1000px rgba(158, 169, 156, 0.08) inset;\r\n}\r\n.blackbuttonDown {\r\n    box-shadow: 0 0 3px 2px #343434 inset;\r\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 593:
/***/ ((module, __nested_webpack_exports__, __nested_webpack_require_11687__) => {

"use strict";
/* harmony export */ __nested_webpack_require_11687__.d(__nested_webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_11687__(1);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_11687__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_11687__(935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_11687__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_11687__(62);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_11687__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __nested_webpack_require_11687__(952), __nested_webpack_require_11687__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.black_dropdown {
    display: inline-block;
    position: relative;
    overflow: hidden;
    height: 21px;
    border-radius: 3px;
    border: 1px solid #1c1c1c;
    background: #383838 linear-gradient(0deg, #323232 0%, #383838 100%);
    box-shadow: 0px 1px 0px rgba(255, 255, 255, 0.15) inset, 0px 1px 0px 0px rgba(255, 255, 255, 0.1);
    text-shadow: none;
    min-height: 19px !important;
    max-height: 19px !important;
}
.black_dropdown .lbl {
    position: relative;
    overflow: hidden;
    height: 17px;
    padding: 4px 0 0 6px;
    margin: 0 19px 0 0;
    font-family: Arial, Helvetica, sans-serif;
    font-size: 12px;
    color: #c0dabe;
    line-height: 13px;
    border-right: 1px solid #1c1c1c;
    cursor: default;
    white-space: nowrap;
}
.black_dropdown .button {
    width: 19px;
    border-left: 1px solid #4d4c4d;
    bottom: 0;
    position: absolute;
    top: 0;
    right: 0;
    background-repeat: no-repeat;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_0___});
    background-size: 9px 13px;
    background-position: 4px 4px;
}
.black_dropdownOver {
    background-image: linear-gradient(0deg, #2f2f2f 0%, #3f3f3f 100%);
}
.black_dropdownDown {
    background: #2d2d2d linear-gradient(0deg, #2d2d2d 0%, #363636 100%);
}`, "",{"version":3,"sources":["webpack://./assets/styles/dropdown.css"],"names":[],"mappings":"AAAA;IACI,qBAAqB;IACrB,kBAAkB;IAClB,gBAAgB;IAChB,YAAY;IACZ,kBAAkB;IAClB,yBAAyB;IACzB,mEAAmE;IACnE,iGAAiG;IACjG,iBAAiB;IACjB,2BAA2B;IAC3B,2BAA2B;AAC/B;AACA;IACI,kBAAkB;IAClB,gBAAgB;IAChB,YAAY;IACZ,oBAAoB;IACpB,kBAAkB;IAClB,yCAAyC;IACzC,eAAe;IACf,cAAc;IACd,iBAAiB;IACjB,+BAA+B;IAC/B,eAAe;IACf,mBAAmB;AACvB;AACA;IACI,WAAW;IACX,8BAA8B;IAC9B,SAAS;IACT,kBAAkB;IAClB,MAAM;IACN,QAAQ;IACR,4BAA4B;IAC5B,yDAAmE;IACnE,yBAAyB;IACzB,4BAA4B;AAChC;AACA;IACI,iEAAiE;AACrE;AACA;IACI,mEAAmE;AACvE","sourcesContent":[".black_dropdown {\r\n    display: inline-block;\r\n    position: relative;\r\n    overflow: hidden;\r\n    height: 21px;\r\n    border-radius: 3px;\r\n    border: 1px solid #1c1c1c;\r\n    background: #383838 linear-gradient(0deg, #323232 0%, #383838 100%);\r\n    box-shadow: 0px 1px 0px rgba(255, 255, 255, 0.15) inset, 0px 1px 0px 0px rgba(255, 255, 255, 0.1);\r\n    text-shadow: none;\r\n    min-height: 19px !important;\r\n    max-height: 19px !important;\r\n}\r\n.black_dropdown .lbl {\r\n    position: relative;\r\n    overflow: hidden;\r\n    height: 17px;\r\n    padding: 4px 0 0 6px;\r\n    margin: 0 19px 0 0;\r\n    font-family: Arial, Helvetica, sans-serif;\r\n    font-size: 12px;\r\n    color: #c0dabe;\r\n    line-height: 13px;\r\n    border-right: 1px solid #1c1c1c;\r\n    cursor: default;\r\n    white-space: nowrap;\r\n}\r\n.black_dropdown .button {\r\n    width: 19px;\r\n    border-left: 1px solid #4d4c4d;\r\n    bottom: 0;\r\n    position: absolute;\r\n    top: 0;\r\n    right: 0;\r\n    background-repeat: no-repeat;\r\n    background-image: url(../images/dropdown-dark-glossy/button@1x.png);\r\n    background-size: 9px 13px;\r\n    background-position: 4px 4px;\r\n}\r\n.black_dropdownOver {\r\n    background-image: linear-gradient(0deg, #2f2f2f 0%, #3f3f3f 100%);\r\n}\r\n.black_dropdownDown {\r\n    background: #2d2d2d linear-gradient(0deg, #2d2d2d 0%, #363636 100%);\r\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 0:
/***/ ((module, __nested_webpack_exports__, __nested_webpack_require_16988__) => {

"use strict";
/* harmony export */ __nested_webpack_require_16988__.d(__nested_webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_16988__(1);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_16988__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_16988__(935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_16988__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `body {
    font-family: Tahoma, sans-serif;
}

body.disableIframe iframe {pointer-events: none;}

.splitter {
    background: var(--splitter-color);
    z-index:10;
    position: absolute;
}

.splitter-h {
    width: 1px;
    cursor: ew-resize;
}

.splitter-v {
    height: 1px;
    cursor: ns-resize;
    box-shadow: 1px 1px 0px rgba(143, 143, 143, 0.14);
}
.splitter-h div {
    margin-left: -2px;
    width: 5px;
    height: 100%
}
.splitter-v div {
    margin-top: -2px;
    height: 5px;
}
.splitter-h:hover {

}
.splitter-v:hover {

}
.splitter:hover {

}
.box {
    overflow: hidden;
}

.menuToolBar {
    display: flex;
    height: 30px;
    background: #787878;
    color: #111;
    align-items: stretch;
    justify-content: stretch;
    overflow: hidden;
    position: absolute;
}

.findbar {
    display:flex;
    height:30px;
    background: #665a82;
    background: #cecece;
    color: #111;
    align-items: stretch;
    justify-content: stretch;
    overflow: hidden;
    position: absolute;
}


.fullScreenParent {overflow: visible}
.fullScreenNode {
    position: fixed!important;
    z-index: 1!important;
}
.fullScreenSibling {
    z-index: 0!important;
}


body {
    overflow: hidden!important;
    width: 100%;
    height: 100%;
}

.consoleCloseBtn {
    background-repeat: no-repeat;
    background-size: 22px 66px;
    cursor: pointer;
    padding-right: 5px;
}

div.consoleCloseBtn:hover {
    color: #35cc95;
}

.buttons {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    z-index: 1000;
    padding: 0px;
    position: absolute;
    right: 3px;
    top: 0px;
    height: 24px;
}

.animateBoxes {
    transition-duration: 0.15s;
    transition-property: top, left, width, height, transform;
    transition-timing-function: cubic-bezier(.10, .10, .25, .90);
}


.animateBoxes * {
    transition-duration: inherit;
    transition-property: top, left, width, height, transform;
    transition-timing-function: inherit;
}


.tabPanel {
    background: whitesmoke;
}

.inheritCursor *{
    cursor: inherit;
}

.panelbar {
    background-color: var(--toolbar-background);
    position: absolute;
    box-sizing: border-box;
}
.panelbar.top, .tabbar {
    border-bottom: 1px solid var(--splitter-color);
    box-sizing: border-box;
}
.panelbar.bottom {
    border-top: 1px solid var(--splitter-color);
}

body {
    --toolbar-background: #f3f3f3;
    --splitter-color: #d0d0d0;
    --hover-background: #eaeaea;
}

.spacer {
    flex: 1
}
.panelbar {
    display: flex;
    align-items: center;
    padding: 4px;
}
.panelbar>* {
    margin: 0 4px
}
.panelbar> button {
    padding: 5px;
}
.panelbar> button, .panelbar> input  {
    border: none;
    color: #333
}
.panelbar> *:active,
.panelbar> *:focus {
    outline: 1px solid lightblue;
    outline-offset: 1px
}
.panelbar> button {
    background: transparent;
    color: #0da6ff;
}
.panelbar> button:hover  {
    background: var(--hover-background);
    color: black
}
.panelbar> button[disabled] {
    pointer-events: none;
    color: gray!important;
}

.ace_editor.ace_listBox {
    background: var(--toolbar-background)!important;
    font-family: inherit;
    border: none;
}


.ace_listBox .ace_ {
    margin-left: 1em;
}
.ace_listBox .ace_header {
    font-weight: bold;
    margin-left: 0;
}

iframe {
    margin: 0;
    padding: 0;
    border: 0;
    font-size: 100%;
    font: inherit;
    vertical-align: baseline;
}`, "",{"version":3,"sources":["webpack://./assets/styles/layout.css"],"names":[],"mappings":"AAAA;IACI,+BAA+B;AACnC;;AAEA,2BAA2B,oBAAoB,CAAC;;AAEhD;IACI,iCAAiC;IACjC,UAAU;IACV,kBAAkB;AACtB;;AAEA;IACI,UAAU;IACV,iBAAiB;AACrB;;AAEA;IACI,WAAW;IACX,iBAAiB;IACjB,iDAAiD;AACrD;AACA;IACI,iBAAiB;IACjB,UAAU;IACV;AACJ;AACA;IACI,gBAAgB;IAChB,WAAW;AACf;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;IACI,gBAAgB;AACpB;;AAEA;IACI,aAAa;IACb,YAAY;IACZ,mBAAmB;IACnB,WAAW;IACX,oBAAoB;IACpB,wBAAwB;IACxB,gBAAgB;IAChB,kBAAkB;AACtB;;AAEA;IACI,YAAY;IACZ,WAAW;IACX,mBAAmB;IACnB,mBAAmB;IACnB,WAAW;IACX,oBAAoB;IACpB,wBAAwB;IACxB,gBAAgB;IAChB,kBAAkB;AACtB;;;AAGA,mBAAmB,iBAAiB;AACpC;IACI,yBAAyB;IACzB,oBAAoB;AACxB;AACA;IACI,oBAAoB;AACxB;;;AAGA;IACI,0BAA0B;IAC1B,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,4BAA4B;IAC5B,0BAA0B;IAC1B,eAAe;IACf,kBAAkB;AACtB;;AAEA;IACI,cAAc;AAClB;;AAEA;IACI,aAAa;IACb,mBAAmB;IACnB,yBAAyB;IACzB,aAAa;IACb,YAAY;IACZ,kBAAkB;IAClB,UAAU;IACV,QAAQ;IACR,YAAY;AAChB;;AAEA;IACI,0BAA0B;IAC1B,wDAAwD;IACxD,4DAA4D;AAChE;;;AAGA;IACI,4BAA4B;IAC5B,wDAAwD;IACxD,mCAAmC;AACvC;;;AAGA;IACI,sBAAsB;AAC1B;;AAEA;IACI,eAAe;AACnB;;AAEA;IACI,2CAA2C;IAC3C,kBAAkB;IAClB,sBAAsB;AAC1B;AACA;IACI,8CAA8C;IAC9C,sBAAsB;AAC1B;AACA;IACI,2CAA2C;AAC/C;;AAEA;IACI,6BAA6B;IAC7B,yBAAyB;IACzB,2BAA2B;AAC/B;;AAEA;IACI;AACJ;AACA;IACI,aAAa;IACb,mBAAmB;IACnB,YAAY;AAChB;AACA;IACI;AACJ;AACA;IACI,YAAY;AAChB;AACA;IACI,YAAY;IACZ;AACJ;AACA;;IAEI,4BAA4B;IAC5B;AACJ;AACA;IACI,uBAAuB;IACvB,cAAc;AAClB;AACA;IACI,mCAAmC;IACnC;AACJ;AACA;IACI,oBAAoB;IACpB,qBAAqB;AACzB;;AAEA;IACI,+CAA+C;IAC/C,oBAAoB;IACpB,YAAY;AAChB;;;AAGA;IACI,gBAAgB;AACpB;AACA;IACI,iBAAiB;IACjB,cAAc;AAClB;;AAEA;IACI,SAAS;IACT,UAAU;IACV,SAAS;IACT,eAAe;IACf,aAAa;IACb,wBAAwB;AAC5B","sourcesContent":["body {\r\n    font-family: Tahoma, sans-serif;\r\n}\r\n\r\nbody.disableIframe iframe {pointer-events: none;}\r\n\r\n.splitter {\r\n    background: var(--splitter-color);\r\n    z-index:10;\r\n    position: absolute;\r\n}\r\n\r\n.splitter-h {\r\n    width: 1px;\r\n    cursor: ew-resize;\r\n}\r\n\r\n.splitter-v {\r\n    height: 1px;\r\n    cursor: ns-resize;\r\n    box-shadow: 1px 1px 0px rgba(143, 143, 143, 0.14);\r\n}\r\n.splitter-h div {\r\n    margin-left: -2px;\r\n    width: 5px;\r\n    height: 100%\r\n}\r\n.splitter-v div {\r\n    margin-top: -2px;\r\n    height: 5px;\r\n}\r\n.splitter-h:hover {\r\n\r\n}\r\n.splitter-v:hover {\r\n\r\n}\r\n.splitter:hover {\r\n\r\n}\r\n.box {\r\n    overflow: hidden;\r\n}\r\n\r\n.menuToolBar {\r\n    display: flex;\r\n    height: 30px;\r\n    background: #787878;\r\n    color: #111;\r\n    align-items: stretch;\r\n    justify-content: stretch;\r\n    overflow: hidden;\r\n    position: absolute;\r\n}\r\n\r\n.findbar {\r\n    display:flex;\r\n    height:30px;\r\n    background: #665a82;\r\n    background: #cecece;\r\n    color: #111;\r\n    align-items: stretch;\r\n    justify-content: stretch;\r\n    overflow: hidden;\r\n    position: absolute;\r\n}\r\n\r\n\r\n.fullScreenParent {overflow: visible}\r\n.fullScreenNode {\r\n    position: fixed!important;\r\n    z-index: 1!important;\r\n}\r\n.fullScreenSibling {\r\n    z-index: 0!important;\r\n}\r\n\r\n\r\nbody {\r\n    overflow: hidden!important;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\n.consoleCloseBtn {\r\n    background-repeat: no-repeat;\r\n    background-size: 22px 66px;\r\n    cursor: pointer;\r\n    padding-right: 5px;\r\n}\r\n\r\ndiv.consoleCloseBtn:hover {\r\n    color: #35cc95;\r\n}\r\n\r\n.buttons {\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: flex-end;\r\n    z-index: 1000;\r\n    padding: 0px;\r\n    position: absolute;\r\n    right: 3px;\r\n    top: 0px;\r\n    height: 24px;\r\n}\r\n\r\n.animateBoxes {\r\n    transition-duration: 0.15s;\r\n    transition-property: top, left, width, height, transform;\r\n    transition-timing-function: cubic-bezier(.10, .10, .25, .90);\r\n}\r\n\r\n\r\n.animateBoxes * {\r\n    transition-duration: inherit;\r\n    transition-property: top, left, width, height, transform;\r\n    transition-timing-function: inherit;\r\n}\r\n\r\n\r\n.tabPanel {\r\n    background: whitesmoke;\r\n}\r\n\r\n.inheritCursor *{\r\n    cursor: inherit;\r\n}\r\n\r\n.panelbar {\r\n    background-color: var(--toolbar-background);\r\n    position: absolute;\r\n    box-sizing: border-box;\r\n}\r\n.panelbar.top, .tabbar {\r\n    border-bottom: 1px solid var(--splitter-color);\r\n    box-sizing: border-box;\r\n}\r\n.panelbar.bottom {\r\n    border-top: 1px solid var(--splitter-color);\r\n}\r\n\r\nbody {\r\n    --toolbar-background: #f3f3f3;\r\n    --splitter-color: #d0d0d0;\r\n    --hover-background: #eaeaea;\r\n}\r\n\r\n.spacer {\r\n    flex: 1\r\n}\r\n.panelbar {\r\n    display: flex;\r\n    align-items: center;\r\n    padding: 4px;\r\n}\r\n.panelbar>* {\r\n    margin: 0 4px\r\n}\r\n.panelbar> button {\r\n    padding: 5px;\r\n}\r\n.panelbar> button, .panelbar> input  {\r\n    border: none;\r\n    color: #333\r\n}\r\n.panelbar> *:active,\r\n.panelbar> *:focus {\r\n    outline: 1px solid lightblue;\r\n    outline-offset: 1px\r\n}\r\n.panelbar> button {\r\n    background: transparent;\r\n    color: #0da6ff;\r\n}\r\n.panelbar> button:hover  {\r\n    background: var(--hover-background);\r\n    color: black\r\n}\r\n.panelbar> button[disabled] {\r\n    pointer-events: none;\r\n    color: gray!important;\r\n}\r\n\r\n.ace_editor.ace_listBox {\r\n    background: var(--toolbar-background)!important;\r\n    font-family: inherit;\r\n    border: none;\r\n}\r\n\r\n\r\n.ace_listBox .ace_ {\r\n    margin-left: 1em;\r\n}\r\n.ace_listBox .ace_header {\r\n    font-weight: bold;\r\n    margin-left: 0;\r\n}\r\n\r\niframe {\r\n    margin: 0;\r\n    padding: 0;\r\n    border: 0;\r\n    font-size: 100%;\r\n    font: inherit;\r\n    vertical-align: baseline;\r\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 807:
/***/ ((module, __nested_webpack_exports__, __nested_webpack_require_27732__) => {

"use strict";
/* harmony export */ __nested_webpack_require_27732__.d(__nested_webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_27732__(1);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_27732__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_27732__(935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_27732__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_27732__(62);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_27732__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __nested_webpack_require_27732__(784), __nested_webpack_require_27732__.b);
var ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __nested_webpack_require_27732__(560), __nested_webpack_require_27732__.b);
var ___CSS_LOADER_URL_IMPORT_2___ = new URL(/* asset import */ __nested_webpack_require_27732__(937), __nested_webpack_require_27732__.b);
var ___CSS_LOADER_URL_IMPORT_3___ = new URL(/* asset import */ __nested_webpack_require_27732__(147), __nested_webpack_require_27732__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
var ___CSS_LOADER_URL_REPLACEMENT_2___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_2___);
var ___CSS_LOADER_URL_REPLACEMENT_3___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_3___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.menuButton {
    height: 100%;
    box-sizing: border-box;
    overflow: visible;
    cursor: default;
    position: relative;
    display: inline-block;
    font-family: Tahoma, Arial;
    font-size: 12px;
    line-height: 14px;
    color: #cecece;
    padding: 4px 7px 0 7px;
    text-shadow: #292a2b 0px 1px 0px;
    -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
}
.menuButtonOver, .menuButton:hover {
    background-color: #333333;
    box-shadow: 1px -1px 0 0 #000000, -1px 0 0 0 #000000, 0 1px 0 0 rgba(255, 255, 255, 0.15) inset;
    color: #d4d4d4;
}
.menuButton.menuButtonDown {
    font-weight: normal;
    background-color: #494949;
    box-shadow: 1px 0 0 0 #000000 inset, 1px 0 0 0 #000000, 0 1px 0 0 rgba(255, 255, 255, 0.15) inset;
    border: 0;
    border-width: 0;
    padding: 4px 7px 0 7px;
    z-index: 100000000;
}
.menuButtonDisabled.menuButton .label {
    color: #999999;
}
.menuButtonIcon {
    padding-left: 24px;
}
.menuButtonIcon .icon {
    display: block;
}
.menuButtonEmpty {
    padding-left: 7px;
}
.menuButtonEmpty .icon {
    left: 0;
    top: 0;
}
.menuButtonDisabled {
    color: gray;
}
.menuButton.btn {
    min-width: 12px;
    font-weight: bold;
    background-position: 2px 50%;
}


.menu {
    margin: -1px 0 0 0;
    padding: 3px 0 3px 0;
    z-index: 10000;
    position: absolute;
    overflow: visible;
    font-family: Tahoma, Arial;
    font-size: 11px;
    line-height: 14px;
    color: #f1f1f1;
    cursor: default;
    display: none;
    border: 1px solid #00040a;
    box-shadow: 0px 3px 15px 0px rgba(0, 0, 0, 0.65);
    background-color: #494949;
    text-shadow: 0px 1px 0px #2c2c2c;
    border-radius: 0;
}
.menu > div.menu_item {
    padding: 3px 16px 5px 23px;
    white-space: nowrap;
    cursor: default;
    z-index: 1100000;
    height: 13px;
}
.menu > div.menu_item.update {
    background-color: #748512;
    font-weight: bold;
    color: #f1f1f1;
    text-shadow: none;
}
.menu > div.menu_item.hover {
    background-color: #262626;
    color: #a0b42a;
}
.menu > div.menu_divider {
    overflow: visible;
    padding: 0;
    font-size: 1px;
    margin: 2px 3px;
    border-top: 1px solid #353535;
    border-bottom: 1px solid #565656;
    height: 0;
}
.menu > div.menu_item > .shortcut {
    right: 15px;
    margin-top: 0px;
    z-index: 10;
    text-align: right;
    padding-left: 15px;
    float: right;
}
.menu > div.submenu > .shortcut {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_0___}) no-repeat right -15px;
    width: 4px;
    height: 7px;
    display: block;
    position: absolute;
    right: 8px;
    margin: 4px 0 0 0;
    z-index: 10;
}
.menu > div.submenu.hover > span {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_0___}) no-repeat right -15px;
}
.menu > div.menu_item.disabled {
    color: #808080;
    text-shadow: none;
    -webkit-font-smoothing: antialiased;-moz-osx-font-smoothing: grayscale;
}
.menu > div.menu_item > u {
    width: 16px;
    height: 16px;
    position: absolute;
    left: 3px;
    margin-top: -1px;
}
.menu > div.menu_item > a {
    float: left;
}
.menu > div.menu_item.selected > u {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_1___}) no-repeat 0 -16px;
}
.menu > div.menu_item.selected:hover > u {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_1___}) no-repeat 0 -16px;
}
.menu > div.menu_item.checked > u {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_2___}) no-repeat 0 -16px;
}
.menu > div.menu_item.checked:hover > u {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_2___}) no-repeat 0 -16px;
}
.menu > div.menu_item.disabled > u {
    opacity: 0.2;
}
.menu > div.menu_item.checked.disabled > u {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_2___}) no-repeat 0 -16px;
}
.menu > div.menu_item.selected.disabled > u {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_1___}) no-repeat 0 -16px;
}

.menu_searchbox {
    height: auto;
    width: auto;
    border: 1px solid #be1100;
    background-color: #653b13;
    color: white;
    position: absolute;
    font-family: Tahoma, Arial;
    font-size: 12px;
}

.menu-completion-highlight {
    color: #2d69c7;
}
.searchbtn_close {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_3___}) no-repeat 50% 0;
    border-radius: 50%;
    border: 0 none;
    color: #656565;
    cursor: pointer;
    font: 16px/16px Arial;
    padding: 0;
    height: 14px;
    width: 14px; 
    display: inline-block;
}
.searchbtn_close:hover {
    background-color: #656565;
    background-position: 50% 100%;
    color: white;
}

.searchbtn_filter {
    background: url(${___CSS_LOADER_URL_REPLACEMENT_2___}) no-repeat 50% 0;
    border-radius: 50%;
    border: 0 none;
    color: #656565;
    cursor: pointer;
    font: 16px/16px Arial;
    padding: 0;
    height: 14px;
    width: 14px; 
    display: inline-block;
}

.searchbtn_filter:hover {
    background-color: #656565;
    background-position: 50% 100%;
    color: white;
}

.menu_no_result {
    padding: 3px 10px 5px 20px;
    white-space: nowrap;
    cursor: default;
    z-index: 1100000;
    height: 13px;
}`, "",{"version":3,"sources":["webpack://./assets/styles/menu.css"],"names":[],"mappings":"AAAA;IACI,YAAY;IACZ,sBAAsB;IACtB,iBAAiB;IACjB,eAAe;IACf,kBAAkB;IAClB,qBAAqB;IACrB,0BAA0B;IAC1B,eAAe;IACf,iBAAiB;IACjB,cAAc;IACd,sBAAsB;IACtB,gCAAgC;IAChC,yBAAyB,EAAE,sBAAsB,EAAE,qBAAqB,EAAE,iBAAiB;AAC/F;AACA;IACI,yBAAyB;IACzB,+FAA+F;IAC/F,cAAc;AAClB;AACA;IACI,mBAAmB;IACnB,yBAAyB;IACzB,iGAAiG;IACjG,SAAS;IACT,eAAe;IACf,sBAAsB;IACtB,kBAAkB;AACtB;AACA;IACI,cAAc;AAClB;AACA;IACI,kBAAkB;AACtB;AACA;IACI,cAAc;AAClB;AACA;IACI,iBAAiB;AACrB;AACA;IACI,OAAO;IACP,MAAM;AACV;AACA;IACI,WAAW;AACf;AACA;IACI,eAAe;IACf,iBAAiB;IACjB,4BAA4B;AAChC;;;AAGA;IACI,kBAAkB;IAClB,oBAAoB;IACpB,cAAc;IACd,kBAAkB;IAClB,iBAAiB;IACjB,0BAA0B;IAC1B,eAAe;IACf,iBAAiB;IACjB,cAAc;IACd,eAAe;IACf,aAAa;IACb,yBAAyB;IACzB,gDAAgD;IAChD,yBAAyB;IACzB,gCAAgC;IAChC,gBAAgB;AACpB;AACA;IACI,0BAA0B;IAC1B,mBAAmB;IACnB,eAAe;IACf,gBAAgB;IAChB,YAAY;AAChB;AACA;IACI,yBAAyB;IACzB,iBAAiB;IACjB,cAAc;IACd,iBAAiB;AACrB;AACA;IACI,yBAAyB;IACzB,cAAc;AAClB;AACA;IACI,iBAAiB;IACjB,UAAU;IACV,cAAc;IACd,eAAe;IACf,6BAA6B;IAC7B,gCAAgC;IAChC,SAAS;AACb;AACA;IACI,WAAW;IACX,eAAe;IACf,WAAW;IACX,iBAAiB;IACjB,kBAAkB;IAClB,YAAY;AAChB;AACA;IACI,yEAAoE;IACpE,UAAU;IACV,WAAW;IACX,cAAc;IACd,kBAAkB;IAClB,UAAU;IACV,iBAAiB;IACjB,WAAW;AACf;AACA;IACI,yEAAoE;AACxE;AACA;IACI,cAAc;IACd,iBAAiB;IACjB,mCAAmC,CAAC,kCAAkC;AAC1E;AACA;IACI,WAAW;IACX,YAAY;IACZ,kBAAkB;IAClB,SAAS;IACT,gBAAgB;AACpB;AACA;IACI,WAAW;AACf;AACA;IACI,qEAAwD;AAC5D;AACA;IACI,qEAAwD;AAC5D;AACA;IACI,qEAAwD;AAC5D;AACA;IACI,qEAAwD;AAC5D;AACA;IACI,YAAY;AAChB;AACA;IACI,qEAAwD;AAC5D;AACA;IACI,qEAAwD;AAC5D;;AAEA;IACI,YAAY;IACZ,WAAW;IACX,yBAAyB;IACzB,yBAAyB;IACzB,YAAY;IACZ,kBAAkB;IAClB,0BAA0B;IAC1B,eAAe;AACnB;;AAEA;IACI,cAAc;AAClB;AACA;IACI,mEAA+Q;IAC/Q,kBAAkB;IAClB,cAAc;IACd,cAAc;IACd,eAAe;IACf,qBAAqB;IACrB,UAAU;IACV,YAAY;IACZ,WAAW;IACX,qBAAqB;AACzB;AACA;IACI,yBAAyB;IACzB,6BAA6B;IAC7B,YAAY;AAChB;;AAEA;IACI,mEAAsD;IACtD,kBAAkB;IAClB,cAAc;IACd,cAAc;IACd,eAAe;IACf,qBAAqB;IACrB,UAAU;IACV,YAAY;IACZ,WAAW;IACX,qBAAqB;AACzB;;AAEA;IACI,yBAAyB;IACzB,6BAA6B;IAC7B,YAAY;AAChB;;AAEA;IACI,0BAA0B;IAC1B,mBAAmB;IACnB,eAAe;IACf,gBAAgB;IAChB,YAAY;AAChB","sourcesContent":[".menuButton {\r\n    height: 100%;\r\n    box-sizing: border-box;\r\n    overflow: visible;\r\n    cursor: default;\r\n    position: relative;\r\n    display: inline-block;\r\n    font-family: Tahoma, Arial;\r\n    font-size: 12px;\r\n    line-height: 14px;\r\n    color: #cecece;\r\n    padding: 4px 7px 0 7px;\r\n    text-shadow: #292a2b 0px 1px 0px;\r\n    -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;\r\n}\r\n.menuButtonOver, .menuButton:hover {\r\n    background-color: #333333;\r\n    box-shadow: 1px -1px 0 0 #000000, -1px 0 0 0 #000000, 0 1px 0 0 rgba(255, 255, 255, 0.15) inset;\r\n    color: #d4d4d4;\r\n}\r\n.menuButton.menuButtonDown {\r\n    font-weight: normal;\r\n    background-color: #494949;\r\n    box-shadow: 1px 0 0 0 #000000 inset, 1px 0 0 0 #000000, 0 1px 0 0 rgba(255, 255, 255, 0.15) inset;\r\n    border: 0;\r\n    border-width: 0;\r\n    padding: 4px 7px 0 7px;\r\n    z-index: 100000000;\r\n}\r\n.menuButtonDisabled.menuButton .label {\r\n    color: #999999;\r\n}\r\n.menuButtonIcon {\r\n    padding-left: 24px;\r\n}\r\n.menuButtonIcon .icon {\r\n    display: block;\r\n}\r\n.menuButtonEmpty {\r\n    padding-left: 7px;\r\n}\r\n.menuButtonEmpty .icon {\r\n    left: 0;\r\n    top: 0;\r\n}\r\n.menuButtonDisabled {\r\n    color: gray;\r\n}\r\n.menuButton.btn {\r\n    min-width: 12px;\r\n    font-weight: bold;\r\n    background-position: 2px 50%;\r\n}\r\n\r\n\r\n.menu {\r\n    margin: -1px 0 0 0;\r\n    padding: 3px 0 3px 0;\r\n    z-index: 10000;\r\n    position: absolute;\r\n    overflow: visible;\r\n    font-family: Tahoma, Arial;\r\n    font-size: 11px;\r\n    line-height: 14px;\r\n    color: #f1f1f1;\r\n    cursor: default;\r\n    display: none;\r\n    border: 1px solid #00040a;\r\n    box-shadow: 0px 3px 15px 0px rgba(0, 0, 0, 0.65);\r\n    background-color: #494949;\r\n    text-shadow: 0px 1px 0px #2c2c2c;\r\n    border-radius: 0;\r\n}\r\n.menu > div.menu_item {\r\n    padding: 3px 16px 5px 23px;\r\n    white-space: nowrap;\r\n    cursor: default;\r\n    z-index: 1100000;\r\n    height: 13px;\r\n}\r\n.menu > div.menu_item.update {\r\n    background-color: #748512;\r\n    font-weight: bold;\r\n    color: #f1f1f1;\r\n    text-shadow: none;\r\n}\r\n.menu > div.menu_item.hover {\r\n    background-color: #262626;\r\n    color: #a0b42a;\r\n}\r\n.menu > div.menu_divider {\r\n    overflow: visible;\r\n    padding: 0;\r\n    font-size: 1px;\r\n    margin: 2px 3px;\r\n    border-top: 1px solid #353535;\r\n    border-bottom: 1px solid #565656;\r\n    height: 0;\r\n}\r\n.menu > div.menu_item > .shortcut {\r\n    right: 15px;\r\n    margin-top: 0px;\r\n    z-index: 10;\r\n    text-align: right;\r\n    padding-left: 15px;\r\n    float: right;\r\n}\r\n.menu > div.submenu > .shortcut {\r\n    background: url(\"../images/submenu_arrow.gif\") no-repeat right -15px;\r\n    width: 4px;\r\n    height: 7px;\r\n    display: block;\r\n    position: absolute;\r\n    right: 8px;\r\n    margin: 4px 0 0 0;\r\n    z-index: 10;\r\n}\r\n.menu > div.submenu.hover > span {\r\n    background: url(\"../images/submenu_arrow.gif\") no-repeat right -15px;\r\n}\r\n.menu > div.menu_item.disabled {\r\n    color: #808080;\r\n    text-shadow: none;\r\n    -webkit-font-smoothing: antialiased;-moz-osx-font-smoothing: grayscale;\r\n}\r\n.menu > div.menu_item > u {\r\n    width: 16px;\r\n    height: 16px;\r\n    position: absolute;\r\n    left: 3px;\r\n    margin-top: -1px;\r\n}\r\n.menu > div.menu_item > a {\r\n    float: left;\r\n}\r\n.menu > div.menu_item.selected > u {\r\n    background: url(\"../images/radio.gif\") no-repeat 0 -16px;\r\n}\r\n.menu > div.menu_item.selected:hover > u {\r\n    background: url(\"../images/radio.gif\") no-repeat 0 -16px;\r\n}\r\n.menu > div.menu_item.checked > u {\r\n    background: url(\"../images/check.gif\") no-repeat 0 -16px;\r\n}\r\n.menu > div.menu_item.checked:hover > u {\r\n    background: url(\"../images/check.gif\") no-repeat 0 -16px;\r\n}\r\n.menu > div.menu_item.disabled > u {\r\n    opacity: 0.2;\r\n}\r\n.menu > div.menu_item.checked.disabled > u {\r\n    background: url(\"../images/check.gif\") no-repeat 0 -16px;\r\n}\r\n.menu > div.menu_item.selected.disabled > u {\r\n    background: url(\"../images/radio.gif\") no-repeat 0 -16px;\r\n}\r\n\r\n.menu_searchbox {\r\n    height: auto;\r\n    width: auto;\r\n    border: 1px solid #be1100;\r\n    background-color: #653b13;\r\n    color: white;\r\n    position: absolute;\r\n    font-family: Tahoma, Arial;\r\n    font-size: 12px;\r\n}\r\n\r\n.menu-completion-highlight {\r\n    color: #2d69c7;\r\n}\r\n.searchbtn_close {\r\n    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAcCAYAAABRVo5BAAAAZ0lEQVR42u2SUQrAMAhDvazn8OjZBilCkYVVxiis8H4CT0VrAJb4WHT3C5xU2a2IQZXJjiQIRMdkEoJ5Q2yMqpfDIo+XY4k6h+YXOyKqTIj5REaxloNAd0xiKmAtsTHqW8sR2W5f7gCu5nWFUpVjZwAAAABJRU5ErkJggg==) no-repeat 50% 0;\r\n    border-radius: 50%;\r\n    border: 0 none;\r\n    color: #656565;\r\n    cursor: pointer;\r\n    font: 16px/16px Arial;\r\n    padding: 0;\r\n    height: 14px;\r\n    width: 14px; \r\n    display: inline-block;\r\n}\r\n.searchbtn_close:hover {\r\n    background-color: #656565;\r\n    background-position: 50% 100%;\r\n    color: white;\r\n}\r\n\r\n.searchbtn_filter {\r\n    background: url(\"../images/check.gif\") no-repeat 50% 0;\r\n    border-radius: 50%;\r\n    border: 0 none;\r\n    color: #656565;\r\n    cursor: pointer;\r\n    font: 16px/16px Arial;\r\n    padding: 0;\r\n    height: 14px;\r\n    width: 14px; \r\n    display: inline-block;\r\n}\r\n\r\n.searchbtn_filter:hover {\r\n    background-color: #656565;\r\n    background-position: 50% 100%;\r\n    color: white;\r\n}\r\n\r\n.menu_no_result {\r\n    padding: 3px 10px 5px 20px;\r\n    white-space: nowrap;\r\n    cursor: default;\r\n    z-index: 1100000;\r\n    height: 13px;\r\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 174:
/***/ ((module, __nested_webpack_exports__, __nested_webpack_require_43855__) => {

"use strict";
/* harmony export */ __nested_webpack_require_43855__.d(__nested_webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_43855__(1);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_43855__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_43855__(935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_43855__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.panelbar {
    display:flex;
    height:30px;
    background: #665a82;
    background: #cecece;
    color: #111;
    align-items: stretch;
    justify-content: stretch;
    overflow: hidden;
    position: absolute;
}
.panelbar.vertical {
}

.panelbar.vertical .panelButton {
}
.panelbar.vertical.right .panelButton {
}

.panelButton {
    cursor: default;
    display:flex;
    align-items: center;
    padding: 0 10px;
    box-sizing: border-box;
    transition: 0.5s background-color;
    border-left: #b3b3b3 solid 1px;
    user-select: none;
    height: 30px;
    width: 30px;
    position: absolute;
}
.panelButton:hover {
    background: #e0e0e0;
    border-radius: 10px 10px 0 0;
}
.panelButton.selected {
    background-color: #e7e7e7;
}
.panelButton.active {
    background-color: whitesmoke!important;
    border-radius: 10px 10px 0 0;
}
.panelTitle {
    flex: 1;
    padding: 0 2px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
`, "",{"version":3,"sources":["webpack://./assets/styles/panel.css"],"names":[],"mappings":"AAAA;IACI,YAAY;IACZ,WAAW;IACX,mBAAmB;IACnB,mBAAmB;IACnB,WAAW;IACX,oBAAoB;IACpB,wBAAwB;IACxB,gBAAgB;IAChB,kBAAkB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;IACI,eAAe;IACf,YAAY;IACZ,mBAAmB;IACnB,eAAe;IACf,sBAAsB;IACtB,iCAAiC;IACjC,8BAA8B;IAC9B,iBAAiB;IACjB,YAAY;IACZ,WAAW;IACX,kBAAkB;AACtB;AACA;IACI,mBAAmB;IACnB,4BAA4B;AAChC;AACA;IACI,yBAAyB;AAC7B;AACA;IACI,sCAAsC;IACtC,4BAA4B;AAChC;AACA;IACI,OAAO;IACP,cAAc;IACd,gBAAgB;IAChB,uBAAuB;IACvB,mBAAmB;AACvB","sourcesContent":[".panelbar {\r\n    display:flex;\r\n    height:30px;\r\n    background: #665a82;\r\n    background: #cecece;\r\n    color: #111;\r\n    align-items: stretch;\r\n    justify-content: stretch;\r\n    overflow: hidden;\r\n    position: absolute;\r\n}\r\n.panelbar.vertical {\r\n}\r\n\r\n.panelbar.vertical .panelButton {\r\n}\r\n.panelbar.vertical.right .panelButton {\r\n}\r\n\r\n.panelButton {\r\n    cursor: default;\r\n    display:flex;\r\n    align-items: center;\r\n    padding: 0 10px;\r\n    box-sizing: border-box;\r\n    transition: 0.5s background-color;\r\n    border-left: #b3b3b3 solid 1px;\r\n    user-select: none;\r\n    height: 30px;\r\n    width: 30px;\r\n    position: absolute;\r\n}\r\n.panelButton:hover {\r\n    background: #e0e0e0;\r\n    border-radius: 10px 10px 0 0;\r\n}\r\n.panelButton.selected {\r\n    background-color: #e7e7e7;\r\n}\r\n.panelButton.active {\r\n    background-color: whitesmoke!important;\r\n    border-radius: 10px 10px 0 0;\r\n}\r\n.panelTitle {\r\n    flex: 1;\r\n    padding: 0 2px;\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n    white-space: nowrap;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 915:
/***/ ((module, __nested_webpack_exports__, __nested_webpack_require_47933__) => {

"use strict";
/* harmony export */ __nested_webpack_require_47933__.d(__nested_webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_47933__(1);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_47933__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_47933__(935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_47933__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_47933__(62);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_47933__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __nested_webpack_require_47933__(553), __nested_webpack_require_47933__.b);
var ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __nested_webpack_require_47933__(592), __nested_webpack_require_47933__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.cboffline {
    width: 55px;
    height: 21px;
    background: url(${___CSS_LOADER_URL_REPLACEMENT_0___}) no-repeat 0 -21px;
    display: inline-block;
}
.cbofflineDown {
    background-position: 0 0px;
}
.cbofflineChecked {
    background-position: 0 0px;
}

.checkbox {
    display: inline-block;
    width: 16px;
    height: 17px;
    background-repeat: no-repeat;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_1___});
    background-size: 16px 136px;
    background-position: 0 0;
}

.checkboxOver {
    background-position: 0 -17px;
}

.checkboxDown {
    background-position: 0 -34px;
}

.checkboxChecked {
    background-position: 0 -51px;
}`, "",{"version":3,"sources":["webpack://./assets/styles/switcher.css"],"names":[],"mappings":"AAAA;IACI,WAAW;IACX,YAAY;IACZ,qEAAuD;IACvD,qBAAqB;AACzB;AACA;IACI,0BAA0B;AAC9B;AACA;IACI,0BAA0B;AAC9B;;AAEA;IACI,qBAAqB;IACrB,WAAW;IACX,YAAY;IACZ,4BAA4B;IAC5B,yDAAwD;IACxD,2BAA2B;IAC3B,wBAAwB;AAC5B;;AAEA;IACI,4BAA4B;AAChC;;AAEA;IACI,4BAA4B;AAChC;;AAEA;IACI,4BAA4B;AAChC","sourcesContent":[".cboffline {\r\n    width: 55px;\r\n    height: 21px;\r\n    background: url(\"../images/sync.png\") no-repeat 0 -21px;\r\n    display: inline-block;\r\n}\r\n.cbofflineDown {\r\n    background-position: 0 0px;\r\n}\r\n.cbofflineChecked {\r\n    background-position: 0 0px;\r\n}\r\n\r\n.checkbox {\r\n    display: inline-block;\r\n    width: 16px;\r\n    height: 17px;\r\n    background-repeat: no-repeat;\r\n    background-image: url(\"../images/checkbox_black@1x.png\");\r\n    background-size: 16px 136px;\r\n    background-position: 0 0;\r\n}\r\n\r\n.checkboxOver {\r\n    background-position: 0 -17px;\r\n}\r\n\r\n.checkboxDown {\r\n    background-position: 0 -34px;\r\n}\r\n\r\n.checkboxChecked {\r\n    background-position: 0 -51px;\r\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 129:
/***/ ((module, __nested_webpack_exports__, __nested_webpack_require_52023__) => {

"use strict";
/* harmony export */ __nested_webpack_require_52023__.d(__nested_webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_52023__(1);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_52023__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_52023__(935);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_52023__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.tabContainer {
    align-items: stretch;
    height: 30px;
}

.tabPlusButton {
    --color: #ababab;
    cursor: pointer;
    display: flex;
    align-items: center;
    padding: 8px;
    color: transparent;
}
.tabPlusButton:after {
    content: "";
    background-image: linear-gradient(to bottom, transparent 40%, var(--color) 40%, var(--color) 60%,  transparent 60%),
        linear-gradient(to right, transparent 40%, var(--color) 40%, var(--color) 60%, transparent 60%);
        position: absolute;
    width: 12px;
    height: 12px;
    top: 8px;
}
.tabPlusButton:hover:after {
    --color: #35cc95

}

.tabPlusButton:active {
    color: darkgreen
}

.tabScroller {
    overflow: hidden;
    position: relative;
}
.tab.changed>.tabCloseButton {
    background: #afafaf;
    border: transparent;
}

.tabbar {
    display:flex;
    background: var(--toolbar-background);
    color: #333;
    align-items: stretch;
    overflow: hidden;
    position: absolute;
    user-select: none;
}
.tab {
    font-size: 12px;
    height: 100%;
    /*min-width: 100px;*/
    cursor: default;
    display:flex;
    align-items: center;
    padding: 0 10px;
    box-sizing: border-box;
    background: var(--toolbar-background);
    border-left: transparent solid 1px;
    border-right: transparent solid 1px;
    user-select: none;
    position: absolute;
}

.tab.selected.active:after {
    content: "";
    border-bottom: 2px solid rgb(127, 127, 191);
    width: calc(100% - 22px);
    bottom: 0;
    position: absolute;
}
.tab.focused.active:after {
    content: "";
    border-bottom: 3px solid rgb(127, 127, 191);
    width: calc(100% - 22px);
    bottom: 0;
    position: absolute;
}

.tab.scrolledLeft {
    border-color: var(--splitter-color);
    box-shadow: 0px 0px 2px 0px #d0d0d0;
}
.tabIcon {
    display: none;
}

.tabLeftOverflow {

}
.tabRightOverflow {

}
.tabDragging {
    display: flex;
    box-sizing: border-box;
    transition: 0.5s background-color;
    user-select: none;
    z-index: 100000;
    pointer-events: none;
    position: absolute;
}

.tab:hover {
    background: var(--hover-background);
}
.tab.selected {
    background-color: #e7e7e7;
}
.tab.active {
    background-color: whitesmoke;
}
 .tabDragging > .tab.active {
    background-color: #e7e7e7;
}

.tabCloseButton {
    transform: rotate(45deg);
    width: 11px;
    height: 11px;
    display: inline-block;
    border-radius: 10px;
    cursor: pointer;
    opacity: 0;
    background: linear-gradient(to bottom, transparent 40%, #ababab 40%, #ababab 60%,  transparent 60%),
        linear-gradient(to right, transparent 40%, #ababab 40%, #ababab 60%, transparent 60%);
}


.tabCloseButton:hover {
    background-color: #ababab;
    border: 1px solid #ababab;
    background-image: linear-gradient(to bottom, transparent 40%, #fff 40%, #fff 60%,  transparent 60%),
        linear-gradient(to right, transparent 40%, #fff 40%, #fff 60%, transparent 60%);

}

.tab.active .tabCloseButton,
.tab:hover .tabCloseButton,
.tabCloseButton.changed {
    opacity: 1
}

.tabIcon {
    color: yellow;
    padding: 0 4px 0 0;
}
.tab.active .tabIcon {
    color: orange
}
.tabTitle {
    flex: 1;
    padding: 0 2px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}



.tabbar.vertical .tab {
    transform: rotate(180deg);
}


.split-area {
    position: absolute;
    background: rgba(0, 0, 0, 0.05);
    border: 1px solid rgba(0, 0, 0, 0.2);
    z-index: 100000;
    pointer-events: none;
    box-sizing: border-box;
    cursor: default;
}

.dark.split-area {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 0 200px rgba(255, 255, 255, 0.15) inset;
    outline: 1px solid black;
}

.tab-editor {
    position: absolute;
}`, "",{"version":3,"sources":["webpack://./assets/styles/tab.css"],"names":[],"mappings":"AAAA;IACI,oBAAoB;IACpB,YAAY;AAChB;;AAEA;IACI,gBAAgB;IAChB,eAAe;IACf,aAAa;IACb,mBAAmB;IACnB,YAAY;IACZ,kBAAkB;AACtB;AACA;IACI,WAAW;IACX;uGACmG;QAC/F,kBAAkB;IACtB,WAAW;IACX,YAAY;IACZ,QAAQ;AACZ;AACA;IACI;;AAEJ;;AAEA;IACI;AACJ;;AAEA;IACI,gBAAgB;IAChB,kBAAkB;AACtB;AACA;IACI,mBAAmB;IACnB,mBAAmB;AACvB;;AAEA;IACI,YAAY;IACZ,qCAAqC;IACrC,WAAW;IACX,oBAAoB;IACpB,gBAAgB;IAChB,kBAAkB;IAClB,iBAAiB;AACrB;AACA;IACI,eAAe;IACf,YAAY;IACZ,oBAAoB;IACpB,eAAe;IACf,YAAY;IACZ,mBAAmB;IACnB,eAAe;IACf,sBAAsB;IACtB,qCAAqC;IACrC,kCAAkC;IAClC,mCAAmC;IACnC,iBAAiB;IACjB,kBAAkB;AACtB;;AAEA;IACI,WAAW;IACX,2CAA2C;IAC3C,wBAAwB;IACxB,SAAS;IACT,kBAAkB;AACtB;AACA;IACI,WAAW;IACX,2CAA2C;IAC3C,wBAAwB;IACxB,SAAS;IACT,kBAAkB;AACtB;;AAEA;IACI,mCAAmC;IACnC,mCAAmC;AACvC;AACA;IACI,aAAa;AACjB;;AAEA;;AAEA;AACA;;AAEA;AACA;IACI,aAAa;IACb,sBAAsB;IACtB,iCAAiC;IACjC,iBAAiB;IACjB,eAAe;IACf,oBAAoB;IACpB,kBAAkB;AACtB;;AAEA;IACI,mCAAmC;AACvC;AACA;IACI,yBAAyB;AAC7B;AACA;IACI,4BAA4B;AAChC;CACC;IACG,yBAAyB;AAC7B;;AAEA;IACI,wBAAwB;IACxB,WAAW;IACX,YAAY;IACZ,qBAAqB;IACrB,mBAAmB;IACnB,eAAe;IACf,UAAU;IACV;6FACyF;AAC7F;;;AAGA;IACI,yBAAyB;IACzB,yBAAyB;IACzB;uFACmF;;AAEvF;;AAEA;;;IAGI;AACJ;;AAEA;IACI,aAAa;IACb,kBAAkB;AACtB;AACA;IACI;AACJ;AACA;IACI,OAAO;IACP,cAAc;IACd,gBAAgB;IAChB,uBAAuB;IACvB,mBAAmB;AACvB;;;;AAIA;IACI,yBAAyB;AAC7B;;;AAGA;IACI,kBAAkB;IAClB,+BAA+B;IAC/B,oCAAoC;IACpC,eAAe;IACf,oBAAoB;IACpB,sBAAsB;IACtB,eAAe;AACnB;;AAEA;IACI,qCAAqC;IACrC,0CAA0C;IAC1C,qDAAqD;IACrD,wBAAwB;AAC5B;;AAEA;IACI,kBAAkB;AACtB","sourcesContent":[".tabContainer {\r\n    align-items: stretch;\r\n    height: 30px;\r\n}\r\n\r\n.tabPlusButton {\r\n    --color: #ababab;\r\n    cursor: pointer;\r\n    display: flex;\r\n    align-items: center;\r\n    padding: 8px;\r\n    color: transparent;\r\n}\r\n.tabPlusButton:after {\r\n    content: \"\";\r\n    background-image: linear-gradient(to bottom, transparent 40%, var(--color) 40%, var(--color) 60%,  transparent 60%),\r\n        linear-gradient(to right, transparent 40%, var(--color) 40%, var(--color) 60%, transparent 60%);\r\n        position: absolute;\r\n    width: 12px;\r\n    height: 12px;\r\n    top: 8px;\r\n}\r\n.tabPlusButton:hover:after {\r\n    --color: #35cc95\r\n\r\n}\r\n\r\n.tabPlusButton:active {\r\n    color: darkgreen\r\n}\r\n\r\n.tabScroller {\r\n    overflow: hidden;\r\n    position: relative;\r\n}\r\n.tab.changed>.tabCloseButton {\r\n    background: #afafaf;\r\n    border: transparent;\r\n}\r\n\r\n.tabbar {\r\n    display:flex;\r\n    background: var(--toolbar-background);\r\n    color: #333;\r\n    align-items: stretch;\r\n    overflow: hidden;\r\n    position: absolute;\r\n    user-select: none;\r\n}\r\n.tab {\r\n    font-size: 12px;\r\n    height: 100%;\r\n    /*min-width: 100px;*/\r\n    cursor: default;\r\n    display:flex;\r\n    align-items: center;\r\n    padding: 0 10px;\r\n    box-sizing: border-box;\r\n    background: var(--toolbar-background);\r\n    border-left: transparent solid 1px;\r\n    border-right: transparent solid 1px;\r\n    user-select: none;\r\n    position: absolute;\r\n}\r\n\r\n.tab.selected.active:after {\r\n    content: \"\";\r\n    border-bottom: 2px solid rgb(127, 127, 191);\r\n    width: calc(100% - 22px);\r\n    bottom: 0;\r\n    position: absolute;\r\n}\r\n.tab.focused.active:after {\r\n    content: \"\";\r\n    border-bottom: 3px solid rgb(127, 127, 191);\r\n    width: calc(100% - 22px);\r\n    bottom: 0;\r\n    position: absolute;\r\n}\r\n\r\n.tab.scrolledLeft {\r\n    border-color: var(--splitter-color);\r\n    box-shadow: 0px 0px 2px 0px #d0d0d0;\r\n}\r\n.tabIcon {\r\n    display: none;\r\n}\r\n\r\n.tabLeftOverflow {\r\n\r\n}\r\n.tabRightOverflow {\r\n\r\n}\r\n.tabDragging {\r\n    display: flex;\r\n    box-sizing: border-box;\r\n    transition: 0.5s background-color;\r\n    user-select: none;\r\n    z-index: 100000;\r\n    pointer-events: none;\r\n    position: absolute;\r\n}\r\n\r\n.tab:hover {\r\n    background: var(--hover-background);\r\n}\r\n.tab.selected {\r\n    background-color: #e7e7e7;\r\n}\r\n.tab.active {\r\n    background-color: whitesmoke;\r\n}\r\n .tabDragging > .tab.active {\r\n    background-color: #e7e7e7;\r\n}\r\n\r\n.tabCloseButton {\r\n    transform: rotate(45deg);\r\n    width: 11px;\r\n    height: 11px;\r\n    display: inline-block;\r\n    border-radius: 10px;\r\n    cursor: pointer;\r\n    opacity: 0;\r\n    background: linear-gradient(to bottom, transparent 40%, #ababab 40%, #ababab 60%,  transparent 60%),\r\n        linear-gradient(to right, transparent 40%, #ababab 40%, #ababab 60%, transparent 60%);\r\n}\r\n\r\n\r\n.tabCloseButton:hover {\r\n    background-color: #ababab;\r\n    border: 1px solid #ababab;\r\n    background-image: linear-gradient(to bottom, transparent 40%, #fff 40%, #fff 60%,  transparent 60%),\r\n        linear-gradient(to right, transparent 40%, #fff 40%, #fff 60%, transparent 60%);\r\n\r\n}\r\n\r\n.tab.active .tabCloseButton,\r\n.tab:hover .tabCloseButton,\r\n.tabCloseButton.changed {\r\n    opacity: 1\r\n}\r\n\r\n.tabIcon {\r\n    color: yellow;\r\n    padding: 0 4px 0 0;\r\n}\r\n.tab.active .tabIcon {\r\n    color: orange\r\n}\r\n.tabTitle {\r\n    flex: 1;\r\n    padding: 0 2px;\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n    white-space: nowrap;\r\n}\r\n\r\n\r\n\r\n.tabbar.vertical .tab {\r\n    transform: rotate(180deg);\r\n}\r\n\r\n\r\n.split-area {\r\n    position: absolute;\r\n    background: rgba(0, 0, 0, 0.05);\r\n    border: 1px solid rgba(0, 0, 0, 0.2);\r\n    z-index: 100000;\r\n    pointer-events: none;\r\n    box-sizing: border-box;\r\n    cursor: default;\r\n}\r\n\r\n.dark.split-area {\r\n    background: rgba(255, 255, 255, 0.05);\r\n    border: 1px solid rgba(255, 255, 255, 0.3);\r\n    box-shadow: 0 0 200px rgba(255, 255, 255, 0.15) inset;\r\n    outline: 1px solid black;\r\n}\r\n\r\n.tab-editor {\r\n    position: absolute;\r\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 935:
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ 62:
/***/ ((module) => {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    options = {};
  }
  if (!url) {
    return url;
  }
  url = String(url.__esModule ? url.default : url);

  // If url is already wrapped in quotes, remove them
  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }
  if (options.hash) {
    url += options.hash;
  }

  // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls
  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }
  return url;
};

/***/ }),

/***/ 1:
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ 532:
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
  if (true)
    module.exports = factory();
  else { var i, a; }
})(this, () => {
  return (
    /******/
    (() => {
      var __webpack_modules__ = {
        /***/
        217: (
          /***/
          (module2) => {
            "use strict";
            var $cancelT;
            module2.exports = {
              lineMode: false,
              pasteCancelled: function() {
                if ($cancelT && $cancelT > Date.now() - 50)
                  return true;
                return $cancelT = false;
              },
              cancel: function() {
                $cancelT = Date.now();
              }
            };
          }
        ),
        /***/
        379: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            var oop = __webpack_require__2(645);
            var MultiHashHandler = __webpack_require__2(50).O;
            var EventEmitter = __webpack_require__2(366).b;
            var CommandManager = function(platform, commands) {
              MultiHashHandler.call(this, commands, platform);
              this.byName = this.commands;
              this.setDefaultHandler("exec", function(e) {
                if (!e.args) {
                  return e.command.exec(e.editor, {}, e.event, true);
                }
                return e.command.exec(e.editor, e.args, e.event, false);
              });
            };
            oop.inherits(CommandManager, MultiHashHandler);
            (function() {
              oop.implement(this, EventEmitter);
              this.exec = function(command, editor, args) {
                if (Array.isArray(command)) {
                  for (var i = command.length; i--; ) {
                    if (this.exec(command[i], editor, args))
                      return true;
                  }
                  return false;
                }
                if (typeof command === "string")
                  command = this.commands[command];
                if (!command)
                  return false;
                if (editor && editor.$readOnly && !command.readOnly)
                  return false;
                if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor))
                  return false;
                var e = { editor, command, args };
                e.returnValue = this._emit("exec", e);
                this._signal("afterExec", e);
                return e.returnValue === false ? false : true;
              };
              this.toggleRecording = function(editor) {
                if (this.$inReplay)
                  return;
                editor && editor._emit("changeStatus");
                if (this.recording) {
                  this.macro.pop();
                  this.off("exec", this.$addCommandToMacro);
                  if (!this.macro.length)
                    this.macro = this.oldMacro;
                  return this.recording = false;
                }
                if (!this.$addCommandToMacro) {
                  this.$addCommandToMacro = function(e) {
                    this.macro.push([e.command, e.args]);
                  }.bind(this);
                }
                this.oldMacro = this.macro;
                this.macro = [];
                this.on("exec", this.$addCommandToMacro);
                return this.recording = true;
              };
              this.replay = function(editor) {
                if (this.$inReplay || !this.macro)
                  return;
                if (this.recording)
                  return this.toggleRecording(editor);
                try {
                  this.$inReplay = true;
                  this.macro.forEach(function(x) {
                    if (typeof x == "string")
                      this.exec(x, editor);
                    else
                      this.exec(x[0], editor, x[1]);
                  }, this);
                } finally {
                  this.$inReplay = false;
                }
              };
              this.trimMacro = function(m) {
                return m.map(function(x) {
                  if (typeof x[0] != "string")
                    x[0] = x[0].name;
                  if (!x[1])
                    x = x[0];
                  return x;
                });
              };
            }).call(CommandManager.prototype);
            exports2.F = CommandManager;
          }
        ),
        /***/
        50: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            var __webpack_unused_export__;
            var keyUtil = __webpack_require__2(451);
            var useragent = __webpack_require__2(943);
            var KEY_MODS = keyUtil.KEY_MODS;
            function HashHandler(config, platform) {
              this.platform = platform || (useragent.isMac ? "mac" : "win");
              this.commands = {};
              this.commandKeyBinding = {};
              this.addCommands(config);
              this.$singleCommand = true;
            }
            function MultiHashHandler(config, platform) {
              HashHandler.call(this, config, platform);
              this.$singleCommand = false;
            }
            MultiHashHandler.prototype = HashHandler.prototype;
            (function() {
              this.addCommand = function(command) {
                if (this.commands[command.name])
                  this.removeCommand(command);
                this.commands[command.name] = command;
                if (command.bindKey)
                  this._buildKeyHash(command);
              };
              this.removeCommand = function(command, keepCommand) {
                var name = command && (typeof command === "string" ? command : command.name);
                command = this.commands[name];
                if (!keepCommand)
                  delete this.commands[name];
                var ckb = this.commandKeyBinding;
                for (var keyId in ckb) {
                  var cmdGroup = ckb[keyId];
                  if (cmdGroup == command) {
                    delete ckb[keyId];
                  } else if (Array.isArray(cmdGroup)) {
                    var i = cmdGroup.indexOf(command);
                    if (i != -1) {
                      cmdGroup.splice(i, 1);
                      if (cmdGroup.length == 1)
                        ckb[keyId] = cmdGroup[0];
                    }
                  }
                }
              };
              this.bindKey = function(key, command, position) {
                if (typeof key == "object" && key) {
                  if (position == void 0)
                    position = key.position;
                  key = key[this.platform];
                }
                if (!key)
                  return;
                if (typeof command == "function")
                  return this.addCommand({ exec: command, bindKey: key, name: command.name || key });
                key.split("|").forEach(function(keyPart) {
                  var chain = "";
                  if (keyPart.indexOf(" ") != -1) {
                    var parts = keyPart.split(/\s+/);
                    keyPart = parts.pop();
                    parts.forEach(function(keyPart2) {
                      var binding2 = this.parseKeys(keyPart2);
                      var id2 = KEY_MODS[binding2.hashId] + binding2.key;
                      chain += (chain ? " " : "") + id2;
                      this._addCommandToBinding(chain, "chainKeys");
                    }, this);
                    chain += " ";
                  }
                  var binding = this.parseKeys(keyPart);
                  var id = KEY_MODS[binding.hashId] + binding.key;
                  this._addCommandToBinding(chain + id, command, position);
                }, this);
              };
              function getPosition(command) {
                return typeof command == "object" && command.bindKey && command.bindKey.position || (command.isDefault ? -100 : 0);
              }
              this._addCommandToBinding = function(keyId, command, position) {
                var ckb = this.commandKeyBinding, i;
                if (!command) {
                  delete ckb[keyId];
                } else if (!ckb[keyId] || this.$singleCommand) {
                  ckb[keyId] = command;
                } else {
                  if (!Array.isArray(ckb[keyId])) {
                    ckb[keyId] = [ckb[keyId]];
                  } else if ((i = ckb[keyId].indexOf(command)) != -1) {
                    ckb[keyId].splice(i, 1);
                  }
                  if (typeof position != "number") {
                    position = getPosition(command);
                  }
                  var commands = ckb[keyId];
                  for (i = 0; i < commands.length; i++) {
                    var other = commands[i];
                    var otherPos = getPosition(other);
                    if (otherPos > position)
                      break;
                  }
                  commands.splice(i, 0, command);
                }
              };
              this.addCommands = function(commands) {
                commands && Object.keys(commands).forEach(function(name) {
                  var command = commands[name];
                  if (!command)
                    return;
                  if (typeof command === "string")
                    return this.bindKey(command, name);
                  if (typeof command === "function")
                    command = { exec: command };
                  if (typeof command !== "object")
                    return;
                  if (!command.name)
                    command.name = name;
                  this.addCommand(command);
                }, this);
              };
              this.removeCommands = function(commands) {
                Object.keys(commands).forEach(function(name) {
                  this.removeCommand(commands[name]);
                }, this);
              };
              this.bindKeys = function(keyList) {
                Object.keys(keyList).forEach(function(key) {
                  this.bindKey(key, keyList[key]);
                }, this);
              };
              this._buildKeyHash = function(command) {
                this.bindKey(command.bindKey, command);
              };
              this.parseKeys = function(keys) {
                var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x) {
                  return x;
                });
                var key = parts.pop();
                var keyCode = keyUtil[key];
                if (keyUtil.FUNCTION_KEYS[keyCode])
                  key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
                else if (!parts.length)
                  return { key, hashId: -1 };
                else if (parts.length == 1 && parts[0] == "shift")
                  return { key: key.toUpperCase(), hashId: -1 };
                var hashId = 0;
                for (var i = parts.length; i--; ) {
                  var modifier = keyUtil.KEY_MODS[parts[i]];
                  if (modifier == null) {
                    if (typeof console != "undefined")
                      console.error("invalid modifier " + parts[i] + " in " + keys);
                    return false;
                  }
                  hashId |= modifier;
                }
                return { key, hashId };
              };
              this.findKeyCommand = function findKeyCommand(hashId, keyString) {
                var key = KEY_MODS[hashId] + keyString;
                return this.commandKeyBinding[key];
              };
              this.handleKeyboard = function(data, hashId, keyString, keyCode) {
                if (keyCode < 0)
                  return;
                var key = KEY_MODS[hashId] + keyString;
                var command = this.commandKeyBinding[key];
                if (data.$keyChain) {
                  data.$keyChain += " " + key;
                  command = this.commandKeyBinding[data.$keyChain] || command;
                }
                if (command) {
                  if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                    data.$keyChain = data.$keyChain || key;
                    return { command: "null" };
                  }
                }
                if (data.$keyChain) {
                  if ((!hashId || hashId == 4) && keyString.length == 1)
                    data.$keyChain = data.$keyChain.slice(0, -key.length - 1);
                  else if (hashId == -1 || keyCode > 0)
                    data.$keyChain = "";
                }
                return { command };
              };
              this.getStatusText = function(editor, data) {
                return data.$keyChain || "";
              };
            }).call(HashHandler.prototype);
            __webpack_unused_export__ = HashHandler;
            exports2.O = MultiHashHandler;
          }
        ),
        /***/
        957: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            var keyUtil = __webpack_require__2(451);
            var event = __webpack_require__2(631);
            var KeyBinding = function(editor) {
              this.$editor = editor;
              this.$data = { editor };
              this.$handlers = [];
              this.setDefaultHandler(editor.commands);
            };
            (function() {
              this.setDefaultHandler = function(kb) {
                this.removeKeyboardHandler(this.$defaultHandler);
                this.$defaultHandler = kb;
                this.addKeyboardHandler(kb, 0);
              };
              this.setKeyboardHandler = function(kb) {
                var h = this.$handlers;
                if (h[h.length - 1] == kb)
                  return;
                while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
                  this.removeKeyboardHandler(h[h.length - 1]);
                this.addKeyboardHandler(kb, 1);
              };
              this.addKeyboardHandler = function(kb, pos) {
                if (!kb)
                  return;
                if (typeof kb == "function" && !kb.handleKeyboard)
                  kb.handleKeyboard = kb;
                var i = this.$handlers.indexOf(kb);
                if (i != -1)
                  this.$handlers.splice(i, 1);
                if (pos == void 0)
                  this.$handlers.push(kb);
                else
                  this.$handlers.splice(pos, 0, kb);
                if (i == -1 && kb.attach)
                  kb.attach(this.$editor);
              };
              this.removeKeyboardHandler = function(kb) {
                var i = this.$handlers.indexOf(kb);
                if (i == -1)
                  return false;
                this.$handlers.splice(i, 1);
                kb.detach && kb.detach(this.$editor);
                return true;
              };
              this.getKeyboardHandler = function() {
                return this.$handlers[this.$handlers.length - 1];
              };
              this.getStatusText = function() {
                var data = this.$data;
                var editor = data.editor;
                return this.$handlers.map(function(h) {
                  return h.getStatusText && h.getStatusText(editor, data) || "";
                }).filter(Boolean).join(" ");
              };
              this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
                var toExecute;
                var success = false;
                var commands = this.$editor.commands;
                for (var i = this.$handlers.length; i--; ) {
                  toExecute = this.$handlers[i].handleKeyboard(
                    this.$data,
                    hashId,
                    keyString,
                    keyCode,
                    e
                  );
                  if (!toExecute || !toExecute.command)
                    continue;
                  if (toExecute.command == "null") {
                    success = true;
                  } else {
                    success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
                  }
                  if (success && e && hashId != -1 && toExecute.passEvent != true && toExecute.command.passEvent != true) {
                    event.stopEvent(e);
                  }
                  if (success)
                    break;
                }
                if (!success && hashId == -1) {
                  toExecute = { command: "insertstring" };
                  success = commands.exec("insertstring", this.$editor, keyString);
                }
                if (success && this.$editor._signal)
                  this.$editor._signal("keyboardActivity", toExecute);
                return success;
              };
              this.onCommandKey = function(e, hashId, keyCode) {
                var keyString = keyUtil.keyCodeToString(keyCode);
                return this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
              };
              this.onTextInput = function(text) {
                return this.$callKeyboardHandlers(-1, text);
              };
            }).call(KeyBinding.prototype);
            exports2.$ = KeyBinding;
          }
        ),
        /***/
        984: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            var __webpack_unused_export__;
            var event = __webpack_require__2(631);
            var useragent = __webpack_require__2(943);
            var dom = __webpack_require__2(435);
            var lang = __webpack_require__2(955);
            var clipboard = __webpack_require__2(217);
            var BROKEN_SETDATA = useragent.isChrome < 18;
            var USE_IE_MIME_TYPE = useragent.isIE;
            var HAS_FOCUS_ARGS = useragent.isChrome > 63;
            var MAX_LINE_LENGTH = 400;
            var KEYS = __webpack_require__2(451);
            var MODS = KEYS.KEY_MODS;
            var isIOS = useragent.isIOS;
            var valueResetRegex = isIOS ? /\s/ : /\n/;
            var isMobile = useragent.isMobile;
            var TextInput = function(parentNode, host) {
              var text = dom.createElement("textarea");
              text.className = "ace_text-input";
              text.setAttribute("wrap", "off");
              text.setAttribute("autocorrect", "off");
              text.setAttribute("autocapitalize", "off");
              text.setAttribute("spellcheck", false);
              text.style.opacity = "0";
              parentNode.insertBefore(text, parentNode.firstChild);
              var copied = false;
              var pasted = false;
              var inComposition = false;
              var sendingText = false;
              var tempStyle = "";
              if (!isMobile)
                text.style.fontSize = "1px";
              var commandMode = false;
              var ignoreFocusEvents = false;
              var lastValue = "";
              var lastSelectionStart = 0;
              var lastSelectionEnd = 0;
              var lastRestoreEnd = 0;
              try {
                var isFocused = document.activeElement === text;
              } catch (e) {
              }
              this.setAriaOptions = function(options) {
                if (options.activeDescendant) {
                  text.setAttribute("aria-haspopup", "true");
                  text.setAttribute("aria-autocomplete", "list");
                  text.setAttribute("aria-activedescendant", options.activeDescendant);
                } else {
                  text.setAttribute("aria-haspopup", "false");
                  text.setAttribute("aria-autocomplete", "both");
                  text.removeAttribute("aria-activedescendant");
                }
                if (options.role) {
                  text.setAttribute("role", options.role);
                }
              };
              this.setAriaOptions({ role: "textbox" });
              event.addListener(text, "blur", function(e) {
                if (ignoreFocusEvents)
                  return;
                host.onBlur(e);
                isFocused = false;
              }, host);
              event.addListener(text, "focus", function(e) {
                if (ignoreFocusEvents)
                  return;
                isFocused = true;
                if (useragent.isEdge) {
                  try {
                    if (!document.hasFocus())
                      return;
                  } catch (e2) {
                  }
                }
                host.onFocus(e);
                if (useragent.isEdge)
                  setTimeout(resetSelection);
                else
                  resetSelection();
              }, host);
              this.$focusScroll = false;
              this.focus = function() {
                if (tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == "browser")
                  return text.focus({ preventScroll: true });
                var top = text.style.top;
                text.style.position = "fixed";
                text.style.top = "0px";
                try {
                  var isTransformed = text.getBoundingClientRect().top != 0;
                } catch (e) {
                  return;
                }
                var ancestors = [];
                if (isTransformed) {
                  var t = text.parentElement;
                  while (t && t.nodeType == 1) {
                    ancestors.push(t);
                    t.setAttribute("ace_nocontext", true);
                    if (!t.parentElement && t.getRootNode)
                      t = t.getRootNode().host;
                    else
                      t = t.parentElement;
                  }
                }
                text.focus({ preventScroll: true });
                if (isTransformed) {
                  ancestors.forEach(function(p) {
                    p.removeAttribute("ace_nocontext");
                  });
                }
                setTimeout(function() {
                  text.style.position = "";
                  if (text.style.top == "0px")
                    text.style.top = top;
                }, 0);
              };
              this.blur = function() {
                text.blur();
              };
              this.isFocused = function() {
                return isFocused;
              };
              host.on("beforeEndOperation", function() {
                var curOp = host.curOp;
                var commandName = curOp && curOp.command && curOp.command.name;
                if (commandName == "insertstring")
                  return;
                var isUserAction = commandName && (curOp.docChanged || curOp.selectionChanged);
                if (inComposition && isUserAction) {
                  lastValue = text.value = "";
                  onCompositionEnd();
                }
                resetSelection();
              });
              var resetSelection = isIOS ? function(value) {
                if (!isFocused || copied && !value || sendingText)
                  return;
                if (!value)
                  value = "";
                var newValue = "\n ab" + value + "cde fg\n";
                if (newValue != text.value)
                  text.value = lastValue = newValue;
                var selectionStart = 4;
                var selectionEnd = 4 + (value.length || (host.selection.isEmpty() ? 0 : 1));
                if (lastSelectionStart != selectionStart || lastSelectionEnd != selectionEnd) {
                  text.setSelectionRange(selectionStart, selectionEnd);
                }
                lastSelectionStart = selectionStart;
                lastSelectionEnd = selectionEnd;
              } : function() {
                if (inComposition || sendingText)
                  return;
                if (!isFocused && !afterContextMenu)
                  return;
                inComposition = true;
                var selectionStart = 0;
                var selectionEnd = 0;
                var line = "";
                if (host.session) {
                  var selection = host.selection;
                  var range = selection.getRange();
                  var row = selection.cursor.row;
                  selectionStart = range.start.column;
                  selectionEnd = range.end.column;
                  line = host.session.getLine(row);
                  if (range.start.row != row) {
                    var prevLine = host.session.getLine(row - 1);
                    selectionStart = range.start.row < row - 1 ? 0 : selectionStart;
                    selectionEnd += prevLine.length + 1;
                    line = prevLine + "\n" + line;
                  } else if (range.end.row != row) {
                    var nextLine = host.session.getLine(row + 1);
                    selectionEnd = range.end.row > row + 1 ? nextLine.length : selectionEnd;
                    selectionEnd += line.length + 1;
                    line = line + "\n" + nextLine;
                  } else if (isMobile && row > 0) {
                    line = "\n" + line;
                    selectionEnd += 1;
                    selectionStart += 1;
                  }
                  if (line.length > MAX_LINE_LENGTH) {
                    if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {
                      line = line.slice(0, MAX_LINE_LENGTH);
                    } else {
                      line = "\n";
                      if (selectionStart == selectionEnd) {
                        selectionStart = selectionEnd = 0;
                      } else {
                        selectionStart = 0;
                        selectionEnd = 1;
                      }
                    }
                  }
                }
                var newValue = line + "\n\n";
                if (newValue != lastValue) {
                  text.value = lastValue = newValue;
                  lastSelectionStart = lastSelectionEnd = newValue.length;
                }
                if (afterContextMenu) {
                  lastSelectionStart = text.selectionStart;
                  lastSelectionEnd = text.selectionEnd;
                }
                if (lastSelectionEnd != selectionEnd || lastSelectionStart != selectionStart || text.selectionEnd != lastSelectionEnd) {
                  try {
                    text.setSelectionRange(selectionStart, selectionEnd);
                    lastSelectionStart = selectionStart;
                    lastSelectionEnd = selectionEnd;
                  } catch (e) {
                  }
                }
                inComposition = false;
              };
              this.resetSelection = resetSelection;
              if (isFocused)
                host.onFocus();
              var isAllSelected = function(text2) {
                return text2.selectionStart === 0 && text2.selectionEnd >= lastValue.length && text2.value === lastValue && lastValue && text2.selectionEnd !== lastSelectionEnd;
              };
              var onSelect = function(e) {
                if (inComposition)
                  return;
                if (copied) {
                  copied = false;
                } else if (isAllSelected(text)) {
                  host.selectAll();
                  resetSelection();
                } else if (isMobile && text.selectionStart != lastSelectionStart) {
                  resetSelection();
                }
              };
              var inputHandler = null;
              this.setInputHandler = function(cb) {
                inputHandler = cb;
              };
              this.getInputHandler = function() {
                return inputHandler;
              };
              var afterContextMenu = false;
              var sendText = function(value, fromInput) {
                if (afterContextMenu)
                  afterContextMenu = false;
                if (pasted) {
                  resetSelection();
                  if (value)
                    host.onPaste(value);
                  pasted = false;
                  return "";
                } else {
                  var selectionStart = text.selectionStart;
                  var selectionEnd = text.selectionEnd;
                  var extendLeft = lastSelectionStart;
                  var extendRight = lastValue.length - lastSelectionEnd;
                  var inserted = value;
                  var restoreStart = value.length - selectionStart;
                  var restoreEnd = value.length - selectionEnd;
                  var i = 0;
                  while (extendLeft > 0 && lastValue[i] == value[i]) {
                    i++;
                    extendLeft--;
                  }
                  inserted = inserted.slice(i);
                  i = 1;
                  while (extendRight > 0 && lastValue.length - i > lastSelectionStart - 1 && lastValue[lastValue.length - i] == value[value.length - i]) {
                    i++;
                    extendRight--;
                  }
                  restoreStart -= i - 1;
                  restoreEnd -= i - 1;
                  var endIndex = inserted.length - i + 1;
                  if (endIndex < 0) {
                    extendLeft = -endIndex;
                    endIndex = 0;
                  }
                  inserted = inserted.slice(0, endIndex);
                  if (!fromInput && !inserted && !restoreStart && !extendLeft && !extendRight && !restoreEnd)
                    return "";
                  sendingText = true;
                  var shouldReset = false;
                  if (useragent.isAndroid && inserted == ". ") {
                    inserted = "  ";
                    shouldReset = true;
                  }
                  if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || commandMode) {
                    host.onTextInput(inserted);
                  } else {
                    host.onTextInput(inserted, {
                      extendLeft,
                      extendRight,
                      restoreStart,
                      restoreEnd
                    });
                  }
                  sendingText = false;
                  lastValue = value;
                  lastSelectionStart = selectionStart;
                  lastSelectionEnd = selectionEnd;
                  lastRestoreEnd = restoreEnd;
                  return shouldReset ? "\n" : inserted;
                }
              };
              var onInput = function(e) {
                if (inComposition)
                  return onCompositionUpdate();
                if (e && e.inputType) {
                  if (e.inputType == "historyUndo")
                    return host.execCommand("undo");
                  if (e.inputType == "historyRedo")
                    return host.execCommand("redo");
                }
                var data = text.value;
                var inserted = sendText(data, true);
                if (data.length > MAX_LINE_LENGTH + 100 || valueResetRegex.test(inserted) || isMobile && lastSelectionStart < 1 && lastSelectionStart == lastSelectionEnd) {
                  resetSelection();
                }
              };
              var handleClipboardData = function(e, data, forceIEMime) {
                var clipboardData = e.clipboardData || window.clipboardData;
                if (!clipboardData || BROKEN_SETDATA)
                  return;
                var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
                try {
                  if (data) {
                    return clipboardData.setData(mime, data) !== false;
                  } else {
                    return clipboardData.getData(mime);
                  }
                } catch (e2) {
                  if (!forceIEMime)
                    return handleClipboardData(e2, data, true);
                }
              };
              var doCopy = function(e, isCut) {
                var data = host.getCopyText();
                if (!data)
                  return event.preventDefault(e);
                if (handleClipboardData(e, data)) {
                  if (isIOS) {
                    resetSelection(data);
                    copied = data;
                    setTimeout(function() {
                      copied = false;
                    }, 10);
                  }
                  isCut ? host.onCut() : host.onCopy();
                  event.preventDefault(e);
                } else {
                  copied = true;
                  text.value = data;
                  text.select();
                  setTimeout(function() {
                    copied = false;
                    resetSelection();
                    isCut ? host.onCut() : host.onCopy();
                  });
                }
              };
              var onCut = function(e) {
                doCopy(e, true);
              };
              var onCopy = function(e) {
                doCopy(e, false);
              };
              var onPaste = function(e) {
                var data = handleClipboardData(e);
                if (clipboard.pasteCancelled())
                  return;
                if (typeof data == "string") {
                  if (data)
                    host.onPaste(data, e);
                  if (useragent.isIE)
                    setTimeout(resetSelection);
                  event.preventDefault(e);
                } else {
                  text.value = "";
                  pasted = true;
                }
              };
              event.addCommandKeyListener(text, host.onCommandKey.bind(host), host);
              event.addListener(text, "select", onSelect, host);
              event.addListener(text, "input", onInput, host);
              event.addListener(text, "cut", onCut, host);
              event.addListener(text, "copy", onCopy, host);
              event.addListener(text, "paste", onPaste, host);
              if (!("oncut" in text) || !("oncopy" in text) || !("onpaste" in text)) {
                event.addListener(parentNode, "keydown", function(e) {
                  if (useragent.isMac && !e.metaKey || !e.ctrlKey)
                    return;
                  switch (e.keyCode) {
                    case 67:
                      onCopy(e);
                      break;
                    case 86:
                      onPaste(e);
                      break;
                    case 88:
                      onCut(e);
                      break;
                  }
                }, host);
              }
              var onCompositionStart = function(e) {
                if (inComposition || !host.onCompositionStart || host.$readOnly)
                  return;
                inComposition = {};
                if (commandMode)
                  return;
                if (e.data)
                  inComposition.useTextareaForIME = false;
                setTimeout(onCompositionUpdate, 0);
                host._signal("compositionStart");
                host.on("mousedown", cancelComposition);
                var range = host.getSelectionRange();
                range.end.row = range.start.row;
                range.end.column = range.start.column;
                inComposition.markerRange = range;
                inComposition.selectionStart = lastSelectionStart;
                host.onCompositionStart(inComposition);
                if (inComposition.useTextareaForIME) {
                  lastValue = text.value = "";
                  lastSelectionStart = 0;
                  lastSelectionEnd = 0;
                } else {
                  if (text.msGetInputContext)
                    inComposition.context = text.msGetInputContext();
                  if (text.getInputContext)
                    inComposition.context = text.getInputContext();
                }
              };
              var onCompositionUpdate = function() {
                if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
                  return;
                if (commandMode)
                  return cancelComposition();
                if (inComposition.useTextareaForIME) {
                  host.onCompositionUpdate(text.value);
                } else {
                  var data = text.value;
                  sendText(data);
                  if (inComposition.markerRange) {
                    if (inComposition.context) {
                      inComposition.markerRange.start.column = inComposition.selectionStart = inComposition.context.compositionStartOffset;
                    }
                    inComposition.markerRange.end.column = inComposition.markerRange.start.column + lastSelectionEnd - inComposition.selectionStart + lastRestoreEnd;
                  }
                }
              };
              var onCompositionEnd = function(e) {
                if (!host.onCompositionEnd || host.$readOnly)
                  return;
                inComposition = false;
                host.onCompositionEnd();
                host.off("mousedown", cancelComposition);
                if (e)
                  onInput();
              };
              function cancelComposition() {
                ignoreFocusEvents = true;
                text.blur();
                text.focus();
                ignoreFocusEvents = false;
              }
              var syncComposition = lang.delayedCall(onCompositionUpdate, 50).schedule.bind(null, null);
              function onKeyup(e) {
                if (e.keyCode == 27 && text.value.length < text.selectionStart) {
                  if (!inComposition)
                    lastValue = text.value;
                  lastSelectionStart = lastSelectionEnd = -1;
                  resetSelection();
                }
                syncComposition();
              }
              event.addListener(text, "compositionstart", onCompositionStart, host);
              event.addListener(text, "compositionupdate", onCompositionUpdate, host);
              event.addListener(text, "keyup", onKeyup, host);
              event.addListener(text, "keydown", syncComposition, host);
              event.addListener(text, "compositionend", onCompositionEnd, host);
              this.getElement = function() {
                return text;
              };
              this.setCommandMode = function(value) {
                commandMode = value;
                text.readOnly = false;
              };
              this.setReadOnly = function(readOnly) {
                if (!commandMode)
                  text.readOnly = readOnly;
              };
              this.setCopyWithEmptySelection = function(value) {
              };
              this.onContextMenu = function(e) {
                afterContextMenu = true;
                resetSelection();
                host._emit("nativecontextmenu", { target: host, domEvent: e });
                this.moveToMouse(e, true);
              };
              this.moveToMouse = function(e, bringToFront) {
                if (!tempStyle)
                  tempStyle = text.style.cssText;
                text.style.cssText = (bringToFront ? "z-index:100000;" : "") + (useragent.isIE ? "opacity:0.1;" : "") + "text-indent: -" + (lastSelectionStart + lastSelectionEnd) * host.renderer.characterWidth * 0.5 + "px;";
                var rect = host.container.getBoundingClientRect();
                var style = dom.computedStyle(host.container);
                var top = rect.top + (parseInt(style.borderTopWidth) || 0);
                var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
                var maxTop = rect.bottom - top - text.clientHeight - 2;
                var move = function(e2) {
                  dom.translate(text, e2.clientX - left - 2, Math.min(e2.clientY - top - 2, maxTop));
                };
                move(e);
                if (e.type != "mousedown")
                  return;
                host.renderer.$isMousePressed = true;
                clearTimeout(closeTimeout);
                if (useragent.isWin)
                  event.capture(host.container, move, onContextMenuClose);
              };
              this.onContextMenuClose = onContextMenuClose;
              var closeTimeout;
              function onContextMenuClose() {
                clearTimeout(closeTimeout);
                closeTimeout = setTimeout(function() {
                  if (tempStyle) {
                    text.style.cssText = tempStyle;
                    tempStyle = "";
                  }
                  host.renderer.$isMousePressed = false;
                  if (host.renderer.$keepTextAreaAtCursor)
                    host.renderer.$moveTextAreaToCursor();
                }, 0);
              }
              var onContextMenu = function(e) {
                host.textInput.onContextMenu(e);
                onContextMenuClose();
              };
              event.addListener(text, "mouseup", onContextMenu, host);
              event.addListener(text, "mousedown", function(e) {
                e.preventDefault();
                onContextMenuClose();
              }, host);
              event.addListener(host.renderer.scroller, "contextmenu", onContextMenu, host);
              event.addListener(text, "contextmenu", onContextMenu, host);
              if (isIOS)
                addIosSelectionHandler(parentNode, host, text);
              function addIosSelectionHandler(parentNode2, host2, text2) {
                var typingResetTimeout = null;
                var typing = false;
                text2.addEventListener("keydown", function(e) {
                  if (typingResetTimeout)
                    clearTimeout(typingResetTimeout);
                  typing = true;
                }, true);
                text2.addEventListener("keyup", function(e) {
                  typingResetTimeout = setTimeout(function() {
                    typing = false;
                  }, 100);
                }, true);
                var detectArrowKeys = function(e) {
                  if (document.activeElement !== text2)
                    return;
                  if (typing || inComposition || host2.$mouseHandler.isMousePressed)
                    return;
                  if (copied) {
                    return;
                  }
                  var selectionStart = text2.selectionStart;
                  var selectionEnd = text2.selectionEnd;
                  var key = null;
                  var modifier = 0;
                  if (selectionStart == 0) {
                    key = KEYS.up;
                  } else if (selectionStart == 1) {
                    key = KEYS.home;
                  } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd] == "\n") {
                    key = KEYS.end;
                  } else if (selectionStart < lastSelectionStart && lastValue[selectionStart - 1] == " ") {
                    key = KEYS.left;
                    modifier = MODS.option;
                  } else if (selectionStart < lastSelectionStart || selectionStart == lastSelectionStart && lastSelectionEnd != lastSelectionStart && selectionStart == selectionEnd) {
                    key = KEYS.left;
                  } else if (selectionEnd > lastSelectionEnd && lastValue.slice(0, selectionEnd).split("\n").length > 2) {
                    key = KEYS.down;
                  } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd - 1] == " ") {
                    key = KEYS.right;
                    modifier = MODS.option;
                  } else if (selectionEnd > lastSelectionEnd || selectionEnd == lastSelectionEnd && lastSelectionEnd != lastSelectionStart && selectionStart == selectionEnd) {
                    key = KEYS.right;
                  }
                  if (selectionStart !== selectionEnd)
                    modifier |= MODS.shift;
                  if (key) {
                    var result = host2.onCommandKey({}, modifier, key);
                    if (!result && host2.commands) {
                      key = KEYS.keyCodeToString(key);
                      var command = host2.commands.findKeyCommand(modifier, key);
                      if (command)
                        host2.execCommand(command);
                    }
                    lastSelectionStart = selectionStart;
                    lastSelectionEnd = selectionEnd;
                    resetSelection("");
                  }
                };
                document.addEventListener("selectionchange", detectArrowKeys);
                host2.on("destroy", function() {
                  document.removeEventListener("selectionchange", detectArrowKeys);
                });
              }
              this.destroy = function() {
                if (text.parentElement)
                  text.parentElement.removeChild(text);
              };
            };
            exports2.k = TextInput;
            __webpack_unused_export__ = function(_isMobile, _isIOS) {
              isMobile = _isMobile;
              isIOS = _isIOS;
            };
          }
        ),
        /***/
        845: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "no use strict";
            var oop = __webpack_require__2(645);
            var EventEmitter = __webpack_require__2(366).b;
            var optionsProvider = {
              setOptions: function(optList) {
                Object.keys(optList).forEach(function(key) {
                  this.setOption(key, optList[key]);
                }, this);
              },
              getOptions: function(optionNames) {
                var result = {};
                if (!optionNames) {
                  var options = this.$options;
                  optionNames = Object.keys(options).filter(function(key) {
                    return !options[key].hidden;
                  });
                } else if (!Array.isArray(optionNames)) {
                  result = optionNames;
                  optionNames = Object.keys(result);
                }
                optionNames.forEach(function(key) {
                  result[key] = this.getOption(key);
                }, this);
                return result;
              },
              setOption: function(name, value) {
                if (this["$" + name] === value)
                  return;
                var opt = this.$options[name];
                if (!opt) {
                  return warn('misspelled option "' + name + '"');
                }
                if (opt.forwardTo)
                  return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
                if (!opt.handlesSet)
                  this["$" + name] = value;
                if (opt && opt.set)
                  opt.set.call(this, value);
              },
              getOption: function(name) {
                var opt = this.$options[name];
                if (!opt) {
                  return warn('misspelled option "' + name + '"');
                }
                if (opt.forwardTo)
                  return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
                return opt && opt.get ? opt.get.call(this) : this["$" + name];
              }
            };
            function warn(message) {
              if (typeof console != "undefined" && console.warn)
                console.warn.apply(console, arguments);
            }
            function reportError(msg, data) {
              var e = new Error(msg);
              e.data = data;
              if (typeof console == "object" && console.error)
                console.error(e);
              setTimeout(function() {
                throw e;
              });
            }
            var AppConfig = function() {
              this.$defaultOptions = {};
            };
            (function() {
              oop.implement(this, EventEmitter);
              this.defineOptions = function(obj, path, options) {
                if (!obj.$options)
                  this.$defaultOptions[path] = obj.$options = {};
                Object.keys(options).forEach(function(key) {
                  var opt = options[key];
                  if (typeof opt == "string")
                    opt = { forwardTo: opt };
                  opt.name || (opt.name = key);
                  obj.$options[opt.name] = opt;
                  if ("initialValue" in opt)
                    obj["$" + opt.name] = opt.initialValue;
                });
                oop.implement(obj, optionsProvider);
                return this;
              };
              this.resetOptions = function(obj) {
                Object.keys(obj.$options).forEach(function(key) {
                  var opt = obj.$options[key];
                  if ("value" in opt)
                    obj.setOption(key, opt.value);
                });
              };
              this.setDefaultValue = function(path, name, value) {
                if (!path) {
                  for (path in this.$defaultOptions)
                    if (this.$defaultOptions[path][name])
                      break;
                  if (!this.$defaultOptions[path][name])
                    return false;
                }
                var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
                if (opts[name]) {
                  if (opts.forwardTo)
                    this.setDefaultValue(opts.forwardTo, name, value);
                  else
                    opts[name].value = value;
                }
              };
              this.setDefaultValues = function(path, optionHash) {
                Object.keys(optionHash).forEach(function(key) {
                  this.setDefaultValue(path, key, optionHash[key]);
                }, this);
              };
              this.warn = warn;
              this.reportError = reportError;
            }).call(AppConfig.prototype);
            exports2.o = AppConfig;
          }
        ),
        /***/
        435: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            var useragent = __webpack_require__2(943);
            var XHTML_NS = "http://www.w3.org/1999/xhtml";
            exports2.buildDom = function buildDom(arr, parent, refs) {
              if (typeof arr == "string" && arr) {
                var txt = document.createTextNode(arr);
                if (parent)
                  parent.appendChild(txt);
                return txt;
              }
              if (!Array.isArray(arr)) {
                if (arr && arr.appendChild && parent)
                  parent.appendChild(arr);
                return arr;
              }
              if (typeof arr[0] != "string" || !arr[0]) {
                var els = [];
                for (var i = 0; i < arr.length; i++) {
                  var ch = buildDom(arr[i], parent, refs);
                  ch && els.push(ch);
                }
                return els;
              }
              var el = document.createElement(arr[0]);
              var options = arr[1];
              var childIndex = 1;
              if (options && typeof options == "object" && !Array.isArray(options))
                childIndex = 2;
              for (var i = childIndex; i < arr.length; i++)
                buildDom(arr[i], el, refs);
              if (childIndex == 2) {
                Object.keys(options).forEach(function(n) {
                  var val = options[n];
                  if (n === "class") {
                    el.className = Array.isArray(val) ? val.join(" ") : val;
                  } else if (typeof val == "function" || n == "value" || n[0] == "$") {
                    el[n] = val;
                  } else if (n === "ref") {
                    if (refs)
                      refs[val] = el;
                  } else if (n === "style") {
                    if (typeof val == "string")
                      el.style.cssText = val;
                  } else if (val != null) {
                    el.setAttribute(n, val);
                  }
                });
              }
              if (parent)
                parent.appendChild(el);
              return el;
            };
            exports2.getDocumentHead = function(doc) {
              if (!doc)
                doc = document;
              return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
            };
            exports2.createElement = function(tag, ns) {
              return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
            };
            exports2.removeChildren = function(element) {
              element.innerHTML = "";
            };
            exports2.createTextNode = function(textContent, element) {
              var doc = element ? element.ownerDocument : document;
              return doc.createTextNode(textContent);
            };
            exports2.createFragment = function(element) {
              var doc = element ? element.ownerDocument : document;
              return doc.createDocumentFragment();
            };
            exports2.hasCssClass = function(el, name) {
              var classes = (el.className + "").split(/\s+/g);
              return classes.indexOf(name) !== -1;
            };
            exports2.addCssClass = function(el, name) {
              if (!exports2.hasCssClass(el, name)) {
                el.className += " " + name;
              }
            };
            exports2.removeCssClass = function(el, name) {
              var classes = el.className.split(/\s+/g);
              while (true) {
                var index = classes.indexOf(name);
                if (index == -1) {
                  break;
                }
                classes.splice(index, 1);
              }
              el.className = classes.join(" ");
            };
            exports2.toggleCssClass = function(el, name) {
              var classes = el.className.split(/\s+/g), add = true;
              while (true) {
                var index = classes.indexOf(name);
                if (index == -1) {
                  break;
                }
                add = false;
                classes.splice(index, 1);
              }
              if (add)
                classes.push(name);
              el.className = classes.join(" ");
              return add;
            };
            exports2.setCssClass = function(node, className, include) {
              if (include) {
                exports2.addCssClass(node, className);
              } else {
                exports2.removeCssClass(node, className);
              }
            };
            exports2.hasCssString = function(id, doc) {
              var index = 0, sheets;
              doc = doc || document;
              if (sheets = doc.querySelectorAll("style")) {
                while (index < sheets.length) {
                  if (sheets[index++].id === id) {
                    return true;
                  }
                }
              }
            };
            exports2.removeElementById = function(id, doc) {
              doc = doc || document;
              if (doc.getElementById(id)) {
                doc.getElementById(id).remove();
              }
            };
            var strictCSP;
            var cssCache = [];
            exports2.useStrictCSP = function(value) {
              strictCSP = value;
              if (value == false)
                insertPendingStyles();
              else if (!cssCache)
                cssCache = [];
            };
            function insertPendingStyles() {
              var cache = cssCache;
              cssCache = null;
              cache && cache.forEach(function(item) {
                importCssString(item[0], item[1]);
              });
            }
            function importCssString(cssText, id, target) {
              if (typeof document == "undefined")
                return;
              if (cssCache) {
                if (target) {
                  insertPendingStyles();
                } else if (target === false) {
                  return cssCache.push([cssText, id]);
                }
              }
              if (strictCSP)
                return;
              var container = target;
              if (!target || !target.getRootNode) {
                container = document;
              } else {
                container = target.getRootNode();
                if (!container || container == target)
                  container = document;
              }
              var doc = container.ownerDocument || container;
              if (id && exports2.hasCssString(id, container))
                return null;
              if (id)
                cssText += "\n/*# sourceURL=ace/css/" + id + " */";
              var style = exports2.createElement("style");
              style.appendChild(doc.createTextNode(cssText));
              if (id)
                style.id = id;
              if (container == doc)
                container = exports2.getDocumentHead(doc);
              container.insertBefore(style, container.firstChild);
            }
            exports2.importCssString = importCssString;
            exports2.importCssStylsheet = function(uri, doc) {
              exports2.buildDom(["link", { rel: "stylesheet", href: uri }], exports2.getDocumentHead(doc));
            };
            exports2.scrollbarWidth = function(doc) {
              var inner = exports2.createElement("ace_inner");
              inner.style.width = "100%";
              inner.style.minWidth = "0px";
              inner.style.height = "200px";
              inner.style.display = "block";
              var outer = exports2.createElement("ace_outer");
              var style = outer.style;
              style.position = "absolute";
              style.left = "-10000px";
              style.overflow = "hidden";
              style.width = "200px";
              style.minWidth = "0px";
              style.height = "150px";
              style.display = "block";
              outer.appendChild(inner);
              var body = doc && doc.documentElement || document && document.documentElement;
              if (!body)
                return 0;
              body.appendChild(outer);
              var noScrollbar = inner.offsetWidth;
              style.overflow = "scroll";
              var withScrollbar = inner.offsetWidth;
              if (noScrollbar === withScrollbar) {
                withScrollbar = outer.clientWidth;
              }
              body.removeChild(outer);
              return noScrollbar - withScrollbar;
            };
            exports2.computedStyle = function(element, style) {
              return window.getComputedStyle(element, "") || {};
            };
            exports2.setStyle = function(styles, property, value) {
              if (styles[property] !== value) {
                styles[property] = value;
              }
            };
            exports2.HAS_CSS_ANIMATION = false;
            exports2.HAS_CSS_TRANSFORMS = false;
            exports2.HI_DPI = useragent.isWin ? typeof window !== "undefined" && window.devicePixelRatio >= 1.5 : true;
            if (useragent.isChromeOS)
              exports2.HI_DPI = false;
            if (typeof document !== "undefined") {
              var div = document.createElement("div");
              if (exports2.HI_DPI && div.style.transform !== void 0)
                exports2.HAS_CSS_TRANSFORMS = true;
              if (!useragent.isEdge && typeof div.style.animationName !== "undefined")
                exports2.HAS_CSS_ANIMATION = true;
              div = null;
            }
            if (exports2.HAS_CSS_TRANSFORMS) {
              exports2.translate = function(element, tx, ty) {
                element.style.transform = "translate(" + Math.round(tx) + "px, " + Math.round(ty) + "px)";
              };
            } else {
              exports2.translate = function(element, tx, ty) {
                element.style.top = Math.round(ty) + "px";
                element.style.left = Math.round(tx) + "px";
              };
            }
          }
        ),
        /***/
        631: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            var keys = __webpack_require__2(451);
            var useragent = __webpack_require__2(943);
            var pressedKeys = null;
            var ts = 0;
            var activeListenerOptions;
            function detectListenerOptionsSupport() {
              activeListenerOptions = false;
              try {
                document.createComment("").addEventListener("test", function() {
                }, {
                  get passive() {
                    activeListenerOptions = { passive: false };
                  }
                });
              } catch (e) {
              }
            }
            function getListenerOptions() {
              if (activeListenerOptions == void 0)
                detectListenerOptionsSupport();
              return activeListenerOptions;
            }
            function EventListener(elem, type, callback) {
              this.elem = elem;
              this.type = type;
              this.callback = callback;
            }
            EventListener.prototype.destroy = function() {
              removeListener(this.elem, this.type, this.callback);
              this.elem = this.type = this.callback = void 0;
            };
            var addListener = exports2.addListener = function(elem, type, callback, destroyer) {
              elem.addEventListener(type, callback, getListenerOptions());
              if (destroyer)
                destroyer.$toDestroy.push(new EventListener(elem, type, callback));
            };
            var removeListener = exports2.removeListener = function(elem, type, callback) {
              elem.removeEventListener(type, callback, getListenerOptions());
            };
            exports2.stopEvent = function(e) {
              exports2.stopPropagation(e);
              exports2.preventDefault(e);
              return false;
            };
            exports2.stopPropagation = function(e) {
              if (e.stopPropagation)
                e.stopPropagation();
            };
            exports2.preventDefault = function(e) {
              if (e.preventDefault)
                e.preventDefault();
            };
            exports2.getButton = function(e) {
              if (e.type == "dblclick")
                return 0;
              if (e.type == "contextmenu" || useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey))
                return 2;
              return e.button;
            };
            exports2.capture = function(el, eventHandler, releaseCaptureHandler) {
              var ownerDocument = el && el.ownerDocument || document;
              function onMouseUp(e) {
                eventHandler && eventHandler(e);
                releaseCaptureHandler && releaseCaptureHandler(e);
                removeListener(ownerDocument, "mousemove", eventHandler);
                removeListener(ownerDocument, "mouseup", onMouseUp);
                removeListener(ownerDocument, "dragstart", onMouseUp);
              }
              addListener(ownerDocument, "mousemove", eventHandler);
              addListener(ownerDocument, "mouseup", onMouseUp);
              addListener(ownerDocument, "dragstart", onMouseUp);
              return onMouseUp;
            };
            exports2.addMouseWheelListener = function(el, callback, destroyer) {
              addListener(el, "wheel", function(e) {
                var factor = 0.15;
                var deltaX = e.deltaX || 0;
                var deltaY = e.deltaY || 0;
                switch (e.deltaMode) {
                  case e.DOM_DELTA_PIXEL:
                    e.wheelX = deltaX * factor;
                    e.wheelY = deltaY * factor;
                    break;
                  case e.DOM_DELTA_LINE:
                    var linePixels = 15;
                    e.wheelX = deltaX * linePixels;
                    e.wheelY = deltaY * linePixels;
                    break;
                  case e.DOM_DELTA_PAGE:
                    var pagePixels = 150;
                    e.wheelX = deltaX * pagePixels;
                    e.wheelY = deltaY * pagePixels;
                    break;
                }
                callback(e);
              }, destroyer);
            };
            exports2.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName, destroyer) {
              var clicks = 0;
              var startX, startY, timer;
              var eventNames = {
                2: "dblclick",
                3: "tripleclick",
                4: "quadclick"
              };
              function onMousedown(e) {
                if (exports2.getButton(e) !== 0) {
                  clicks = 0;
                } else if (e.detail > 1) {
                  clicks++;
                  if (clicks > 4)
                    clicks = 1;
                } else {
                  clicks = 1;
                }
                if (useragent.isIE) {
                  var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
                  if (!timer || isNewClick)
                    clicks = 1;
                  if (timer)
                    clearTimeout(timer);
                  timer = setTimeout(function() {
                    timer = null;
                  }, timeouts[clicks - 1] || 600);
                  if (clicks == 1) {
                    startX = e.clientX;
                    startY = e.clientY;
                  }
                }
                e._clicks = clicks;
                eventHandler[callbackName]("mousedown", e);
                if (clicks > 4)
                  clicks = 0;
                else if (clicks > 1)
                  return eventHandler[callbackName](eventNames[clicks], e);
              }
              if (!Array.isArray(elements))
                elements = [elements];
              elements.forEach(function(el) {
                addListener(el, "mousedown", onMousedown, destroyer);
              });
            };
            var getModifierHash = function(e) {
              return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
            };
            exports2.getModifierString = function(e) {
              return keys.KEY_MODS[getModifierHash(e)];
            };
            function normalizeCommandKeys(callback, e, keyCode) {
              var hashId = getModifierHash(e);
              if (!useragent.isMac && pressedKeys) {
                if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win")))
                  hashId |= 8;
                if (pressedKeys.altGr) {
                  if ((3 & hashId) != 3)
                    pressedKeys.altGr = 0;
                  else
                    return;
                }
                if (keyCode === 18 || keyCode === 17) {
                  var location = "location" in e ? e.location : e.keyLocation;
                  if (keyCode === 17 && location === 1) {
                    if (pressedKeys[keyCode] == 1)
                      ts = e.timeStamp;
                  } else if (keyCode === 18 && hashId === 3 && location === 2) {
                    var dt = e.timeStamp - ts;
                    if (dt < 50)
                      pressedKeys.altGr = true;
                  }
                }
              }
              if (keyCode in keys.MODIFIER_KEYS) {
                keyCode = -1;
              }
              if (!hashId && keyCode === 13) {
                var location = "location" in e ? e.location : e.keyLocation;
                if (location === 3) {
                  callback(e, hashId, -keyCode);
                  if (e.defaultPrevented)
                    return;
                }
              }
              if (useragent.isChromeOS && hashId & 8) {
                callback(e, hashId, keyCode);
                if (e.defaultPrevented)
                  return;
                else
                  hashId &= ~8;
              }
              if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
                return false;
              }
              return callback(e, hashId, keyCode);
            }
            exports2.addCommandKeyListener = function(el, callback, destroyer) {
              if (useragent.isOldGecko || useragent.isOpera && !("KeyboardEvent" in window)) {
                var lastKeyDownKeyCode = null;
                addListener(el, "keydown", function(e) {
                  lastKeyDownKeyCode = e.keyCode;
                }, destroyer);
                addListener(el, "keypress", function(e) {
                  return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
                }, destroyer);
              } else {
                var lastDefaultPrevented = null;
                addListener(el, "keydown", function(e) {
                  pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
                  var result = normalizeCommandKeys(callback, e, e.keyCode);
                  lastDefaultPrevented = e.defaultPrevented;
                  return result;
                }, destroyer);
                addListener(el, "keypress", function(e) {
                  if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
                    exports2.stopEvent(e);
                    lastDefaultPrevented = null;
                  }
                }, destroyer);
                addListener(el, "keyup", function(e) {
                  pressedKeys[e.keyCode] = null;
                }, destroyer);
                if (!pressedKeys) {
                  resetPressedKeys();
                  addListener(window, "focus", resetPressedKeys);
                }
              }
            };
            function resetPressedKeys() {
              pressedKeys = /* @__PURE__ */ Object.create(null);
            }
            if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
              var postMessageId = 1;
              exports2.nextTick = function(callback, win) {
                win = win || window;
                var messageName = "zero-timeout-message-" + postMessageId++;
                var listener = function(e) {
                  if (e.data == messageName) {
                    exports2.stopPropagation(e);
                    removeListener(win, "message", listener);
                    callback();
                  }
                };
                addListener(win, "message", listener);
                win.postMessage(messageName, "*");
              };
            }
            exports2.$idleBlocked = false;
            exports2.onIdle = function(cb, timeout) {
              return setTimeout(function handler() {
                if (!exports2.$idleBlocked) {
                  cb();
                } else {
                  setTimeout(handler, 100);
                }
              }, timeout);
            };
            exports2.$idleBlockId = null;
            exports2.blockIdle = function(delay) {
              if (exports2.$idleBlockId)
                clearTimeout(exports2.$idleBlockId);
              exports2.$idleBlocked = true;
              exports2.$idleBlockId = setTimeout(function() {
                exports2.$idleBlocked = false;
              }, delay || 100);
            };
            exports2.nextFrame = typeof window == "object" && (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame);
            if (exports2.nextFrame)
              exports2.nextFrame = exports2.nextFrame.bind(window);
            else
              exports2.nextFrame = function(callback) {
                setTimeout(callback, 17);
              };
          }
        ),
        /***/
        366: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            var EventEmitter = {};
            var stopPropagation = function() {
              this.propagationStopped = true;
            };
            var preventDefault = function() {
              this.defaultPrevented = true;
            };
            EventEmitter._emit = EventEmitter._dispatchEvent = function(eventName, e) {
              this._eventRegistry || (this._eventRegistry = {});
              this._defaultHandlers || (this._defaultHandlers = {});
              var listeners = this._eventRegistry[eventName] || [];
              var defaultHandler = this._defaultHandlers[eventName];
              if (!listeners.length && !defaultHandler)
                return;
              if (typeof e != "object" || !e)
                e = {};
              if (!e.type)
                e.type = eventName;
              if (!e.stopPropagation)
                e.stopPropagation = stopPropagation;
              if (!e.preventDefault)
                e.preventDefault = preventDefault;
              listeners = listeners.slice();
              for (var i = 0; i < listeners.length; i++) {
                listeners[i](e, this);
                if (e.propagationStopped)
                  break;
              }
              if (defaultHandler && !e.defaultPrevented)
                return defaultHandler(e, this);
            };
            EventEmitter._signal = function(eventName, e) {
              var listeners = (this._eventRegistry || {})[eventName];
              if (!listeners)
                return;
              listeners = listeners.slice();
              for (var i = 0; i < listeners.length; i++)
                listeners[i](e, this);
            };
            EventEmitter.once = function(eventName, callback) {
              var _self = this;
              this.on(eventName, function newCallback() {
                _self.off(eventName, newCallback);
                callback.apply(null, arguments);
              });
              if (!callback) {
                return new Promise(function(resolve) {
                  callback = resolve;
                });
              }
            };
            EventEmitter.setDefaultHandler = function(eventName, callback) {
              var handlers = this._defaultHandlers;
              if (!handlers)
                handlers = this._defaultHandlers = { _disabled_: {} };
              if (handlers[eventName]) {
                var old = handlers[eventName];
                var disabled = handlers._disabled_[eventName];
                if (!disabled)
                  handlers._disabled_[eventName] = disabled = [];
                disabled.push(old);
                var i = disabled.indexOf(callback);
                if (i != -1)
                  disabled.splice(i, 1);
              }
              handlers[eventName] = callback;
            };
            EventEmitter.removeDefaultHandler = function(eventName, callback) {
              var handlers = this._defaultHandlers;
              if (!handlers)
                return;
              var disabled = handlers._disabled_[eventName];
              if (handlers[eventName] == callback) {
                if (disabled)
                  this.setDefaultHandler(eventName, disabled.pop());
              } else if (disabled) {
                var i = disabled.indexOf(callback);
                if (i != -1)
                  disabled.splice(i, 1);
              }
            };
            EventEmitter.on = EventEmitter.addEventListener = function(eventName, callback, capturing) {
              this._eventRegistry = this._eventRegistry || {};
              var listeners = this._eventRegistry[eventName];
              if (!listeners)
                listeners = this._eventRegistry[eventName] = [];
              if (listeners.indexOf(callback) == -1)
                listeners[capturing ? "unshift" : "push"](callback);
              return callback;
            };
            EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function(eventName, callback) {
              this._eventRegistry = this._eventRegistry || {};
              var listeners = this._eventRegistry[eventName];
              if (!listeners)
                return;
              var index = listeners.indexOf(callback);
              if (index !== -1)
                listeners.splice(index, 1);
            };
            EventEmitter.removeAllListeners = function(eventName) {
              if (!eventName)
                this._eventRegistry = this._defaultHandlers = void 0;
              if (this._eventRegistry)
                this._eventRegistry[eventName] = void 0;
              if (this._defaultHandlers)
                this._defaultHandlers[eventName] = void 0;
            };
            exports2.b = EventEmitter;
          }
        ),
        /***/
        451: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            /*! @license
            ==========================================================================
            SproutCore -- JavaScript Application Framework
            copyright 2006-2009, Sprout Systems Inc., Apple Inc. and contributors.
            
            Permission is hereby granted, free of charge, to any person obtaining a
            copy of this software and associated documentation files (the "Software"),
            to deal in the Software without restriction, including without limitation
            the rights to use, copy, modify, merge, publish, distribute, sublicense,
            and/or sell copies of the Software, and to permit persons to whom the
            Software is furnished to do so, subject to the following conditions:
            
            The above copyright notice and this permission notice shall be included in
            all copies or substantial portions of the Software.
            
            THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
            IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
            FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
            AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
            LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
            FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
            DEALINGS IN THE SOFTWARE.
            
            SproutCore and the SproutCore logo are trademarks of Sprout Systems, Inc.
            
            For more information about SproutCore, visit http://www.sproutcore.com
            
            
            ==========================================================================
            @license */
            var oop = __webpack_require__2(645);
            var Keys = function() {
              var ret = {
                MODIFIER_KEYS: {
                  16: "Shift",
                  17: "Ctrl",
                  18: "Alt",
                  224: "Meta",
                  91: "MetaLeft",
                  92: "MetaRight",
                  93: "ContextMenu"
                },
                KEY_MODS: {
                  "ctrl": 1,
                  "alt": 2,
                  "option": 2,
                  "shift": 4,
                  "super": 8,
                  "meta": 8,
                  "command": 8,
                  "cmd": 8,
                  "control": 1
                },
                FUNCTION_KEYS: {
                  8: "Backspace",
                  9: "Tab",
                  13: "Return",
                  19: "Pause",
                  27: "Esc",
                  32: "Space",
                  33: "PageUp",
                  34: "PageDown",
                  35: "End",
                  36: "Home",
                  37: "Left",
                  38: "Up",
                  39: "Right",
                  40: "Down",
                  44: "Print",
                  45: "Insert",
                  46: "Delete",
                  96: "Numpad0",
                  97: "Numpad1",
                  98: "Numpad2",
                  99: "Numpad3",
                  100: "Numpad4",
                  101: "Numpad5",
                  102: "Numpad6",
                  103: "Numpad7",
                  104: "Numpad8",
                  105: "Numpad9",
                  "-13": "NumpadEnter",
                  112: "F1",
                  113: "F2",
                  114: "F3",
                  115: "F4",
                  116: "F5",
                  117: "F6",
                  118: "F7",
                  119: "F8",
                  120: "F9",
                  121: "F10",
                  122: "F11",
                  123: "F12",
                  144: "Numlock",
                  145: "Scrolllock"
                },
                PRINTABLE_KEYS: {
                  32: " ",
                  48: "0",
                  49: "1",
                  50: "2",
                  51: "3",
                  52: "4",
                  53: "5",
                  54: "6",
                  55: "7",
                  56: "8",
                  57: "9",
                  59: ";",
                  61: "=",
                  65: "a",
                  66: "b",
                  67: "c",
                  68: "d",
                  69: "e",
                  70: "f",
                  71: "g",
                  72: "h",
                  73: "i",
                  74: "j",
                  75: "k",
                  76: "l",
                  77: "m",
                  78: "n",
                  79: "o",
                  80: "p",
                  81: "q",
                  82: "r",
                  83: "s",
                  84: "t",
                  85: "u",
                  86: "v",
                  87: "w",
                  88: "x",
                  89: "y",
                  90: "z",
                  107: "+",
                  109: "-",
                  110: ".",
                  186: ";",
                  187: "=",
                  188: ",",
                  189: "-",
                  190: ".",
                  191: "/",
                  192: "`",
                  219: "[",
                  220: "\\",
                  221: "]",
                  222: "'",
                  111: "/",
                  106: "*"
                }
              };
              ret.PRINTABLE_KEYS[173] = "-";
              var name, i;
              for (i in ret.FUNCTION_KEYS) {
                name = ret.FUNCTION_KEYS[i].toLowerCase();
                ret[name] = parseInt(i, 10);
              }
              for (i in ret.PRINTABLE_KEYS) {
                name = ret.PRINTABLE_KEYS[i].toLowerCase();
                ret[name] = parseInt(i, 10);
              }
              oop.mixin(ret, ret.MODIFIER_KEYS);
              oop.mixin(ret, ret.PRINTABLE_KEYS);
              oop.mixin(ret, ret.FUNCTION_KEYS);
              ret.enter = ret["return"];
              ret.escape = ret.esc;
              ret.del = ret["delete"];
              (function() {
                var mods = ["cmd", "ctrl", "alt", "shift"];
                for (var i2 = Math.pow(2, mods.length); i2--; ) {
                  ret.KEY_MODS[i2] = mods.filter(function(x) {
                    return i2 & ret.KEY_MODS[x];
                  }).join("-") + "-";
                }
              })();
              ret.KEY_MODS[0] = "";
              ret.KEY_MODS[-1] = "input-";
              return ret;
            }();
            oop.mixin(exports2, Keys);
            exports2.keyCodeToString = function(keyCode) {
              var keyString = Keys[keyCode];
              if (typeof keyString != "string")
                keyString = String.fromCharCode(keyCode);
              return keyString.toLowerCase();
            };
          }
        ),
        /***/
        955: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            exports2.last = function(a) {
              return a[a.length - 1];
            };
            exports2.stringReverse = function(string) {
              return string.split("").reverse().join("");
            };
            exports2.stringRepeat = function(string, count) {
              var result = "";
              while (count > 0) {
                if (count & 1)
                  result += string;
                if (count >>= 1)
                  string += string;
              }
              return result;
            };
            var trimBeginRegexp = /^\s\s*/;
            var trimEndRegexp = /\s\s*$/;
            exports2.stringTrimLeft = function(string) {
              return string.replace(trimBeginRegexp, "");
            };
            exports2.stringTrimRight = function(string) {
              return string.replace(trimEndRegexp, "");
            };
            exports2.copyObject = function(obj) {
              var copy = {};
              for (var key in obj) {
                copy[key] = obj[key];
              }
              return copy;
            };
            exports2.copyArray = function(array) {
              var copy = [];
              for (var i = 0, l = array.length; i < l; i++) {
                if (array[i] && typeof array[i] == "object")
                  copy[i] = this.copyObject(array[i]);
                else
                  copy[i] = array[i];
              }
              return copy;
            };
            exports2.deepCopy = function deepCopy(obj) {
              if (typeof obj !== "object" || !obj)
                return obj;
              var copy;
              if (Array.isArray(obj)) {
                copy = [];
                for (var key = 0; key < obj.length; key++) {
                  copy[key] = deepCopy(obj[key]);
                }
                return copy;
              }
              if (Object.prototype.toString.call(obj) !== "[object Object]")
                return obj;
              copy = {};
              for (var key in obj)
                copy[key] = deepCopy(obj[key]);
              return copy;
            };
            exports2.arrayToMap = function(arr) {
              var map = {};
              for (var i = 0; i < arr.length; i++) {
                map[arr[i]] = 1;
              }
              return map;
            };
            exports2.createMap = function(props) {
              var map = /* @__PURE__ */ Object.create(null);
              for (var i in props) {
                map[i] = props[i];
              }
              return map;
            };
            exports2.arrayRemove = function(array, value) {
              for (var i = 0; i <= array.length; i++) {
                if (value === array[i]) {
                  array.splice(i, 1);
                }
              }
            };
            exports2.escapeRegExp = function(str) {
              return str.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1");
            };
            exports2.escapeHTML = function(str) {
              return ("" + str).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
            };
            exports2.getMatchOffsets = function(string, regExp) {
              var matches = [];
              string.replace(regExp, function(str) {
                matches.push({
                  offset: arguments[arguments.length - 2],
                  length: str.length
                });
              });
              return matches;
            };
            exports2.deferredCall = function(fcn) {
              var timer = null;
              var callback = function() {
                timer = null;
                fcn();
              };
              var deferred = function(timeout) {
                deferred.cancel();
                timer = setTimeout(callback, timeout || 0);
                return deferred;
              };
              deferred.schedule = deferred;
              deferred.call = function() {
                this.cancel();
                fcn();
                return deferred;
              };
              deferred.cancel = function() {
                clearTimeout(timer);
                timer = null;
                return deferred;
              };
              deferred.isPending = function() {
                return timer;
              };
              return deferred;
            };
            exports2.delayedCall = function(fcn, defaultTimeout) {
              var timer = null;
              var callback = function() {
                timer = null;
                fcn();
              };
              var _self = function(timeout) {
                if (timer == null)
                  timer = setTimeout(callback, timeout || defaultTimeout);
              };
              _self.delay = function(timeout) {
                timer && clearTimeout(timer);
                timer = setTimeout(callback, timeout || defaultTimeout);
              };
              _self.schedule = _self;
              _self.call = function() {
                this.cancel();
                fcn();
              };
              _self.cancel = function() {
                timer && clearTimeout(timer);
                timer = null;
              };
              _self.isPending = function() {
                return timer;
              };
              return _self;
            };
          }
        ),
        /***/
        552: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            /*
             * based on code from:
             *
             * @license RequireJS text 0.25.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
             * Available via the MIT or new BSD license.
             * see: http://github.com/jrburke/requirejs for details
             */
            var dom = __webpack_require__2(435);
            exports2.get = function(url, callback) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, true);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  callback(xhr.responseText);
                }
              };
              xhr.send(null);
            };
            exports2.loadScript = function(path, callback) {
              var head = dom.getDocumentHead();
              var s = document.createElement("script");
              s.src = path;
              head.appendChild(s);
              s.onload = s.onreadystatechange = function(_, isAbort) {
                if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
                  s = s.onload = s.onreadystatechange = null;
                  if (!isAbort)
                    callback();
                }
              };
            };
            exports2.qualifyURL = function(url) {
              var a = document.createElement("a");
              a.href = url;
              return a.href;
            };
          }
        ),
        /***/
        645: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            exports2.inherits = function(ctor, superCtor) {
              ctor.super_ = superCtor;
              ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                  value: ctor,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
            };
            exports2.mixin = function(obj, mixin) {
              for (var key in mixin) {
                obj[key] = mixin[key];
              }
              return obj;
            };
            exports2.implement = function(proto, mixin) {
              exports2.mixin(proto, mixin);
            };
          }
        ),
        /***/
        943: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            exports2.OS = {
              LINUX: "LINUX",
              MAC: "MAC",
              WINDOWS: "WINDOWS"
            };
            exports2.getOS = function() {
              if (exports2.isMac) {
                return exports2.OS.MAC;
              } else if (exports2.isLinux) {
                return exports2.OS.LINUX;
              } else {
                return exports2.OS.WINDOWS;
              }
            };
            var _navigator = typeof navigator == "object" ? navigator : {};
            var os = (/mac|win|linux/i.exec(_navigator.platform) || ["other"])[0].toLowerCase();
            var ua = _navigator.userAgent || "";
            var appName = _navigator.appName || "";
            exports2.isWin = os == "win";
            exports2.isMac = os == "mac";
            exports2.isLinux = os == "linux";
            exports2.isIE = appName == "Microsoft Internet Explorer" || appName.indexOf("MSAppHost") >= 0 ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]);
            exports2.isOldIE = exports2.isIE && exports2.isIE < 9;
            exports2.isGecko = exports2.isMozilla = ua.match(/ Gecko\/\d+/);
            exports2.isOpera = typeof opera == "object" && Object.prototype.toString.call(window.opera) == "[object Opera]";
            exports2.isWebKit = parseFloat(ua.split("WebKit/")[1]) || void 0;
            exports2.isChrome = parseFloat(ua.split(" Chrome/")[1]) || void 0;
            exports2.isEdge = parseFloat(ua.split(" Edge/")[1]) || void 0;
            exports2.isAIR = ua.indexOf("AdobeAIR") >= 0;
            exports2.isAndroid = ua.indexOf("Android") >= 0;
            exports2.isChromeOS = ua.indexOf(" CrOS ") >= 0;
            exports2.isIOS = /iPad|iPhone|iPod/.test(ua) && !window.MSStream;
            if (exports2.isIOS)
              exports2.isMac = true;
            exports2.isMobile = exports2.isIOS || exports2.isAndroid;
          }
        ),
        /***/
        481: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            var event = __webpack_require__2(631);
            var RenderLoop = function(onRender, win) {
              this.onRender = onRender;
              this.pending = false;
              this.changes = 0;
              this.$recursionLimit = 2;
              this.window = win || window;
              var _self = this;
              this._flush = function(ts) {
                _self.pending = false;
                var changes = _self.changes;
                if (changes) {
                  event.blockIdle(100);
                  _self.changes = 0;
                  _self.onRender(changes);
                }
                if (_self.changes) {
                  if (_self.$recursionLimit-- < 0)
                    return;
                  _self.schedule();
                } else {
                  _self.$recursionLimit = 2;
                }
              };
            };
            (function() {
              this.schedule = function(change) {
                this.changes = this.changes | change;
                if (this.changes && !this.pending) {
                  event.nextFrame(this._flush);
                  this.pending = true;
                }
              };
              this.clear = function(change) {
                var changes = this.changes;
                this.changes = 0;
                return changes;
              };
            }).call(RenderLoop.prototype);
            exports2.x = RenderLoop;
          }
        ),
        /***/
        745: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            var __webpack_unused_export__;
            var oop = __webpack_require__2(645);
            var dom = __webpack_require__2(435);
            var event = __webpack_require__2(631);
            var EventEmitter = __webpack_require__2(366).b;
            var MAX_SCROLL_H = 32768;
            var ScrollBar = function(parent) {
              this.element = dom.createElement("div");
              this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;
              this.inner = dom.createElement("div");
              this.inner.className = "ace_scrollbar-inner";
              this.inner.textContent = "\xA0";
              this.element.appendChild(this.inner);
              parent.appendChild(this.element);
              this.setVisible(false);
              this.skipEvent = false;
              event.addListener(this.element, "scroll", this.onScroll.bind(this));
              event.addListener(this.element, "mousedown", event.preventDefault);
            };
            (function() {
              oop.implement(this, EventEmitter);
              this.setVisible = function(isVisible) {
                this.element.style.display = isVisible ? "" : "none";
                this.isVisible = isVisible;
                this.coeff = 1;
              };
            }).call(ScrollBar.prototype);
            var VScrollBar = function(parent, renderer) {
              ScrollBar.call(this, parent);
              this.scrollTop = 0;
              this.scrollHeight = 0;
              renderer.$scrollbarWidth = this.width = dom.scrollbarWidth(parent.ownerDocument);
              this.inner.style.width = this.element.style.width = (this.width || 15) + 5 + "px";
              this.$minWidth = 0;
            };
            oop.inherits(VScrollBar, ScrollBar);
            (function() {
              this.classSuffix = "-v";
              this.onScroll = function() {
                if (!this.skipEvent) {
                  this.scrollTop = this.element.scrollTop;
                  if (this.coeff != 1) {
                    var h = this.element.clientHeight / this.scrollHeight;
                    this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
                  }
                  this._emit("scroll", { data: this.scrollTop });
                }
                this.skipEvent = false;
              };
              this.getWidth = function() {
                return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
              };
              this.setHeight = function(height) {
                this.element.style.height = height + "px";
              };
              this.setInnerHeight = /**
               * Sets the scroll height of the scroll bar, in pixels.
               * @param {Number} height The new scroll height
               **/
              this.setScrollHeight = function(height) {
                this.scrollHeight = height;
                if (height > MAX_SCROLL_H) {
                  this.coeff = MAX_SCROLL_H / height;
                  height = MAX_SCROLL_H;
                } else if (this.coeff != 1) {
                  this.coeff = 1;
                }
                this.inner.style.height = height + "px";
              };
              this.setScrollTop = function(scrollTop) {
                if (this.scrollTop != scrollTop) {
                  this.skipEvent = true;
                  this.scrollTop = scrollTop;
                  this.element.scrollTop = scrollTop * this.coeff;
                }
              };
            }).call(VScrollBar.prototype);
            var HScrollBar = function(parent, renderer) {
              ScrollBar.call(this, parent);
              this.scrollLeft = 0;
              this.height = renderer.$scrollbarWidth;
              this.inner.style.height = this.element.style.height = (this.height || 15) + 5 + "px";
            };
            oop.inherits(HScrollBar, ScrollBar);
            (function() {
              this.classSuffix = "-h";
              this.onScroll = function() {
                if (!this.skipEvent) {
                  this.scrollLeft = this.element.scrollLeft;
                  this._emit("scroll", { data: this.scrollLeft });
                }
                this.skipEvent = false;
              };
              this.getHeight = function() {
                return this.isVisible ? this.height : 0;
              };
              this.setWidth = function(width) {
                this.element.style.width = width + "px";
              };
              this.setInnerWidth = function(width) {
                this.inner.style.width = width + "px";
              };
              this.setScrollWidth = function(width) {
                this.inner.style.width = width + "px";
              };
              this.setScrollLeft = function(scrollLeft) {
                if (this.scrollLeft != scrollLeft) {
                  this.skipEvent = true;
                  this.scrollLeft = this.element.scrollLeft = scrollLeft;
                }
              };
            }).call(HScrollBar.prototype);
            __webpack_unused_export__ = VScrollBar;
            exports2.lc = VScrollBar;
            exports2.zy = HScrollBar;
            __webpack_unused_export__ = VScrollBar;
            __webpack_unused_export__ = HScrollBar;
          }
        ),
        /***/
        677: (
          /***/
          (module2, exports2, __webpack_require__2) => {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports3, module3) {
              "use strict";
              function bindKey(win, mac) {
                return {
                  win,
                  mac
                };
              }
              exports3.commands = [
                {
                  name: "selectAll",
                  bindKey: bindKey("Ctrl-A", "Command-A"),
                  exec: function(editor) {
                    editor.selectAll();
                  }
                },
                {
                  name: "centerselection",
                  bindKey: bindKey(null, "Ctrl-L"),
                  exec: function(editor) {
                    editor.centerSelection();
                  }
                },
                {
                  name: "closeOrlevelUp",
                  bindKey: bindKey("Left", "Left|Ctrl-B"),
                  exec: function(editor) {
                    editor.navigateLevelUp(true);
                  }
                },
                ,
                {
                  name: "levelUp",
                  bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-B"),
                  exec: function(editor) {
                    editor.navigateLevelUp();
                  }
                },
                {
                  name: "levelDown",
                  bindKey: bindKey("Right", "Right|Ctrl-F"),
                  exec: function(editor) {
                    editor.navigateLevelDown();
                  }
                },
                {
                  name: "goToStart",
                  editorKey: bindKey("Ctrl-Home", "Ctrl-Home"),
                  bindKey: bindKey("Home|Ctrl-Home", "Home|Ctrl-Home"),
                  exec: function(editor) {
                    editor.navigateStart();
                  }
                },
                {
                  name: "goToEnd",
                  editorKey: bindKey("Ctrl-End", "Ctrl-End"),
                  bindKey: bindKey("End|Ctrl-End", "End|Ctrl-End"),
                  exec: function(editor) {
                    editor.navigateEnd();
                  }
                },
                {
                  name: "closeAllFromSelected",
                  bindKey: bindKey("Ctrl-Left", "Ctrl-Left"),
                  exec: function(ed) {
                    ed.provider.close(ed.selection.getCursor(), true);
                  }
                },
                {
                  name: "openAllFromSelected",
                  bindKey: bindKey("Ctrl-Right", "Ctrl-Right"),
                  exec: function(ed) {
                    ed.provider.open(ed.selection.getCursor(), true);
                  }
                },
                {
                  name: "pageup",
                  bindKey: "Option-PageUp",
                  exec: function(editor) {
                    editor.scrollPageUp();
                  }
                },
                {
                  name: "gotopageup",
                  bindKey: "PageUp",
                  exec: function(editor) {
                    editor.gotoPageUp();
                  }
                },
                {
                  name: "pagedown",
                  bindKey: "Option-PageDown",
                  exec: function(editor) {
                    editor.scrollPageDown();
                  }
                },
                {
                  name: "gotopageDown",
                  bindKey: "PageDown",
                  exec: function(editor) {
                    editor.gotoPageDown();
                  }
                },
                {
                  name: "scrollup",
                  bindKey: bindKey("Ctrl-Up", null),
                  exec: function(e) {
                    e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight);
                  }
                },
                {
                  name: "scrolldown",
                  bindKey: bindKey("Ctrl-Down", null),
                  exec: function(e) {
                    e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight);
                  }
                },
                {
                  name: "insertstring",
                  exec: function(e, args) {
                    e.insertSting(args);
                  }
                },
                {
                  name: "goUp",
                  bindKey: bindKey("Up", "Up|Ctrl-P"),
                  exec: function(editor) {
                    editor.selection.moveSelection(-1);
                  }
                },
                {
                  name: "goDown",
                  bindKey: bindKey("Down", "Down|Ctrl-N"),
                  exec: function(editor) {
                    editor.selection.moveSelection(1);
                  }
                },
                {
                  name: "selectUp",
                  bindKey: bindKey("Shift-Up", "Shift-Up"),
                  exec: function(editor) {
                    editor.selection.moveSelection(-1, true);
                  }
                },
                {
                  name: "selectDown",
                  bindKey: bindKey("Shift-Down", "Shift-Down"),
                  exec: function(editor) {
                    editor.selection.moveSelection(1, true);
                  }
                },
                {
                  name: "selectToUp",
                  bindKey: bindKey("Ctrl-Up", "Ctrl-Up"),
                  exec: function(editor) {
                    editor.selection.moveSelection(-1, false, true);
                  }
                },
                {
                  name: "selectToDown",
                  bindKey: bindKey("Ctrl-Down", "Ctrl-Down"),
                  exec: function(editor) {
                    editor.selection.moveSelection(1, false, true);
                  }
                },
                {
                  name: "selectMoreUp",
                  bindKey: bindKey("Ctrl-Shift-Up", "Ctrl-Shift-Up"),
                  exec: function(editor) {
                    editor.selection.moveSelection(-1, true, true);
                  }
                },
                {
                  name: "selectMoreDown",
                  bindKey: bindKey("Ctrl-Shift-Down", "Ctrl-Shift-Down"),
                  exec: function(editor) {
                    editor.selection.moveSelection(1, true, true);
                  }
                },
                {
                  name: "rename",
                  bindKey: "F2",
                  exec: function(tree) {
                    tree.edit && tree.edit.startRename();
                  }
                },
                {
                  name: "chose",
                  bindKey: "Enter",
                  exec: function(tree) {
                    tree._emit("afterChoose");
                  }
                },
                {
                  name: "delete",
                  bindKey: "Delete",
                  exec: function(tree) {
                    tree._emit("delete");
                  }
                },
                {
                  name: "foldOther",
                  bindKey: bindKey("Alt-0", "Command-Option-0"),
                  exec: function(tree) {
                    tree.provider.close(tree.provider.root, true);
                    tree.reveal(tree.selection.getCursor());
                  }
                }
              ];
            }.call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          }
        ),
        /***/
        614: (
          /***/
          (module2, exports2, __webpack_require__2) => {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports3, module3) {
              "no use strict";
              var lang = __webpack_require__2(955);
              var oop = __webpack_require__2(645);
              var net = __webpack_require__2(552);
              var AppConfig = __webpack_require__2(845).o;
              module3.exports = exports3 = new AppConfig();
              var global = /* @__PURE__ */ function() {
                return this;
              }();
              var options = {
                packaged: false,
                workerPath: null,
                modePath: null,
                themePath: null,
                basePath: "",
                suffix: ".js",
                $moduleUrls: {}
              };
              exports3.get = function(key) {
                if (!options.hasOwnProperty(key))
                  throw new Error("Unknown config key: " + key);
                return options[key];
              };
              exports3.set = function(key, value) {
                if (!options.hasOwnProperty(key))
                  throw new Error("Unknown config key: " + key);
                options[key] = value;
              };
              exports3.all = function() {
                return lang.copyObject(options);
              };
              exports3.moduleUrl = function(name, component) {
                if (options.$moduleUrls[name])
                  return options.$moduleUrls[name];
                var parts = name.split("/");
                component = component || parts[parts.length - 2] || "";
                var base = parts[parts.length - 1].replace(component, "").replace(/(^[\-_])|([\-_]$)/, "");
                if (!base && parts.length > 1)
                  base = parts[parts.length - 2];
                var path = options[component + "Path"];
                if (path == null)
                  path = options.basePath;
                if (path && path.slice(-1) != "/")
                  path += "/";
                return path + component + "-" + base + this.get("suffix");
              };
              exports3.setModuleUrl = function(name, subst) {
                return options.$moduleUrls[name] = subst;
              };
              exports3.$loading = {};
              exports3.loadModule = function(moduleName, onLoad) {
                debugger;
              };
            }.call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          }
        ),
        /***/
        768: (
          /***/
          (module2, exports2, __webpack_require__2) => {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports3, module3) {
              exports3.isDark = false;
              exports3.cssClass = "ace_tree-light";
              exports3.cssText = __webpack_require__2(28);
              var dom = __webpack_require__2(435);
              dom.importCssString(exports3.cssText, exports3.cssClass);
            }.call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          }
        ),
        /***/
        950: (
          /***/
          (module2, exports2, __webpack_require__2) => {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports3, module3) {
              "use strict";
              var oop = __webpack_require__2(645);
              var Scrollable = __webpack_require__2(541);
              var dom = __webpack_require__2(435);
              var escapeHTML = __webpack_require__2(955).escapeHTML;
              var DataProvider = function(root) {
                this.rowHeight = 25;
                this.setRoot(root);
              };
              (function() {
                this.rowHeight = void 0;
                this.rowHeightInner = void 0;
                this.$indentSize = 10;
                oop.implement(this, Scrollable);
                this.$sortNodes = true;
                this.setRoot = function(root) {
                  if (Array.isArray(root))
                    root = {
                      items: root
                    };
                  this.root = root || {};
                  if (this.root.$depth == void 0) {
                    this.root.$depth = -1;
                  }
                  if (this.root.$depth < 0) {
                    this.visibleItems = [];
                    this.open(this.root);
                    this.visibleItems.unshift();
                  } else {
                    this.visibleItems = [
                      this.root
                    ];
                  }
                  this.$selectedNode = this.root;
                  this._signal("setRoot");
                  this._signal("change");
                };
                this.open = this.expand = function(node, deep, silent) {
                  if (typeof deep != "number")
                    deep = deep ? 100 : 0;
                  if (!node)
                    return;
                  var items = this.visibleItems;
                  if (this.isOpen(node) && (node !== this.root || items.length))
                    return;
                  var ch = this.getChildren(node);
                  if (this.loadChildren && this.shouldLoadChildren(node, ch)) {
                    var timer = setTimeout(function() {
                      node.status = "loading";
                      this._signal("change", node);
                    }.bind(this), 100);
                    this.loadChildren(node, function(err, ch2) {
                      clearTimeout(timer);
                      this.collapse(node, null, true);
                      node.status = "loaded";
                      if (!err)
                        this.expand(node, null, false);
                    }.bind(this));
                    this.setOpen(node, true);
                    return;
                  }
                  this.setOpen(node, true);
                  var i = items.indexOf(node);
                  if (!ch) {
                    this._signal("change", node);
                    return;
                  }
                  if (i === -1 && items.length || this.forceEmpty)
                    return;
                  ch = [
                    i + 1,
                    0
                  ].concat(ch);
                  items.splice.apply(items, ch);
                  for (var j = 2; j < ch.length; j++) {
                    var childNode = ch[j];
                    if (this.isOpen(childNode)) {
                      this.setOpen(childNode, false);
                      this.open(childNode, deep - 1, silent);
                    } else if (deep > 0) {
                      this.open(childNode, deep - 1, silent);
                    }
                  }
                  this.rows = items.length;
                  silent || this._signal("expand", node);
                };
                this.close = this.collapse = function(node, deep, silent) {
                  if (typeof deep != "number")
                    deep = deep ? 1e3 : 0;
                  var items = this.visibleItems;
                  var isRoot = node === this.root;
                  if (isRoot) {
                    this.setOpen(node, false);
                    if (deep) {
                      for (var i = 0; i < items.length; i++) {
                        var ch = items[i];
                        if (!ch.isRoot) {
                          if (this.isOpen(ch) && ch.$depth - node.$depth < deep) {
                            this.setOpen(ch, false);
                            silent || this._signal("collapse", ch);
                          }
                        }
                      }
                    }
                    items.length = 0;
                    if (isRoot)
                      this.open(this.root, 0, silent);
                    return;
                  }
                  if (!node || !this.isOpen(node))
                    return;
                  var i = items.indexOf(node);
                  if (i === -1)
                    return;
                  var thisDepth = node.$depth;
                  var deletecount = 0;
                  for (var t = i + 1; t < items.length; t++) {
                    if (items[t].$depth > thisDepth)
                      deletecount++;
                    else
                      break;
                  }
                  if (deep) {
                    for (var j = 0; j < deletecount; j++) {
                      var ch = items[j + i];
                      if (this.isOpen(ch) && ch.$depth - node.$depth < deep) {
                        this.setOpen(ch, false);
                        silent || this._signal("collapse", ch);
                      }
                    }
                  }
                  items.splice(i + 1, deletecount);
                  this.setOpen(node, false);
                  silent || this._signal("collapse", node);
                  if (isRoot)
                    this.open(this.root, 0, silent);
                };
                this.toggleNode = function(node, deep, silent) {
                  if (node && this.isOpen(node))
                    this.close(node, deep, silent);
                  else
                    this.open(node, deep, silent);
                };
                this.sort = function(children, compare) {
                  if (!compare) {
                    compare = alphanumCompare;
                  }
                  return children.sort(function(a, b) {
                    var aChildren = a.children || a.map;
                    var bChildren = b.children || b.map;
                    if (aChildren && !bChildren)
                      return -1;
                    if (!aChildren && bChildren)
                      return 1;
                    return compare(a.label || "", b.label || "");
                  });
                };
                this.setFilter = function(fn) {
                  this.$filterFn = fn;
                  this.setRoot(this.root);
                };
                this.getChildren = function(node) {
                  var children = node.children;
                  if (!children) {
                    if (node.status === "pending")
                      return;
                    if (node.map) {
                      children = Object.keys(node.map).map(function(key) {
                        var ch2 = node.map[key];
                        ch2.parent = node;
                        return ch2;
                      });
                    } else if (node.items) {
                      children = node.items;
                    }
                    if (children) {
                      node.children = children;
                    }
                  }
                  var ch = children && children[0] && children[0];
                  if (ch) {
                    var d = node.$depth + 1 || 0;
                    children.forEach(function(n) {
                      n.$depth = d;
                      n.parent = node;
                    });
                  }
                  if (this.$filterFn) {
                    children = children && children.filter(this.$filterFn);
                  }
                  if (this.$sortNodes && !node.$sorted) {
                    children && this.sort(children);
                  }
                  return children;
                };
                this.loadChildren = null;
                this.shouldLoadChildren = function(node, ch) {
                  return node.status === "pending";
                };
                this.hasChildren = function(node) {
                  if (node.children)
                    return node.children.length !== 0;
                  return node.map || node.status === "pending" || node.items && node.items.length;
                };
                this.findNodeByPath = function() {
                };
                this.getSibling = function(node, dir) {
                  if (!dir)
                    dir = 1;
                  var parent = node.parent;
                  var ch = this.getChildren(parent);
                  var pos = ch.indexOf(node);
                  return ch[pos + dir];
                };
                this.getNodeAtIndex = function(i) {
                  return this.visibleItems[i];
                };
                this.getIndexForNode = function(node) {
                  return this.visibleItems.indexOf(node);
                };
                this.getMinIndex = function() {
                  return 0;
                };
                this.getMaxIndex = function() {
                  return this.visibleItems.length - 1;
                };
                this.setOpen = function(node, val) {
                  return node.isOpen = val;
                };
                this.isOpen = function(node) {
                  return node.isOpen;
                };
                this.isVisible = function(node) {
                  return this.visibleItems.indexOf(node) !== -1;
                };
                this.isSelected = function(node) {
                  return node.isSelected;
                };
                this.setSelected = function(node, val) {
                  return node.isSelected = !!val;
                };
                this.isSelectable = function(node) {
                  return !node || !(node.noSelect || node.$depth < 0);
                };
                this.isAncestor = function(node, child) {
                  do {
                    if (child == node)
                      return true;
                  } while (child = child.parent);
                  return false;
                };
                this.setAttribute = function(node, name, value) {
                  node[name] = value;
                  this._signal("change", node);
                };
                this.getDataRange = function(rows, columns, callback) {
                  var view = this.visibleItems.slice(rows.start, rows.start + rows.length);
                  callback(null, view, false);
                  return view;
                };
                this.getRange = function(top, bottom) {
                  var start = Math.floor(top / this.rowHeight);
                  var end = Math.ceil(bottom / this.rowHeight) + 1;
                  var range = this.visibleItems.slice(start, end);
                  range.count = start;
                  range.size = this.rowHeight * range.count;
                  return range;
                };
                this.getTotalHeight = function(top, bottom) {
                  return this.rowHeight * this.visibleItems.length;
                };
                this.getNodePosition = function(node) {
                  var i = this.visibleItems.indexOf(node);
                  if (i == -1 && node && node.parent) {
                    i = this.visibleItems.indexOf(node.parent);
                  }
                  var top = i * this.rowHeight;
                  var height = this.rowHeight;
                  return {
                    top,
                    height
                  };
                };
                this.findItemAtOffset = function(offset, clip) {
                  var index = Math.floor(offset / this.rowHeight);
                  if (clip)
                    index = Math.min(Math.max(0, index), this.visibleItems.length - 1);
                  return this.visibleItems[index];
                };
                this.getIconHTML = function(node) {
                  return "";
                };
                this.getClassName = function(node) {
                  return (node.className || "") + (node.status == "loading" ? " loading" : "");
                };
                this.setClass = function(node, name, include) {
                  node.className = node.className || "";
                  dom.setCssClass(node, name, include);
                  this._signal("changeClass");
                };
                this.redrawNode = null;
                this.getCaptionHTML = function(node) {
                  return escapeHTML(node.label || node.name || (typeof node == "string" ? node : ""));
                };
                this.getContentHTML = null;
                this.getEmptyMessage = function() {
                  return this.emptyMessage || "";
                };
                this.getText = function(node) {
                  return node.label || node.name || "";
                };
                this.getRowIndent = function(node) {
                  return node.$depth;
                };
                this.hideAllNodes = function() {
                  this.visibleItems = [];
                  this.forceEmpty = true;
                  this.setRoot(this.root);
                };
                this.showAllNodes = function() {
                  this.forceEmpty = false;
                  this.setRoot(this.root);
                };
              }).call(DataProvider.prototype);
              function alphanumCompare(a, b) {
                var caseOrder = 0;
                for (var x = 0, l = Math.min(a.length, b.length); x < l; x++) {
                  var ch1 = a.charCodeAt(x);
                  var ch2 = b.charCodeAt(x);
                  if (ch1 < 58 && ch2 < 58 && ch1 > 47 && ch2 > 47) {
                    var num1 = 0, num2 = 0;
                    var n = x;
                    do {
                      num1 = 10 * num1 + (ch1 - 48);
                      ch1 = a.charCodeAt(++n);
                    } while (ch1 > 47 && ch1 < 58);
                    n = x;
                    do {
                      num2 = 10 * num2 + (ch2 - 48);
                      ch2 = b.charCodeAt(++n);
                    } while (ch2 > 47 && ch2 < 58);
                    if (num1 === num2)
                      x = n - 1;
                    else
                      return num1 - num2;
                  } else if (ch1 !== ch2) {
                    var ch1L = a[x].toLowerCase();
                    var ch2L = b[x].toLowerCase();
                    if (ch1L < ch2L)
                      return -1;
                    if (ch1L > ch2L)
                      return 1;
                    if (!caseOrder)
                      caseOrder = ch2 - ch1;
                  }
                }
                return caseOrder || a.length - b.length;
              }
              DataProvider.alphanumCompare = alphanumCompare;
              DataProvider.prototype.alphanumCompare = alphanumCompare;
              DataProvider.variableHeightRowMixin = function() {
                var reset = function() {
                  this.$cachedTotalHeight = 0;
                }.bind(this);
                this.on("collapse", reset);
                this.on("expand", reset);
                this.getNodePosition = function(node) {
                  var i = this.visibleItems.indexOf(node);
                  if (i == -1 && node && node.parent) {
                    i = this.visibleItems.indexOf(node.parent);
                  }
                  var items = this.visibleItems;
                  var top = 0, height = 0;
                  for (var index = 0; index < i; index++) {
                    height = this.getItemHeight(items[index], index);
                    top += height;
                  }
                  height = this.getItemHeight(items[i], i);
                  return {
                    top,
                    height
                  };
                };
                this.findIndexAtOffset = function(offset, clip) {
                  var items = this.visibleItems;
                  var top = 0, index = 0, l = items.length;
                  while (index < l) {
                    var height = this.getItemHeight(items[index], index);
                    top += height;
                    index++;
                    if (top >= offset) {
                      index--;
                      top -= height;
                      break;
                    }
                  }
                  if (clip)
                    index = Math.min(Math.max(0, index), items.length - 1);
                  return index;
                };
                this.findItemAtOffset = function(offset, clip) {
                  var index = this.findIndexAtOffset(offset, clip);
                  return this.visibleItems[index];
                };
                this.getItemHeight = function(node, index) {
                  return node.height || this.rowHeight;
                };
                this.getRange = function(top, bottom) {
                  var items = this.visibleItems;
                  var startH = 0, index = 0, l = items.length;
                  while (index < l) {
                    var height = this.getItemHeight(items[index], index);
                    startH += height;
                    index++;
                    if (startH >= top) {
                      index--;
                      startH -= height;
                      break;
                    }
                  }
                  index = Math.min(Math.max(0, index), items.length - 1);
                  var start = index;
                  var end = this.findIndexAtOffset(bottom, true) + 1;
                  var range = this.visibleItems.slice(start, end);
                  range.count = start;
                  range.size = startH;
                  return range;
                };
                this.getTotalHeight = function() {
                  if (!this.$cachedTotalHeight) {
                    var items = this.visibleItems;
                    var height = 0;
                    for (var index = 0; index < items.length; index++) {
                      height += this.getItemHeight(items[index], index);
                    }
                    this.$cachedTotalHeight = height;
                  }
                  return this.$cachedTotalHeight;
                };
              };
              module3.exports = DataProvider;
            }.call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          }
        ),
        /***/
        365: (
          /***/
          (module2, exports2, __webpack_require__2) => {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports3, module3) {
              "use strict";
              var oop = __webpack_require__2(645);
              var dom = __webpack_require__2(435);
              var lang = __webpack_require__2(955);
              var escapeHTML = lang.escapeHTML;
              var EventEmitter = __webpack_require__2(366).b;
              var Cells = function(parentEl) {
                this.element = dom.createElement("div");
                this.element.className = "ace_tree_layer ace_tree_cell-layer";
                parentEl.appendChild(this.element);
              };
              (function() {
                oop.implement(this, EventEmitter);
                this.config = {}, this.setDataProvider = function(provider) {
                  this.provider = provider;
                  if (provider)
                    this.update = provider.renderRow ? this.$customUpdate : this.$treeModeUpdate;
                };
                this.update = function(config) {
                };
                this.measureSizes = function() {
                  var domNode = this.element.firstChild;
                  if (domNode) {
                    this.provider.rowHeight = domNode.offsetHeight;
                    this.provider.rowHeightInner = domNode.clientHeight;
                  }
                };
                this.$treeModeUpdate = function(config) {
                  this.config = config;
                  var provider = this.provider;
                  var row, html = [], view = config.view, datarow;
                  var firstRow = config.firstRow, lastRow = config.lastRow + 1;
                  var hsize = "auto;", vsize = provider.rowHeightInner || provider.rowHeight;
                  for (row = firstRow; row < lastRow; row++) {
                    datarow = view[row - firstRow];
                    if (provider.getItemHeight)
                      vsize = provider.getItemHeight(datarow, row);
                    this.$renderRow(html, datarow, vsize, hsize, row);
                  }
                  if (firstRow <= 0 && lastRow <= 0) {
                    this.renderPlaceHolder(provider, html, config);
                  }
                  this.element.innerHTML = html.join("");
                  if (!vsize) {
                    this.measureSizes();
                  }
                };
                this.columnNode = function(datarow, column) {
                  return "<span class='tree-column " + (column.className || "") + "' style='" + (datarow.fullWidth ? "" : "width:" + column.$width + ";") + "'>";
                };
                this.getRowClass = function(datarow, row) {
                  var provider = this.provider;
                  return "tree-row " + (provider.isSelected(datarow) ? "selected " : "") + (provider.getClassName(datarow) || "") + (row & 1 ? " odd" : " even");
                };
                this.$renderRow = function(html, datarow, vsize, hsize, row) {
                  var provider = this.provider;
                  var columns = provider.columns;
                  var indent = provider.$indentSize;
                  html.push("<div style='height:" + vsize + "px;" + (columns ? "padding-right:" + columns.$fixedWidth : "") + "' class='" + this.getRowClass(datarow, row) + "'>");
                  if (!columns || columns[0].type == "tree") {
                    if (columns) {
                      html.push(this.columnNode(datarow, columns[0], row));
                    }
                    var depth = provider.getRowIndent(datarow);
                    html.push((depth ? "<span style='width:" + depth * indent + "px' class='tree-indent'></span>" : "") + "<span class='toggler " + (provider.hasChildren(datarow) ? provider.isOpen(datarow) ? "open" : "closed" : "empty") + "'></span>" + (provider.getCheckboxHTML ? provider.getCheckboxHTML(datarow) : "") + provider.getIconHTML(datarow) + (provider.getContentHTML ? provider.getContentHTML(datarow) : "<span class='caption' style='width: " + hsize + "px;height: " + vsize + "px'>" + provider.getCaptionHTML(datarow) + "</span>"));
                  }
                  if (columns) {
                    for (var col = columns[0].type == "tree" ? 1 : 0; col < columns.length; col++) {
                      var column = columns[col];
                      var rowStr = column.getHTML ? column.getHTML(datarow) : escapeHTML(column.getText(datarow) + "");
                      html.push("</span>" + this.columnNode(datarow, column, row) + rowStr);
                    }
                    html.push("</span>");
                  }
                  html.push("</div>");
                };
                this.$customUpdate = function(config) {
                  this.config = config;
                  var provider = this.provider;
                  var html = [];
                  var firstRow = config.firstRow, lastRow = config.lastRow + 1;
                  for (var row = firstRow; row < lastRow; row++) {
                    provider.renderRow(row, html, config);
                  }
                  if (firstRow <= 0 && lastRow <= 0) {
                    this.renderPlaceHolder(provider, html, config);
                  }
                  this.element.innerHTML = html.join("");
                };
                this.updateClasses = function(config) {
                  if (this.update == this.$customUpdate && !this.provider.updateNode)
                    return this.update(config);
                  this.config = config;
                  var provider = this.provider;
                  var row, view = config.view, datarow;
                  var firstRow = config.firstRow, lastRow = config.lastRow + 1;
                  var children = this.element.children;
                  if (children.length != lastRow - firstRow)
                    return this.update(config);
                  for (row = firstRow; row < lastRow; row++) {
                    datarow = view[row - firstRow];
                    var el = children[row - firstRow];
                    el.className = this.getRowClass(datarow, row);
                    if (provider.redrawNode)
                      provider.redrawNode(el, datarow);
                  }
                };
                this.scroll = function(config) {
                  return this.update(config);
                  this.element.insertAdjacentHTML("afterBegin", "<span>a</span><s>r</s>");
                  this.element.insertAdjacentHTML("beforeEnd", "<span>a</span><s>r</s>");
                };
                this.updateRows = function(config, firstRow, lastRow) {
                };
                this.destroy = function() {
                };
                this.getDomNodeAtIndex = function(i) {
                  return this.element.children[i - this.config.firstRow];
                };
                this.renderPlaceHolder = function(provider, html, config) {
                  if (provider.renderEmptyMessage) {
                    provider.renderEmptyMessage(html, config);
                  } else if (provider.getEmptyMessage) {
                    html.push("<div class='message empty'>", escapeHTML(provider.getEmptyMessage()), "</div>");
                  }
                };
              }).call(Cells.prototype);
              exports3.Cells = Cells;
            }.call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          }
        ),
        /***/
        86: (
          /***/
          (module2, exports2, __webpack_require__2) => {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports3, module3) {
              "use strict";
              var oop = __webpack_require__2(645);
              var dom = __webpack_require__2(435);
              var lang = __webpack_require__2(955);
              var EventEmitter = __webpack_require__2(366).b;
              var RESIZER_WIDTH = 3;
              function getColumnText(node) {
                return node[this.value] || this.defaultValue || "";
              }
              function ColumnHeader(parentEl, renderer) {
                this.element = dom.createElement("div");
                parentEl.appendChild(this.element);
                this.element.className = "tree-headings";
                this.visible = false;
              }
              (function() {
                this.minWidth = 25;
                this.update = function() {
                  if (!this.provider || !this.visible)
                    return;
                  var columns = this.provider.columns;
                  var html = [];
                  for (var i = 0; i < columns.length; i++) {
                    var col = columns[i];
                    html.push("<span class='tree-column " + (col.className || "") + "' style='width:" + col.$width + ";height:'>" + col.caption + "</span><span class='tree-column-resizer' ></span>");
                  }
                  this.element.style.paddingRight = columns.$fixedWidth;
                  this.element.innerHTML = html.join("");
                };
                this.setDataProvider = function(provider) {
                  this.provider = provider;
                  if (!provider)
                    return;
                  var columns = this.provider.columns;
                  if (!columns) {
                    this.visible = false;
                    return;
                  }
                  this.visible = true;
                  var fixedWidth = 0;
                  columns.forEach(function(col, i) {
                    col.index = i;
                    if (col.value && !col.getText)
                      col.getText = getColumnText;
                    var w = col.width;
                    if (typeof w == "string" && w.slice(-1) == "%") {
                      col.flex = parseInt(w, 10) / 100;
                      col.$width = col.width;
                    } else {
                      col.width = parseInt(w, 10) || this.minWidth;
                      fixedWidth += col.width;
                      col.$width = col.width + "px";
                    }
                    col.pixelWidth = 0;
                  }, this);
                  columns.fixedWidth = fixedWidth;
                  columns.$fixedWidth = fixedWidth + "px";
                  columns.width = null;
                  provider.columns = columns;
                };
                this.updateWidth = function(width) {
                  if (!this.provider || !this.visible)
                    return;
                  var columns = this.provider.columns;
                  var fixedWidth = 0;
                  columns.width = width;
                  columns.forEach(function(col) {
                    if (!col.flex) {
                      fixedWidth += col.width;
                    }
                  });
                  var flexWidth = width - fixedWidth;
                  columns.forEach(function(col) {
                    if (col.flex) {
                      col.pixelWidth = flexWidth * col.flex;
                      col.$width = col.flex * 100 + "%";
                    } else {
                      col.pixelWidth = col.width;
                      col.$width = col.width + "px";
                    }
                  });
                  columns.fixedWidth = fixedWidth;
                  columns.$fixedWidth = fixedWidth + "px";
                };
                this.changeColumnWidth = function(changedColumn, dw, total) {
                  this.updateWidth(total);
                  var columns = this.provider.columns;
                  var minWidth = this.minWidth;
                  if (!dw)
                    return;
                  var index = columns.indexOf(changedColumn);
                  var col, nextCol, prevCol;
                  for (var i = index + 1; i < columns.length; i++) {
                    col = columns[i];
                    if (Math.floor(col.pixelWidth) > minWidth || dw < 0) {
                      if (col.flex) {
                        nextCol = col;
                        break;
                      } else if (!nextCol) {
                        nextCol = col;
                      }
                    }
                  }
                  for (var i = index; i >= 0; i--) {
                    col = columns[i];
                    if (Math.floor(col.pixelWidth) > minWidth || dw > 0) {
                      if (col.flex) {
                        prevCol = col;
                        break;
                      } else if (!prevCol) {
                        prevCol = col;
                        if (col == changedColumn)
                          break;
                      }
                    }
                  }
                  if (!prevCol || !nextCol)
                    return;
                  if (nextCol.pixelWidth - dw < minWidth)
                    dw = nextCol.pixelWidth - minWidth;
                  if (prevCol.pixelWidth + dw < minWidth)
                    dw = minWidth - prevCol.pixelWidth;
                  nextCol.pixelWidth -= dw;
                  prevCol.pixelWidth += dw;
                  if (!nextCol.flex)
                    columns.fixedWidth -= dw;
                  if (!prevCol.flex)
                    columns.fixedWidth += dw;
                  var flexWidth = total - columns.fixedWidth;
                  columns.forEach(function(col2) {
                    if (col2.flex) {
                      col2.flex = col2.pixelWidth / flexWidth;
                    } else {
                      col2.width = col2.pixelWidth;
                    }
                  });
                  this.updateWidth(total);
                };
                this.findColumn = function(x) {
                  var columns = this.provider.columns;
                  if (this.element.offsetWidth != columns.width)
                    this.updateWidth(this.element.offsetWidth);
                  var w = 0;
                  for (var i = 0; i < columns.length; i++) {
                    var column = columns[i];
                    w += column.pixelWidth;
                    if (x < w + RESIZER_WIDTH) {
                      return {
                        index: i,
                        column,
                        overResizer: x > w - RESIZER_WIDTH
                      };
                    }
                  }
                };
              }).call(ColumnHeader.prototype);
              exports3.ColumnHeader = ColumnHeader;
            }.call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          }
        ),
        /***/
        611: (
          /***/
          (module2, exports2, __webpack_require__2) => {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports3, module3) {
              "use strict";
              var dom = __webpack_require__2(435);
              var Selection = function(parentEl, renderer) {
                this.element = dom.createElement("div");
                this.element.className = "ace_tree_layer ace_tree_selection-layer";
                parentEl.appendChild(this.element);
                this.renderer = renderer;
                this.markerEl = null;
                this.arrowEl = null;
              };
              (function() {
                this.setDataProvider = function(provider) {
                  this.provider = provider;
                };
                this.update = function(config) {
                  if (!this.provider.markedFolder || this.provider.markedFolderType) {
                    this.markerEl && this.clearFolderMarker();
                  } else {
                    this.showFolderMarker(config);
                  }
                  if (!this.provider.markedFolder || !this.provider.markedFolderType) {
                    this.arrowEl && this.clearInsertionMarker();
                  } else {
                    this.showInsertionMarker(config);
                  }
                };
                this.showFolderMarker = function(config) {
                  this.config = config;
                  var provider = this.provider;
                  var node = provider.markedFolder;
                  var start = provider.getIndexForNode(node);
                  var items = provider.visibleItems;
                  var end = start + 1;
                  var depth = node.$depth;
                  while (items[end] && items[end].$depth > depth) {
                    end++;
                  }
                  end--;
                  if (start > config.lastRow || end < config.firstRow || start === end) {
                    return this.clearFolderMarker();
                  }
                  start++;
                  end++;
                  var top = Math.max(start - config.firstRow, -1) * provider.rowHeight;
                  var left = (depth + 1) * provider.$indentSize;
                  var bottom = Math.min(end - config.firstRow, config.lastRow - config.firstRow + 2) * provider.rowHeight;
                  if (!this.markerEl) {
                    this.markerEl = dom.createElement("div");
                    this.markerEl.className = "dragHighlight";
                    this.element.appendChild(this.markerEl);
                  }
                  this.markerEl.style.top = top + "px";
                  this.markerEl.style.left = left + "px";
                  this.markerEl.style.right = "7px";
                  this.markerEl.style.height = bottom - top + "px";
                };
                this.showInsertionMarker = function(config) {
                  this.config = config;
                  var provider = this.provider;
                  var node = provider.markedFolder;
                  var type = this.provider.markedFolderType;
                  var start = provider.getIndexForNode(node);
                  var depth = node.$depth;
                  if (start > config.lastRow || start < config.firstRow) {
                    return this.clearInsertionMarker();
                  }
                  if (type == 1)
                    start++;
                  var top = Math.max(start - config.firstRow, -1) * provider.rowHeight;
                  var left = (depth + 1) * provider.$indentSize;
                  if (!this.arrowEl) {
                    this.arrowEl = dom.createElement("div");
                    this.arrowEl.className = "dragArrow";
                    this.element.appendChild(this.arrowEl);
                  }
                  this.arrowEl.style.top = top + "px";
                  this.arrowEl.style.left = left + "px";
                  this.arrowEl.style.right = "7px";
                };
                this.clearFolderMarker = function() {
                  if (this.markerEl) {
                    this.markerEl.parentNode.removeChild(this.markerEl);
                    this.markerEl = null;
                  }
                };
                this.clearInsertionMarker = function() {
                  if (this.arrowEl) {
                    this.arrowEl.parentNode.removeChild(this.arrowEl);
                    this.arrowEl = null;
                  }
                };
                this.clear = function() {
                  this.clearFolderMarker();
                  this.clearInsertMarker();
                };
                this.destroy = function() {
                };
              }).call(Selection.prototype);
              exports3.Selection = Selection;
            }.call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          }
        ),
        /***/
        127: (
          /***/
          (module2, exports2, __webpack_require__2) => {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports3, module3) {
              "use strict";
              var dom = __webpack_require__2(435);
              var DRAG_OFFSET = 5;
              function DefaultHandlers(mouseHandler) {
                mouseHandler.$clickSelection = null;
                var editor = mouseHandler.editor;
                editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
                editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
                editor.setDefaultHandler("mouseleave", this.onMouseLeave.bind(mouseHandler));
                editor.setDefaultHandler("mousemove", this.onMouseMove.bind(mouseHandler));
                editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
                editor.setDefaultHandler("mouseup", this.onMouseUp.bind(mouseHandler));
                editor.setDefaultHandler("click", this.onClick.bind(mouseHandler));
                var exports4 = [
                  "dragMoveSelection",
                  "dragWait",
                  "dragWaitEnd",
                  "getRegion",
                  "updateHoverState"
                ];
                exports4.forEach(function(x) {
                  mouseHandler[x] = this[x];
                }, this);
              }
              (function() {
                function isTogglerClick(target) {
                  return dom.hasCssClass(target, "toggler") && !dom.hasCssClass(target, "empty");
                }
                this.onMouseMove = function(e) {
                  var editor = this.editor;
                  var node = e.getNode();
                  var title, provider = editor.provider;
                  if (!node) {
                    title = "";
                  } else if (provider.columns) {
                    var pos = e.getDocumentPosition();
                    var columnData = editor.renderer.$headingLayer.findColumn(pos.x);
                    title = columnData ? columnData.column.getText(node) : "";
                  } else {
                    title = provider.getTooltipText ? provider.getTooltipText(node) : provider.getText(node);
                  }
                  if (!editor.tooltip && editor.container.title != title)
                    editor.container.title = title;
                  this.updateHoverState(node);
                };
                this.onMouseLeave = function() {
                  this.updateHoverState(null);
                };
                this.updateHoverState = function(node) {
                  var provider = this.editor.provider;
                  if (node !== this.node && provider) {
                    if (this.node)
                      provider.setClass(this.node, "hover", false);
                    this.node = node;
                    if (this.node)
                      provider.setClass(this.node, "hover", true);
                  }
                };
                this.onMouseDown = function(ev) {
                  var editor = this.editor;
                  var provider = editor.provider;
                  ev.detail = 1;
                  this.mousedownEvent = ev;
                  this.delayedSelect = false;
                  this.isMousePressed = true;
                  var button = ev.getButton();
                  var selectedNodes = editor.selection.getSelectedNodes();
                  var isMultiSelect = selectedNodes.length > 1;
                  if (button !== 0 && isMultiSelect) {
                    return;
                  }
                  var node = ev.getNode();
                  this.$clickNode = node;
                  if (!node)
                    return;
                  var inSelection = provider.isSelected(node);
                  var target = ev.domEvent.target;
                  this.region = null;
                  if (isTogglerClick(target) || node.clickAction == "toggle") {
                    this.region = "toggler";
                    var toggleChildren = ev.getShiftKey();
                    var deep = ev.getAccelKey();
                    if (button === 0) {
                      if (toggleChildren) {
                        if (deep) {
                          node = node.parent;
                        }
                        provider.close(node, true);
                        provider.open(node);
                      } else {
                        provider.toggleNode(node, deep);
                      }
                    }
                    this.$clickNode = null;
                  } else if (dom.hasCssClass(target, "checkbox")) {
                    var nodes = inSelection && editor.selection.getSelectedNodes();
                    provider._signal("toggleCheckbox", {
                      target: node,
                      selectedNodes: nodes
                    });
                    node.isChecked = !node.isChecked;
                    if (nodes) {
                      nodes.forEach(function(n) {
                        n.isChecked = node.isChecked;
                      });
                    }
                    provider._signal(node.isChecked ? "check" : "uncheck", nodes || [
                      node
                    ]);
                    provider._signal("change");
                  } else if (dom.hasCssClass(target, "icon-ok")) {
                    if (ev.getShiftKey()) {
                      editor.selection.expandSelection(node, null, true);
                    } else {
                      editor.selection.toggleSelect(node);
                    }
                  } else if (ev.getAccelKey()) {
                    if (inSelection && isMultiSelect)
                      this.delayedSelect = "toggle";
                    else if (!inSelection || isMultiSelect)
                      editor.selection.toggleSelect(node);
                  } else if (ev.getShiftKey()) {
                    editor.selection.expandSelection(node);
                  } else if (inSelection && isMultiSelect) {
                    if (!editor.isFocused())
                      this.$clickNode = null;
                    else
                      this.delayedSelect = true;
                  } else {
                    editor.selection.setSelection(node);
                  }
                  if (this.$clickNode)
                    editor.$mouseHandler.captureMouse(ev, "dragWait");
                  return ev.preventDefault();
                };
                this.onMouseUp = function(ev) {
                  if (this.isMousePressed == 2)
                    return;
                  this.isMousePressed = false;
                  var pos = ev.getDocumentPosition();
                  var node = this.editor.provider.findItemAtOffset(pos.y);
                  if (node && this.$clickNode && this.$clickNode == node) {
                    ev.button = ev.getButton();
                    ev.target = ev.domEvent.target;
                    ev.detail = this.mousedownEvent.detail;
                    this.onMouseEvent("click", ev);
                  }
                  this.$clickNode = this.mouseEvent = null;
                };
                this.onClick = function(ev) {
                  if (this.mousedownEvent.detail === 2) {
                    this.editor._emit("afterChoose");
                  }
                };
                this.onDoubleClick = function(ev) {
                  var provider = this.editor.provider;
                  if (provider.toggleNode && !isTogglerClick(ev.domEvent.target)) {
                    var node = ev.getNode();
                    if (node)
                      provider.toggleNode(node);
                  }
                  if (this.mousedownEvent)
                    this.mousedownEvent.detail = 2;
                };
                this.dragMoveSelection = function() {
                  var editor = this.editor;
                  var ev = this.mouseEvent;
                  ev.$pos = ev.node = null;
                  var node = ev.getNode(true);
                  if (node != editor.selection.getCursor() && node) {
                    if (ev.getShiftKey()) {
                      editor.selection.expandSelection(node, null, true);
                    } else {
                      editor.selection.selectNode(node);
                    }
                    editor.renderer.scrollCaretIntoView();
                  }
                };
                this.dragWait = function() {
                  var ev = this.mousedownEvent;
                  if (Math.abs(this.x - ev.x) + Math.abs(this.y - ev.y) > DRAG_OFFSET) {
                    this.delayedSelect = false;
                    this.editor._emit("startDrag", ev);
                    if (this.state == "dragWait" && ev.getButton() === 0)
                      this.setState("dragMoveSelection");
                  }
                };
                this.dragWaitEnd = function() {
                  if (this.delayedSelect) {
                    var selection = this.editor.selection;
                    if (this.$clickNode) {
                      if (this.delayedSelect == "toggle")
                        selection.toggleSelect(this.$clickNode);
                      else
                        selection.setSelection(this.$clickNode);
                    }
                    this.delayedSelect = false;
                  }
                };
                this.onMouseWheel = function(ev) {
                  if (ev.getShiftKey() || ev.getAccelKey())
                    return;
                  var t = ev.domEvent.timeStamp;
                  var dt = t - (this.$lastScrollTime || 0);
                  var editor = this.editor;
                  var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                  if (isScrolable || dt < 200) {
                    this.$lastScrollTime = t;
                    editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                    return ev.stop();
                  }
                };
              }).call(DefaultHandlers.prototype);
              exports3.DefaultHandlers = DefaultHandlers;
            }.call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          }
        ),
        /***/
        513: (
          /***/
          (module2, exports2, __webpack_require__2) => {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports3, module3) {
              "use strict";
              var event = __webpack_require__2(631);
              var useragent = __webpack_require__2(943);
              var DefaultHandlers = __webpack_require__2(127).DefaultHandlers;
              var MouseEvent = __webpack_require__2(118).MouseEvent;
              var config = __webpack_require__2(614);
              var dom = __webpack_require__2(435);
              function initDragHandlers(mouseHandler) {
                var tree = mouseHandler.editor;
                var UNFOLD_TIMEOUT = 500;
                var WIDGET_UNFOLD_TIMEOUT = 500;
                var AUTOSCROLL_DELAY = 300;
                var MIN_DRAG_T = 500;
                var dragInfo, x, y, dx, dy;
                var scrollerRect;
                mouseHandler.drag = function() {
                  var ev = this.mouseEvent;
                  if (!dragInfo || !ev)
                    return;
                  var node = ev.getNode();
                  dx = ev.x - x;
                  dy = ev.y - y;
                  x = ev.x;
                  y = ev.y;
                  var isInTree = isInRect(x, y, scrollerRect);
                  if (!isInTree) {
                    node = null;
                  }
                  if (dragInfo.isInTree != isInTree && dragInfo.selectedNodes) {
                    dragInfo.isInTree = isInTree;
                    ev.dragInfo = dragInfo;
                    tree._signal(isInTree ? "dragIn" : "dragOut", ev);
                  }
                  if (!isInTree) {
                    ev.dragInfo = dragInfo;
                    tree._signal("dragMoveOutside", ev);
                  }
                  if (dragInfo.el) {
                    dragInfo.el.style.top = ev.y - dragInfo.offsetY + "px";
                    dragInfo.el.style.left = ev.x - dragInfo.offsetX + "px";
                  }
                  var hoverNode = node;
                  if (hoverNode) {
                    var xOffset = x - scrollerRect.left;
                    var depth = Math.max(0, Math.floor(xOffset / tree.provider.$indentSize));
                    var depthDiff = hoverNode.$depth - depth;
                    while (depthDiff > 0 && hoverNode.parent) {
                      depthDiff--;
                      hoverNode = hoverNode.parent;
                    }
                    if (!hoverNode.isFolder && dragInfo.mode != "sort") {
                      hoverNode = hoverNode.parent;
                    }
                  }
                  if (dragInfo.hoverNode !== hoverNode) {
                    if (dragInfo.hoverNode) {
                      tree.provider.setClass(dragInfo.hoverNode, "dropTarget", false);
                      tree._signal("folderDragLeave", dragInfo);
                    }
                    if (hoverNode && dragInfo.selectedNodes && dragInfo.selectedNodes.indexOf(hoverNode) != -1) {
                      hoverNode = null;
                    }
                    dragInfo.hoverNode = hoverNode;
                    if (dragInfo.hoverNode) {
                      tree._signal("folderDragEnter", dragInfo);
                      if (dragInfo.mode !== "sort")
                        tree.provider.setClass(dragInfo.hoverNode, "dropTarget", true);
                    }
                    highlightFolder(tree, dragInfo.hoverNode, dragInfo.insertPos);
                  }
                  var now = Date.now();
                  var target = ev.domEvent.target;
                  var isFoldWidget = target && dom.hasCssClass(target, "toggler") && !dom.hasCssClass(target, "empty");
                  var distance = Math.abs(dx) + Math.abs(dy);
                  var pos = ev.y - scrollerRect.top;
                  var rowHeight = tree.provider.rowHeight;
                  var renderer = tree.renderer;
                  var autoScrollMargin = 1.5 * rowHeight;
                  var scroll = pos - autoScrollMargin;
                  if (scroll > 0) {
                    scroll += -renderer.$size.scrollerHeight + 2 * autoScrollMargin;
                    if (scroll < 0)
                      scroll = 0;
                  }
                  if (!scroll || !isInTree)
                    dragInfo.autoScroll = false;
                  if (distance <= 2) {
                    if (!dragInfo.stopTime)
                      dragInfo.stopTime = now;
                  } else {
                    if (!isFoldWidget)
                      dragInfo.stopTime = void 0;
                  }
                  var dt = now - dragInfo.stopTime;
                  if (scroll && isInTree) {
                    if (dt > AUTOSCROLL_DELAY || dragInfo.autoScroll) {
                      tree.renderer.scrollBy(0, scroll / 2);
                      dragInfo.autoScroll = true;
                    }
                  } else if (node && dragInfo.mode === "move") {
                    if (node.parent === tree.provider.root || node.isRoot || node.parent && node.parent.isRoot)
                      isFoldWidget = false;
                    if (isFoldWidget && dt > WIDGET_UNFOLD_TIMEOUT && dt < 2 * WIDGET_UNFOLD_TIMEOUT) {
                      tree.provider.toggleNode(node);
                      dragInfo.stopTime = Infinity;
                    } else if (!isFoldWidget && dt > UNFOLD_TIMEOUT && dt < 2 * UNFOLD_TIMEOUT) {
                      tree.provider.open(node);
                      dragInfo.stopTime = Infinity;
                    }
                  }
                };
                mouseHandler.dragEnd = function(e, cancel) {
                  if (dragInfo) {
                    window.removeEventListener("mousedown", keyHandler, true);
                    window.removeEventListener("keydown", keyHandler, true);
                    window.removeEventListener("keyup", keyHandler, true);
                    if (dragInfo.el && dragInfo.el.parentNode)
                      dragInfo.el.parentNode.removeChild(dragInfo.el);
                    if (dragInfo.hoverNode) {
                      tree.provider.setClass(dragInfo.hoverNode, "dropTarget", false);
                      tree._signal("folderDragLeave", dragInfo);
                    }
                    highlightFolder(tree, null);
                    if (tree.isFocused())
                      tree.renderer.visualizeFocus();
                    tree.renderer.setStyle("dragOver", false);
                    dragInfo.target = dragInfo.hoverNode;
                    if (!cancel && dragInfo.selectedNodes && Date.now() - dragInfo.startT > MIN_DRAG_T)
                      tree._emit("drop", dragInfo);
                    if (!dragInfo.isInTree) {
                      if (cancel)
                        dragInfo.selectedNodes = null;
                      tree._signal("dropOutside", {
                        dragInfo
                      });
                    }
                    dragInfo = null;
                  }
                };
                mouseHandler.dragStart = function() {
                  if (dragInfo)
                    this.dragEnd(null, true);
                  mouseHandler.setState("drag");
                  tree.renderer.visualizeBlur();
                  tree.renderer.setStyle("dragOver", true);
                  scrollerRect = tree.renderer.scroller.getBoundingClientRect();
                  dragInfo = {};
                };
                tree.on("startDrag", function(ev) {
                  if (!tree.getOption("enableDragDrop"))
                    return;
                  var node = ev.getNode();
                  if (!node || ev.getButton())
                    return;
                  mouseHandler.dragStart();
                  window.addEventListener("mousedown", keyHandler, true);
                  window.addEventListener("keydown", keyHandler, true);
                  window.addEventListener("keyup", keyHandler, true);
                  var selectedNodes = tree.selection.getSelectedNodes();
                  var el = constructDragNode(node);
                  dragInfo = {
                    el,
                    node,
                    selectedNodes,
                    offsetX: 10,
                    offsetY: 10,
                    target: node,
                    startT: Date.now(),
                    isInTree: true,
                    mode: "move"
                  };
                  ev.dragInfo = dragInfo;
                  tree._signal("dragStarted", ev);
                  if (mouseHandler.state == "drag")
                    mouseHandler.drag();
                });
                function constructDragNode(node) {
                  var i = tree.provider.getIndexForNode(node);
                  var domNode = tree.renderer.$cellLayer.getDomNodeAtIndex(i);
                  if (!domNode)
                    return;
                  var offset = domNode.offsetHeight;
                  var selectedNodes = tree.selection.getSelectedNodes();
                  var el = document.createElement("div");
                  el.className = tree.container.className + " dragImage";
                  var ch = el.appendChild(domNode.cloneNode(true));
                  ch.removeChild(ch.firstChild);
                  ch.style.paddingRight = "5px";
                  ch.style.opacity = "0.8";
                  el.style.position = "absolute";
                  el.style.zIndex = "1000000";
                  el.style.pointerEvents = "none";
                  el.style.overflow = "visible";
                  if (selectedNodes.length > 1) {
                    ch.style.color = "transparent";
                    ch = el.appendChild(domNode.cloneNode(true));
                    ch.removeChild(ch.firstChild);
                    ch.style.paddingRight = "5px";
                    ch.style.top = -offset + 2 + "px";
                    ch.style.left = "2px";
                    ch.style.position = "relative";
                    ch.style.opacity = "0.8";
                  }
                  document.body.appendChild(el);
                  return el;
                }
                function keyHandler(e) {
                  if (dragInfo) {
                    if (e.keyCode === 27 || e.type == "mousedown") {
                      mouseHandler.dragEnd(null, true);
                      event.stopEvent(e);
                    } else if (dragInfo && e.keyCode == 17 || e.keyCode == 18) {
                      dragInfo.isCopy = e.type == "keydown";
                      dom.setCssClass(dragInfo.el, "copy", dragInfo.isCopy);
                    }
                  }
                }
              }
              function highlightFolder(tree, node, type) {
                tree.provider.markedFolder = node;
                tree.provider.markedFolderType = type;
                tree.renderer.$loop.schedule(tree.renderer.CHANGE_MARKER);
              }
              function isInRect(x, y, rect) {
                if (x < rect.right && x > rect.left && y > rect.top && y < rect.bottom)
                  return true;
              }
              module3.exports = initDragHandlers;
            }.call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          }
        ),
        /***/
        543: (
          /***/
          (module2, exports2, __webpack_require__2) => {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports3, module3) {
              "use strict";
              var event = __webpack_require__2(631);
              function HeadingHandler(mouseHandler) {
                var editor = mouseHandler.editor;
                var headingLayer = editor.renderer.$headingLayer;
                event.addListener(headingLayer.element, "mousedown", mouseHandler.onMouseEvent.bind(mouseHandler, "headerMouseDown"));
                event.addListener(headingLayer.element, "mousemove", mouseHandler.onMouseEvent.bind(mouseHandler, "headerMouseMove"));
                var overResizer, dragStartPos, columnData;
                editor.setDefaultHandler("headerMouseMove", function(e) {
                  if (dragStartPos || !editor.provider || !editor.provider.columns)
                    return;
                  var pos = e.getDocumentPosition();
                  var width = editor.renderer.$size.scrollerWidth;
                  if (width != editor.provider.columns.width)
                    headingLayer.updateWidth(width);
                  columnData = headingLayer.findColumn(pos.x);
                  overResizer = columnData && columnData.overResizer;
                  headingLayer.element.style.cursor = overResizer ? "ew-resize" : "default";
                });
                editor.setDefaultHandler("headerMouseDown", function(e) {
                  if (overResizer) {
                    var pos = e.getDocumentPosition();
                    dragStartPos = {
                      x: pos.x
                    };
                    mouseHandler.setState("headerResize");
                    mouseHandler.captureMouse(e);
                    mouseHandler.mouseEvent = e;
                  }
                  e.stop();
                });
                mouseHandler.headerResize = function() {
                  if (this.mouseEvent && dragStartPos) {
                    var pos = this.mouseEvent.getDocumentPosition();
                    var dx = pos.x;
                    var columns = editor.renderer.provider.columns;
                    for (var i = 0; i < columns.length; i++) {
                      var col = columns[i];
                      dx -= col.pixelWidth;
                      if (col === columnData.column)
                        break;
                    }
                    var total = editor.renderer.$size.scrollerWidth;
                    headingLayer.changeColumnWidth(columnData.column, dx, total);
                    var renderer = editor.renderer;
                    renderer.updateFull();
                  }
                };
                mouseHandler.headerResizeEnd = function() {
                  dragStartPos = null;
                  headingLayer.element.style.cursor = "";
                  overResizer = false;
                };
              }
              exports3.HeadingHandler = HeadingHandler;
            }.call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          }
        ),
        /***/
        118: (
          /***/
          (module2, exports2, __webpack_require__2) => {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports3, module3) {
              "use strict";
              var event = __webpack_require__2(631);
              var useragent = __webpack_require__2(943);
              var MouseEvent = exports3.MouseEvent = function(domEvent, editor) {
                this.domEvent = domEvent;
                this.editor = editor;
                this.x = this.clientX = domEvent.clientX;
                this.y = this.clientY = domEvent.clientY;
                this.$pos = null;
                this.$inSelection = null;
                this.propagationStopped = false;
                this.defaultPrevented = false;
              };
              (function() {
                this.stopPropagation = function() {
                  event.stopPropagation(this.domEvent);
                  this.propagationStopped = true;
                };
                this.preventDefault = function() {
                  event.preventDefault(this.domEvent);
                  this.defaultPrevented = true;
                };
                this.stop = function() {
                  this.stopPropagation();
                  this.preventDefault();
                };
                this.getDocumentPosition = function() {
                  if (this.$pos)
                    return this.$pos;
                  this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
                  return this.$pos;
                };
                this.inSelection = function() {
                  if (this.$inSelection !== null)
                    return this.$inSelection;
                  var node = this.getNode();
                  this.$inSelection = !!(node && node.isSelected);
                  return this.$inSelection;
                };
                this.node = null;
                this.getNode = function(clip) {
                  if (this.node)
                    return this.node;
                  var pos = this.getDocumentPosition(clip);
                  if (!pos || !this.editor.provider)
                    return;
                  return this.node = this.editor.provider.findItemAtOffset(pos.y, clip);
                };
                this.getButton = function() {
                  return event.getButton(this.domEvent);
                };
                this.getShiftKey = function() {
                  return this.domEvent.shiftKey;
                };
                this.getAccelKey = useragent.isMac ? function() {
                  return this.domEvent.metaKey;
                } : function() {
                  return this.domEvent.ctrlKey;
                };
              }).call(MouseEvent.prototype);
            }.call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          }
        ),
        /***/
        202: (
          /***/
          (module2, exports2, __webpack_require__2) => {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports3, module3) {
              "use strict";
              var event = __webpack_require__2(631);
              var useragent = __webpack_require__2(943);
              var DefaultHandlers = __webpack_require__2(127).DefaultHandlers;
              var initDragHandlers = __webpack_require__2(513);
              var HeadingHandler = __webpack_require__2(543).HeadingHandler;
              var MouseEvent = __webpack_require__2(118).MouseEvent;
              var config = __webpack_require__2(614);
              var MouseHandler = function(editor) {
                this.editor = editor;
                new DefaultHandlers(this);
                new HeadingHandler(this);
                initDragHandlers(this);
                var mouseTarget = editor.renderer.getMouseEventTarget();
                event.addListener(mouseTarget, "mousedown", function(e) {
                  editor.focus(true);
                  return event.preventDefault(e);
                });
                event.addListener(mouseTarget, "mousemove", this.onMouseEvent.bind(this, "mousemove"));
                event.addListener(mouseTarget, "mouseup", this.onMouseEvent.bind(this, "mouseup"));
                event.addMultiMouseDownListener(mouseTarget, [
                  300,
                  300,
                  250
                ], this, "onMouseEvent");
                event.addMultiMouseDownListener(editor.renderer.scrollBarV.inner, [
                  300,
                  300,
                  250
                ], this, "onMouseEvent");
                event.addMultiMouseDownListener(editor.renderer.scrollBarH.inner, [
                  300,
                  300,
                  250
                ], this, "onMouseEvent");
                event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));
                event.addListener(mouseTarget, "mouseout", this.onMouseEvent.bind(this, "mouseleave"));
              };
              (function() {
                this.onMouseEvent = function(name, e) {
                  this.editor._emit(name, new MouseEvent(e, this.editor));
                };
                this.onMouseWheel = function(name, e) {
                  var mouseEvent = new MouseEvent(e, this.editor);
                  mouseEvent.speed = this.$scrollSpeed * 2;
                  mouseEvent.wheelX = e.wheelX;
                  mouseEvent.wheelY = e.wheelY;
                  this.editor._emit(name, mouseEvent);
                };
                this.setState = function(state) {
                  this.state = state;
                };
                this.captureMouse = function(ev, state) {
                  if (state)
                    this.setState(state);
                  this.x = ev.x;
                  this.y = ev.y;
                  this.isMousePressed = 2;
                  var renderer = this.editor.renderer;
                  if (renderer.$keepTextAreaAtCursor)
                    renderer.$keepTextAreaAtCursor = null;
                  var self = this;
                  var onMouseMove = function(e) {
                    self.x = e.clientX;
                    self.y = e.clientY;
                    self.mouseEvent = new MouseEvent(e, self.editor);
                    self.$mouseMoved = true;
                  };
                  var onCaptureEnd = function(e) {
                    clearInterval(timerId);
                    onCaptureInterval();
                    self[self.state + "End"] && self[self.state + "End"](e);
                    self.$clickSelection = null;
                    if (renderer.$keepTextAreaAtCursor == null) {
                      renderer.$keepTextAreaAtCursor = true;
                      renderer.$moveTextAreaToCursor();
                    }
                    self.isMousePressed = false;
                    e && self.onMouseEvent("mouseup", e);
                    self.$onCaptureMouseMove = self.releaseMouse = null;
                  };
                  var onCaptureInterval = function() {
                    self[self.state] && self[self.state]();
                    self.$mouseMoved = false;
                  };
                  if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
                    return setTimeout(function() {
                      onCaptureEnd(ev.domEvent);
                    });
                  }
                  self.$onCaptureMouseMove = onMouseMove;
                  self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
                  var timerId = setInterval(onCaptureInterval, 20);
                };
                this.releaseMouse = null;
              }).call(MouseHandler.prototype);
              config.defineOptions(MouseHandler.prototype, "mouseHandler", {
                scrollSpeed: {
                  initialValue: 2
                },
                dragDelay: {
                  initialValue: 150
                },
                focusTimeout: {
                  initialValue: 0
                },
                enableDragDrop: {
                  initialValue: false
                }
              });
              exports3.MouseHandler = MouseHandler;
            }.call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          }
        ),
        /***/
        277: (
          /***/
          (module2, exports2, __webpack_require__2) => {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports3, module3) {
              "use strict";
              var quickSearch = function(tree, str) {
                var node = tree.selection.getCursor();
                var siblings = tree.provider.getChildren(node.parent);
                if (!siblings || siblings.length == 1) {
                  return;
                }
                var index = siblings.indexOf(node);
                var newNode;
                for (var i = index + 1; i < siblings.length; i++) {
                  node = siblings[i];
                  var label = node.label || node.name || "";
                  if (label[0] == str) {
                    newNode = node;
                    break;
                  }
                }
                if (!newNode) {
                  for (var i = 0; i < index; i++) {
                    node = siblings[i];
                    var label = node.label || node.name || "";
                    if (label[0] == str) {
                      newNode = node;
                      break;
                    }
                  }
                }
                if (newNode) {
                  tree.selection.selectNode(newNode);
                  tree.renderer.scrollCaretIntoView(newNode, 0.5);
                }
              };
              module3.exports = quickSearch;
            }.call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          }
        ),
        /***/
        541: (
          /***/
          (module2, exports2, __webpack_require__2) => {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports3, module3) {
              "use strict";
              var oop = __webpack_require__2(645);
              var EventEmitter = __webpack_require__2(366).b;
              var scrollable = {};
              (function() {
                oop.implement(this, EventEmitter);
                this.$scrollTop = 0;
                this.getScrollTop = function() {
                  return this.$scrollTop;
                };
                this.setScrollTop = function(scrollTop) {
                  scrollTop = Math.round(scrollTop);
                  if (this.$scrollTop === scrollTop || isNaN(scrollTop))
                    return;
                  this.$scrollTop = scrollTop;
                  this._signal("changeScrollTop", scrollTop);
                };
                this.$scrollLeft = 0;
                this.getScrollLeft = function() {
                  return this.$scrollLeft;
                };
                this.setScrollLeft = function(scrollLeft) {
                  scrollLeft = Math.round(scrollLeft);
                  if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
                    return;
                  this.$scrollLeft = scrollLeft;
                  this._signal("changeScrollLeft", scrollLeft);
                };
              }).call(scrollable);
              module3.exports = scrollable;
            }.call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          }
        ),
        /***/
        592: (
          /***/
          (module2, exports2, __webpack_require__2) => {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports3, module3) {
              "use strict";
              var oop = __webpack_require__2(645);
              var EventEmitter = __webpack_require__2(366).b;
              var Selection = function(provider) {
                this.provider = provider;
                if (this.provider && !this.provider.selectedItems)
                  this.provider.selectedItems = [];
                this.provider.on("remove", this.unselectRemoved = this.unselectRemoved.bind(this));
              };
              (function() {
                oop.implement(this, EventEmitter);
                this.$wrapAround = false;
                this.getRange = function() {
                };
                this.selectAll = function() {
                  var sel = this.provider.selectedItems;
                  this.expandSelection(sel[0], sel[sel.length - 1]);
                  this._signal("change");
                };
                this.moveSelection = function(dir, select, add) {
                  var provider = this.provider;
                  var cursor = this.getCursor();
                  var anchor = this.getAnchor();
                  var i = provider.getIndexForNode(cursor);
                  if (!add) {
                    this.clear(true);
                  } else if (add && !select) {
                    this.unselectNode(cursor);
                  }
                  var min = provider.getMinIndex();
                  var max = provider.getMaxIndex();
                  var wrapped = false;
                  var newI = i;
                  do {
                    newI += dir;
                    if (newI < min) {
                      newI = this.$wrapAround ? max : min;
                      wrapped = true;
                    } else if (newI > max) {
                      newI = this.$wrapAround ? min : max;
                      wrapped = true;
                    }
                    var newNode = provider.getNodeAtIndex(newI);
                  } while (!wrapped && newNode && !provider.isSelectable(newNode));
                  if (!newNode || !provider.isSelectable(newNode))
                    newNode = cursor;
                  if (select) {
                    this.expandSelection(newNode, anchor, add);
                  } else {
                    this.selectNode(newNode, add);
                  }
                };
                this.getCursor = function() {
                  var sel = this.provider.selectedItems;
                  return sel.cursor || sel[sel.length - 1];
                };
                this.getAnchor = function() {
                  var sel = this.provider.selectedItems;
                  return sel.anchor || sel.cursor || sel[0];
                };
                this.getSelectedNodes = function() {
                  var sel = this.provider.selectedItems;
                  return sel.slice();
                };
                this.getVisibleSelectedNodes = function() {
                  var provider = this.provider;
                  var sel = provider.selectedItems;
                  return sel.filter(function(node) {
                    return provider.isVisible(node);
                  });
                };
                this.isEmpty = function() {
                  var sel = this.provider.selectedItems;
                  return sel.length === 0;
                };
                this.isMultiRow = function() {
                  var sel = this.provider.selectedItems;
                  return sel.length > 1;
                };
                this.toggleSelect = function(node) {
                  var provider = this.provider;
                  var sel = provider.selectedItems;
                  var i = sel.indexOf(node);
                  if (i != -1)
                    sel.splice(i, 1);
                  provider.setSelected(node, !provider.isSelected(node));
                  if (provider.isSelected(node)) {
                    sel.push(node);
                    sel.anchor = sel.cursor = node;
                  } else
                    sel.anchor = sel.cursor = sel[sel.length - 1];
                  this._signal("change");
                };
                this.selectNode = function(node, add, silent) {
                  var provider = this.provider;
                  var sel = provider.selectedItems;
                  if (!provider.isSelectable(node))
                    return;
                  if (!add)
                    this.clear(true);
                  if (node) {
                    var i = sel.indexOf(node);
                    if (i != -1)
                      sel.splice(i, 1);
                    provider.setSelected(node, true);
                    if (provider.isSelected(node))
                      sel.push(node);
                  }
                  sel.anchor = sel.cursor = node;
                  this._signal("change");
                };
                this.add = function(node) {
                  this.selectNode(node, true);
                };
                this.remove = function(node) {
                  if (this.provider.isSelected(node))
                    this.toggleSelect(node);
                };
                this.clear = this.clearSelection = function(silent) {
                  var provider = this.provider;
                  var sel = provider.selectedItems;
                  sel.forEach(function(node) {
                    provider.setSelected(node, false);
                  });
                  sel.splice(0, sel.length);
                  sel.anchor = sel.cursor;
                  silent || this._signal("change");
                };
                this.unselectNode = function(node, silent) {
                  var provider = this.provider;
                  var sel = provider.selectedItems;
                  var i = sel.indexOf(node);
                  if (i != -1) {
                    sel.splice(i, 1);
                    provider.setSelected(node, false);
                    if (sel.anchor == node)
                      sel.anchor = sel[i - 1] || sel[i];
                    if (sel.cursor == node)
                      sel.cursor = sel[i] || sel[i - 1];
                    silent || this._signal("change");
                  }
                };
                this.setSelection = function(nodes) {
                  if (Array.isArray(nodes)) {
                    this.clear(true);
                    nodes.forEach(function(node) {
                      this.selectNode(node, true, true);
                    }, this);
                  } else
                    this.selectNode(nodes, false, true);
                };
                this.expandSelection = function(cursor, anchor, additive) {
                  anchor = anchor || this.getAnchor();
                  if (!additive)
                    this.clear(true);
                  var provider = this.provider;
                  var sel = provider.selectedItems;
                  var end = provider.getIndexForNode(cursor);
                  var start = provider.getIndexForNode(anchor || cursor);
                  if (end > start) {
                    for (var i = start; i <= end; i++) {
                      var node = provider.getNodeAtIndex(i);
                      var index = sel.indexOf(node);
                      if (index != -1)
                        sel.splice(index, 1);
                      if (provider.isSelectable(node))
                        provider.setSelected(node, true);
                      sel.push(node);
                    }
                  } else {
                    for (var i = start; i >= end; i--) {
                      var node = provider.getNodeAtIndex(i);
                      var index = sel.indexOf(node);
                      if (index != -1)
                        sel.splice(index, 1);
                      if (provider.isSelectable(node))
                        provider.setSelected(node, true);
                      sel.push(node);
                    }
                  }
                  sel.cursor = cursor;
                  sel.anchor = anchor;
                  this._signal("change");
                };
                this.unselectRemoved = function(toRemove) {
                  var sel = this.getSelectedNodes();
                  var provider = this.provider;
                  var changed, cursor = this.getCursor();
                  sel.forEach(function(n) {
                    if (provider.isAncestor(toRemove, n)) {
                      changed = true;
                      this.unselectNode(n, true);
                    }
                  }, this);
                  if (changed && !provider.isSelected(cursor)) {
                    var parent = toRemove.parent;
                    var ch = [];
                    if (parent && provider.isOpen(parent)) {
                      ch = provider.getChildren(parent);
                      var i = ch.indexOf(toRemove);
                    }
                    if (i == -1) {
                      i = toRemove.index;
                      var node = ch[i] || ch[i - 1] || parent;
                    } else {
                      node = ch[i + 1] || ch[i - 1] || parent;
                    }
                    if (node == provider.root)
                      node = ch[0] || node;
                    if (node)
                      this.selectNode(node, true);
                    this._signal("change");
                  }
                };
              }).call(Selection.prototype);
              exports3.Selection = Selection;
            }.call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          }
        ),
        /***/
        336: (
          /***/
          (module2, exports2, __webpack_require__2) => {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports3, module3) {
              "use strict";
              var Renderer = __webpack_require__2(743).VirtualRenderer;
              exports3.config = __webpack_require__2(614);
              var oop = __webpack_require__2(645);
              var lang = __webpack_require__2(955);
              var useragent = __webpack_require__2(943);
              var TextInput = __webpack_require__2(984).k;
              var MouseHandler = __webpack_require__2(202).MouseHandler;
              var KeyBinding = __webpack_require__2(957).$;
              var Selection = __webpack_require__2(592).Selection;
              var EventEmitter = __webpack_require__2(366).b;
              var CommandManager = __webpack_require__2(379).F;
              var defaultCommands = __webpack_require__2(677).commands;
              var config = __webpack_require__2(614);
              var quickSearch = __webpack_require__2(277);
              var Tree = function(element, cellWidth, cellHeight) {
                this.$toDestroy = [];
                this.cellWidth = cellWidth || 80;
                this.cellHeight = cellHeight || 24;
                this.renderer = new Renderer(element, this.cellWidth, this.cellHeight);
                this.container = this.renderer.container;
                this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
                this.textInput = new TextInput(this.container, this);
                this.keyBinding = new KeyBinding(this);
                this.$mouseHandler = new MouseHandler(this);
                this.$blockScrolling = 0;
                var _self = this;
                this.renderer.on("edit", function(e) {
                  _self._emit("edit", e);
                });
                this.commands.on("exec", function() {
                  this.selectionChanged = false;
                }.bind(this));
                this.commands.on("afterExec", function() {
                  if (this.selectionChanged) {
                    this.selectionChanged = false;
                    this.renderer.scrollCaretIntoView();
                    this._signal("userSelect");
                  }
                }.bind(this));
                this.on("changeSelection", function() {
                  if (this.$mouseHandler.isMousePressed)
                    this._signal("userSelect");
                }.bind(this));
                config.resetOptions(this);
                config._emit("Tree", this);
              };
              (function() {
                oop.implement(this, EventEmitter);
                this.setDataProvider = function(provider) {
                  if (this.provider) {
                    var oldProvider = this.provider;
                    this.selection.off("changeCaret", this.$onCaretChange);
                    this.selection.off("change", this.$onSelectionChange);
                    oldProvider.off("changeClass", this.$onChangeClass);
                    oldProvider.off("expand", this.$redraw);
                    oldProvider.off("collapse", this.$redraw);
                    oldProvider.off("change", this.$redraw);
                    oldProvider.off("changeScrollTop", this.$onScrollTopChange);
                    oldProvider.off("changeScrollLeft", this.$onScrollLeftChange);
                  }
                  this.provider = provider;
                  this.model = provider;
                  if (provider) {
                    this.renderer.setDataProvider(provider);
                    if (!this.$redraw)
                      this.$redraw = this.redraw.bind(this);
                    this.provider.on("expand", this.$redraw);
                    this.provider.on("collapse", this.$redraw);
                    this.provider.on("change", this.$redraw);
                    if (!this.provider.selection) {
                      this.provider.selection = new Selection(this.provider);
                    }
                    this.selection = this.provider.selection;
                    this.$onCaretChange = this.onCaretChange.bind(this);
                    this.selection.on("changeCaret", this.$onCaretChange);
                    this.$onChangeClass = this.$onChangeClass.bind(this);
                    this.provider.on("changeClass", this.$onChangeClass);
                    this.$onSelectionChange = this.onSelectionChange.bind(this);
                    this.selection.on("change", this.$onSelectionChange);
                    this.$onScrollTopChange = this.onScrollTopChange.bind(this);
                    this.provider.on("changeScrollTop", this.$onScrollTopChange);
                    this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
                    this.provider.on("changeScrollLeft", this.$onScrollLeftChange);
                    this.$blockScrolling += 1;
                    this.onCaretChange();
                    this.$blockScrolling -= 1;
                    this.onScrollTopChange();
                    this.onScrollLeftChange();
                    this.onSelectionChange();
                    this.renderer.updateFull();
                  }
                  this._emit("changeDataProvider", {
                    provider,
                    oldProvider
                  });
                };
                this.redraw = function() {
                  this.renderer.updateFull();
                };
                this.getLength = function() {
                  return 0;
                };
                this.getLine = function(row) {
                  return {
                    length: 0
                    // this.renderer.$horHeadingLayer.length - 1
                  };
                };
                this.getDataProvider = function() {
                  return this.provider;
                };
                this.getSelection = function() {
                  return this.selection;
                };
                this.resize = function(force) {
                  this.renderer.onResize(force);
                };
                this.focus = function(once) {
                  var _self = this;
                  once || setTimeout(function() {
                    _self.textInput.focus();
                  });
                  this.textInput.focus();
                };
                this.isFocused = function() {
                  return this.textInput.isFocused();
                };
                this.blur = function() {
                  this.textInput.blur();
                };
                this.onFocus = function() {
                  if (this.$isFocused)
                    return;
                  this.$isFocused = true;
                  this.renderer.visualizeFocus();
                  this._emit("focus");
                };
                this.onBlur = function() {
                  if (!this.$isFocused)
                    return;
                  this.$isFocused = false;
                  this.renderer.visualizeBlur();
                  this._emit("blur");
                };
                this.onScrollTopChange = function() {
                  this.renderer.scrollToY(this.provider.getScrollTop());
                };
                this.onScrollLeftChange = function() {
                  this.renderer.scrollToX(this.renderer.getScrollLeft());
                };
                this.$onChangeClass = function() {
                  this.renderer.updateCaret();
                };
                this.onCaretChange = function() {
                  this.$onChangeClass();
                  if (!this.$blockScrolling)
                    this.selectionChanged = true;
                  this._emit("changeSelection");
                };
                this.onSelectionChange = function(e) {
                  this.onCaretChange();
                };
                this.execCommand = function(command, args) {
                  this.commands.exec(command, this, args);
                };
                this.onTextInput = function(text) {
                  this.keyBinding.onTextInput(text);
                };
                this.onCommandKey = function(e, hashId, keyCode) {
                  this.keyBinding.onCommandKey(e, hashId, keyCode);
                };
                this.insertSting = function(str) {
                  if (this.startFilter)
                    return this.startFilter(str);
                  quickSearch(this, str);
                };
                this.setTheme = function(theme) {
                  this.renderer.setTheme(theme);
                };
                this.$getSelectedRows = function() {
                  var range = this.getSelectionRange().collapseRows();
                  return {
                    first: range.start.row,
                    last: range.end.row
                  };
                };
                this.getVisibleNodes = function(tolerance) {
                  return this.renderer.getVisibleNodes(tolerance);
                };
                this.isNodeVisible = function(node, tolerance) {
                  return this.renderer.isNodeVisible(node, tolerance);
                };
                this.$moveByPage = function(dir, select) {
                  var renderer = this.renderer;
                  var config2 = this.renderer.layerConfig;
                  config2.lineHeight = this.provider.rowHeight;
                  var rows = dir * Math.floor(config2.height / config2.lineHeight);
                  this.$blockScrolling++;
                  this.selection.moveSelection(rows, select);
                  this.$blockScrolling--;
                  var scrollTop = renderer.scrollTop;
                  renderer.scrollBy(0, rows * config2.lineHeight);
                  if (select != null)
                    renderer.scrollCaretIntoView(null, 0.5);
                  renderer.animateScrolling(scrollTop);
                };
                this.selectPageDown = function() {
                  this.$moveByPage(1, true);
                };
                this.selectPageUp = function() {
                  this.$moveByPage(-1, true);
                };
                this.gotoPageDown = function() {
                  this.$moveByPage(1, false);
                };
                this.gotoPageUp = function() {
                  this.$moveByPage(-1, false);
                };
                this.scrollPageDown = function() {
                  this.$moveByPage(1);
                };
                this.scrollPageUp = function() {
                  this.$moveByPage(-1);
                };
                this.scrollToRow = function(row, center, animate, callback) {
                  this.renderer.scrollToRow(row, center, animate, callback);
                };
                this.centerSelection = function() {
                  var range = this.getSelectionRange();
                  var pos = {
                    row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
                    column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
                  };
                  this.renderer.alignCaret(pos, 0.5);
                };
                this.getCursorPosition = function() {
                  return this.selection.getCursor();
                };
                this.getCursorPositionScreen = function() {
                  return this.session.documentToScreenPosition(this.getCursorPosition());
                };
                this.getSelectionRange = function() {
                  return this.selection.getRange();
                };
                this.selectAll = function() {
                  this.$blockScrolling += 1;
                  this.selection.selectAll();
                  this.$blockScrolling -= 1;
                };
                this.clearSelection = function() {
                  this.selection.clearSelection();
                };
                this.moveCaretTo = function(row, column) {
                  this.selection.moveCaretTo(row, column);
                };
                this.moveCaretToPosition = function(pos) {
                  this.selection.moveCaretToPosition(pos);
                };
                this.gotoRow = function(rowNumber, column, animate) {
                  this.selection.clearSelection();
                  if (column === void 0)
                    column = this.selection.getCursor().column;
                  this.$blockScrolling += 1;
                  this.moveCaretTo(rowNumber - 1, column || 0);
                  this.$blockScrolling -= 1;
                  if (!this.isRowFullyVisible(rowNumber - 1))
                    this.scrollToRow(rowNumber - 1, true, animate);
                };
                this.navigateTo = function(row, column) {
                  this.clearSelection();
                  this.moveCaretTo(row, column);
                };
                this.navigateUp = function() {
                  var node = this.provider.navigate("up");
                  node && this.selection.setSelection(node);
                  this.$scrollIntoView();
                };
                this.navigateDown = function() {
                  var node = this.provider.navigate("down");
                  node && this.selection.setSelection(node);
                };
                this.navigateLevelUp = function(toggleNode) {
                  var node = this.selection.getCursor();
                  if (!node) {
                  } else if (toggleNode && this.provider.isOpen(node)) {
                    this.provider.close(node);
                  } else {
                    this.selection.setSelection(node.parent);
                  }
                };
                this.navigateLevelDown = function() {
                  var node = this.selection.getCursor();
                  var hasChildren = this.provider.hasChildren(node);
                  if (!hasChildren || this.provider.isOpen(node))
                    return this.selection.moveSelection(1);
                  this.provider.open(node);
                };
                this.navigateStart = function() {
                  var node = this.getFirstNode();
                  this.selection.setSelection(node);
                };
                this.navigateEnd = function() {
                  var node = this.getLastNode();
                  this.selection.setSelection(node);
                };
                this.getFirstNode = function() {
                  var index = this.provider.getMinIndex();
                  return this.provider.getNodeAtIndex(index);
                };
                this.getLastNode = function() {
                  var index = this.provider.getMaxIndex();
                  return this.provider.getNodeAtIndex(index);
                };
                this.$scrollIntoView = function(node) {
                  this.renderer.scrollCaretIntoView();
                };
                this.select = function(node) {
                  this.selection.setSelection(node);
                };
                this.getCopyText = function(node) {
                  return "";
                };
                this.onPaste = function(node) {
                  return "";
                };
                this.reveal = function(node, animate) {
                  var provider = this.provider;
                  var parent = node.parent;
                  while (parent) {
                    if (!provider.isOpen(parent))
                      provider.expand(parent);
                    parent = parent.parent;
                  }
                  this.select(node);
                  var scrollTop = this.renderer.scrollTop;
                  this.renderer.scrollCaretIntoView(node, 0.5);
                  if (animate !== false)
                    this.renderer.animateScrolling(scrollTop);
                };
                this.undo = function() {
                  this.$blockScrolling++;
                  this.session.getUndoManager().undo();
                  this.$blockScrolling--;
                  this.renderer.scrollCaretIntoView(null, 0.5);
                };
                this.redo = function() {
                  this.$blockScrolling++;
                  this.session.getUndoManager().redo();
                  this.$blockScrolling--;
                  this.renderer.scrollCaretIntoView(null, 0.5);
                };
                this.getReadOnly = function() {
                  return this.getOption("readOnly");
                };
                this.destroy = function() {
                  this.renderer.destroy();
                  this._emit("destroy", this);
                };
                this.setHorHeadingVisible = function(value) {
                  this.renderer.setHorHeadingVisible(value);
                };
                this.setVerHeadingVisible = function(value) {
                  this.renderer.setVerHeadingVisible(value);
                };
                this.enable = function() {
                  this.$disabled = false;
                  this.container.style.pointerEvents = "";
                  this.container.style.opacity = "";
                };
                this.disable = function() {
                  this.$disabled = true;
                  this.container.style.pointerEvents = "none";
                  this.container.style.opacity = "0.9";
                  if (this.isFocused())
                    this.blur();
                };
              }).call(Tree.prototype);
              config.defineOptions(Tree.prototype, "Tree", {
                toggle: {
                  set: function(toggle) {
                  },
                  initialValue: false
                },
                readOnly: {
                  set: function(readOnly) {
                    this.textInput.setReadOnly(readOnly);
                  },
                  initialValue: false
                },
                animatedScroll: "renderer",
                maxLines: "renderer",
                minLines: "renderer",
                scrollSpeed: "$mouseHandler",
                enableDragDrop: "$mouseHandler"
              });
              module3.exports = Tree;
            }.call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          }
        ),
        /***/
        743: (
          /***/
          (module2, exports2, __webpack_require__2) => {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports3, module3) {
              "use strict";
              var oop = __webpack_require__2(645);
              var dom = __webpack_require__2(435);
              var config = __webpack_require__2(614);
              var CellLayer = __webpack_require__2(365).Cells;
              var MarkerLayer = __webpack_require__2(611).Selection;
              var HeaderLayer = __webpack_require__2(86).ColumnHeader;
              var ScrollBarH = __webpack_require__2(745).zy;
              var ScrollBarV = __webpack_require__2(745).lc;
              var RenderLoop = __webpack_require__2(481).x;
              var EventEmitter = __webpack_require__2(366).b;
              var pivotCss = __webpack_require__2(268);
              dom.importCssString(pivotCss, "ace_tree");
              var defaultTheme = __webpack_require__2(768);
              var VirtualRenderer = function(container, cellWidth, cellHeight) {
                var _self = this;
                this.container = container || dom.createElement("div");
                dom.addCssClass(this.container, "ace_tree");
                dom.addCssClass(this.container, "ace_tree");
                this.scroller = dom.createElement("div");
                this.scroller.className = "ace_tree_scroller";
                this.container.appendChild(this.scroller);
                this.cells = dom.createElement("div");
                this.cells.className = "ace_tree_cells";
                this.scroller.appendChild(this.cells);
                this.$headingLayer = new HeaderLayer(this.container, this);
                this.$markerLayer = new MarkerLayer(this.cells, this);
                this.$cellLayer = new CellLayer(this.cells);
                this.canvas = this.$cellLayer.element;
                this.$horizScroll = false;
                this.scrollBarV = new ScrollBarV(this.container, this);
                this.scrollBarV.setVisible(true);
                this.scrollBarV.addEventListener("scroll", function(e) {
                  if (!_self.$inScrollAnimation)
                    _self.setScrollTop(e.data - _self.scrollMargin.top);
                });
                this.scrollBarH = new ScrollBarH(this.container, this);
                this.scrollBarH.addEventListener("scroll", function(e) {
                  if (!_self.$inScrollAnimation)
                    _self.setScrollLeft(e.data);
                });
                this.scrollTop = 0;
                this.scrollLeft = 0;
                this.caretPos = {
                  row: 0,
                  column: 0
                };
                this.$size = {
                  width: 0,
                  height: 0,
                  scrollerHeight: 0,
                  scrollerWidth: 0,
                  headingHeight: 0
                };
                this.layerConfig = {
                  width: 1,
                  padding: 0,
                  firstRow: 0,
                  firstRowScreen: 0,
                  lastRow: 0,
                  lineHeight: 1,
                  characterWidth: 1,
                  minHeight: 1,
                  maxHeight: 1,
                  offset: 0,
                  height: 1
                };
                this.scrollMargin = {
                  left: 0,
                  right: 0,
                  top: 0,
                  bottom: 0,
                  v: 0,
                  h: 0
                };
                this.$scrollIntoView = null;
                this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
                this.$loop.schedule(this.CHANGE_FULL);
                this.setTheme(defaultTheme);
                this.$windowFocus = this.$windowFocus.bind(this);
                window.addEventListener("focus", this.$windowFocus);
              };
              (function() {
                this.CHANGE_SCROLL = 1;
                this.CHANGE_COLUMN = 2;
                this.CHANGE_ROW = 4;
                this.CHANGE_CELLS = 8;
                this.CHANGE_SIZE = 16;
                this.CHANGE_CLASS = 32;
                this.CHANGE_MARKER = 64;
                this.CHANGE_FULL = 128;
                this.CHANGE_H_SCROLL = 1024;
                oop.implement(this, EventEmitter);
                this.setDataProvider = function(provider) {
                  this.provider = provider;
                  this.model = provider;
                  if (this.scrollMargin.top && provider && provider.getScrollTop() <= 0)
                    provider.setScrollTop(-this.scrollMargin.top);
                  this.scroller.className = "ace_tree_scroller";
                  this.$cellLayer.setDataProvider(provider);
                  this.$markerLayer.setDataProvider(provider);
                  this.$headingLayer.setDataProvider(provider);
                  this.$size.headingHeight = provider && provider.columns ? provider.headerHeight || provider.rowHeight : 0;
                  this.$loop.schedule(this.CHANGE_FULL);
                };
                this.updateRows = function(firstRow, lastRow) {
                  if (lastRow === void 0)
                    lastRow = Infinity;
                  if (!this.$changedLines) {
                    this.$changedLines = {
                      firstRow,
                      lastRow
                    };
                  } else {
                    if (this.$changedLines.firstRow > firstRow)
                      this.$changedLines.firstRow = firstRow;
                    if (this.$changedLines.lastRow < lastRow)
                      this.$changedLines.lastRow = lastRow;
                  }
                  if (this.$changedLines.firstRow > this.layerConfig.lastRow || this.$changedLines.lastRow < this.layerConfig.firstRow)
                    return;
                  this.$loop.schedule(this.CHANGE_ROW);
                };
                this.updateCaret = function() {
                  this.$loop.schedule(this.CHANGE_CLASS);
                };
                this.updateCells = function() {
                  this.$loop.schedule(this.CHANGE_CELLS);
                };
                this.updateFull = function(force) {
                  if (force)
                    this.$renderChanges(this.CHANGE_FULL, true);
                  else
                    this.$loop.schedule(this.CHANGE_FULL);
                };
                this.updateHorizontalHeadings = function() {
                  this.$loop.schedule(this.CHANGE_COLUMN);
                };
                this.updateVerticalHeadings = function() {
                  this.$loop.schedule(this.CHANGE_ROW);
                };
                this.$changes = 0;
                this.onResize = function(force, width, height) {
                  if (this.resizing > 2)
                    return;
                  else if (this.resizing > 0)
                    this.resizing++;
                  else
                    this.resizing = force ? 1 : 0;
                  var el = this.container;
                  if (!height)
                    height = el.clientHeight || el.scrollHeight;
                  if (!width)
                    width = el.clientWidth || el.scrollWidth;
                  var changes = this.$updateCachedSize(force, width, height);
                  if (!this.$size.scrollerHeight || !width && !height)
                    return this.resizing = 0;
                  if (force)
                    this.$renderChanges(changes, true);
                  else
                    this.$loop.schedule(changes | this.$changes);
                  if (this.resizing)
                    this.resizing = 0;
                };
                this.$windowFocus = function() {
                  this.onResize();
                };
                this.$updateCachedSize = function(force, width, height) {
                  var changes = 0;
                  var size = this.$size;
                  var provider = this.provider;
                  if (provider) {
                    var headingHeight = provider.columns ? provider.headerHeight || provider.rowHeight : 0;
                    if (headingHeight != size.headingHeight) {
                      size.headingHeight = headingHeight;
                      changes |= this.CHANGE_SIZE;
                    }
                  }
                  if (height && (force || size.height != height)) {
                    size.height = height;
                    changes |= this.CHANGE_SIZE;
                    size.scrollerHeight = size.height;
                    if (this.$horizScroll)
                      size.scrollerHeight -= this.scrollBarH.getHeight();
                    size.scrollerHeight -= size.headingHeight;
                    this.$headingLayer.element.style.height = this.scroller.style.top = this.scrollBarV.element.style.top = size.headingHeight + "px";
                    this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";
                    if (provider && provider.setScrollTop) {
                      changes |= this.CHANGE_SCROLL;
                    }
                    if (this.$scrollIntoView) {
                      if (this.$scrollIntoView.model == this.model) {
                        this.scrollCaretIntoView(this.$scrollIntoView.caret, this.$scrollIntoView.offset);
                        this.$scrollIntoView = null;
                      }
                    }
                  }
                  if (width && (force || size.width != width)) {
                    changes |= this.CHANGE_SIZE;
                    size.width = width;
                    this.scrollBarH.element.style.left = this.scroller.style.left = "0px";
                    size.scrollerWidth = Math.max(0, width - this.scrollBarV.getWidth());
                    this.$headingLayer.element.style.right = this.scrollBarH.element.style.right = this.scroller.style.right = this.scrollBarV.getWidth() + "px";
                    this.scroller.style.bottom = this.scrollBarH.getHeight() + "px";
                    this.$headingLayer.updateWidth(size.scrollerWidth);
                    if (provider && provider.columns)
                      changes |= this.CHANGE_FULL;
                  }
                  if (changes)
                    this._signal("resize");
                  return changes;
                };
                this.setVerHeadingVisible = function(value) {
                  this.$treeLayer.visible = value;
                  if (this.layerConfig.vRange && this.layerConfig.hRange) {
                    this.$renderChanges(this.CHANGE_FULL, true);
                    this.onResize(true);
                  }
                };
                this.getContainerElement = function() {
                  return this.container;
                };
                this.getMouseEventTarget = function() {
                  return this.scroller;
                };
                this.getVisibleNodes = function(tolerance) {
                  var nodes = this.layerConfig.vRange;
                  var first = 0;
                  var last = nodes.length - 1;
                  while (this.isNodeVisible(nodes[first], tolerance) && first < last)
                    first++;
                  while (!this.isNodeVisible(nodes[last], tolerance) && last > first)
                    last--;
                  return nodes.slice(first, last + 1);
                };
                this.isNodeVisible = function(node, tolerance) {
                  var layerConfig = this.layerConfig;
                  if (!layerConfig.vRange)
                    return;
                  var provider = this.provider;
                  var i = layerConfig.vRange.indexOf(node);
                  if (i == -1)
                    return false;
                  var nodePos = provider.getNodePosition(node);
                  var top = nodePos.top;
                  var height = nodePos.height;
                  if (tolerance === void 0)
                    tolerance = 1 / 3;
                  if (this.scrollTop > top + tolerance * height)
                    return false;
                  if (this.scrollTop + this.$size.scrollerHeight <= top + (1 - tolerance) * height)
                    return false;
                  return true;
                };
                this.$updateScrollBar = function() {
                  this.$updateScrollBarH();
                  this.$updateScrollBarV();
                };
                this.setScrollMargin = function(top, bottom, left, right) {
                  var sm = this.scrollMargin;
                  sm.top = top | 0;
                  sm.bottom = bottom | 0;
                  sm.right = right | 0;
                  sm.left = left | 0;
                  sm.v = sm.top + sm.bottom;
                  sm.h = sm.left + sm.right;
                  if (sm.top && this.scrollTop <= 0 && this.provider)
                    this.provider.setScrollTop(-sm.top);
                  this.updateFull();
                };
                this.$updateScrollBarV = function() {
                  this.scrollBarV.setInnerHeight(this.layerConfig.maxHeight + this.scrollMargin.v);
                  this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
                };
                this.$updateScrollBarH = function() {
                  this.scrollBarH.setInnerWidth(this.layerConfig.maxWidth + this.scrollMargin.h);
                  this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
                };
                this.$frozen = false;
                this.freeze = function() {
                  this.$frozen = true;
                };
                this.unfreeze = function() {
                  this.$frozen = false;
                };
                this.$renderChanges = function(changes, force) {
                  if (this.$changes) {
                    changes |= this.$changes;
                    this.$changes = 0;
                  }
                  if (!this.provider || !this.container.offsetWidth || this.$frozen || !changes && !force) {
                    this.$changes |= changes;
                    return;
                  }
                  if (!this.$size.width) {
                    this.$changes |= changes;
                    return this.onResize(true);
                  }
                  this._signal("beforeRender");
                  var config2 = this.layerConfig;
                  if (changes & this.CHANGE_FULL || changes & this.CHANGE_SIZE || changes & this.CHANGE_SCROLL || changes & this.CHANGE_H_SCROLL || changes & this.CHANGE_COLUMN || changes & this.CHANGE_ROW || changes & this.CHANGE_CELLS) {
                    changes |= this.$computeLayerConfig();
                    config2 = this.layerConfig;
                    this.$updateScrollBar();
                    this.cells.style.marginTop = -config2.vOffset + "px";
                    this.cells.style.marginLeft = -config2.hOffset + "px";
                    this.cells.style.width = config2.width + "px";
                    this.cells.style.height = config2.height + config2.rowHeight + "px";
                  }
                  if (changes & this.CHANGE_FULL) {
                    this.$headingLayer.update(this.layerConfig);
                    this.$cellLayer.update(this.layerConfig);
                    this.$markerLayer.update(this.layerConfig);
                    this._signal("afterRender");
                    return;
                  }
                  if (changes & this.CHANGE_SCROLL) {
                    if (changes & this.CHANGE_ROW || changes & this.CHANGE_COLUMN || changes & this.CHANGE_CELLS) {
                      this.$headingLayer.update(this.layerConfig);
                      this.$cellLayer.update(this.layerConfig);
                    } else {
                      this.$headingLayer.update(this.layerConfig);
                      this.$cellLayer.scroll(this.layerConfig);
                    }
                    this.$markerLayer.update(this.layerConfig);
                    this.$updateScrollBar();
                    this._signal("afterRender");
                    return;
                  }
                  if (changes & this.CHANGE_CLASS)
                    this.$cellLayer.updateClasses(this.layerConfig);
                  if (changes & this.CHANGE_MARKER || changes & this.CHANGE_CELLS)
                    this.$markerLayer.update(this.layerConfig);
                  if (changes & this.CHANGE_COLUMN)
                    this.$horHeadingLayer.update(this.layerConfig);
                  if (changes & this.CHANGE_CELLS)
                    this.$cellLayer.update(this.layerConfig);
                  if (changes & this.CHANGE_SIZE)
                    this.$updateScrollBar();
                  this._signal("afterRender");
                  if (this.$scrollIntoView)
                    this.$scrollIntoView = null;
                };
                this.$autosize = function() {
                  var headingHeight = this.$size.headingHeight;
                  var height = this.provider.getTotalHeight() + headingHeight;
                  var maxHeight = this.getMaxHeight ? this.getMaxHeight() : this.$maxLines * this.provider.rowHeight + headingHeight;
                  var desiredHeight = Math.max((this.$minLines || 1) * this.provider.rowHeight + headingHeight, Math.min(maxHeight, height)) + this.scrollMargin.v;
                  var vScroll = height > maxHeight;
                  if (desiredHeight != this.desiredHeight || this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
                    if (vScroll != this.$vScroll) {
                      this.$vScroll = vScroll;
                      this.scrollBarV.setVisible(vScroll);
                    }
                    var w = this.container.clientWidth;
                    this.container.style.height = desiredHeight + "px";
                    this.$updateCachedSize(true, w, desiredHeight);
                    this.desiredHeight = desiredHeight;
                    this._signal("autoresize");
                  }
                };
                this.$computeLayerConfig = function() {
                  if (this.$maxLines)
                    this.$autosize();
                  var provider = this.provider;
                  var vertical = this.$treeLayer;
                  var horizontal = this.$horHeadingLayer;
                  var minHeight = this.$size.scrollerHeight;
                  var maxHeight = provider.getTotalHeight();
                  var minWidth = this.$size.scrollerWidth;
                  var maxWidth = 0;
                  var hideScrollbars = this.$size.height <= 2 * 10;
                  var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible || this.$size.scrollerWidth - maxWidth < 0);
                  var hScrollChanged = this.$horizScroll !== horizScroll;
                  if (hScrollChanged) {
                    this.$horizScroll = horizScroll;
                    this.scrollBarH.setVisible(horizScroll);
                  }
                  var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible || this.$size.scrollerHeight - maxHeight < 0);
                  var vScrollChanged = this.$vScroll !== vScroll;
                  if (vScrollChanged) {
                    this.$vScroll = vScroll;
                    this.scrollBarV.setVisible(vScroll);
                  }
                  this.provider.setScrollTop(Math.max(-this.scrollMargin.top, Math.min(this.scrollTop, maxHeight - this.$size.scrollerHeight + this.scrollMargin.bottom)));
                  this.provider.setScrollLeft(Math.max(-this.scrollMargin.left, Math.min(this.scrollLeft, maxWidth - this.$size.scrollerWidth + this.scrollMargin.right)));
                  if (this.provider.getScrollTop() != this.scrollTop)
                    this.scrollTop = this.provider.getScrollTop();
                  var top = Math.max(this.scrollTop, 0);
                  var vRange = provider.getRange(top, top + this.$size.height);
                  var hRange = {
                    size: 0
                  };
                  var vOffset = this.scrollTop - vRange.size;
                  var hOffset = this.scrollLeft - hRange.size;
                  var rowCount = vRange.length;
                  var firstRow = vRange.count;
                  var lastRow = firstRow + rowCount - 1;
                  var colCount = hRange.length;
                  var firstCol = hRange.count;
                  var lastCol = firstCol + colCount - 1;
                  if (this.layerConfig)
                    this.layerConfig.discard = true;
                  var changes = 0;
                  if (hScrollChanged || vScrollChanged) {
                    changes = this.$updateCachedSize(true, this.$size.width, this.$size.height);
                    this._signal("scrollbarVisibilityChanged");
                  }
                  this.layerConfig = {
                    vRange,
                    hRange,
                    width: minWidth,
                    height: minHeight,
                    firstRow,
                    lastRow,
                    firstCol,
                    lastCol,
                    minHeight,
                    maxHeight,
                    minWidth,
                    maxWidth,
                    vOffset,
                    hOffset,
                    rowHeight: provider.rowHeight
                  };
                  var config2 = this.layerConfig, renderer = this;
                  if (vRange) {
                    config2.view = provider.getDataRange({
                      start: vRange.count,
                      length: vRange.length
                    }, {
                      start: hRange.count,
                      length: hRange.length
                    }, function(err, view, update) {
                      if (err)
                        return false;
                      config2.view = view;
                      if (update)
                        renderer.$loop.schedule(renderer.CHANGE_CELLS);
                    });
                  }
                  return changes;
                };
                this.$updateRows = function() {
                  var firstRow = this.$changedLines.firstRow;
                  var lastRow = this.$changedLines.lastRow;
                  this.$changedLines = null;
                  var layerConfig = this.layerConfig;
                  if (firstRow > layerConfig.lastRow + 1) {
                    return;
                  }
                  if (lastRow < layerConfig.firstRow) {
                    return;
                  }
                  if (lastRow === Infinity) {
                    this.$cellLayer.update(layerConfig);
                    return;
                  }
                  this.$cellLayer.updateRows(layerConfig, firstRow, lastRow);
                  return true;
                };
                this.scrollSelectionIntoView = function(anchor, lead, offset) {
                  this.scrollCaretIntoView(anchor, offset);
                  this.scrollCaretIntoView(lead, offset);
                };
                this.scrollCaretIntoView = function(caret, offset) {
                  this.$scrollIntoView = {
                    caret,
                    offset,
                    scrollTop: this.scrollTop,
                    model: this.model,
                    height: this.$size.scrollerHeight
                  };
                  if (this.$size.scrollerHeight === 0)
                    return;
                  var provider = this.provider;
                  var node = caret || provider.selection.getCursor();
                  if (!node)
                    return;
                  var nodePos = provider.getNodePosition(node);
                  var top = nodePos.top;
                  var height = nodePos.height;
                  var left = 0;
                  var width = 0;
                  if (this.scrollTop > top) {
                    if (offset)
                      top -= offset * this.$size.scrollerHeight;
                    if (top === 0)
                      top = -this.scrollMargin.top;
                    this.provider.setScrollTop(top);
                  } else if (this.scrollTop + this.$size.scrollerHeight < top + height) {
                    if (offset)
                      top += offset * this.$size.scrollerHeight;
                    this.provider.setScrollTop(top + height - this.$size.scrollerHeight);
                  }
                  var scrollLeft = this.scrollLeft;
                  if (scrollLeft > left) {
                    if (left < 0)
                      left = 0;
                    this.provider.setScrollLeft(left);
                  } else if (scrollLeft + this.$size.scrollerWidth < left + width) {
                    this.provider.setScrollLeft(Math.round(left + width - this.$size.scrollerWidth));
                  }
                  this.$scrollIntoView.scrollTop = this.scrollTop;
                };
                this.getScrollTop = function() {
                  return this.scrollTop;
                };
                this.getScrollLeft = function() {
                  return this.scrollLeft;
                };
                this.setScrollTop = function(scrollTop) {
                  scrollTop = Math.round(scrollTop);
                  if (this.scrollTop === scrollTop || isNaN(scrollTop))
                    return;
                  this.scrollToY(scrollTop);
                };
                this.setScrollLeft = function(scrollLeft) {
                  scrollLeft = Math.round(scrollLeft);
                  if (this.scrollLeft === scrollLeft || isNaN(scrollLeft))
                    return;
                  this.scrollToX(scrollLeft);
                };
                this.getScrollTopRow = function() {
                  return this.layerConfig.firstRow;
                };
                this.getScrollBottomRow = function() {
                  return this.layerConfig.lastRow;
                };
                this.alignCaret = function(cursor, alignment) {
                  if (typeof cursor == "number")
                    cursor = {
                      row: cursor,
                      column: 0
                    };
                  var node = this.provider.findNodeByIndex(cursor.row);
                  var pos = this.provider.findSizeAtIndex(cursor.row);
                  var h = this.$size.scrollerHeight;
                  var offset = pos - (h - node.size) * (alignment || 0);
                  this.setScrollTop(offset);
                  return offset;
                };
                this.STEPS = 8;
                this.$calcSteps = function(fromValue, toValue) {
                  var i = 0;
                  var l = this.STEPS;
                  var steps = [];
                  var func = function(t, x_min, dx) {
                    return dx * (Math.pow(t - 1, 3) + 1) + x_min;
                  };
                  for (i = 0; i < l; ++i)
                    steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
                  return steps;
                };
                this.scrollToRow = function(row, center, animate, callback) {
                  var node = this.provider.findNodeByIndex(row);
                  var offset = this.provider.findSizeAtIndex(row);
                  if (center)
                    offset -= (this.$size.scrollerHeight - node.size) / 2;
                  var initialScroll = this.scrollTop;
                  this.setScrollTop(offset);
                  if (animate !== false)
                    this.animateScrolling(initialScroll, callback);
                };
                this.animateScrolling = function(fromValue, callback) {
                  var toValue = this.scrollTop;
                  if (!this.$animatedScroll)
                    return;
                  var _self = this;
                  if (fromValue == toValue)
                    return;
                  if (this.$scrollAnimation) {
                    var oldSteps = this.$scrollAnimation.steps;
                    if (oldSteps.length) {
                      fromValue = oldSteps[0];
                      if (fromValue == toValue)
                        return;
                    }
                  }
                  var steps = _self.$calcSteps(fromValue, toValue);
                  this.$scrollAnimation = {
                    from: fromValue,
                    to: toValue,
                    steps
                  };
                  clearInterval(this.$timer);
                  _self.provider.setScrollTop(steps.shift());
                  _self.provider.$scrollTop = toValue;
                  this.$timer = setInterval(function() {
                    if (steps.length) {
                      _self.provider.setScrollTop(steps.shift());
                      _self.provider.$scrollTop = toValue;
                    } else if (toValue != null) {
                      _self.provider.$scrollTop = -1;
                      _self.provider.setScrollTop(toValue);
                      toValue = null;
                    } else {
                      _self.$timer = clearInterval(_self.$timer);
                      _self.$scrollAnimation = null;
                      callback && callback();
                    }
                  }, 10);
                };
                this.scrollToY = function(scrollTop) {
                  if (this.scrollTop !== scrollTop) {
                    this.$loop.schedule(this.CHANGE_SCROLL);
                    this.scrollTop = scrollTop;
                  }
                };
                this.scrollToX = function(scrollLeft) {
                  if (scrollLeft < 0)
                    scrollLeft = 0;
                  if (this.scrollLeft !== scrollLeft) {
                    this.$loop.schedule(this.CHANGE_SCROLL);
                    this.scrollLeft = scrollLeft;
                  }
                };
                this.scrollBy = function(deltaX, deltaY) {
                  deltaY && this.provider.setScrollTop(this.provider.getScrollTop() + deltaY);
                  deltaX && this.provider.setScrollLeft(this.provider.getScrollLeft() + deltaX);
                };
                this.isScrollableBy = function(deltaX, deltaY) {
                  if (deltaY < 0 && this.getScrollTop() >= 1 - this.scrollMargin.top)
                    return true;
                  if (deltaY > 0 && this.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
                    return true;
                  if (deltaX < 0 && this.getScrollLeft() >= 1)
                    return true;
                  if (deltaX > 0 && this.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.maxWidth < -1)
                    return true;
                };
                this.screenToTextCoordinates = function(x, y) {
                  var canvasPos = this.scroller.getBoundingClientRect();
                  y -= canvasPos.top;
                  x -= canvasPos.left;
                  return {
                    x: x + this.scrollLeft,
                    y: y + this.scrollTop
                  };
                };
                this.textToScreenCoordinates = function(row, column) {
                  throw new Error();
                };
                this.findNodeAt = function(x, y, coords) {
                };
                this.$moveTextAreaToCursor = function() {
                };
                this.visualizeFocus = function() {
                  dom.addCssClass(this.container, "ace_tree_focus");
                };
                this.visualizeBlur = function() {
                  dom.removeCssClass(this.container, "ace_tree_focus");
                };
                this.setTheme = function(theme, cb) {
                  var _self = this;
                  this.$themeValue = theme;
                  _self._dispatchEvent("themeChange", {
                    theme
                  });
                  if (!theme || typeof theme == "string") {
                    var moduleName = theme || "ace/theme/textmate";
                    config.loadModule([
                      "theme",
                      moduleName
                    ], afterLoad);
                  } else {
                    afterLoad(theme);
                  }
                  function afterLoad(module4) {
                    if (_self.$themeValue != theme)
                      return cb && cb();
                    if (!module4.cssClass)
                      return;
                    dom.importCssString(module4.cssText, module4.cssClass, _self.container.ownerDocument);
                    if (_self.theme)
                      dom.removeCssClass(_self.container, _self.theme.cssClass);
                    _self.$theme = module4.cssClass;
                    _self.theme = module4;
                    dom.addCssClass(_self.container, module4.cssClass);
                    dom.setCssClass(_self.container, "ace_dark", module4.isDark);
                    var padding = module4.padding || 4;
                    if (_self.$padding && padding != _self.$padding)
                      _self.setPadding(padding);
                    if (_self.$size) {
                      _self.$size.width = 0;
                      _self.onResize();
                    }
                    _self._dispatchEvent("themeLoaded", {
                      theme: module4
                    });
                    cb && cb();
                  }
                };
                this.getTheme = function() {
                  return this.$themeValue;
                };
                this.setStyle = function setStyle(style, include) {
                  dom.setCssClass(this.container, style, include !== false);
                };
                this.unsetStyle = function unsetStyle(style) {
                  dom.removeCssClass(this.container, style);
                };
                this.destroy = function() {
                  window.removeEventListener("focus", this.$windowFocus);
                  this.$cellLayer.destroy();
                };
              }).call(VirtualRenderer.prototype);
              config.defineOptions(VirtualRenderer.prototype, "renderer", {
                animatedScroll: {
                  initialValue: true
                },
                showInvisibles: {
                  set: function(value) {
                    if (this.$cellLayer.setShowInvisibles(value))
                      this.$loop.schedule(this.CHANGE_TEXT);
                  },
                  initialValue: false
                },
                showPrintMargin: {
                  set: function() {
                    this.$updatePrintMargin();
                  },
                  initialValue: true
                },
                printMarginColumn: {
                  set: function() {
                    this.$updatePrintMargin();
                  },
                  initialValue: 80
                },
                printMargin: {
                  set: function(val) {
                    if (typeof val == "number")
                      this.$printMarginColumn = val;
                    this.$showPrintMargin = !!val;
                    this.$updatePrintMargin();
                  },
                  get: function() {
                    return this.$showPrintMargin && this.$printMarginColumn;
                  }
                },
                displayIndentGuides: {
                  set: function(show) {
                    if (this.$cellLayer.setDisplayIndentGuides(show))
                      this.$loop.schedule(this.CHANGE_TEXT);
                  },
                  initialValue: true
                },
                hScrollBarAlwaysVisible: {
                  set: function(alwaysVisible) {
                    this.$hScrollBarAlwaysVisible = alwaysVisible;
                    if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
                      this.$loop.schedule(this.CHANGE_SCROLL);
                  },
                  initialValue: false
                },
                vScrollBarAlwaysVisible: {
                  set: function(val) {
                    if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
                      this.$loop.schedule(this.CHANGE_SCROLL);
                  },
                  initialValue: false
                },
                fontSize: {
                  set: function(size) {
                    if (typeof size == "number")
                      size = size + "px";
                    this.container.style.fontSize = size;
                    this.updateFontSize();
                  },
                  initialValue: 12
                },
                fontFamily: {
                  set: function(name) {
                    this.container.style.fontFamily = name;
                    this.updateFontSize();
                  }
                },
                maxLines: {
                  set: function(val) {
                    this.updateFull();
                  }
                },
                minLines: {
                  set: function(val) {
                    this.updateFull();
                  }
                },
                scrollPastEnd: {
                  set: function(val) {
                    val = +val || 0;
                    if (this.$scrollPastEnd == val)
                      return;
                    this.$scrollPastEnd = val;
                    this.$loop.schedule(this.CHANGE_SCROLL);
                  },
                  initialValue: 0,
                  handlesSet: true
                }
              });
              exports3.VirtualRenderer = VirtualRenderer;
            }.call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          }
        ),
        /***/
        28: (
          /***/
          (module2) => {
            module2.exports = ".ace_tree-light.ace_tree{\n    font: 12px Arial;\n}\n\n.ace_tree_selection_range{\n    background : rgba(0, 110, 255, 0.2);\n    border : 1px solid rgba(0,0,0,0.1);\n}\n.ace_tree_focus .ace_tree_selection_range{\n    \n}\n\n.ace_tree-light .toggler {\n    overflow: visible;\n    width: 10px;\n    height: 10px;\n}\n\n.ace_tree-light .tree-row .caption {\n    padding : 4px 5px;\n}\n.ace_tree-light .tree-row > .caption {\n    overflow: visible;\n    display: inline-block;\n}\n.ace_tree-light .tree-row {\n    border: 1px solid transparent;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n}\n.ace_tree-light .tree-row:hover,\n.ace_tree-light .tree-row.hover{\n    background: rgba(0, 0, 0, 0.03);\n}\n.ace_tree-light .tree-row.selected {\n    background: rgba(0, 0, 0, 0.04);\n}\n\n.ace_tree_focus.ace_tree-light .tree-row.selected {\n    background: -webkit-gradient(linear, left top, left bottom, from(#2890E5), color-stop(1, #1F82D2));\n    background: -moz-linear-gradient(center bottom, #1f82d2 0%, #2890e5 100%) repeat scroll 0 0 transparent;\n    background: linear-gradient(center bottom, #1f82d2 0%, #2890e5 100%) repeat scroll 0 0 transparent;\n    color: #f8f8f8;\n}\n\n\n/* datagrid */\n\n.ace_tree-light .tree-row>.tree-column {\n    border: 1px solid rgb(204, 204, 204);\n    border-width: 0 1px 1px 0;\n    padding: 4px 5px;\n}\n\n.ace_tree-light .tree-row.selected>.tree-column {\n    background: transparent;\n}\n.ace_tree-light .tree-headings {\n    background: rgb(253, 253, 253);\n}\n.ace_tree-light .tree-headings>.tree-column {\n    background: transparent;\n    padding: 5px 3px;\n}\n\n.ace_tree-light .tree-headings>.tree-column-resizer {\n    height: 100%;\n    background: rgb(182, 182, 182);\n    display: inline-block;\n    width: 1px;\n    z-index: 1000;\n    position: absolute;\n    margin-left: -1px;\n    border-left: 1px solid rgba(0, 0, 0, 0);\n}\n";
          }
        ),
        /***/
        268: (
          /***/
          (module2) => {
            module2.exports = ".ace_tree{\n    overflow : hidden;\n    font : 12px Tahoma, Arial;\n    cursor: default;\n    position: relative;\n    white-space: pre;\n}\n\n.ace_tree textarea{\n    position : absolute;\n    z-index : 0;\n}\n\n.ace_tree_scroller {\n    position: absolute;\n    overflow: hidden;\n    top: 0;\n    bottom: 0;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n         -o-user-select: none;\n            user-select: none;\n}\n\n.ace_tree_content {\n    position: absolute;\n    -moz-box-sizing: border-box;\n    -webkit-box-sizing: border-box;\n    box-sizing: border-box;\n}\n\n.ace_scrollbar {\n    position: absolute;\n    overflow-x: hidden;\n    overflow-y: auto;\n    right: 0;\n    bottom: 0;\n}\n\n.ace_scrollbar-inner {\n    position: absolute;\n    cursor: text;\n    left: 0;\n    top: 0;\n}\n\n.ace_scrollbar-h {\n    position: absolute;\n    overflow-x: auto;\n    overflow-y: hidden;\n    right: 0;\n    left: 0;\n    bottom: 0;\n}\n\n.ace_tree_horheading {\n    position : absolute;\n}\n\n.ace_tree_verheading{\n    bottom : 0;\n    position : absolute;\n}\n\n.ace_tree_heading {\n    z-index: 10;\n    position: relative;\n    white-space: nowrap;\n    -webkit-box-sizing: border-box;\n       -moz-box-sizing: border-box;\n            box-sizing: border-box;\n    pointer-events: none;\n}\n\n.ace_tree_layer {\n    z-index: 1;\n    position: absolute;\n    overflow: hidden;\n    white-space: nowrap;\n    -webkit-box-sizing: border-box;\n       -moz-box-sizing: border-box;\n            box-sizing: border-box;\n    pointer-events: none;\n}\n\n.ace_tree .tree-indent {\n    display : inline-block;\n}\n\n.ace_tree_selection_range{\n    position : absolute;\n    -webkit-box-sizing: border-box;\n       -moz-box-sizing: border-box;\n            box-sizing: border-box;\n}\n.ace_tree_focus .ace_tree_selection_range{\n    \n}\n\n.ace_tree-editor {\n    position : absolute;\n    z-index : 10000;\n    background : white;\n    padding : 3px 4px 3px 4px;\n    -moz-box-sizing : border-box;\n         box-sizing : border-box;\n    border : 1px dotted green;\n    left: 0;\n    right: 0\n}\n\n\n\n.ace_tree .toggler {\n    width: 10px;\n    height: 10px;\n    background-repeat: no-repeat;\n    background-position: 0px 0px;\n    background-repeat: no-repeat;\n    cursor: pointer;\n    display: inline-block;\n    pointer-events: auto;\n}\n\n.ace_tree .toggler.empty {\n    pointer-events: none;\n}\n\n.ace_tree .toggler.open {\n    background-position: -10px 0px;\n}\n\n.ace_tree .toggler.empty {\n    background-position: 50px 0px;\n    cursor: default;\n}\n\n.ace_tree_cells, .ace_tree_cell-layer {\n    width: 100%;\n}\n.ace_tree_selection-layer {\n    width: 100%;\n    height: 110%;\n}\n.ace_tree_cells .message.empty {\n    text-align: center;\n    opacity: 0.9;\n    cursor : default;\n}\n\n/* datagrid */\n\n.ace_tree .tree-row>.tree-column {\n    display: inline-block;\n    overflow: hidden;\n    -webkit-box-sizing: border-box;\n       -moz-box-sizing: border-box;\n            box-sizing: border-box;\n}\n\n\n.tree-headings {\n    white-space: nowrap;\n    position: absolute;\n    overflow: hidden;\n    top: 0;\n    left: 0;\n    right: 0;\n    -webkit-box-sizing: border-box;\n       -moz-box-sizing: border-box;\n            box-sizing: border-box;\n}\n.tree-headings>.tree-column {\n    display: inline-block;\n    -webkit-box-sizing: border-box;\n       -moz-box-sizing: border-box;\n            box-sizing: border-box;\n}\n\n.tree-headings>.tree-column-resizer {\n    height: 100%;\n    background: rgb(182, 182, 182);\n    display: inline-block;\n    width: 2px;\n    z-index: 1000;\n    position: absolute;\n    margin-left: -2px;\n    border-left: 1px solid rgba(0, 0, 0, 0);\n}\n";
          }
        )
        /******/
      };
      var __webpack_module_cache__ = {};
      function __nested_webpack_require_262623__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) {
          return cachedModule.exports;
        }
        var module2 = __webpack_module_cache__[moduleId] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        __webpack_modules__[moduleId](module2, module2.exports, __nested_webpack_require_262623__);
        return module2.exports;
      }
      (() => {
        __nested_webpack_require_262623__.n = (module2) => {
          var getter = module2 && module2.__esModule ? (
            /******/
            () => module2["default"]
          ) : (
            /******/
            () => module2
          );
          __nested_webpack_require_262623__.d(getter, { a: getter });
          return getter;
        };
      })();
      (() => {
        __nested_webpack_require_262623__.d = (exports2, definition) => {
          for (var key in definition) {
            if (__nested_webpack_require_262623__.o(definition, key) && !__nested_webpack_require_262623__.o(exports2, key)) {
              Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
            }
          }
        };
      })();
      (() => {
        __nested_webpack_require_262623__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
      })();
      (() => {
        __nested_webpack_require_262623__.r = (exports2) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
      })();
      var __nested_webpack_exports__ = {};
      (() => {
        "use strict";
        __nested_webpack_require_262623__.r(__nested_webpack_exports__);
        __nested_webpack_require_262623__.d(__nested_webpack_exports__, {
          /* harmony export */
          DataProvider: () => (
            /* reexport module object */
            _src_data_provider__WEBPACK_IMPORTED_MODULE_1__
          ),
          /* harmony export */
          Tree: () => (
            /* reexport module object */
            _src_tree__WEBPACK_IMPORTED_MODULE_0__
          )
          /* harmony export */
        });
        var _src_tree__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_262623__(336);
        var _src_tree__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __nested_webpack_require_262623__.n(_src_tree__WEBPACK_IMPORTED_MODULE_0__);
        var _src_data_provider__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_262623__(950);
        var _src_data_provider__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __nested_webpack_require_262623__.n(_src_data_provider__WEBPACK_IMPORTED_MODULE_1__);
      })();
      return __nested_webpack_exports__;
    })()
  );
});


/***/ }),

/***/ 46:
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ 591:
/***/ ((module) => {

"use strict";


var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ 128:
/***/ ((module) => {

"use strict";


var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ 51:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ 855:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_351155__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =   true ? __nested_webpack_require_351155__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ 740:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ 656:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ 937:
/***/ ((module) => {

"use strict";
module.exports = "data:image/gif;base64,R0lGODlhDAAjAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAAMACMAAAItlI+py+2fgAMSVUGvoZjHrFkeE0LmiabqagZO4CKxAM8GTONJrSv1ywoKh4oCADs=";

/***/ }),

/***/ 592:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAACICAYAAADuxmtPAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpBQkU4MzRBNDE1RjcxMUUyQjBEREY4NkZDMkM2NDc5MyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpBQkU4MzRBNTE1RjcxMUUyQjBEREY4NkZDMkM2NDc5MyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkFCRTgzNEEyMTVGNzExRTJCMERERjg2RkMyQzY0NzkzIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkFCRTgzNEEzMTVGNzExRTJCMERERjg2RkMyQzY0NzkzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+JumAiwAACF9JREFUeNrsmX9sU9cVx6/t599J6JrUSZyfjg2OnR+khB91qdRQ0a4pVA3QlgilaemP/TFtfyG1f7VSxRqgQ9M2RZUYYh2MpghNKlJAqVKphbUNtEAggRjHTuwk2IlJ45g48e8fb+cY+8XGdvADNHVdrnQU5/l+z73vnnM+795nDk3TBFthUZES/jSCFYHxSfoWBLODXbplt5vxAhUTP9Xe3r772c2bnywuLlZQFCVMpw6FQv6pqSlzb2/vedB8Ck6+o+BD1Wttbbtfb29vlUDj8XhkiSaUSqUauVxeweFyceApLmie2LJliy4vL08CIxMOh7OkYR/s+0Jz85Og3UAFg8HHKioqqvBLNg00CtSiA0oIjbBsqEFtdBHZjp7Yog64sCAP5OB/fAYCgSAMzc/n81lFArMSNGGuTCZz2Ww2y70S6G6zWq2WwsJCF7e5uXnk9OnTfRBTD65FNoZ9UYNa3r/Pnbt9+PBhemx83A+5Lc7Nzc2DeuClGxVuNTAxMWH6rKurx2g0ftnZ2dnHiZWz/I8HD9aePHmyDKotF0ZIW1F4z1Ct8607d1r37NlzDS5Nxh1gewRMBibFyGZYuwiYG+wW2BwTxhgT8uFPAwugzD1coLzz9tut+fn5EizMTIkFtysEmGgqKyuTgbJjxw5daWmpRCwWR8OUKfb4HfbBvtu3bYsChYtQ0Gq1VWxTGDSLQIF0Zg0U1KD2/svwYVXjL2EGCJQYHO4fKFCiFrYjj4+PLwLl1KlTfYFAwJMtjbAvahigHDp0iB4bG/MXxYACKcvLMO2AxWIxHT16tGdoaOiXAhSscSIrLHxq//79R0wm0w2/3++LRCJ0OsPvoI++o6PjCGqis4cPVR/BBY/H4wbq0tkY9t0HA4JWeQco27frYIEkMArJxrDvtpaWxR1KWVlZVcJiZtVAswgUeI4I0TObhhpmh8JWnFLO/+8OECiQYQ8GlJuw28A8YGMTN28uAqW7u7vP6/V6ss1E7Isa1GI5r2hra3tOqVQ246a7pKSkCp7OgkxAgb2R+cyZM31ms/nL48eP9y4D5SEAhVQqFLsMBoMeFo6+l/3j7HH6nc9+F/0Mmhuo5SYCZSk7N/Qt+fOlT4g3h5DWY2+wA4rRaiJ7v/uYqDR1ZNBwmfx9R2d6oDidTjLnc5HK4ookBx+eO0CK5OXkqk1PPtr8HtHKNIyGG3eA1m3qIa1f7CZfXOlmrr3f8wdC5YqIfsZE2hUvkeeVm5nvksrZ5pwk/xw8QTZqmkjH9wdJmBMm8/4FYgtOE/OCjazJXUV+r/tNSukzMyheUUQOvfJX0m+6QGoVa0i3uZd8cvEwmfbfJnlBiny8ZS+JhJKLKuUW5MI7TkasNwgH6qlW0UicM5PkLy0HCD9EpVRl1EEcKPGLpUI5+dvL4GRyiFwd6yd7n/+AFPFlKWLYI2QGSrmohHRu+xP57YY3yAZZ45JA4b351lu5kN/59fX1aogtP97hUf4jpLZAm1bs8/k8n5840aNSqb5ZBkoiUA4cOGIaGbkB4fHRGRp+B330Hfv2JQMFL8DKuuksG/bFARmgIKYyYSzR4kDBz4g/Bijl5eX3PPJ8PXiWAcorn75GQLMIFDzmLbXFGbLoU4CCmpQjj91uJ8NjxhQHcaBcA6B8AEB5vKwhuZzjKRoHyokL/2KuvXvq/SSgtNRsZb5LygOTbSQroKQ9saA3lVx5T6CIheKkoko58qgLVmYEyqPiX6U/MyFQEA5xr9rHqlOAsipflVLSEIHMR566Qi0DlOdWPrPkkScKlNHR0fzGxkY1xJYpInleMVlXuiatGAjowVNLRWXlN8yRxwJHHvCY3ZHn2LEe/fKRZ3mHsrxDWd6hLO9QMr+Ura6u3rimoUEAa8CDqaZ9O4dlbLPZVlzu71eA5nvmpeyqlSs3Nj39NIWxnZyaCtMZnvUcaCKxmLdp0yY+/LMRX8pSMNp6iEBk1uFwZ3NmDgYCYfgTUCoUAojEOgoQJRPw+X62J3gY2IdaCoT8OxuwAOujP2gFVGxx7vsFws/EARRH+IEcwALe/wzgUR70er00lDLNMgL4sj5ESaVSx5zLJc7JyWEVx4WFBQFoZ7hqtXrQefu2yOf1YpbR2Rj2RQ1qsZwFT+h0TZM22yqJROIWCYVBSHk6ww8UHJ/fL4CHq1heUmK6cP782TgPJLt27VL/ePGi1u12F8D9UWm3dHDPOO3169bpu7q6huGSJxEoiDFxLDKZXrZj5xCYF4N3N1DKHuhn4/8KUKanpwukOTkRAEqENVAcDseKUbO5GtfBr1b3A1BoBAo3ASgZ2+zsrHRkdLTu1Vd3ctauXe8dNhrrYvulZKBACCU4GoTKEx95fn5eCiOvbmnZDmnPd8AmRCISifxgQdQy5QwO+HAmrANnPJVSeRE7QcJIzBbL6q1bXxTAw2r2hx/OS6zWieDaxkb93NwchpNHxTbPBKa4uqnpmTwej0t/9VVvA0Tjus1qrf918wtiHoj7+y8Jx8bMIRBfn5mZWYgvNDdWGCKYgcR+y+7iC0Sz1ZoaLizQehDnwPPWOThwVTQyYqTr6+pQ7IK+4TiEqNjP4PNajebalf7LNcFAkC4vrwjKi+XBUDBMhg0GvslkDDc0NAzMOBxz4VCITgEKzCAETuya6urIwMCVGlhdqrS0LARnCmp42EBg5GsQZmfoLnESUGBaUSdQomRg8KoWOlND+uuc2pqaQVj5mbupFQcKD7JJhSXNo6gQdoLmhp2HxzBsKIAM1UNopz1ebzgMm+1Ec83PY724eDqdjsCZSSWEZIoe8WG7BIXvUVZV/QQjO8FBOBIOk0QDqHAgIaRarfbHjECB6XFwi//zB8p/BBgAHNqa8EdleScAAAAASUVORK5CYII=";

/***/ }),

/***/ 952:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANCAYAAAB7AEQGAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozNEM5MTlGOTAwMDQxMUUyQjQxMkIyMEY3MzE5QTlBRCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozNEM5MTlGQTAwMDQxMUUyQjQxMkIyMEY3MzE5QTlBRCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjM0QzkxOUY3MDAwNDExRTJCNDEyQjIwRjczMTlBOUFEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjM0QzkxOUY4MDAwNDExRTJCNDEyQjIwRjczMTlBOUFEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+52cTFgAAAQdJREFUeNpi+v//PwMyZuQUUEEXY2JAAkxcghMV5OVug2hkcWQTJgRFxPy/c+fOf3efwP9Afg9MDqagx9bZ4/+lS5f+Hzhw4P/Fixf/Wzu6gRS2g+WBDHNDfb0T82dNYXj18iXEDUxMDIJCQgwxSRkMN27e0oObBMRfgfg/Ev4ANwlsJ8TRXECKnQEVfPn37f1vsCKggnZOTo4KNjY2FBVfv35j+PPnDxvIKkNdY8v/V69e+//w4UM4Pn/+wn9VHSOQtZpwkzTV1Srys1IYWJiZGX79+sXQO3kmw937D5qA1tWjhJOhuc3/qdOm/Tcws8YMJ2SFojJKIAUTkMUZsMSdEroYQIABAD4w1u/PTSI1AAAAAElFTkSuQmCC";

/***/ }),

/***/ 560:
/***/ ((module) => {

"use strict";
module.exports = "data:image/gif;base64,R0lGODlhDAAjAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAAMACMAAAIjlI+py+0PDZhs2mWpyqDqCIbiSJbmEqRMyqJs4LbxSdf2UgAAOw==";

/***/ }),

/***/ 784:
/***/ ((module) => {

"use strict";
module.exports = "data:image/gif;base64,R0lGODlhBAAeAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAAEAB4AAAIXhA4maeyr1Jm02mvDDFpw/YVe12HmaRUAOw==";

/***/ }),

/***/ 553:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADcAAAAqCAYAAAAXk8MDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NjQyQUZBRjU3QkFEMTFFMjhCODRFOEFGNTQyODdCNTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NjQyQUZBRjY3QkFEMTFFMjhCODRFOEFGNTQyODdCNTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo2NDJBRkFGMzdCQUQxMUUyOEI4NEU4QUY1NDI4N0I1NCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo2NDJBRkFGNDdCQUQxMUUyOEI4NEU4QUY1NDI4N0I1NCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv8NHYkAAASLSURBVHja3FhLbyNFEP7aHj+z3k1k5yGUxYmEtICSFRJrIXHYUyBCAo6cOEX5BZz4I9y4J3vgEIG0h0U5RQpIK22AA4l4HJIgsrE3b4f4MdN0tdPj2cnMZCZMj1eU1B67uz1dX9dX1V3FOOcgmZqa4pZlQQljzP6u5jjHqM85xz3Xa4yE1uh0Omi1Wi/1m6aJdDp9bZ9Xv/qdSqWQyWSwt7cnFzfo4/XqXV6e3UflXhuFIVKMtEMkoencBk8gr87pCjzbz4DPPvoCDx98gvKdCuKUF0d1PP7+W1RGK7xRbzBjenqaj71Tx1StjXwOyGYj4/IF45a/fwc+//RL1N78AC+eH+D5X/uxgjMMAx8+/BhGJo2JiQlukElfe7uF27eAYh5IG32FfU1kc9ADpEe/GvvzEHir+h7q9Tp0CNGd3v3g/vv4qvU1DPKN0h0gLyyWE82msuIZcynrBZpf8x81zUyhdd654sOxg7zoSj+UdiJAwhfBxNNSyvK+4szHWld05N4W7QeTDLrdLnSLWsNQypCilhkyciAABHNZEg5rQr/VXvLBHl1oV8XTuqqk7Uf29kcInS56irMmWXC0mATGewBvJF5+6YNhIOCIkhYPCBIxiMV7h3iitLQuaWn7HPP3KWdw4dzHz3ytlrDl5FXqv9IypPCkaWlbzlQ7G4GKLGTUvPxNm5g8La1eM60QoFjEyDlIWirLmWbIcy5MtPQZGwg40+pbL+qFuXd+BQNVF+uebycITvoA9/C3EH7nqSf3n2dhANHy4kxkBKVwlvM8CvzSIBfgtLi/nreaKGSLWkGdXzTlM0Xg6n9k0WkLenb7FvRrloPCgfMUDR3ziiL7+G33R2k9ne3ZLz8gl8vB2N7eZpN3J7mR2cf4vQ6Ktx0WivF2QlIcBtZ/fgRLbOIbk++K/PFWrBZr/nOKn359iu++eYLDw0PGlA9Uq1W7huKujzh/O31G1VKuq7k451JC2W63Zb6lQ6iWQsD6KY8QKthQi3tRWiybzcrCDRVwiC7UvC7U7qJSUBHKb/Od/dJylUqFLy4uYn5+HqOjo7GCo7R/dXUVy8vLGBsbk3UOVQUjsOq7U6hf9ak5zuqZc9w9dnJygqOjI+zs7DA2Pj7OFxYWMDc3JzvjzpQJzPDwMNbW1rCysoJyuay3xCBof3BwgOPjYxhExVqtpr1oMzs7i6WlJapK2TTSdeaNjIxIgLL6RdbSfbjSGtZlJh43MOf7FO3tgJJk0UYXMK/AYySd+rsVC77ehdfLa64nOL+diCVhddDyOuWj6uBmha/ldFhTvTPsu6Pq4J5veJ0z2soMCdKf1hqoz4XdhCD93If8KxNQwvraTfyf/pMoLZNeK3bLBUVaXRE4UVr6vS8p+it2JOpz/wvLvQpHAVlPgjs7O8PQ0JDWxZrNZmDYjlMoGSCWpChL3tjY0F602dzcRD6fT8RilJfSRhqNRoOJ/EfyZWZmBqVSKdbFTk9PsbW1hfX1de2JKmUeAo9su7u7/QIRAbxJ/SRsClMoFGSuFaYmEnXcfWOhih59/1eAAQAVvW4V+Ky7cAAAAABJRU5ErkJggg==";

/***/ }),

/***/ 147:
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAcCAYAAABRVo5BAAAAZ0lEQVR42u2SUQrAMAhDvazn8OjZBilCkYVVxiis8H4CT0VrAJb4WHT3C5xU2a2IQZXJjiQIRMdkEoJ5Q2yMqpfDIo+XY4k6h+YXOyKqTIj5REaxloNAd0xiKmAtsTHqW8sR2W5f7gCu5nWFUpVjZwAAAABJRU5ErkJggg==";

/***/ }),

/***/ 444:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__444__;

/***/ }),

/***/ 910:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__910__;

/***/ }),

/***/ 254:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__254__;

/***/ }),

/***/ 685:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__685__;

/***/ }),

/***/ 292:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__292__;

/***/ }),

/***/ 736:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__736__;

/***/ }),

/***/ 517:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__517__;

/***/ }),

/***/ 540:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__540__;

/***/ }),

/***/ 863:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__863__;

/***/ }),

/***/ 387:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__387__;

/***/ }),

/***/ 493:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__493__;

/***/ }),

/***/ 748:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__748__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_364669__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_364669__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_364669__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__nested_webpack_require_364669__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__nested_webpack_require_364669__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__nested_webpack_require_364669__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__nested_webpack_require_364669__.o(definition, key) && !__nested_webpack_require_364669__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__nested_webpack_require_364669__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__nested_webpack_require_364669__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__nested_webpack_require_364669__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			57: 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__nested_webpack_require_364669__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __nested_webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
// ESM COMPAT FLAG
__nested_webpack_require_364669__.r(__nested_webpack_exports__);

// EXPORTS
__nested_webpack_require_364669__.d(__nested_webpack_exports__, {
  Accordion: () => (/* reexport */ Accordion),
  AceEditor: () => (/* reexport */ AceEditor),
  AceLayout: () => (/* reexport */ AceLayout),
  AceTreeWrapper: () => (/* reexport */ AceTreeWrapper),
  Box: () => (/* reexport */ Box),
  Button: () => (/* reexport */ Button),
  CommandManager: () => (/* reexport */ CommandManager),
  Dropdown: () => (/* reexport */ Dropdown),
  EditorType: () => (/* reexport */ EditorType),
  FileSystemWeb: () => (/* reexport */ FileSystemWeb),
  ListBox: () => (/* reexport */ ListBox),
  Menu: () => (/* reexport */ Menu),
  MenuBar: () => (/* reexport */ MenuBar),
  MenuItems: () => (/* reexport */ MenuItems),
  MenuManager: () => (/* reexport */ MenuManager),
  MenuPopup: () => (/* reexport */ MenuPopup),
  MenuSearchBox: () => (/* reexport */ MenuSearchBox),
  MenuToolbar: () => (/* reexport */ MenuToolbar),
  Pane: () => (/* reexport */ Pane),
  Panel: () => (/* reexport */ Panel),
  PanelBar: () => (/* reexport */ PanelBar),
  PanelManager: () => (/* reexport */ PanelManager),
  PreviewEditor: () => (/* reexport */ PreviewEditor),
  SettingsSearchBox: () => (/* reexport */ SettingsSearchBox),
  SizeUnit: () => (/* reexport */ SizeUnit),
  Switcher: () => (/* reexport */ Switcher),
  Tab: () => (/* reexport */ Tab),
  TabManager: () => (/* reexport */ TabManager),
  Toolbar: () => (/* reexport */ Toolbar),
  dom: () => (/* reexport */ dom)
});

// NAMESPACE OBJECT: ./assets/styles/accordion.css
var accordion_namespaceObject = {};
__nested_webpack_require_364669__.r(accordion_namespaceObject);
__nested_webpack_require_364669__.d(accordion_namespaceObject, {
  "default": () => (styles_accordion)
});

// NAMESPACE OBJECT: ./assets/styles/tab.css
var tab_namespaceObject = {};
__nested_webpack_require_364669__.r(tab_namespaceObject);
__nested_webpack_require_364669__.d(tab_namespaceObject, {
  "default": () => (styles_tab)
});

// NAMESPACE OBJECT: ./assets/styles/menu.css
var menu_namespaceObject = {};
__nested_webpack_require_364669__.r(menu_namespaceObject);
__nested_webpack_require_364669__.d(menu_namespaceObject, {
  "default": () => (styles_menu)
});

// NAMESPACE OBJECT: ./assets/styles/button.css
var button_namespaceObject = {};
__nested_webpack_require_364669__.r(button_namespaceObject);
__nested_webpack_require_364669__.d(button_namespaceObject, {
  "default": () => (assets_styles_button)
});

// NAMESPACE OBJECT: ./assets/styles/dropdown.css
var dropdown_namespaceObject = {};
__nested_webpack_require_364669__.r(dropdown_namespaceObject);
__nested_webpack_require_364669__.d(dropdown_namespaceObject, {
  "default": () => (styles_dropdown)
});

// NAMESPACE OBJECT: ./assets/styles/switcher.css
var switcher_namespaceObject = {};
__nested_webpack_require_364669__.r(switcher_namespaceObject);
__nested_webpack_require_364669__.d(switcher_namespaceObject, {
  "default": () => (styles_switcher)
});

// NAMESPACE OBJECT: ./assets/styles/panel.css
var panel_namespaceObject = {};
__nested_webpack_require_364669__.r(panel_namespaceObject);
__nested_webpack_require_364669__.d(panel_namespaceObject, {
  "default": () => (styles_panel)
});

// NAMESPACE OBJECT: ./assets/styles/layout.css
var layout_namespaceObject = {};
__nested_webpack_require_364669__.r(layout_namespaceObject);
__nested_webpack_require_364669__.d(layout_namespaceObject, {
  "default": () => (styles_layout)
});

// NAMESPACE OBJECT: ./assets/styles/ace-tree.css
var ace_tree_namespaceObject = {};
__nested_webpack_require_364669__.r(ace_tree_namespaceObject);
__nested_webpack_require_364669__.d(ace_tree_namespaceObject, {
  "default": () => (styles_ace_tree)
});

// EXTERNAL MODULE: external "ace-code/src/keyboard/hash_handler"
var hash_handler_ = __nested_webpack_require_364669__(736);
;// ./src/commands/commandManager.ts
const commandManager_event = __nested_webpack_require_364669__(517);
const keyUtil = __nested_webpack_require_364669__(863);

class CommandManager {
  static registerCommands(commands, context) {
    let menuKb = new hash_handler_.HashHandler(commands);
    let _this = context;
    commandManager_event.addCommandKeyListener(window, function(e, hashId, keyCode) {
      let keyString = keyUtil.keyCodeToString(keyCode);
      let command = menuKb.findKeyCommand(hashId, keyString);
      if (command && command.exec) {
        commandManager_event.stopEvent(e);
        command.exec(_this);
      }
    });
  }
}

// EXTERNAL MODULE: external "ace-code/src/lib/useragent"
var useragent_ = __nested_webpack_require_364669__(493);
;// ./src/utils/dom.ts


var XHTML_NS = "http://www.w3.org/1999/xhtml";
var dom;
((dom2) => {
  dom2.buildDom = function(arr, parent, refs) {
    if (typeof arr == "string" && arr) {
      var txt = document.createTextNode(arr);
      if (parent)
        parent.appendChild(txt);
      return txt;
    }
    if (!Array.isArray(arr)) {
      if (arr && arr.appendChild && parent)
        parent.appendChild(arr);
      return arr;
    }
    if (typeof arr[0] != "string" || !arr[0]) {
      var els = [];
      for (var i = 0; i < arr.length; i++) {
        var ch = (0, dom2.buildDom)(arr[i], parent, refs);
        ch && els.push(ch);
      }
      return els;
    }
    var el = document.createElement(arr[0]);
    var options = arr[1];
    var childIndex = 1;
    if (options && typeof options == "object" && !Array.isArray(options))
      childIndex = 2;
    for (var i = childIndex; i < arr.length; i++)
      (0, dom2.buildDom)(arr[i], el, refs);
    if (childIndex == 2) {
      Object.keys(options).forEach(function(n) {
        var val = options[n];
        if (n === "class") {
          el.className = Array.isArray(val) ? val.join(" ") : val;
        } else if (typeof val == "function" || n == "value" || n[0] == "$") {
          el[n] = val;
        } else if (n === "ref") {
          if (refs)
            refs[val] = el;
        } else if (n === "style") {
          if (typeof val == "string")
            el.style.cssText = val;
        } else if (val != null) {
          el.setAttribute(n, val);
        }
      });
    }
    if (parent)
      parent.appendChild(el);
    return el;
  };
  dom2.getDocumentHead = function(doc) {
    if (!doc)
      doc = document;
    return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
  };
  dom2.createElement = function(tag, ns) {
    return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
  };
  dom2.removeChildren = function(element) {
    element.innerHTML = "";
  };
  dom2.createTextNode = function(textContent, element) {
    var doc = element ? element.ownerDocument : document;
    return doc.createTextNode(textContent);
  };
  dom2.createFragment = function(element) {
    var doc = element ? element.ownerDocument : document;
    return doc.createDocumentFragment();
  };
  dom2.hasCssClass = function(el, name) {
    var classes = (el.className + "").split(/\s+/g);
    return classes.indexOf(name) !== -1;
  };
  dom2.addCssClass = function(el, name) {
    if (!(0, dom2.hasCssClass)(el, name)) {
      el.className += " " + name;
    }
  };
  dom2.removeCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g);
    while (true) {
      var index = classes.indexOf(name);
      if (index == -1) {
        break;
      }
      classes.splice(index, 1);
    }
    el.className = classes.join(" ");
  };
  dom2.toggleCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g), add = true;
    while (true) {
      var index = classes.indexOf(name);
      if (index == -1) {
        break;
      }
      add = false;
      classes.splice(index, 1);
    }
    if (add)
      classes.push(name);
    el.className = classes.join(" ");
    return add;
  };
  dom2.setCssClass = function(node, className, include) {
    if (include) {
      (0, dom2.addCssClass)(node, className);
    } else {
      (0, dom2.removeCssClass)(node, className);
    }
  };
  dom2.hasCssString = function(id, doc) {
    var index = 0, sheets;
    doc = doc || document;
    if (sheets = doc.querySelectorAll("style")) {
      while (index < sheets.length) {
        if (sheets[index++].id === id) {
          return true;
        }
      }
    }
  };
  dom2.removeElementById = function(id, doc) {
    doc = doc || document;
    if (doc.getElementById(id)) {
      doc.getElementById(id).remove();
    }
  };
  var strictCSP;
  var cssCache = [];
  dom2.useStrictCSP = function(value) {
    strictCSP = value;
    if (value == false)
      insertPendingStyles();
    else if (!cssCache)
      cssCache = [];
  };
  function insertPendingStyles() {
    var cache = cssCache;
    cssCache = null;
    cache && cache.forEach(function(item) {
      importCssString(item[0], item[1]);
    });
  }
  function importCssString(cssText, id, target) {
    if (typeof document == "undefined")
      return;
    if (cssCache) {
      if (target) {
        insertPendingStyles();
      } else if (target === false) {
        return cssCache.push([cssText, id]);
      }
    }
    if (strictCSP)
      return;
    var container = target;
    if (!target || !target.getRootNode) {
      container = document;
    } else {
      container = target.getRootNode();
      if (!container || container == target)
        container = document;
    }
    var doc = container.ownerDocument || container;
    if (id && (0, dom2.hasCssString)(id, container))
      return null;
    if (id)
      cssText += "\n/*# sourceURL=ace/css/" + id + " */";
    var style = (0, dom2.createElement)("style");
    style.appendChild(doc.createTextNode(cssText));
    if (id)
      style.id = id;
    if (container == doc)
      container = (0, dom2.getDocumentHead)(doc);
    container.insertBefore(style, container.firstChild);
  }
  dom2.importCssString = importCssString;
  dom2.importCssStylsheet = function(uri, doc) {
    (0, dom2.buildDom)(["link", { rel: "stylesheet", href: uri }], (0, dom2.getDocumentHead)(doc));
  };
  dom2.scrollbarWidth = function(document2) {
    var inner = (0, dom2.createElement)("ace_inner");
    inner.style.width = "100%";
    inner.style.minWidth = "0px";
    inner.style.height = "200px";
    inner.style.display = "block";
    var outer = (0, dom2.createElement)("ace_outer");
    var style = outer.style;
    style.position = "absolute";
    style.left = "-10000px";
    style.overflow = "hidden";
    style.width = "200px";
    style.minWidth = "0px";
    style.height = "150px";
    style.display = "block";
    outer.appendChild(inner);
    var body = document2.documentElement;
    body.appendChild(outer);
    var noScrollbar = inner.offsetWidth;
    style.overflow = "scroll";
    var withScrollbar = inner.offsetWidth;
    if (noScrollbar == withScrollbar) {
      withScrollbar = outer.clientWidth;
    }
    body.removeChild(outer);
    return noScrollbar - withScrollbar;
  };
  dom2.computedStyle = function(element, style) {
    return window.getComputedStyle(element, "") || {};
  };
  dom2.setStyle = function(styles, property, value) {
    if (styles[property] !== value) {
      styles[property] = value;
    }
  };
  dom2.HAS_CSS_ANIMATION = false;
  dom2.HAS_CSS_TRANSFORMS = false;
  dom2.HI_DPI = useragent_.isWin ? typeof window !== "undefined" && window.devicePixelRatio >= 1.5 : true;
  if (useragent_.isChromeOS)
    dom2.HI_DPI = false;
  if (typeof document !== "undefined") {
    var div = document.createElement("div");
    if (dom2.HI_DPI && div.style.transform !== void 0)
      dom2.HAS_CSS_TRANSFORMS = true;
    if (!useragent_.isEdge && typeof div.style.animationName !== "undefined")
      dom2.HAS_CSS_ANIMATION = true;
    div = null;
  }
  if (dom2.HAS_CSS_TRANSFORMS) {
    dom2.translate = function(element, tx, ty) {
      element.style.transform = "translate(" + Math.round(tx) + "px, " + Math.round(ty) + "px)";
    };
  } else {
    dom2.translate = function(element, tx, ty) {
      element.style.top = Math.round(ty) + "px";
      element.style.left = Math.round(tx) + "px";
    };
  }
})(dom || (dom = {}));

;// ./src/utils/params.ts
var SizeUnit = /* @__PURE__ */ ((SizeUnit2) => {
  SizeUnit2[SizeUnit2["px"] = 0] = "px";
  SizeUnit2[SizeUnit2["percent"] = 1] = "percent";
  return SizeUnit2;
})(SizeUnit || {});
var EditorType = /* @__PURE__ */ ((EditorType2) => {
  EditorType2["ace"] = "ace";
  EditorType2["preview"] = "preview";
  return EditorType2;
})(EditorType || {});

;// ./src/utils/lib.ts
var Utils;
((Utils2) => {
  Utils2.findHost = function(el, constructor) {
    while (el) {
      if (el.$host && (!constructor || el.$host.constructor === constructor))
        return el.$host;
      el = el.parentElement;
    }
  };
  Utils2.findNode = function(node, className) {
    while (node && node.classList) {
      if (node.classList.contains(className))
        return node;
      node = node.parentNode;
    }
    return null;
  };
  Utils2.findHostTarget = function(target) {
    while (target) {
      if (target.$host)
        return target;
      target = target.parentElement;
    }
    return null;
  };
  Utils2.setBox = function(el, x, y, w, h) {
    if (w) {
      w = Math.max(w, 0);
    }
    if (h) {
      h = Math.max(h, 0);
    }
    let s = el.style;
    s.left = x + "px";
    s.top = y + "px";
    s.width = w + "px";
    s.height = h + "px";
  };
  function getEdge(style, dir) {
    return parseInt(style["padding" + dir], 10) + parseInt(style["margin" + dir], 10) + parseInt(style["border" + dir], 10);
  }
  Utils2.getEdge = getEdge;
  function getElementEdges(element) {
    let style = getComputedStyle(element);
    return {
      "top": getEdge(style, "Top"),
      "bottom": getEdge(style, "Bottom"),
      "left": getEdge(style, "Left"),
      "right": getEdge(style, "Right")
    };
  }
  Utils2.getElementEdges = getElementEdges;
})(Utils || (Utils = {}));

// EXTERNAL MODULE: external "ace-code/src/lib/event"
var event_ = __nested_webpack_require_364669__(517);
// EXTERNAL MODULE: ../../node_modules/events/events.js
var events = __nested_webpack_require_364669__(46);
;// ./src/widgets/boxes/box.ts





const SPLITTER_SIZE = 1;
const BOX_MIN_SIZE = 40;
class Box extends events.EventEmitter {
  constructor(options) {
    var _a, _b, _c, _d;
    super();
    this.$editorAdded = (editor) => {
      this.emit("editorAdded", editor);
    };
    if (options.splitter !== false) {
    }
    this.vertical = options.vertical || false;
    this.color = (_a = options.color) != null ? _a : "";
    this.isMain = options.isMain || false;
    this[0] = options[0];
    this[1] = options[1];
    if (this[0])
      this[0].parent = this;
    if (this[1])
      this[1].parent = this;
    this.ratio = options.ratio;
    this.toolBars = options.toolBars || {};
    this.padding = { top: 0, right: 0, bottom: 0, left: 0 };
    this.size = options.size;
    this.sizeUnit = (_b = options.sizeUnit) != null ? _b : SizeUnit.px;
    this.minSize = options.minSize || BOX_MIN_SIZE;
    this.minVerticalSize = options.minVerticalSize || this.minSize;
    this.minHorizontalSize = options.minHorizontalSize || this.minSize;
    this.classNames = (_c = options.classNames) != null ? _c : "";
    this.hidden = (_d = options.hidden) != null ? _d : false;
    this.fixedSize = options.fixedSize;
  }
  //TODO
  static enableAnimation() {
    document.documentElement.classList.add("animateBoxes");
  }
  static disableAnimation() {
    document.documentElement.classList.remove("animateBoxes");
  }
  static setGlobalCursor(value) {
    if (value)
      document.documentElement.classList.add("inheritCursor");
    else
      document.documentElement.classList.remove("inheritCursor");
    document.documentElement.style.cursor = value;
  }
  toJSON() {
    return {
      0: this[0] && this[0].toJSON(),
      1: this[1] && this[1].toJSON(),
      ratio: this.ratio,
      type: this.vertical ? "vbox" : "hbox",
      fixedSize: this.fixedSize || null,
      hidden: this.hidden,
      color: this.color,
      size: this.size
    };
  }
  onMouseDown(e) {
    let button = e.button;
    if (button !== 0)
      return;
    let box = this;
    let rect = this.element.getBoundingClientRect();
    let x = e.clientX;
    let y = e.clientY;
    document.body.classList.add("dragging");
    let onMouseMove = function(e2) {
      x = e2.clientX - rect.left - box.padding.left;
      y = e2.clientY - rect.top - box.padding.top;
      let height = rect.height - box.padding.top - box.padding.bottom;
      let width = rect.width - box.padding.left - box.padding.right;
      if (box.fixedChild) {
        if (box.vertical) {
          box.fixedChild.fixedSize = box.fixedChild === box[1] ? height - y : y;
        } else {
          box.fixedChild.fixedSize = box.fixedChild === box[1] ? width - x : x;
        }
        box.fixedChild.fixedSize = Math.max(box.fixedChild.fixedSize, box.fixedChild.minSize);
        box.ratio = void 0;
      } else {
        if (box.vertical) {
          box.ratio = y / height;
        } else {
          box.ratio = x / width;
        }
        box.ratio = Math.max(box.minRatio, Math.min(box.ratio, box.maxRatio));
      }
      box.resize();
    };
    let onResizeEnd = function(e2) {
      Box.setGlobalCursor("");
      document.body.classList.remove("dragging");
    };
    Box.setGlobalCursor(`${box.vertical ? "ns" : "ew"}-resize`);
    event_.capture(window, onMouseMove, onResizeEnd);
    return e.preventDefault();
  }
  resize() {
    if (!this.box)
      return;
    this.setBox(...this.box);
  }
  calculateMinMaxRatio() {
    if (!this.box || !this[0] && !this[1])
      return;
    let propertyName = this.vertical ? "minVerticalSize" : "minHorizontalSize";
    let size = this.vertical ? this.box[3] - this.padding.top - this.padding.bottom : this.box[2] - this.padding.left - this.padding.right;
    this.minRatio = this[0] ? this[0][propertyName] / size : 0;
    this.maxRatio = this[1] ? (size - this[1][propertyName]) / size : 1;
  }
  render() {
    var _a;
    if ((_a = this.element) == null ? void 0 : _a.$host)
      return this.element;
    this.renderElement();
    this.splitter = dom.buildDom(["div", {
      class: `splitter splitter${this.vertical ? "-v" : "-h"}`
    }, ["div"]]);
    this.splitter.onmousedown = this.onMouseDown.bind(this);
    this.element.appendChild(this.splitter);
    this.element.$host = this;
    this.element.style.backgroundColor = this.color;
    this.element.style.position = "absolute";
    this.renderToolBarList();
    this.renderChildren();
    if (!this.ratio)
      this.calculateRatio();
    return this.element;
  }
  renderElement() {
    var _a;
    (_a = this.element) != null ? _a : this.element = dom.buildDom(["div", {
      class: "box" + this.classNames
    }]);
  }
  renderToolBarList() {
    for (let position in this.toolBars) {
      this.addToolBar(position, this.toolBars[position]);
    }
  }
  addToolBar(position, bar) {
    var _a, _b;
    if (position == "left" || position == "right")
      bar.direction = "vertical";
    (_b = (_a = this.toolBars[position]) == null ? void 0 : _a.element) == null ? void 0 : _b.remove();
    bar.position = position;
    this.padding[position] = bar.size;
    this.element.appendChild(bar.render());
    this.toolBars[position] = bar;
  }
  removeToolBar(position) {
    delete this.toolBars[position];
    this.padding[position] = 0;
  }
  renderChildren() {
    this.renderChild(this[0]);
    this.renderChild(this[1]);
    this.calculateMinSize();
  }
  renderChild(child) {
    if (!child)
      return;
    if (!this.element)
      this.render();
    child.on("editorAdded", this.$editorAdded);
    this.element.appendChild(child.render());
  }
  calculateMinSize(forceChildrenSize = false) {
    let childrenMinVerticalSize = 0;
    let childrenMinHorizontalSize = 0;
    let calculateChildBoxMinSize = (childBox) => {
      if (this.vertical) {
        childrenMinVerticalSize += childBox.minVerticalSize;
        childrenMinHorizontalSize = Math.max(childBox.minHorizontalSize, childrenMinHorizontalSize);
      } else {
        childrenMinVerticalSize = Math.max(childBox.minVerticalSize, childrenMinVerticalSize);
        childrenMinHorizontalSize += childBox.minHorizontalSize;
      }
    };
    if (this[0])
      calculateChildBoxMinSize(this[0]);
    if (this[1])
      calculateChildBoxMinSize(this[1]);
    if (forceChildrenSize) {
      this.minVerticalSize = childrenMinVerticalSize;
      this.minHorizontalSize = childrenMinHorizontalSize;
    } else {
      this.minVerticalSize = Math.max(this.minVerticalSize, childrenMinVerticalSize);
      this.minHorizontalSize = Math.max(this.minHorizontalSize, childrenMinHorizontalSize);
    }
    this.minSize = this.vertical ? this.minVerticalSize : this.minHorizontalSize;
    this.calculateMinMaxRatio();
  }
  calculateRatio() {
    if (this[0]) {
      this.calculateChildRatio(this[0]);
    }
    if (this.ratio || this.fixedChild) {
      return;
    }
    if (this[1]) {
      this.calculateChildRatio(this[1]);
    }
    if (!this.ratio && !this.fixedChild) {
      this.ratio = 0.5;
    }
  }
  calculateChildRatio(childBox, isSecond = false) {
    if (!childBox.size) {
      return;
    }
    let size = childBox.size;
    switch (this.sizeUnit) {
      case SizeUnit.px:
        childBox.fixedSize = size;
        this.fixedChild = childBox;
        break;
      case SizeUnit.percent:
        if (isSecond) {
          size = 100 - size;
        }
        this.ratio = Math.min(size / 100, 1);
        break;
    }
  }
  renderButtons(buttonList) {
    let buttons = buttonList.map((button) => {
      return dom.buildDom(["div", {
        class: "button " + button.class,
        title: button.title,
        onclick: button.onclick
      }, button.content]);
    });
    this.setButtons(buttons);
  }
  /**
   * Sets buttons of this box top-right tabBar
   */
  setButtons(buttons) {
    this.buttons = buttons;
    if (this.topRightPane)
      this.topRightPane.removeButtons();
    this.topRightPane = this.getTopRightPane();
    if (this.topRightPane)
      this.topRightPane.setButtons(buttons);
  }
  addButton(button) {
    this.topRightPane = this.getTopRightPane();
    if (this.topRightPane)
      this.topRightPane.addButton(button);
  }
  /**
   * Finds the most top-right Pane
   */
  getTopRightPane() {
    let childBox = this.vertical ? this[0] || this[1] : this[1] || this[0];
    if (!childBox)
      return;
    return childBox.getTopRightPane();
  }
  setBox(x, y, w, h) {
    this.box = [x, y, w, h];
    if (this.isMaximized) {
      x = 0;
      y = 0;
      w = window.innerWidth;
      h = window.innerHeight;
    }
    Utils.setBox(this.element, x, y, w, h);
    this.calculateMinMaxRatio();
    this.$updateChildSize(x, y, w, h);
  }
  $updateChildSize(x, y, w, h) {
    var _a;
    let splitterSize = SPLITTER_SIZE;
    if (!this[0] || this[0].hidden || !this[1] || this[1].hidden) {
      this.splitter.style.display = "none";
      splitterSize = 0;
    } else {
      this.splitter.style.display = "";
    }
    this.updateToolBarSize(w, h);
    w -= this.padding.left + this.padding.right;
    h -= this.padding.top + this.padding.bottom;
    x = this.padding.left;
    y = this.padding.top;
    if (this.fixedChild) {
      let size = this.fixedChild.fixedSize;
      if (this.fixedChild === this[1]) {
        size = this.vertical ? h - size : w - size;
      }
      this.ratio = this.vertical ? size / h : size / w;
    }
    this.ratio = Math.max(this.minRatio, Math.min((_a = this.ratio) != null ? _a : this.maxRatio, this.maxRatio));
    let ratio = this.ratio;
    if (!this[0] || this[0].hidden) {
      ratio = 0;
    } else if (!this[1] || this[1].hidden) {
      ratio = 1;
    }
    if (this.vertical) {
      let splitY = h * ratio - splitterSize;
      if (this.splitter)
        Utils.setBox(this.splitter, x, y + splitY, w, splitterSize);
      if (this[0])
        this[0].setBox(x, y, w, splitY);
      if (this[1])
        this[1].setBox(x, y + splitY + splitterSize, w, h - splitY - splitterSize);
    } else {
      let splitX = w * ratio - splitterSize;
      if (this.splitter)
        Utils.setBox(this.splitter, x + splitX, y, splitterSize, h);
      if (this[0])
        this[0].setBox(x, y, splitX, h);
      if (this[1])
        this[1].setBox(x + splitX + splitterSize, y, w - splitX - splitterSize, h);
    }
  }
  updateToolBarSize(width, height) {
    let bar, x, y, w, h;
    for (let type in this.toolBars) {
      x = 0;
      y = 0;
      w = width;
      h = height;
      bar = this.toolBars[type];
      switch (type) {
        case "top":
        case "bottom":
          h = bar.size;
          if (type === "bottom")
            y = height - bar.size;
          break;
        case "left":
        case "right":
          w = bar.size;
          y = this.padding.top;
          h -= this.padding.top + this.padding.bottom;
          if (type === "right")
            x = width - bar.size;
          break;
        default:
          continue;
      }
      bar.setBox(x, y, w, h);
    }
  }
  restore(disableAnimation = false) {
    let node = this.element;
    function rmClass(ch, cls) {
      for (let i = 0; i < ch.length; i++) {
        if (ch[i].classList)
          ch[i].classList.remove(cls);
      }
    }
    let finishRestore = () => {
      classes.forEach(function(className) {
        rmClass(document.querySelectorAll("." + className), className);
      });
      this.setBox(...this.box);
    };
    let classes = [
      "fullScreenSibling",
      "fullScreenNode",
      "fullScreenParent"
    ];
    this.isMaximized = false;
    if (disableAnimation) {
      finishRestore();
    } else {
      Box.enableAnimation();
      node.addEventListener("transitionend", function handler(l) {
        Box.disableAnimation();
        node.removeEventListener("transitionend", handler);
        finishRestore();
      });
    }
    let parentRect = node.parentNode.getBoundingClientRect();
    let top = parentRect.top + this.box[1];
    let left = parentRect.left + this.box[0];
    Utils.setBox(node, left, top, this.box[2], this.box[3]);
  }
  maximize(disableAnimation = false) {
    let node = this.element;
    function addClasses() {
      node.classList.add("fullScreenNode");
      let parent = node.parentNode;
      while (parent && parent !== document.body) {
        if (parent.classList)
          parent.classList.add("fullScreenParent");
        let childNodes = parent.childNodes;
        for (let i = 0; i < childNodes.length; i++) {
          let childNode = childNodes[i];
          if (childNode != node && childNode.classList && !childNode.classList.contains("fullScreenParent"))
            childNode.classList.add("fullScreenSibling");
        }
        parent = parent.parentNode;
      }
    }
    let rect = node.getBoundingClientRect();
    Utils.setBox(node, rect.left, rect.top, rect.width, rect.height);
    addClasses();
    this.isMaximized = true;
    node.getBoundingClientRect();
    if (!disableAnimation) {
      Box.enableAnimation();
      node.addEventListener("transitionend", function handler() {
        node.removeEventListener("transitionend", handler);
        Box.disableAnimation();
      });
    }
    this.setBox(...this.box);
  }
  toggleMaximize() {
    if (this.isMaximized)
      this.restore();
    else
      this.maximize();
  }
  remove() {
    this.removeAllChildren();
    if (this.element)
      this.element.remove();
    if (this.parent) {
      if (this.parent[0] == this)
        this.parent[0] = void 0;
      if (this.parent[1] == this)
        this.parent[1] = void 0;
      this.parent.recalculateAllMinSizes();
      this.parent = void 0;
    }
  }
  removeAllChildren() {
    this.removeChild(this[0]);
    this.removeChild(this[1]);
    this[0] = void 0;
    this[1] = void 0;
  }
  removeChild(child) {
    if (!child)
      return;
    child.off("editorAdded", this.$editorAdded);
    child.remove();
    child.element.remove();
  }
  toggleShowHide() {
    var _a;
    Box.enableAnimation();
    this.hidden = !this.hidden;
    (_a = this.parent) == null ? void 0 : _a.resize();
    let node = this.element;
    let self = this;
    node.addEventListener("transitionend", function handler() {
      var _a2;
      node.removeEventListener("transitionend", handler);
      Box.disableAnimation();
      (_a2 = self.parent) == null ? void 0 : _a2.resize();
    });
  }
  hide() {
    var _a;
    Box.enableAnimation();
    this.hidden = true;
    (_a = this.parent) == null ? void 0 : _a.resize();
    let node = this.element;
    let self = this;
    node.addEventListener("transitionend", function handler() {
      var _a2;
      node.removeEventListener("transitionend", handler);
      Box.disableAnimation();
      (_a2 = self.parent) == null ? void 0 : _a2.resize();
    });
  }
  show() {
    var _a;
    Box.enableAnimation();
    this.hidden = false;
    (_a = this.parent) == null ? void 0 : _a.resize();
    let node = this.element;
    let self = this;
    node.addEventListener("transitionend", function handler() {
      var _a2;
      node.removeEventListener("transitionend", handler);
      Box.disableAnimation();
      (_a2 = self.parent) == null ? void 0 : _a2.resize();
    });
  }
  /**
   *
   * @param {Number} previousBoxIndex
   * @param {Box} box
   * @returns {Box}
   */
  addChildBox(previousBoxIndex, box) {
    let previousBox, index;
    if (previousBoxIndex instanceof Box) {
      previousBox = previousBoxIndex;
      index = this[0] == previousBox ? 0 : 1;
    } else {
      index = previousBoxIndex;
      previousBox = this[index];
    }
    if (previousBox && previousBox === box)
      return previousBox;
    let previousParent = box.parent;
    if (previousParent && previousParent !== this) {
      let previousIndex = previousParent[0] === box ? 0 : 1;
      previousParent[previousIndex] = null;
      previousParent.ratio = 1;
      if (previousParent.fixedChild && previousParent.fixedChild === box) {
        previousParent.fixedChild = null;
      }
      previousParent.resize();
    }
    this[index] = box;
    box.parent = this;
    this.renderChild(box);
    if (previousBox && previousBox.isMaximized) {
      previousBox.restore(true);
      box.maximize(true);
    }
    if (previousBox && previousBox.parent === this) {
      if (this.fixedChild && this.fixedChild == previousBox) {
        box.fixedSize = previousBox.fixedSize;
        if (!box.size)
          box.size = previousBox.size;
        previousBox.fixedSize = previousBox.size = null;
        this.fixedChild = box;
      }
      previousBox.remove();
    }
    if (!this.fixedChild)
      this.calculateChildRatio(box);
    this.recalculateAllMinSizes();
    this.resize();
    return box;
  }
  recalculateAllMinSizes() {
    let node = this;
    while (node) {
      node.calculateMinSize(true);
      node = node.parent;
    }
  }
}

;// ./src/mouse/accordion_handler.ts


let accordion_handler_event = __nested_webpack_require_364669__(517);
var AccordionHandler;
((AccordionHandler2) => {
  AccordionHandler2.toggleBarMouseDown = function(e, accordionConstructor) {
    let toggleBlock = Utils.findNode(e.target, "toggle-block");
    if (!toggleBlock)
      return;
    let accordionBox, accordionBoxRect, toggleBlockDragging, toggleBlockRect;
    let startIndex, changeIndex, previousIndex;
    let toggleBar, section, splitter;
    let startX = e.clientX, startY = e.clientY;
    let isDragging = false;
    let posX, posY, prevY, prevX;
    let prevBlock, topMaxY, nextBlock, bottomMaxY;
    function distance(dx, dy) {
      return dx * dx + dy * dy;
    }
    function calculateNearbyBlocksData() {
      if (!accordionBox)
        return;
      prevBlock = accordionBox.toggleBlockList[changeIndex - 1] || null;
      nextBlock = accordionBox.toggleBlockList[changeIndex + 1] || null;
      topMaxY = prevBlock && parseInt(prevBlock.style.top, 10) + parseInt(prevBlock.style.height, 10) / 2 + accordionBoxRect.top;
      bottomMaxY = nextBlock && parseInt(nextBlock.style.top, 10) + parseInt(nextBlock.style.height, 10) / 2 + accordionBoxRect.top;
    }
    function startDragging() {
      if (isDragging)
        return;
      accordionBox = Utils.findHost(toggleBlock, accordionConstructor);
      if (!accordionBox)
        return;
      accordionBoxRect = accordionBox.element.getBoundingClientRect();
      startIndex = changeIndex = previousIndex = toggleBlock.$index;
      toggleBlockRect = toggleBlock.getBoundingClientRect();
      toggleBlockDragging = toggleBlock.cloneNode(true);
      toggleBlockDragging.$hostAccordionBox = accordionBox;
      toggleBlockDragging.$hostIndex = startIndex;
      toggleBlockDragging.classList.add("toggleBlockDragging");
      Utils.setBox(toggleBlockDragging, toggleBlockRect.left, toggleBlockRect.top, toggleBlockRect.width, toggleBlockRect.height);
      posX = startX - toggleBlockRect.left;
      posY = startY - toggleBlockRect.top;
      document.body.appendChild(toggleBlockDragging);
      toggleBlock.style.opacity = 0;
      calculateNearbyBlocksData();
      isDragging = true;
    }
    function recalculateIndexes(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i].$index = i;
      }
    }
    function accordionDataChanged() {
      if (!accordionBox)
        return;
      recalculateIndexes(accordionBox.sections);
      recalculateIndexes(accordionBox.toggleBarList);
      recalculateIndexes(accordionBox.toggleBlockList);
      recalculateIndexes(accordionBox.splitterList);
      accordionBox.resize();
    }
    function addToAccordionBox(index) {
      if (!accordionBox)
        return;
      accordionBox.sections.splice(index, 0, section);
      accordionBox.toggleBarList.splice(index, 0, toggleBar);
      accordionBox.toggleBlockList.splice(index, 0, toggleBlock);
      calculateNearbyBlocksData();
      if (nextBlock) {
        accordionBox.element.insertBefore(splitter, nextBlock);
        accordionBox.element.insertBefore(toggleBlock, splitter);
        accordionBox.splitterList.splice(index - 1, 0, splitter);
      } else {
        accordionBox.element.appendChild(splitter);
        accordionBox.element.appendChild(toggleBlock);
        accordionBox.splitterList.push(splitter);
      }
      toggleBlock.$parent = accordionBox;
      splitter.$parent = accordionBox;
      accordionBox.calculateSectionsSizesPercents();
      accordionBox.recalculateChildrenSizes();
      accordionDataChanged();
    }
    function removeFromAccordionBox() {
      if (!accordionBox)
        return;
      section = accordionBox.sections.splice(previousIndex, 1)[0];
      toggleBar = accordionBox.toggleBarList.splice(previousIndex, 1)[0];
      toggleBlock = accordionBox.toggleBlockList.splice(previousIndex, 1)[0];
      let splitterIndex = accordionBox.splitterList[previousIndex] ? previousIndex : previousIndex - 1;
      splitter = accordionBox.splitterList.splice(splitterIndex, 1)[0];
      toggleBlockDragging.style.height = accordionBox.toggleBarHeight + "px";
      toggleBlock.remove();
      splitter.remove();
      accordionBox.calculateSectionsSizesPercents();
      accordionBox.recalculateChildrenSizes();
      accordionDataChanged();
      accordionBox = void 0;
      toggleBlock.$parent = null;
      splitter.$parent = null;
    }
    function finishDragging() {
      if (!accordionBox) {
        accordionBox = toggleBlockDragging.$hostAccordionBox;
        addToAccordionBox(toggleBlockDragging.$hostIndex);
      }
      toggleBlockDragging.remove();
      toggleBlock.style.opacity = 1;
      isDragging = false;
    }
    let onMouseMove = function(e2) {
      if (e2.type !== "mousemove")
        return;
      if (!isDragging) {
        if (distance(e2.clientX - startX, e2.clientY - startY) < 25)
          return;
        startDragging();
      }
      let left = e2.clientX - posX;
      let top = e2.clientY - posY;
      if (accordionBox) {
        if (left < accordionBoxRect.left - accordionBoxRect.width || left > accordionBoxRect.left + accordionBoxRect.width) {
          removeFromAccordionBox();
        }
      }
      if (!accordionBox) {
        accordionBox = Utils.findHost(e2.target, accordionConstructor);
        if (accordionBox) {
          accordionBoxRect = accordionBox.element.getBoundingClientRect();
          nextBlock = Utils.findNode(e2.target, "toggle-block");
          if (nextBlock) {
            startIndex = nextBlock.$index;
          } else {
            startIndex = accordionBox.toggleBlockList.length;
          }
          previousIndex = changeIndex = startIndex;
          addToAccordionBox(previousIndex);
          toggleBlockDragging.style.height = toggleBlock.style.height;
        }
      }
      if (accordionBox) {
        left = accordionBoxRect.left;
        if (e2.clientY < prevY && topMaxY && top < topMaxY) {
          changeIndex--;
        } else if (e2.clientY > prevY && bottomMaxY && top + toggleBlockRect.height > bottomMaxY) {
          changeIndex++;
        }
        if (changeIndex !== previousIndex) {
          accordionBox.element.insertBefore(toggleBlock, accordionBox.toggleBlockList[changeIndex]);
          let splitterIndex = accordionBox.splitterList[previousIndex] ? previousIndex : previousIndex + 1;
          accordionBox.element.insertBefore(accordionBox.toggleBlockList[changeIndex], accordionBox.splitterList[splitterIndex]);
          accordionBox.sections.splice(changeIndex, 0, accordionBox.sections.splice(previousIndex, 1)[0]);
          accordionBox.toggleBarList.splice(changeIndex, 0, accordionBox.toggleBarList.splice(previousIndex, 1)[0]);
          accordionBox.toggleBlockList.splice(changeIndex, 0, accordionBox.toggleBlockList.splice(previousIndex, 1)[0]);
          calculateNearbyBlocksData();
          accordionDataChanged();
          previousIndex = changeIndex;
        }
      }
      toggleBlockDragging.style.left = left + "px";
      toggleBlockDragging.style.top = top + "px";
      prevX = e2.clientX;
      prevY = e2.clientY;
    };
    let onMouseUp = function(e2) {
      if (!isDragging)
        return;
      finishDragging();
    };
    accordion_handler_event.capture(window, onMouseMove, onMouseUp);
    return e.preventDefault();
  };
  AccordionHandler2.toggleBarOnClick = function(e) {
    let toggleBlock = Utils.findNode(e.target, "toggle-block");
    if (!toggleBlock)
      return;
    let accordionBox = toggleBlock.$parent;
    let index = toggleBlock.$index;
    let isOpened = accordionBox.isOpenedBlock(toggleBlock);
    if (!isOpened) {
      toggleBlock.classList.add("toggle-opened");
      index = void 0;
    } else {
      toggleBlock.classList.remove("toggle-opened");
    }
    accordionBox.recalculateChildrenSizes(index);
    Box.enableAnimation();
    let node = accordionBox.element;
    node.addEventListener("transitionend", function handler() {
      node.removeEventListener("transitionend", handler);
      Box.disableAnimation();
    });
    accordionBox.resize();
  };
  AccordionHandler2.splitterMouseDown = function(e) {
    let button = e.button;
    if (button !== 0)
      return;
    let splitter = Utils.findNode(e.target, "splitter");
    if (!splitter)
      return;
    let accordionBox = splitter.$parent;
    let x = e.clientX;
    let y = e.clientY;
    let splitterIndex = splitter.$index + 1;
    let prevX = x;
    let prevY = y;
    if (!accordionBox.hasNextOpenedBlocks(splitterIndex) || !accordionBox.hasPrevOpenedBlocks(splitterIndex))
      return;
    accordionBox.keepState();
    let onMouseMove = function(e2) {
      x = e2.clientX;
      y = e2.clientY;
      let changedSize = 0;
      if (prevY > y) {
        changedSize = accordionBox.recalculatePreviousSectionsSize(splitterIndex, y);
        if (changedSize === 0)
          return;
        accordionBox.expandNextSections(splitterIndex, changedSize);
      } else if (prevY < y) {
        changedSize = accordionBox.recalculateNextSectionsSize(splitterIndex, y);
        if (changedSize === 0)
          return;
        accordionBox.expandPreviousSections(splitterIndex, changedSize);
      } else {
        return;
      }
      prevY = y;
      accordionBox.resize();
    };
    let onResizeEnd = function(e2) {
      accordionBox.dischargeState();
      Box.setGlobalCursor("");
      accordionBox.calculateSectionsSizesPercents();
    };
    Box.setGlobalCursor(`${accordionBox.vertical ? "ns" : "ew"}-resize`);
    accordion_handler_event.capture(window, onMouseMove, onResizeEnd);
    return e.preventDefault();
  };
})(AccordionHandler || (AccordionHandler = {}));

// EXTERNAL MODULE: ../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js
var injectStylesIntoStyleTag = __nested_webpack_require_364669__(591);
var injectStylesIntoStyleTag_default = /*#__PURE__*/__nested_webpack_require_364669__.n(injectStylesIntoStyleTag);
// EXTERNAL MODULE: ../../node_modules/style-loader/dist/runtime/styleDomAPI.js
var styleDomAPI = __nested_webpack_require_364669__(740);
var styleDomAPI_default = /*#__PURE__*/__nested_webpack_require_364669__.n(styleDomAPI);
// EXTERNAL MODULE: ../../node_modules/style-loader/dist/runtime/insertBySelector.js
var insertBySelector = __nested_webpack_require_364669__(128);
var insertBySelector_default = /*#__PURE__*/__nested_webpack_require_364669__.n(insertBySelector);
// EXTERNAL MODULE: ../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js
var setAttributesWithoutAttributes = __nested_webpack_require_364669__(855);
var setAttributesWithoutAttributes_default = /*#__PURE__*/__nested_webpack_require_364669__.n(setAttributesWithoutAttributes);
// EXTERNAL MODULE: ../../node_modules/style-loader/dist/runtime/insertStyleElement.js
var insertStyleElement = __nested_webpack_require_364669__(51);
var insertStyleElement_default = /*#__PURE__*/__nested_webpack_require_364669__.n(insertStyleElement);
// EXTERNAL MODULE: ../../node_modules/style-loader/dist/runtime/styleTagTransform.js
var styleTagTransform = __nested_webpack_require_364669__(656);
var styleTagTransform_default = /*#__PURE__*/__nested_webpack_require_364669__.n(styleTagTransform);
// EXTERNAL MODULE: ../../node_modules/css-loader/dist/cjs.js!./assets/styles/accordion.css
var accordion = __nested_webpack_require_364669__(286);
;// ./assets/styles/accordion.css

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (styleTagTransform_default());
options.setAttributes = (setAttributesWithoutAttributes_default());

      options.insert = insertBySelector_default().bind(null, "head");
    
options.domAPI = (styleDomAPI_default());
options.insertStyleElement = (insertStyleElement_default());

var update = injectStylesIntoStyleTag_default()(accordion/* default */.A, options);




       /* harmony default export */ const styles_accordion = (accordion/* default */.A && accordion/* default */.A.locals ? accordion/* default */.A.locals : undefined);

;// ./src/widgets/boxes/accordion.ts





dom.importCssString(accordion_namespaceObject, "accordion.css");
const accordion_BOX_MIN_SIZE = 80;
class Accordion extends Box {
  constructor(options) {
    var _a;
    super(options);
    //TODO extending from Box isn't right
    this.toggleBarList = [];
    this.splitterList = [];
    this.toggleBlockList = [];
    this.boxMinSize = 30;
    this.toggleBarHeight = 20;
    this.splitterSize = 1;
    this.vertical = options.vertical || false;
    this.color = (_a = options.color) != null ? _a : "";
    this.sections = options.sections;
    this.minSize = options.minSize || accordion_BOX_MIN_SIZE;
    this.minVerticalSize = options.minVerticalSize || this.minSize;
    this.minHorizontalSize = options.minHorizontalSize || this.minSize;
    this.padding = { top: 0, right: 0, bottom: 0, left: 0 };
    this.size = options.size;
  }
  hasNextOpenedBlocks(index) {
    for (let i = index; i < this.toggleBlockList.length; i++) {
      if (this.isOpenedByIndex(i))
        return true;
    }
    return false;
  }
  hasPrevOpenedBlocks(index) {
    for (let i = index - 1; i >= 0; i--) {
      if (this.isOpenedByIndex(i))
        return true;
    }
    return false;
  }
  isOpenedByIndex(index) {
    return this.isOpenedBlock(this.toggleBlockList[index]);
  }
  isOpenedBlock(toggleBlock) {
    return toggleBlock.classList.contains("toggle-opened");
  }
  keepState() {
    this.nextChangedIndexes = [];
    this.prevChangedIndexes = [];
    for (let i = 0; i < this.toggleBlockList.length; i++) {
      if (this.isOpenedByIndex(i)) {
        let section = this.sections[i];
        section.previousSize = section.currentSize;
      }
    }
  }
  dischargeState() {
    this.nextChangedIndexes = void 0;
    this.prevChangedIndexes = void 0;
    for (let i = 0; i < this.toggleBlockList.length; i++) {
      if (this.isOpenedByIndex(i))
        this.sections[i].previousSize = void 0;
    }
  }
  recalculatePreviousSectionsSize(index, top, maxChangeSize) {
    let changedSize = 0;
    for (let i = index - 1; i >= 0; i--) {
      if (this.isOpenedByIndex(i)) {
        let section = this.sections[i];
        let rect = section.box.element.getBoundingClientRect();
        let done = false;
        let prevSize = rect.height;
        let currentSize = Math.max(top - rect.top, this.boxMinSize);
        top -= rect.height;
        if (currentSize < prevSize) {
          if (currentSize > this.boxMinSize)
            done = true;
          if (!this.prevChangedIndexes.includes(i))
            this.prevChangedIndexes.unshift(i);
          section.currentSize = currentSize;
          changedSize += prevSize - currentSize;
          if (done || maxChangeSize != void 0 && changedSize >= maxChangeSize)
            break;
        }
      }
      top -= this.toggleBarHeight;
    }
    return changedSize;
  }
  recalculateNextSectionsSize(index, top, maxChangeSize) {
    let changedSize = 0;
    for (let i = index; i < this.toggleBlockList.length; i++) {
      if (this.isOpenedByIndex(i)) {
        let section = this.sections[i];
        let rect = section.box.element.getBoundingClientRect();
        let done = false;
        let prevSize = rect.height;
        let currentSize = Math.max(rect.bottom - top - this.toggleBarHeight, this.boxMinSize);
        top += rect.height;
        if (currentSize < prevSize) {
          if (currentSize > this.boxMinSize)
            done = true;
          if (!this.nextChangedIndexes.includes(i))
            this.nextChangedIndexes.unshift(i);
          section.currentSize = currentSize;
          changedSize += prevSize - currentSize;
          if (done || maxChangeSize != void 0 && changedSize >= maxChangeSize)
            break;
        }
      }
      top += this.toggleBarHeight;
      top += this.splitterSize;
    }
    return changedSize;
  }
  restoreChangedSizes(size, changedIndexes) {
    if (!changedIndexes)
      return size;
    while (changedIndexes.length && size > 0) {
      let index = changedIndexes[0];
      let section = this.sections[index];
      let currSize = section.currentSize;
      section.currentSize = Math.min(section.previousSize, currSize + size);
      size -= section.currentSize - currSize;
      if (section.currentSize >= section.previousSize)
        changedIndexes.shift();
    }
    return size;
  }
  expandPreviousSections(index, size) {
    size = this.restoreChangedSizes(size, this.prevChangedIndexes);
    if (size <= 0)
      return;
    let openedSectionsList = [];
    for (let i = index - 1; i >= 0; i--) {
      if (this.isOpenedByIndex(i))
        openedSectionsList.push(this.sections[i]);
    }
    this.applySizeToOpenedSections(size, openedSectionsList);
  }
  expandNextSections(index, size) {
    size = this.restoreChangedSizes(size, this.nextChangedIndexes);
    if (size <= 0)
      return;
    let openedSectionsList = [];
    for (let i = index; i < this.toggleBlockList.length; i++) {
      if (this.isOpenedByIndex(i)) {
        openedSectionsList.push(this.sections[i]);
      }
    }
    this.applySizeToOpenedSections(size, openedSectionsList);
  }
  applySizeToOpenedSections(size, openedSections) {
    let count = openedSections.length;
    if (!count)
      return;
    let remainder = size % count;
    let addSize = (size - remainder) / count;
    for (let i = 0; i < count; i++) {
      openedSections[i].currentSize += addSize;
    }
    openedSections[0].currentSize += remainder;
  }
  resize() {
    this.$updateChildSize(...this.rect);
  }
  render() {
    var _a, _b;
    if (this.element)
      return this.element;
    this.element = dom.buildDom(["div", {
      class: "box accordion",
      $host: this
    }]);
    let section;
    let splitter;
    let toggleBlock;
    let toggleBar;
    for (let i = 0; i < this.sections.length; i++) {
      section = this.sections[i];
      if (i > 0) {
        splitter = dom.buildDom(["div", {
          class: `splitter accordion-splitter splitter${this.vertical ? "-v" : "-h"}`,
          $index: i - 1,
          $parent: this,
          onmousedown: function(e) {
            AccordionHandler.splitterMouseDown(e);
          }
        }, ["div"]]);
        this.element.appendChild(splitter);
        this.splitterList.push(splitter);
      }
      toggleBlock = dom.buildDom(["div", {
        class: `toggle-block`,
        $index: i,
        $parent: this
      }]);
      toggleBar = dom.buildDom(["div", {
        class: `toggle-bar toggle-bar${this.vertical ? "-v" : "-h"}`,
        onmousedown: function(e) {
          AccordionHandler.toggleBarMouseDown(e, Accordion);
        },
        onclick: function(e) {
          AccordionHandler.toggleBarOnClick(e);
        }
      }, ["div", { class: "title" }, section.title]]);
      section.currentSize = section.savedSize = parseInt((_b = (_a = section.box.size) == null ? void 0 : _a.toString()) != null ? _b : "", 10);
      toggleBlock.appendChild(toggleBar);
      this.toggleBarList.push(toggleBar);
      toggleBlock.appendChild(section.box.render());
      this.element.appendChild(toggleBlock);
      this.toggleBlockList.push(toggleBlock);
    }
    this.element.style.backgroundColor = this.color;
    this.element.style.position = "absolute";
    this.calculateSectionsSizesPercents();
    return this.element;
  }
  calculateSectionsSizesPercents() {
    let totalSize = 0;
    let actualSizes = [];
    for (let i = 0; i < this.sections.length; i++) {
      let section = this.sections[i];
      actualSizes.push(this.isOpenedByIndex(i) ? section.currentSize : section.savedSize);
      totalSize += actualSizes[i];
    }
    let minPercent = Math.floor(this.boxMinSize / totalSize * 100);
    let maxPercent = 100 - minPercent * (this.sections.length - 1);
    let totalPercent = 0;
    for (let i = 0; i < this.sections.length; i++) {
      let section = this.sections[i];
      section.sizePercent = Math.floor(actualSizes[i] / totalSize * 100);
      section.sizePercent = Math.min(Math.max(section.sizePercent, minPercent), maxPercent);
      totalPercent += section.sizePercent;
    }
    if (totalPercent !== 100)
      this.sections[this.sections.length - 1].sizePercent += 100 - totalPercent;
  }
  setBox(x, y, w, h) {
    this.rect = [x, y, w, h];
    Utils.setBox(this.element, x, y, w, h);
    this.recalculateChildrenSizes();
    this.$updateChildSize(x, y, w, h);
  }
  recalculateChildrenSizes(index) {
    let height = this.rect[3];
    height -= this.toggleBarHeight * this.toggleBarList.length;
    height -= this.splitterSize * this.splitterList.length;
    let totalSize = 0;
    let openedIndexes = [];
    for (let i = 0; i < this.sections.length; i++) {
      let section = this.sections[i];
      section.currentSize = Math.max(Math.floor(height * section.sizePercent / 100), this.boxMinSize);
      if (this.isOpenedByIndex(i)) {
        totalSize += section.currentSize;
        openedIndexes.push(i);
      } else {
        section.savedSize = section.currentSize;
        section.currentSize = 0;
      }
    }
    let spareSize = height - totalSize;
    if (!spareSize)
      return;
    if (index !== void 0) {
      let prevOpenedIndexes = [];
      while (openedIndexes.length && openedIndexes[0] < index) {
        prevOpenedIndexes.push(openedIndexes.shift());
      }
      if (!openedIndexes.length)
        openedIndexes = prevOpenedIndexes;
    }
    let prevSize, changedSize, openedBoxesCount, remainder, addSize;
    while (openedIndexes.length && spareSize) {
      let changedIndexes = [];
      openedBoxesCount = openedIndexes.length;
      remainder = spareSize % openedBoxesCount;
      addSize = (spareSize - remainder) / openedBoxesCount;
      for (let i = 0; i < openedIndexes.length; i++) {
        let section = this.sections[openedIndexes[i]];
        prevSize = section.currentSize;
        if (openedBoxesCount === 1)
          addSize += remainder;
        section.currentSize += addSize;
        section.currentSize = Math.max(section.currentSize, this.boxMinSize);
        changedSize = section.currentSize - prevSize;
        spareSize -= changedSize;
        openedBoxesCount--;
        if (changedSize < 0)
          changedIndexes.push(openedIndexes[i]);
      }
      openedIndexes = changedIndexes;
    }
  }
  $updateChildSize(x, y, w, h) {
    x = 0;
    y = 0;
    for (let i = 0; i < this.toggleBlockList.length; i++) {
      let toggleBlock = this.toggleBlockList[i];
      let section = this.sections[i];
      let boxSize = section.currentSize;
      h = this.toggleBarHeight + boxSize;
      Utils.setBox(toggleBlock, x, y, w, h);
      y += this.toggleBarHeight;
      section.box.setBox(0, this.toggleBarHeight, w, boxSize);
      y += boxSize;
      if (this.splitterList[i]) {
        Utils.setBox(this.splitterList[i], x, y, w, this.splitterSize);
        y += this.splitterSize;
      }
    }
  }
  remove() {
    if (this.element)
      this.element.remove();
    if (this.parent) {
      if (this.vertical === this.parent.vertical)
        this.parent.minSize -= this.minSize;
      if (this.parent[0] == this)
        this.parent[0] = void 0;
      if (this.parent[1] == this)
        this.parent[1] = void 0;
    }
  }
  toJSON() {
    let sections = [];
    let section;
    for (let i = 0; i < this.sections.length; i++) {
      section = this.sections[i];
      sections.push({
        title: section.title,
        boxData: section.box.toJSON()
      });
    }
    return {
      type: "accordion",
      vertical: this.vertical,
      size: this.size,
      sections
    };
  }
}

// EXTERNAL MODULE: external "ace-code/src/autocomplete/popup"
var popup_ = __nested_webpack_require_364669__(910);
;// ./src/widgets/boxes/listBox.ts



class ListBox extends Box {
  render() {
    if (this.element)
      return this.element;
    this.element = super.render();
    let popup = new popup_.AcePopup();
    popup.renderer.setStyle("ace_listBox");
    popup.container.style.display = "block";
    popup.container.style.position = "absolute";
    popup.container.style.zIndex = "0";
    popup.container.style.boxShadow = "none";
    popup.renderer.setScrollMargin(2, 2, 0, 0);
    popup.autoSelect = false;
    popup.renderer["$maxLines"] = null;
    popup.setRow(-1);
    popup.on("click", (e) => {
      e.stop();
      let data = popup.getData(popup.getRow());
    });
    popup.on("dblclick", (e) => {
      e.stop();
      let data = popup.getData(popup.getRow());
    });
    popup.on("tripleclick", (e) => {
      e.stop();
    });
    popup.on("quadclick", (e) => {
      e.stop();
    });
    this.element.appendChild(popup.container);
    this.popup = popup;
    delete popup.focus;
    return this.element;
  }
  $updateChildSize(x, y, w, h) {
    Utils.setBox(this.popup.container, x, y, w, h);
    this.popup.resize(true);
  }
}

// EXTERNAL MODULE: external "ace-code/esm-resolver"
var esm_resolver_ = __nested_webpack_require_364669__(444);
var esm_resolver_default = /*#__PURE__*/__nested_webpack_require_364669__.n(esm_resolver_);
// EXTERNAL MODULE: external "ace-code/src/editor"
var editor_ = __nested_webpack_require_364669__(254);
// EXTERNAL MODULE: external "ace-code/src/virtual_renderer"
var virtual_renderer_ = __nested_webpack_require_364669__(748);
// EXTERNAL MODULE: external "ace-code/src/ext/language_tools"
var language_tools_ = __nested_webpack_require_364669__(685);
;// ./src/widgets/editors/aceEditor.ts



const modeList = __nested_webpack_require_364669__(292);

class AceEditor {
  resize() {
    this.editor.resize();
  }
  focus() {
    this.editor.focus();
  }
  destroy() {
    this.editor.setSession(esm_resolver_default().createEditSession("", this.getMode()));
    this.editor.destroy();
    this.container.remove();
  }
  constructor() {
    this.editor = new editor_.Editor(new virtual_renderer_.VirtualRenderer(null));
    this.container = this.editor.container;
    this.container.style.position = "absolute";
    this.editor.setOptions({
      customScrollbar: false,
      newLineMode: "unix",
      enableLiveAutocompletion: true,
      enableBasicAutocompletion: true,
      showPrintMargin: false
    });
  }
  setSession(tab, value) {
    this.tab = tab;
    this.initTabSession(value);
    this.editor.setSession(this.tab.session);
  }
  initTabSession(value) {
    var _a, _b;
    if (this.tab.session && value == null)
      return;
    (_b = (_a = this.tab).session) != null ? _b : _a.session = esm_resolver_default().createEditSession(value != null ? value : "", this.getMode());
    if (value == null) {
      this.restoreSessionFromJson(this.tab);
    } else {
      this.tab.session.setValue(value);
    }
  }
  getMode() {
    if (this.tab.path !== void 0) {
      return modeList.getModeForPath(this.tab.path).mode;
    }
    return null;
  }
  static getSessionState(tab) {
    let session = tab.session;
    let undoManager = session.getUndoManager();
    return JSON.stringify({
      selection: session.selection.toJSON(),
      //@ts-ignore
      undoManager: undoManager.toJSON(),
      value: session.getValue(),
      scroll: [
        session.getScrollLeft(),
        session.getScrollTop()
      ]
    });
  }
  sessionToJSON(tab) {
    return AceEditor.getSessionState(tab);
  }
  restoreSessionFromJson(tab) {
    if (!tab.session || !tab.sessionValue)
      return;
    let session = tab.session;
    let json = JSON.parse(tab.sessionValue);
    try {
      if (typeof json.value == "string" && json.value != session.getValue())
        session.doc.setValue(json.value);
      if (json.selection)
        session.selection.fromJSON(json.selection);
      if (json.scroll) {
        session.setScrollLeft(json.scroll[0]);
        session.setScrollTop(json.scroll[1]);
      }
      tab.sessionValue = void 0;
    } catch (e) {
      console.error(e);
    }
  }
}

;// ./src/widgets/editors/previewEditor.ts
class PreviewEditor {
  resize() {
  }
  focus() {
  }
  destroy() {
    this.container.remove();
  }
  constructor() {
    this.container = document.createElement("iframe");
    this.container.style.position = "absolute";
  }
  setSession(tab, value) {
    this.tab = tab;
    value != null ? value : value = tab.session;
    tab.session = value;
    this.container.setAttribute("srcdoc", value);
  }
  restoreSessionFromJson(tab) {
    var _a;
    tab.session = (_a = tab.sessionValue) != null ? _a : "";
    tab.sessionValue = void 0;
  }
  sessionToJSON(tab) {
    return tab.session;
  }
}

;// ./src/mouse/tabbar_handler.ts


let tabbar_handler_event = __nested_webpack_require_364669__(517);
var TabbarHandler;
((TabbarHandler2) => {
  TabbarHandler2.tabbarMouseDown = function(e, tabConstructor, tabBarConstructor, showSplit = false) {
    let divSplit, splitPosition, pane;
    function hideSplitPosition() {
      if (!divSplit)
        return;
      divSplit.remove();
      divSplit = splitPosition = pane = null;
    }
    function showSplitPosition(e2) {
      let el = e2.target;
      if (tabBar) {
        hideSplitPosition();
        return;
      }
      pane = Utils.findHost(el);
      if (!pane || !pane.acceptsTab || !pane.acceptsTab(tab)) {
        hideSplitPosition();
        return;
      }
      if (pane.tabBar.tabList.length === 0) {
        hideSplitPosition();
        return;
      }
      let dark = false;
      if (!divSplit) {
        divSplit = document.createElement("div");
        document.body.appendChild(divSplit);
      }
      divSplit.className = "split-area" + (dark ? " dark" : "");
      let rect = pane.element.getBoundingClientRect();
      let bHeight = pane.tabBar.element.clientHeight - 1;
      rect = {
        left: rect.left,
        top: rect.top + bHeight,
        width: rect.width,
        height: rect.height - bHeight
      };
      let left = (e2.clientX - rect.left) / rect.width;
      let right = 1 - left;
      let top = (e2.clientY - rect.top) / rect.height;
      let bottom = 1 - top;
      let min = Math.min(left, top, right, bottom);
      if (min == left) {
        splitPosition = [true, false];
        Utils.setBox(divSplit, rect.left, rect.top, rect.width / 2, rect.height);
      } else if (min == right) {
        splitPosition = [false, false];
        Utils.setBox(divSplit, rect.left + rect.width / 2, rect.top, rect.width / 2, rect.height);
      } else if (min == top) {
        splitPosition = [true, true];
        Utils.setBox(divSplit, rect.left, rect.top, rect.width, rect.height / 2);
      } else if (min == bottom) {
        splitPosition = [false, true];
        Utils.setBox(divSplit, rect.left, rect.top + rect.height / 2, rect.width, rect.height / 2);
      }
    }
    if (e.target.classList.contains("tabCloseButton")) {
      return;
    }
    let tab = Utils.findHost(e.target, tabConstructor);
    if (!tab)
      return;
    let tabBar = Utils.findHost(e.target, tabBarConstructor);
    if (!tabBar)
      return;
    let isVertical = tabBar.isVertical();
    tabBar.tabMouseDown(tab, e.shiftKey, e.ctrlKey);
    if (e.shiftKey || e.ctrlKey)
      return;
    let isDragging = false;
    let posX, posY, prevX, prevY;
    let startX = e.clientX, startY = e.clientY;
    let parentRect, tabElement, index, selectedTabs, hostTabBar, hostIndex;
    let prevTab, leftMaxX, topMaxY, nextTab, rightMaxX, bottomMaxY;
    let tabDragElementSize = 0;
    let tabDragElementLeft = 0;
    let tabDragElementTop = 0;
    let calculateNearbyTabsData = function() {
      if (isVertical) {
        topMaxY = prevTab && parseInt(prevTab.style.top, 10) + parseInt(prevTab.style.height, 10) / 2 + parentRect.top;
        bottomMaxY = nextTab && parseInt(nextTab.style.top, 10) + parseInt(nextTab.style.height, 10) / 2 + parentRect.top;
      } else {
        if (prevTab) {
          let prevSibling = prevTab.previousSibling;
          leftMaxX = prevSibling ? parseInt(prevSibling.style.left, 10) + parseInt(prevSibling.style.width, 10) + parentRect.left : parentRect.left;
        }
        rightMaxX = nextTab && parseInt(nextTab.style.left, 10) + parseInt(nextTab.style.width, 10) / 2 + parentRect.left;
      }
    };
    let startDragging = function() {
      if (isDragging || !tabBar)
        return;
      tabElement = dom.buildDom(["div", {
        class: "tabDragging"
      }]);
      let activeIndex = index = tabBar.tabList.indexOf(tab);
      tabBar.tabContainer.insertBefore(tabElement, tab.element);
      tabDragElementLeft = parseInt(tab.element.style.left, 10);
      tabDragElementTop = parseInt(tab.element.style.top, 10);
      selectedTabs = [];
      let selectedTab, selectedTabElement;
      for (let i = 0; i < tabBar.selectedTabs.length; i++) {
        selectedTab = tabBar.selectedTabs[i];
        selectedTab.currentIndex = tabBar.tabList.indexOf(selectedTab);
        if (selectedTab.currentIndex < activeIndex) {
          index--;
          if (isVertical) {
            tabDragElementTop -= parseInt(selectedTab.element.style.top, 10);
          } else {
            tabDragElementLeft -= parseInt(selectedTab.element.style.width, 10);
          }
        }
        selectedTabs.push(selectedTab);
      }
      selectedTabs.sort(function(tab1, tab2) {
        return tab1.currentIndex - tab2.currentIndex;
      });
      for (let i = 0; i < selectedTabs.length; i++) {
        selectedTab = selectedTabs[i];
        selectedTabElement = selectedTab.element;
        tabElement.appendChild(selectedTabElement);
        selectedTabElement.style.pointerEvents = "none";
        if (isVertical) {
          selectedTabElement.style.top = tabDragElementSize + "px";
          tabDragElementSize += parseInt(selectedTabElement.style.height, 10);
        } else {
          selectedTabElement.style.left = tabDragElementSize + "px";
          tabDragElementSize += parseInt(selectedTabElement.style.width, 10);
        }
        tabBar.removeTab(selectedTab);
      }
      prevTab = tabElement.previousSibling;
      nextTab = tabElement.nextSibling;
      parentRect = tabBar.element.getBoundingClientRect();
      if (isVertical) {
        tabDragElementTop += parentRect.top;
        posY = startY - tabDragElementTop;
        posX = startX - parentRect.left;
      } else {
        tabDragElementLeft += parentRect.left;
        posX = startX - tabDragElementLeft;
        posY = startY - parentRect.top;
      }
      prevX = e.clientX;
      prevY = e.clientY;
      hostTabBar = tabBar;
      hostIndex = index;
      calculateNearbyTabsData();
      isDragging = true;
      document.body.appendChild(tabElement);
      if (isVertical) {
        Utils.setBox(tabElement, tabDragElementTop, parentRect.left, parentRect.width, tabDragElementSize);
      } else {
        Utils.setBox(tabElement, tabDragElementLeft, parentRect.top, tabDragElementSize, parentRect.height);
      }
      tabBar.startTabDragging(tabElement, index);
    };
    let finishDragging = function() {
      if (pane && pane.split && splitPosition) {
        let newPane = pane.split(...splitPosition);
        tabBar = newPane.tabBar;
      } else if (!tabBar) {
        tabBar = hostTabBar;
      }
      tabBar.removeSelections();
      tabElement.remove();
      let selectedTab;
      for (let i = 0; i < selectedTabs.length; i++) {
        selectedTab = selectedTabs[i];
        selectedTab.element.style.pointerEvents = "";
        if (selectedTab === tab) {
          selectedTab.active = true;
        }
        tabBar.addTab(selectedTab, index++);
        tabBar.addSelection(selectedTab);
      }
      if (tabBar !== hostTabBar) {
        hostTabBar.removeSelections();
        hostTabBar.activatePrevious(hostIndex);
      }
      tabBar.finishTabDragging();
      isDragging = false;
      hideSplitPosition();
    };
    function distance(dx, dy) {
      return dx * dx + dy * dy;
    }
    let onMouseMove = function(e2) {
      if (e2.type !== "mousemove")
        return;
      if (!isDragging) {
        if (distance(e2.clientX - startX, e2.clientY - startY) < 25)
          return;
        startDragging();
      }
      function removeTabFromBar() {
        tabBar.finishTabDragging();
        tabBar = void 0;
      }
      if (tabBar) {
        tabBar.startTabDragging(tabElement, index);
        if (!isVertical && (e2.clientX < parentRect.left || e2.clientX > parentRect.left + parentRect.width) || isVertical && (e2.clientY < parentRect.top || e2.clientY > parentRect.top + parentRect.height)) {
          removeTabFromBar();
        }
      } else {
        tabBar = Utils.findHost(e2.target, tabBarConstructor);
        if (tabBar) {
          isVertical = tabBar.isVertical();
          let nextTabHost = Utils.findHost(e2.target, tabConstructor);
          if (nextTabHost) {
            index = tabBar.tabList.indexOf(nextTabHost);
            nextTab = nextTabHost.element;
            prevTab = nextTab.previousSibling;
          } else {
            index = tabBar.tabList.length;
            nextTab = null;
            prevTab = tabBar.tabContainer.childNodes[index - 1];
          }
          tabBar.startTabDragging(tabElement, index);
          parentRect = tabBar.element.getBoundingClientRect();
          calculateNearbyTabsData();
        }
      }
      if (showSplit)
        showSplitPosition(e2);
      let left = e2.clientX - posX;
      let top = e2.clientY - posY;
      let x = left;
      let y = top;
      if (tabBar) {
        if (isVertical && (x < parentRect.left - parentRect.width || x > parentRect.left + parentRect.width) || !isVertical && (y < parentRect.top - parentRect.height || y > parentRect.top + parentRect.height)) {
          removeTabFromBar();
        } else {
          if (isVertical) {
            x = parentRect.left;
          } else {
            y = parentRect.top;
          }
          if (isVertical && e2.clientY < prevY && topMaxY && top < topMaxY || !isVertical && e2.clientX < prevX && leftMaxX && left < leftMaxX) {
            if (isVertical) {
              prevTab.style.top = parseInt(prevTab.style.top, 10) + tabDragElementSize + "px";
            } else {
              prevTab.style.left = parseInt(prevTab.style.left, 10) + tabDragElementSize + "px";
            }
            index--;
            [prevTab, nextTab] = [prevTab.previousSibling, prevTab];
            calculateNearbyTabsData();
          } else if (isVertical && e2.clientY > prevY && bottomMaxY && top + tabDragElementSize > bottomMaxY || !isVertical && e2.clientX > prevX && rightMaxX && left + tabDragElementSize > rightMaxX) {
            if (isVertical) {
              nextTab.style.top = parseInt(nextTab.style.top, 10) - tabDragElementSize + "px";
            } else {
              nextTab.style.left = parseInt(nextTab.style.left, 10) - tabDragElementSize + "px";
            }
            index++;
            [prevTab, nextTab] = [nextTab, nextTab.nextSibling];
            calculateNearbyTabsData();
          }
        }
      }
      prevX = e2.clientX;
      prevY = e2.clientY;
      tabElement.style.left = x + "px";
      tabElement.style.top = y + "px";
    };
    let onMouseUp = function(e2) {
      if (!isDragging) {
        if (tabBar.selectedTabs.length > 1) {
          tabBar.removeSelections();
          tabBar.addSelection(tab);
        }
      } else {
        finishDragging();
      }
    };
    tabbar_handler_event.capture(window, onMouseMove, onMouseUp);
    return e.preventDefault();
  };
})(TabbarHandler || (TabbarHandler = {}));
window.addEventListener("mousedown", function() {
  document.body.classList.add("disableIframe");
}, true);
window.addEventListener("mouseup", function() {
  document.body.classList.remove("disableIframe");
}, true);

// EXTERNAL MODULE: ../../node_modules/css-loader/dist/cjs.js!./assets/styles/tab.css
var tab = __nested_webpack_require_364669__(129);
;// ./assets/styles/tab.css

      
      
      
      
      
      
      
      
      

var tab_options = {};

tab_options.styleTagTransform = (styleTagTransform_default());
tab_options.setAttributes = (setAttributesWithoutAttributes_default());

      tab_options.insert = insertBySelector_default().bind(null, "head");
    
tab_options.domAPI = (styleDomAPI_default());
tab_options.insertStyleElement = (insertStyleElement_default());

var tab_update = injectStylesIntoStyleTag_default()(tab/* default */.A, tab_options);




       /* harmony default export */ const styles_tab = (tab/* default */.A && tab/* default */.A.locals ? tab/* default */.A.locals : undefined);

;// ./src/widgets/tabs/tabPanel.ts
class TabPanel {
  constructor(options) {
    var _a;
    this.active = (_a = options.active) != null ? _a : false;
    this.title = options.title;
  }
  activate() {
    this.active = true;
    this.element.classList.add("active");
  }
  deactivate() {
    this.active = false;
    this.element.classList.remove("active");
  }
}

;// ./src/widgets/tabs/tab.ts





dom.importCssString(tab_namespaceObject, "tab.css");
class Tab extends TabPanel {
  constructor(options) {
    var _a, _b, _c;
    super(options);
    this.contextMenu = "tabs";
    this.tabIcon = (_a = options.icon) != null ? _a : "";
    this.path = options.path;
    this.preview = (_b = options.preview) != null ? _b : false;
    this.editorType = (_c = options.editorType) != null ? _c : EditorType.ace;
  }
  toJSON() {
    return {
      title: this.title,
      icon: this.tabIcon || void 0,
      active: this.active || void 0,
      path: this.path,
      preview: this.preview || void 0,
      editorType: this.editorType
    };
  }
  activate(content) {
    super.activate();
    this.activatePane();
    let tabManager = TabManager.getInstance();
    tabManager.loadFile(this, content);
    tabManager.activePane.resize();
  }
  activatePane() {
    var _a;
    TabManager.getInstance().activePane = (_a = this.parent) == null ? void 0 : _a.parent;
  }
  remove() {
    var _a;
    (_a = this.parent) == null ? void 0 : _a.closeTab(this);
  }
  set caption(value) {
    this.$caption = value;
  }
  get caption() {
    return this.$caption;
  }
  render() {
    this.element = dom.buildDom([
      "div",
      {
        class: "tab" + (this.active ? " active" : ""),
        title: this.path
      },
      ["span", { class: "tabIcon" }, this.tabIcon],
      ["span", { class: "tabTitle", ref: "$title" }, this.title],
      ["span", { class: "tabCloseButton" }]
    ], void 0, this);
    if (this.preview)
      this.element.style.fontStyle = "italic";
    this.element.$host = this;
    return this.element;
  }
  setTitle(title) {
    this.title = title;
    this.element.getElementsByClassName("tabTitle")[0].innerHTML = title;
  }
  get isActive() {
    var _a;
    return ((_a = this.parent) == null ? void 0 : _a.activeTab) == this;
  }
  get editor() {
    var _a;
    return (_a = this.parent) == null ? void 0 : _a.parent.getEditor(this.editorType);
  }
}

;// ./src/commands/tabCommands.ts


function getCurrentPaneTabs(element) {
  var _a, _b, _c, _d;
  if (element instanceof Tab) {
    return {
      tabs: [...(_b = (_a = element.parent) == null ? void 0 : _a.tabList) != null ? _b : []],
      activeTab: element
    };
  } else {
    return {
      tabs: [...(_d = (_c = element.activePane) == null ? void 0 : _c.tabBar.tabList) != null ? _d : []],
      activeTab: element.activeTab
    };
  }
}
function goToTab(el, tabNum) {
  let currentPaneTabs = getCurrentPaneTabs(el);
  let tabs = currentPaneTabs.tabs;
  let activeTab = currentPaneTabs.activeTab;
  let index = tabNum != null ? tabNum : tabs.indexOf(activeTab);
  TabManager.getInstance().navigateToTab(index, activeTab, tabs);
}
let tabCommands = [
  {
    name: "clonetab",
    mac: "",
    win: "",
    desc: "Create a new tab with a view on the same file"
  },
  {
    name: "Close Tab",
    mac: "Option-W",
    win: "Alt-W",
    desc: "close the tab that is currently active",
    position: 300,
    exec: (el) => {
      if (el instanceof Tab) {
        el.remove();
      } else {
        el.activeTab.remove();
      }
    }
  },
  {
    name: "Close All Tabs",
    mac: "Option-Shift-W",
    win: "Alt-Shift-W",
    desc: "Close all opened tabs",
    position: 310,
    exec: () => {
      let tabs = TabManager.getInstance().tabs;
      for (let i in tabs) {
        tabs[i].remove();
      }
    }
  },
  {
    name: "Close other tabs",
    mac: "Option-Ctrl-W",
    win: "Ctrl-Alt-W",
    desc: "close all opened tabs, except the tab that is currently active",
    position: 320,
    exec: (el) => {
      let currentPaneTabs = getCurrentPaneTabs(el);
      let tabs = currentPaneTabs.tabs;
      let activeTab = currentPaneTabs.activeTab;
      for (let tab of tabs) {
        if (tab != activeTab)
          tab.remove();
      }
    }
  },
  {
    name: "Go to tab right",
    mac: "Command-}",
    win: "Ctrl-}",
    //TODO: used by ace
    desc: "navigate to the next tab, right to the tab that is currently active",
    position: 330,
    exec: (el) => {
      let currentPaneTabs = getCurrentPaneTabs(el);
      let tabs = currentPaneTabs.tabs;
      let activeTab = currentPaneTabs.activeTab;
      let index = tabs.indexOf(activeTab);
      TabManager.getInstance().navigateToTab(index + 1, activeTab, tabs);
    }
  },
  {
    name: "Go to tab left",
    mac: "Command-{",
    win: "Ctrl-{",
    //TODO: used by ace
    desc: "navigate to the next tab, left to the tab that is currently active",
    position: 340,
    exec: (el) => {
      let currentPaneTabs = getCurrentPaneTabs(el);
      let tabs = currentPaneTabs.tabs;
      let activeTab = currentPaneTabs.activeTab;
      let index = tabs.indexOf(activeTab);
      TabManager.getInstance().navigateToTab(index - 1, activeTab, tabs);
    }
  },
  {
    name: "movetabright",
    mac: "Command-Option-Shift-Right",
    win: "Ctrl-Meta-Right",
    desc: "move the tab that is currently active to the right. Will create a split tab to the right if it's the right most tab."
  },
  {
    name: "movetableft",
    mac: "Command-Option-Shift-Left",
    win: "Ctrl-Meta-Left",
    desc: "move the tab that is currently active to the left. Will create a split tab to the left if it's the left most tab."
  },
  {
    name: "movetabup",
    mac: "Command-Option-Shift-Up",
    win: "Ctrl-Meta-Up",
    desc: "move the tab that is currently active to the up. Will create a split tab to the top if it's the top most tab."
  },
  {
    name: "movetabdown",
    mac: "Command-Option-Shift-Down",
    win: "Ctrl-Meta-Down",
    desc: "move the tab that is currently active to the down. Will create a split tab to the bottom if it's the bottom most tab."
  },
  {
    name: "Go to first tab",
    mac: "Command-1",
    win: "Ctrl-1",
    desc: "navigate to the first tab",
    position: 340,
    exec: (el) => {
      goToTab(el, 0);
    }
  },
  {
    name: "Go to second tab",
    mac: "Command-2",
    win: "Ctrl-2",
    desc: "navigate to the second tab",
    position: 340,
    exec: (el) => {
      goToTab(el, 1);
    }
  },
  {
    name: "Go to third tab",
    mac: "Command-3",
    win: "Ctrl-3",
    desc: "navigate to the third tab",
    position: 340,
    exec: (el) => {
      goToTab(el, 2);
    }
  },
  {
    name: "tab4",
    mac: "Command-4",
    win: "Ctrl-4",
    desc: "navigate to the fourth tab",
    position: 340,
    exec: (el) => {
      goToTab(el, 3);
    }
  },
  {
    name: "tab5",
    mac: "Command-5",
    win: "Ctrl-5",
    desc: "navigate to the fifth tab",
    position: 340,
    exec: (el) => {
      goToTab(el, 4);
    }
  },
  {
    name: "tab6",
    mac: "Command-6",
    win: "Ctrl-6",
    desc: "navigate to the sixth tab",
    position: 340,
    exec: (el) => {
      goToTab(el, 5);
    }
  },
  {
    name: "tab7",
    mac: "Command-7",
    win: "Ctrl-7",
    desc: "navigate to the seventh tab",
    position: 340,
    exec: (el) => {
      goToTab(el, 6);
    }
  },
  {
    name: "tab8",
    mac: "Command-8",
    win: "Ctrl-8",
    desc: "navigate to the eighth tab",
    position: 340,
    exec: (el) => {
      goToTab(el, 7);
    }
  },
  {
    name: "tab9",
    mac: "Command-9",
    win: "Ctrl-9",
    desc: "navigate to the ninth tab",
    position: 340,
    exec: (el) => {
      goToTab(el, 8);
    }
  },
  {
    name: "tab0",
    mac: "Command-0",
    win: "Ctrl-0",
    desc: "navigate to the tenth tab",
    position: 340,
    exec: (el) => {
      goToTab(el, 9);
    }
  },
  {
    name: "Reveal tab",
    mac: "Command-Shift-L",
    win: "Ctrl-Shift-L",
    //TODO: used by ace
    desc: "reveal current tab in the file tree",
    position: 340,
    exec: (el) => {
    }
  },
  {
    name: "Go to next tab",
    mac: "Option-Tab",
    win: "Ctrl-Tab|Alt-`",
    desc: "navigate to the next tab in the stack of accessed tabs",
    position: 340,
    exec: (el) => {
      let currentPaneTabs = getCurrentPaneTabs(el);
      let tabs = currentPaneTabs.tabs;
      let activeTab = currentPaneTabs.activeTab;
      let index = tabs.indexOf(activeTab);
      if (index < tabs.length - 1) {
        TabManager.getInstance().navigateToTab(index + 1, activeTab, tabs);
      } else {
        TabManager.getInstance().navigateToTab(0, activeTab, tabs);
      }
    }
  },
  {
    name: "Go to previous tab",
    mac: "Option-Shift-Tab",
    win: "Ctrl-Shift-Tab|Alt-Shift-`",
    desc: "navigate to the previous tab in the stack of accessed tabs",
    position: 340,
    exec: (el) => {
      let currentPaneTabs = getCurrentPaneTabs(el);
      let tabs = currentPaneTabs.tabs;
      let activeTab = currentPaneTabs.activeTab;
      let index = tabs.indexOf(activeTab);
      if (index > 0) {
        TabManager.getInstance().navigateToTab(index - 1, activeTab, tabs);
      } else {
        TabManager.getInstance().navigateToTab(tabs.length - 1, activeTab, tabs);
      }
    }
  },
  {
    name: "nextpane",
    mac: "Option-ESC",
    win: "Ctrl-`",
    desc: "navigate to the next tab in the stack of panes"
  },
  {
    name: "previouspane",
    mac: "Option-Shift-ESC",
    win: "Ctrl-Shift-`",
    desc: "navigate to the previous tab in the stack of panes"
  },
  {
    name: "gotopaneright",
    mac: "Ctrl-Meta-Right",
    win: "Ctrl-Meta-Right",
    desc: "navigate to the pane on the right"
  },
  {
    name: "gotopaneleft",
    mac: "Ctrl-Meta-Left",
    win: "Ctrl-Meta-Left",
    desc: "navigate to the pane on the left"
  },
  {
    name: "gotopaneup",
    mac: "Ctrl-Meta-Up",
    win: "Ctrl-Meta-Up",
    desc: "navigate to the pane on the top"
  },
  {
    name: "gotopanedown",
    mac: "Ctrl-Meta-Down",
    win: "Ctrl-Meta-Down",
    desc: "navigate to the pane on the bottom"
  },
  {
    name: "reopenLastTab",
    mac: "Option-Shift-T",
    win: "Alt-Shift-T",
    /*exec: function () {
        return menuClosedItems.length;
    },*/
    desc: "reopen last closed tab"
  },
  {
    name: "Close all to the right",
    mac: "",
    win: "",
    desc: "close all tabs to the right of the focussed tab",
    position: 340,
    exec: (el) => {
      let currentPaneTabs = getCurrentPaneTabs(el);
      let tabs = currentPaneTabs.tabs;
      let activeTab = currentPaneTabs.activeTab;
      let index = tabs.indexOf(activeTab);
      if (index < tabs.length - 1) {
        for (let i = index + 1; i < tabs.length; i++) {
          tabs[i].remove();
        }
      }
    }
  },
  {
    name: "Close all to the left",
    mac: "",
    win: "",
    desc: "close all tabs to the left of the focussed tab",
    position: 340,
    exec: (el) => {
      let currentPaneTabs = getCurrentPaneTabs(el);
      let tabs = currentPaneTabs.tabs;
      let activeTab = currentPaneTabs.activeTab;
      let index = tabs.indexOf(activeTab);
      if (index > 0) {
        for (let i = 0; i < index; i++) {
          tabs[i].remove();
        }
      }
    }
  },
  {
    name: "Close pane",
    mac: "Command-Ctrl-W",
    win: "Ctrl-W",
    desc: "close this pane",
    position: 340,
    exec: (el) => {
      var _a, _b;
      let tabs;
      if (el instanceof Tab) {
        tabs = [...(_b = (_a = el.parent) == null ? void 0 : _a.tabList) != null ? _b : []];
      } else {
        tabs = [...el.activePane.tabBar.tabList];
      }
      for (let tab of tabs) {
        tab.remove();
      }
    }
  },
  {
    name: "nosplit",
    mac: "",
    win: "",
    desc: "no split"
  },
  {
    name: "hsplit",
    mac: "",
    win: "",
    desc: "split the current pane in two columns and move the active tab to it"
  },
  {
    name: "vsplit",
    mac: "",
    win: "",
    desc: "split the current pane in two rows and move the active tab to it"
  },
  {
    name: "twovsplit",
    mac: "",
    win: "",
    desc: "create a two pane row layout"
  },
  {
    name: "twohsplit",
    mac: "",
    win: "",
    desc: "create a two pane column layout"
  },
  {
    name: "foursplit",
    mac: "",
    win: "",
    desc: "create a four pane layout"
  },
  {
    name: "threeleft",
    mac: "",
    win: "",
    desc: "create a three pane layout with the stack on the left side"
  },
  {
    name: "threeright",
    mac: "",
    win: "",
    desc: "create a three pane layout with the stack on the right side"
  }
];

// EXTERNAL MODULE: external "ace-code/src/lib/event_emitter"
var event_emitter_ = __nested_webpack_require_364669__(540);
// EXTERNAL MODULE: ../../node_modules/css-loader/dist/cjs.js!./assets/styles/menu.css
var menu = __nested_webpack_require_364669__(807);
;// ./assets/styles/menu.css

      
      
      
      
      
      
      
      
      

var menu_options = {};

menu_options.styleTagTransform = (styleTagTransform_default());
menu_options.setAttributes = (setAttributesWithoutAttributes_default());

      menu_options.insert = insertBySelector_default().bind(null, "head");
    
menu_options.domAPI = (styleDomAPI_default());
menu_options.insertStyleElement = (insertStyleElement_default());

var menu_update = injectStylesIntoStyleTag_default()(menu/* default */.A, menu_options);




       /* harmony default export */ const styles_menu = (menu/* default */.A && menu/* default */.A.locals ? menu/* default */.A.locals : undefined);

;// ./src/widgets/menu/menu.ts



dom.importCssString(menu_namespaceObject, "menu.css");
class Menu {
  getLastOpenPopup() {
    return !this.menuPopup ? this : this.menuPopup.getLastOpenPopup();
  }
  getLastSelectedMenu() {
    return !this.menuPopup || !this.menuPopup.selectedMenu ? this.selectedMenu : this.menuPopup.getLastSelectedMenu();
  }
  closeLastMenu() {
    if (this.menuPopup && this.menuPopup.menuPopup) {
      this.menuPopup.closeLastMenu();
    } else {
      this.closeMenu();
    }
  }
  selectMenu(menu) {
    menu.buttonElement.classList.add(this.selectedClass);
    this.selectedMenu = menu;
  }
  unselectMenu() {
    if (!this.selectedMenu)
      return;
    this.selectedMenu.buttonElement.classList.remove(this.selectedClass);
    this.selectedMenu = void 0;
  }
  openMenu(direction) {
    if (!direction && this.constructor.name === "MenuPopup")
      direction = "right";
    if (this.menuPopup)
      return this.menuPopup;
    this.menuPopup = new MenuPopup();
    this.menuPopup.direction = direction != null ? direction : "";
    this.menuPopup.isSubMenu = this.constructor.name === "MenuPopup";
    this.menuPopup.menuManager = this.menuManager;
    this.menuPopup.menu = this.selectedMenu;
    this.menuPopup.parentMenu = this;
    this.menuPopup.open();
    if (this.menuManager.searchBox && this.menuManager.searchBox.isOpen) {
      if (!this.menuPopup.isSubMenu) {
        this.menuManager.searchBox.setParentPopup(this.menuPopup);
      } else {
        this.menuManager.searchBox.addSymbol("/");
      }
    }
    return this.menuPopup;
  }
  closeMenu() {
    if (!this.menuPopup) {
      return;
    }
    if (this.menuManager.searchBox && this.menuManager.searchBox.isOpen && this.menuPopup.isSubMenu && this.menuManager.searchBox.value.substring(this.menuManager.searchBox.value.length - 1) === "/") {
      this.menuManager.searchBox.removeSymbol();
    }
    this.menuPopup.close();
    this.menuPopup = void 0;
  }
  moveOnTarget(target) {
    let host = target ? target.$host : null;
    if (!host) {
      return;
    }
    if (this.selectedMenu) {
      if (host.path === this.selectedMenu.path) {
        return;
      } else {
        this.unselectMenu();
      }
    }
    if (this.menuPopup) {
      this.closeMenu();
    }
    host.buttonElement = host.$buttonElement || target;
    this.selectMenu(host);
  }
  openMenuByPath(path) {
    var _a;
    if (typeof path === "string")
      path = path.split("/");
    let menu = this.getMenuByPath(path.shift());
    if (!menu)
      return;
    if (!menu.$host)
      menu.$host = menu;
    this.moveOnTarget(menu);
    if (!menu.$host.map)
      return;
    this.openMenu();
    if (path.length)
      (_a = this.menuPopup) == null ? void 0 : _a.openMenuByPath(path);
  }
}
class MenuBar extends Menu {
  constructor() {
    super(...arguments);
    this.selectedClass = "menuButtonDown";
    this.onMouseMove = (e) => {
      let target = this.menuManager.getTarget(e.target);
      this.moveOnTarget(target);
    };
  }
  build(parent) {
    this.element = parent;
    let items = this.menus.map || {};
    Object.keys(items).filter(Boolean).map((key) => items[key]).sort(function(item1, item2) {
      return item1.position - item2.position;
    }).map((item) => {
      item.$buttonElement = dom.buildDom(["div", {
        class: "menuButton" + (item.className ? " " + item.className : ""),
        $host: item,
        onmousedown: (e) => this.onMouseDown(e)
      }, item.label + ""], this.element);
    });
    let rect = this.element.getBoundingClientRect();
    this.bottom = rect.bottom;
  }
  activateMenu() {
    this.element.addEventListener("mousemove", this.onMouseMove);
  }
  inactivateMenu() {
    this.unselectMenu();
    this.closeMenu();
    this.element.removeEventListener("mousemove", this.onMouseMove);
  }
  /*** event handlers ***/
  onMouseDown(e) {
    e.preventDefault();
    let activate = true;
    if (this.menuManager.isActive) {
      this.menuManager.inactivateMenu();
    } else {
      let target = e.target;
      target.$host.buttonElement = target.$host.$buttonElement;
      this.selectMenu(target.$host);
      this.openMenu();
      this.menuManager.activeMenu = this;
      this.menuManager.activateMenu();
    }
  }
  moveOnTarget(target) {
    var _a;
    super.moveOnTarget(target);
    if ((_a = this.selectedMenu) == null ? void 0 : _a.map)
      this.openMenu();
  }
  getMenuByPath(path) {
    return this.menuManager.find(path);
  }
}
class MenuPopup extends Menu {
  constructor() {
    super(...arguments);
    this.selectedClass = "hover";
    this.isSubMenu = false;
    //handle events
    this.onMouseMove = (e) => {
      var _a;
      if (e.target === this.element)
        return;
      if (this.menuPopup && this.isDirectedToSubMenu(e))
        return;
      let target = this.menuManager.getTarget(e.target);
      if (target === this.element)
        return;
      this.moveOnTarget(target);
      if ((_a = this.selectedMenu) == null ? void 0 : _a.map)
        this.openMenu();
    };
    this.onMouseUp = (e) => {
      if (e.target === this.element)
        return;
      let target = this.menuManager.getTarget(e.target);
      if (!target || target === this.element)
        return;
      let host = target.$host;
      if (host && host.buttonElement) {
        e.preventDefault();
        if (host.exec)
          host.exec(this.menuManager.currentHost);
      }
      if (!host.map)
        this.menuManager.inactivateMenu();
    };
  }
  inactivateMenu() {
    this.close();
  }
  activateMenu() {
  }
  open() {
    this.build();
    this.render();
  }
  build() {
    if (this.element) {
      return;
    }
    if (this.menu.element) {
      this.element = this.menu.element;
      return;
    }
    let result = [];
    if (this.menu.map) {
      let items = Object.values(this.menu.map).sort(function(item1, item2) {
        return item1.position - item2.position;
      });
      let afterDivider = true;
      result = items.map((item) => {
        if (item.label[0] === "~") {
          if (afterDivider)
            return;
          afterDivider = true;
          return [
            "div",
            {
              class: "menu_divider",
              $host: item
            }
          ];
        }
        afterDivider = false;
        let classList = ["menu_item"];
        if (item.checked)
          classList.push(item.type === "check" ? "checked" : "selected");
        if (item.map)
          classList.push("submenu");
        if (item.disabled)
          classList.push("disabled");
        return [
          "div",
          {
            class: classList.join(" "),
            $host: item
          },
          ["u", " "],
          ["a", item.label + ""],
          [
            "span",
            {
              class: "shortcut"
            },
            item.hotKey
          ]
        ];
      }).filter(Boolean);
      if (afterDivider)
        result.pop();
    }
    this.menu.element = dom.buildDom(
      [
        "blockquote",
        {
          class: "menu",
          style: "display:block",
          $host: this.menu,
          onmousemove: this.onMouseMove,
          onmouseup: this.onMouseUp
        },
        result
      ],
      document.body
    );
    this.element = this.menu.element;
  }
  render() {
    if (!this.element)
      return;
    if (this.element.style.maxWidth)
      this.element.style.maxWidth = window.innerWidth + "px";
    if (this.element.style.maxHeight)
      this.element.style.maxHeight = window.innerHeight + "px";
    let elRect = this.element.getBoundingClientRect();
    let edge = Utils.getElementEdges(this.element);
    let parentRect, top, left;
    if (this.menu && this.menu.buttonElement)
      parentRect = this.menu.buttonElement.getBoundingClientRect();
    if (parentRect) {
      if (this.isSubMenu) {
        top = parentRect.top - edge.top;
        left = parentRect.right;
      } else {
        top = parentRect.bottom;
        left = parentRect.left;
      }
    } else {
      top = this.position.y;
      left = this.position.x;
    }
    let targetH = Math.min(elRect.height, window.innerHeight);
    let availableH = window.innerHeight - top - edge.top - edge.bottom - 2;
    if (availableH < targetH && (!parentRect || this.isSubMenu)) {
      let tmpTop = parentRect ? window.innerHeight : top;
      top = tmpTop - targetH - edge.top;
      top = Math.max(top, this.menuManager.menuBar.bottom);
      availableH = window.innerHeight - top - edge.top - edge.bottom - 2;
    }
    this.element.style.maxHeight = availableH - 10 + "px";
    elRect = this.element.getBoundingClientRect();
    let availableW = window.innerWidth - left - edge.left - edge.right - 2;
    if (availableW < elRect.width) {
      if (parentRect) {
        let tmpLeft = this.isSubMenu ? parentRect.left : parentRect.right;
        if (tmpLeft > availableW) {
          this.direction = "left";
          left = tmpLeft - elRect.width + edge.left;
          left = Math.max(left, 0);
          availableW = tmpLeft + edge.left + edge.right;
        }
        if (availableW < elRect.width) {
          this.element.style.maxWidth = availableW + "px";
          this.element.style.overflowX = "auto";
        }
      } else {
        left = window.innerWidth - elRect.width - edge.left - edge.right;
      }
    }
    this.element.style.top = top + "px";
    this.element.style.left = left + "px";
    this.element.style.position = "absolute";
    this.element.style.zIndex = String(195055);
    this.element.style.overflowY = "auto";
  }
  close() {
    if (this.menuPopup) {
      this.closeMenu();
    }
    if (this.element) {
      this.element.remove();
      delete this.element;
    }
    if (this.menu.element) {
      delete this.menu.element;
    }
  }
  scrollIfNeeded() {
    if (!this.selectedMenu)
      return;
    let menu = this.element;
    let item = this.selectedMenu.buttonElement;
    let menuRect = menu.getBoundingClientRect();
    let itemRect = item.getBoundingClientRect();
    if (itemRect.top < menuRect.top) {
      item.scrollIntoView(true);
    } else if (itemRect.bottom > menuRect.bottom) {
      item.scrollIntoView(false);
    }
  }
  moveOnTarget(target) {
    super.moveOnTarget(target);
  }
  isDirectedToSubMenu(e) {
    let currPos = { x: e.clientX, y: e.clientY };
    let prevPos = this.menuManager.prevPos;
    let rect = this.menuPopup.element.getBoundingClientRect();
    let rectYTop = rect.top;
    let rectYBottom = rect.bottom;
    if (currPos.y < rectYTop || currPos.y > rectYBottom) {
      return false;
    }
    let rectX = this.menuPopup.direction === "left" ? rect.right : rect.left;
    let prevDiffX = Math.abs(rectX - prevPos.x);
    let currDiffX = Math.abs(rectX - currPos.x);
    if (prevDiffX < currDiffX) {
      return false;
    }
    let directedToBottom = currPos.y > prevPos.y;
    let prevDiffY = directedToBottom ? rectYBottom - prevPos.y : prevPos.y - rectYTop;
    let tng = prevDiffY / prevDiffX;
    let maxYDiff = tng * currDiffX;
    return directedToBottom && rectYBottom - maxYDiff >= currPos.y || !directedToBottom && rectYTop + maxYDiff <= currPos.y;
  }
  renderRecursive() {
    this.render();
    if (this.menuPopup) {
      this.menuPopup.renderRecursive();
    }
  }
  getMenuByPath(path) {
    let childNode;
    let childNodes = this.element.childNodes;
    for (let i = 0; i < childNodes.length; i++) {
      childNode = childNodes[i];
      if (childNode.$host && childNode.$host.id === path) {
        if (childNode.classList.contains("menu_item") && !childNode.classList.contains("disabled")) {
          return childNode;
        }
      }
    }
    return null;
  }
}
class MenuSearchBox {
  constructor() {
    this.isOpen = false;
    this.hideFiltered = false;
    this.value = "";
    this.currValue = "";
  }
  open() {
    if (!this.element) {
      this.build();
    }
    this.isOpen = true;
    document.body.appendChild(this.element);
    this.calcElementPosition();
  }
  close() {
    this.isOpen = false;
    if (this.parentPopup && this.parentPopup.element) {
      if (this.parentPopup.prevMaxHeight) {
        this.parentPopup.element.style.maxHeight = this.parentPopup.prevMaxHeight;
      }
    }
    if (this.value.length) {
      this.value = "";
      this.currValue = "";
      this.update();
    }
    this.parentPopup = void 0;
    this.element.remove();
  }
  setParentPopup(parentPopup) {
    var _a;
    if (this.parentPopup && this.parentPopup.element) {
      if (this.parentPopup.prevMaxHeight) {
        this.parentPopup.element.style.maxHeight = this.parentPopup.prevMaxHeight;
      }
    }
    this.parentPopup = parentPopup;
    this.currPopupMenu = parentPopup;
    if (this.isOpen) {
      this.calcElementPosition();
      let currPopupMenu = parentPopup;
      let valueArr = this.value.split("/");
      while (currPopupMenu) {
        this.currPopupMenu = currPopupMenu;
        this.currValue = (_a = valueArr.shift()) != null ? _a : "";
        this.isChanged = true;
        this.update();
        this.isOpen = false;
        currPopupMenu = this.currPopupMenu.selectedMenu && this.currPopupMenu.selectedMenu.map ? this.currPopupMenu.openMenu() : null;
        this.isOpen = true;
      }
    }
  }
  calcElementPosition() {
    if (!this.parentPopup)
      return;
    this.parentPopup.prevMaxHeight = null;
    let parentRect = this.parentPopup.element.getBoundingClientRect();
    let top = parentRect.top - 20;
    if (top < this.menuManager.menuBar.bottom) {
      top = parentRect.bottom;
      if (parentRect.bottom + 20 > window.innerHeight) {
        this.parentPopup.prevMaxHeight = this.parentPopup.element.style.maxHeight;
        this.parentPopup.element.style.maxHeight = parseInt(this.parentPopup.element.style.maxHeight, 10) - 20 + "px";
        top -= 20;
      }
    }
    this.element.style.top = top + "px";
    this.element.style.right = window.innerWidth - parentRect.right + "px";
  }
  addSymbol(symbol) {
    var _a;
    if (symbol === "/" && this.value.substring(this.value.length - 1) === "/") {
      return;
    }
    this.value += symbol;
    if (symbol === "/") {
      if (((_a = this.currPopupMenu) == null ? void 0 : _a.selectedMenu) && this.currPopupMenu.selectedMenu.map) {
        this.currPopupMenu = this.currPopupMenu.openMenu();
        this.currValue = "";
      }
      this.isChanged = false;
    } else {
      this.currValue += symbol;
      this.isChanged = true;
    }
    this.update();
  }
  removeSymbol() {
    var _a, _b;
    if (!this.isOpen) {
      return;
    }
    let removed = this.value.substring(this.value.length - 1);
    this.value = this.value.substring(0, this.value.length - 1);
    if (removed === "/") {
      this.currValue = (_a = this.value.split("/").pop()) != null ? _a : "";
      this.currPopupMenu = ((_b = this.currPopupMenu) == null ? void 0 : _b.parentMenu) instanceof MenuPopup ? this.currPopupMenu.parentMenu : void 0;
      this.isChanged = false;
    } else {
      this.currValue = this.currValue.substring(0, this.currValue.length - 1);
      this.isChanged = true;
    }
    this.update();
    if (!this.value.length) {
      this.close();
    }
  }
  update() {
    this.searchField.textContent = this.value;
    if (this.currPopupMenu && this.currPopupMenu.element && this.isChanged) {
      this.setPopupMenuHighlights();
      if (this.hideFiltered) {
        this.calcElementPosition();
      }
    }
  }
  switchShowHideFiltered() {
    this.hideFiltered = !this.hideFiltered;
    this.update();
    if (!this.hideFiltered) {
      this.calcElementPosition();
    }
  }
  showHideMenuNode(menu, show) {
    var _a;
    show = show || false;
    if (!show && menu.classList.contains("hover") && ((_a = this.currPopupMenu) == null ? void 0 : _a.menuPopup)) {
      show = true;
    }
    menu.isFiltered = !show;
    show = show || !this.hideFiltered;
    menu.style.display = show ? "block" : "none";
  }
  setPopupMenuHighlights() {
    var _a;
    if (!((_a = this.currPopupMenu) == null ? void 0 : _a.element))
      return;
    let childNode;
    let width = 0;
    this.selectMenu = null;
    this.secondarySelectMenu = null;
    if (this.hideFiltered) {
      let rect = this.currPopupMenu.element.getBoundingClientRect();
      let edges = Utils.getElementEdges(this.currPopupMenu.element);
      width = rect.width - edges.left - edges.right;
    }
    let afterDivider = true;
    let noResult = true;
    for (let i = 0; i < this.currPopupMenu.element.childNodes.length; i++) {
      childNode = this.currPopupMenu.element.childNodes[i];
      if (childNode.classList.contains("menu_item")) {
        this.setHighlights(childNode);
        afterDivider = afterDivider && childNode.isFiltered;
        if (noResult && !childNode.isFiltered) {
          noResult = false;
        }
      } else if (childNode.classList.contains("menu_divider")) {
        this.showHideMenuNode(childNode, !afterDivider);
        afterDivider = true;
      }
    }
    if (this.hideFiltered) {
      this.currPopupMenu.element.style.width = Math.ceil(width) + "px";
      let noResultEl = this.currPopupMenu.element.querySelector(".menu_no_result");
      if (noResult && !noResultEl) {
        dom.buildDom(["div", { class: "menu_no_result" }, "No matching result"], this.currPopupMenu.element);
      } else if (!noResult && noResultEl) {
        noResultEl.remove();
      }
    }
    this.selectMenu = this.selectMenu || this.secondarySelectMenu;
    if (this.selectMenu) {
      this.currPopupMenu.moveOnTarget(this.selectMenu);
      this.currPopupMenu.scrollIfNeeded();
    }
    if (this.hideFiltered) {
      this.currPopupMenu.renderRecursive();
    }
    if (this.suggestionPopup) {
      this.suggestionPopup.close();
    }
    if (noResult) {
      this.currValue = this.value;
      let suggestionList = {};
      let addToSuggestionList = (menus) => {
        Object.keys(menus).forEach((name) => {
          let item = menus[name];
          if (item.label && item.label[0] === "~") {
            return;
          }
          if (!item.path) {
            console.log(item);
            return;
          }
          let path = item.path;
          let tokens = this.getTokens(path);
          if (tokens) {
            suggestionList[path] = {
              label: path,
              tokens
            };
          }
          if (item.map) {
            addToSuggestionList(item.map);
          }
        });
      };
      addToSuggestionList(this.menuManager.menus.map);
      this.suggestionPopup = new MenuPopup();
      this.suggestionPopup.direction = "right";
      this.suggestionPopup.isSubMenu = true;
      this.suggestionPopup.menuManager = this.menuManager;
      this.suggestionPopup.menu = {
        buttonElement: this.element,
        map: suggestionList
      };
      this.suggestionPopup.parentMenu = this;
      this.suggestionPopup.open();
      for (let i = 0; i < this.suggestionPopup.element.childNodes.length; i++) {
        let childNode2 = this.suggestionPopup.element.childNodes[i];
        let menuTitle = childNode2.querySelector("a");
        let innerHtml = "";
        for (let t = 0; t < childNode2.$host.tokens.length; t++) {
          innerHtml += "<span class='menu-" + childNode2.$host.tokens[t].type + "'>" + childNode2.$host.tokens[t].value + "</span>";
        }
        menuTitle.innerHTML = innerHtml;
      }
    }
  }
  setHighlights(menu) {
    let text = menu.$host.label;
    let menuTitle = menu.querySelector("a");
    if (!this.currValue || !this.currValue.length) {
      menuTitle.innerHTML = text;
      this.showHideMenuNode(menu, true);
      return;
    }
    let tokens = this.getTokens(text);
    let innerHtml = "";
    let show = true;
    if (tokens) {
      if (menu.classList.contains("disabled")) {
        innerHtml = text;
      } else {
        this.secondarySelectMenu = this.secondarySelectMenu || menu;
        if (!this.selectMenu && tokens[0].type === "completion-highlight") {
          this.selectMenu = menu;
        }
        for (let i = 0; i < tokens.length; i++) {
          innerHtml += "<span class='menu-" + tokens[i].type + "'>" + tokens[i].value + "</span>";
        }
      }
    } else {
      innerHtml = text;
      show = false;
    }
    this.showHideMenuNode(menu, show);
    menuTitle.innerHTML = innerHtml;
  }
  getTokens(string) {
    let tokens = [];
    let caption = string.toLowerCase();
    let lower = this.currValue.toLowerCase();
    let upper = this.currValue.toUpperCase();
    function addToken(value, className) {
      value && tokens.push({
        type: className || "",
        value
      });
    }
    let lastIndex = -1;
    let matchMask = 0;
    let index, distance;
    let fullMatchIndex = caption.indexOf(lower);
    if (fullMatchIndex === -1) {
      for (let j = 0; j < this.currValue.length; j++) {
        let i1 = caption.indexOf(lower[j], lastIndex + 1);
        let i2 = caption.indexOf(upper[j], lastIndex + 1);
        index = i1 >= 0 ? i2 < 0 || i1 < i2 ? i1 : i2 : i2;
        if (index < 0)
          return;
        distance = index - lastIndex - 1;
        if (distance > 0) {
          matchMask = matchMask | 1 << j;
        }
        lastIndex = index;
      }
    }
    let filterText = lower;
    lower = caption.toLowerCase();
    lastIndex = 0;
    let lastI = 0;
    for (let i = 0; i <= filterText.length; i++) {
      if (i !== lastI && (matchMask & 1 << i || i === filterText.length)) {
        let sub = filterText.slice(lastI, i);
        lastI = i;
        index = lower.indexOf(sub, lastIndex);
        if (index === -1)
          continue;
        addToken(string.slice(lastIndex, index), "");
        lastIndex = index + sub.length;
        addToken(string.slice(index, lastIndex), "completion-highlight");
      }
    }
    addToken(string.slice(lastIndex, string.length), "");
    return tokens;
  }
  build() {
    var _a, _b, _c, _d;
    this.element = dom.buildDom([
      "div",
      { class: "menu_searchbox" },
      ["span", { class: "search_field" }],
      ["span", { class: "searchbtn_filter" }],
      ["span", { class: "searchbtn_close" }]
    ]);
    this.element.$host = this;
    this.searchField = this.element.querySelector(".search_field");
    let _this = this;
    (_b = (_a = this.element) == null ? void 0 : _a.querySelector(".searchbtn_close")) == null ? void 0 : _b.addEventListener("mousedown", function(e) {
      _this.close();
    });
    (_d = (_c = this.element) == null ? void 0 : _c.querySelector(".searchbtn_filter")) == null ? void 0 : _d.addEventListener("mousedown", function(e) {
      _this.switchShowHideFiltered();
    });
  }
}

;// ./src/widgets/menu/menuManager.ts


const menuManager_event = __nested_webpack_require_364669__(517);
const menuManager_keyUtil = __nested_webpack_require_364669__(863);
function getPrevSibling(node, conditionFn, parentElement) {
  parentElement = node ? node.parentElement : parentElement;
  let wrapped = false;
  do {
    node = node && node.previousSibling;
    if (!node && !wrapped) {
      node = parentElement == null ? void 0 : parentElement.lastChild;
      wrapped = true;
    }
    if (!node)
      return;
  } while (!conditionFn(node));
  return node;
}
function getNextSibling(node, conditionFn, parentElement) {
  parentElement = node ? node.parentElement : parentElement;
  let wrapped = false;
  do {
    node = node && node.nextSibling;
    if (!node && !wrapped) {
      node = parentElement == null ? void 0 : parentElement.firstChild;
      wrapped = true;
    }
    if (!node)
      return;
  } while (!conditionFn(node));
  return node;
}
class MenuManager {
  constructor() {
    this.menus = new MenuItems();
    //event handlers
    this.onMouseDown = (e) => {
      let target = this.getTarget(e.target, (target2) => target2.$host instanceof MenuItems);
      if (!target)
        this.inactivateMenu();
    };
    this.onMouseMove = (e) => {
      let lastPos = { x: e.clientX, y: e.clientY };
      if (this.lastPos && this.lastPos.x === lastPos.x && this.lastPos.y === lastPos.y) {
        return;
      }
      this.prevPos = this.lastPos;
      this.lastPos = lastPos;
    };
    this.onWindowResize = (e) => {
      if (!this.activeMenu) {
        return;
      }
      let menuPopup = this.activeMenu instanceof MenuPopup ? this.activeMenu : this.activeMenu.menuPopup;
      if (menuPopup) {
        menuPopup.renderRecursive();
      }
    };
    this.onContextMenuOpen = (e) => {
      e.preventDefault();
      let target = this.getTarget(e.target, (target2) => target2.$host.contextMenu);
      if (!target) {
        return;
      }
      let pos = { x: e.clientX + 2, y: e.clientY + 2 };
      this.openMenuByPath("/context/" + target.$host.contextMenu, pos);
      this.currentHost = target.$host;
    };
    this.add = this.addByPath;
  }
  static getInstance() {
    if (!MenuManager._instance) {
      MenuManager._instance = new MenuManager();
    }
    return MenuManager._instance;
  }
  find(path, item) {
    if (typeof path === "string")
      path = path.split("/");
    item = item || this.menus;
    path.forEach(function(part) {
      if (!item || !item.map)
        return;
      item = item.map[part];
    });
    return item;
  }
  addByPath(path, options = {}) {
    var _a, _b, _c, _d, _e;
    if (typeof path == "string")
      path = path.split("/");
    let item = this.menus;
    path.forEach(function(part) {
      var _a2, _b2, _c2;
      (_a2 = item.map) != null ? _a2 : item.map = {};
      (_c2 = (_b2 = item.map)[part]) != null ? _c2 : _b2[part] = new MenuItems();
      item = item.map[part];
    });
    item.path = path.join("/");
    let name = path.pop();
    item.id = name;
    item.label = options.label || name;
    item.position = (_a = options.position) != null ? _a : 0;
    item.hotKey = options.hotKey;
    item.type = (_b = options.type) != null ? _b : "";
    item.checked = (_c = options.checked) != null ? _c : false;
    item.disabled = (_d = options.disabled) != null ? _d : false;
    item.className = (_e = options.className) != null ? _e : "";
    item.exec = options.exec;
  }
  getTarget(target, callback) {
    while (target) {
      if (target.$host && (!callback || callback(target)))
        return target;
      target = target.parentElement;
    }
    return;
  }
  bindKeys() {
    function isMenuBarItem(node) {
      return node.classList.contains("menuButton");
    }
    function isMenuPopupActiveItem(node) {
      return node.classList.contains("menu_item") && !node.classList.contains("disabled") && !node.isFiltered;
    }
    function menuKeyDown(menuManager) {
      var _a;
      let menuPopup = (_a = menuManager.activeMenu) == null ? void 0 : _a.getLastOpenPopup();
      if (!menuPopup)
        return;
      let menu = menuPopup.selectedMenu ? menuPopup.selectedMenu.buttonElement : null;
      let nextMenu = getNextSibling(menu, isMenuPopupActiveItem, menuPopup.element);
      menuPopup.moveOnTarget(nextMenu);
      menuPopup.scrollIfNeeded();
    }
    let menuKb = new hash_handler_.HashHandler([
      {
        bindKey: "Esc",
        name: "Esc",
        exec: function(menuManager) {
          if (menuManager.searchBox && menuManager.searchBox.isOpen) {
            menuManager.searchBox.close();
            return;
          }
          let activeMenu = menuManager.activeMenu;
          if (!activeMenu.menuPopup && activeMenu !== menuManager.menuBar) {
            activeMenu.close();
            menuManager.inactivateMenu();
          } else {
            activeMenu.closeLastMenu();
            if (!activeMenu.menuPopup && activeMenu === menuManager.menuBar) {
              menuManager.inactivateMenu();
            }
          }
        }
      },
      {
        bindKey: "Left",
        name: "Left",
        exec: function(menuManager) {
          let activeMenu = menuManager.activeMenu;
          activeMenu.closeLastMenu();
          if (!activeMenu.menuPopup) {
            if (activeMenu === menuManager.menuBar) {
              let prevMenu = getPrevSibling(activeMenu.selectedMenu.buttonElement, isMenuBarItem);
              if (prevMenu) {
                activeMenu.moveOnTarget(prevMenu);
              }
            } else if (!activeMenu.element) {
              menuManager.inactivateMenu();
            }
          }
        }
      },
      {
        bindKey: "Right",
        name: "Right",
        exec: function(menuManager) {
          function moveToNextOnBar() {
            if (menuManager.activeMenu !== menuManager.menuBar) {
              return;
            }
            let nextMenu = getNextSibling(menuManager.menuBar.selectedMenu.buttonElement, isMenuBarItem);
            if (nextMenu) {
              menuManager.menuBar.moveOnTarget(nextMenu);
            }
          }
          let menuPopup = menuManager.activeMenu.getLastOpenPopup();
          let menu = menuManager.activeMenu.getLastSelectedMenu();
          if (!menu) {
            return;
          }
          let moveToNext = !menu.map || menuManager.activeMenu === menuManager.menuBar && !menuManager.activeMenu.menuPopup.selectedMenu;
          if (!moveToNext && (!menuPopup.selectedMenu && (menuManager.activeMenu.menuPopup !== menuPopup || menuManager.activeMenu !== menuPopup) || menuPopup.selectedMenu === menu)) {
            let isNewOpened = false;
            if (menuPopup.selectedMenu === menu) {
              menuPopup.openMenu();
              isNewOpened = true;
            }
            menuKeyDown(menuManager);
            if (!isNewOpened && !menuPopup.selectedMenu) {
              moveToNext = true;
            }
          }
          if (moveToNext) {
            moveToNextOnBar();
          }
        }
      },
      {
        bindKey: "Enter",
        name: "Enter",
        exec: function(menuManager) {
          let menuPopup = menuManager.activeMenu.getLastOpenPopup();
          let menu = menuManager.activeMenu.getLastSelectedMenu();
          if (menu && menu.map && menuPopup.selectedMenu === menu) {
            menuPopup.openMenu();
          }
        }
      },
      {
        bindKey: "Up",
        name: "Up",
        exec: function(menuManager) {
          let menuPopup = menuManager.activeMenu.getLastOpenPopup();
          let menu = menuPopup.selectedMenu ? menuPopup.selectedMenu.buttonElement : null;
          let prevMenu = getPrevSibling(menu, isMenuPopupActiveItem, menuPopup.element);
          menuPopup.moveOnTarget(prevMenu);
          menuPopup.scrollIfNeeded();
        }
      },
      {
        bindKey: "Backspace",
        name: "Backspace",
        exec: function(menuManager) {
          menuManager.searchBox.removeSymbol();
        }
      },
      {
        bindKey: "Down",
        name: "Down",
        exec: menuKeyDown
      }
    ]);
    let _this = this;
    menuManager_event.addCommandKeyListener(window, function(e, hashId, keyCode) {
      if (!_this.isActive) {
        return;
      }
      menuManager_event.stopEvent(e);
      let keyString = menuManager_keyUtil.keyCodeToString(keyCode);
      let command = menuKb.findKeyCommand(hashId, keyString);
      if (command && command.exec) {
        command.exec(_this);
      } else if (e.key.length === 1) {
        MenuManager.getInstance().addSymbolToSearchBox(e.key);
      }
    });
  }
  build() {
    window.addEventListener("contextmenu", this.onContextMenuOpen);
  }
  buildMenuBar(parent) {
    this.menuBar = new MenuBar();
    this.menuBar.menus = this.menus;
    this.menuBar.menuManager = this;
    this.menuBar.build(parent);
  }
  openMenuByPath(path, position) {
    if (typeof path === "string")
      path = path.split("/");
    if (path[0] && path[0].length) {
      this.activeMenu = this.menuBar;
    } else {
      this.activeMenu = new MenuPopup();
      this.activeMenu.menuManager = this;
      this.activeMenu.position = position;
      this.activeMenu.menu = this.find(path);
      this.activeMenu.open();
    }
    this.activateMenu();
    this.activeMenu.openMenuByPath(path);
  }
  activateMenu() {
    var _a;
    this.isActive = true;
    window.addEventListener("mousedown", this.onMouseDown);
    window.addEventListener("mousemove", this.onMouseMove);
    window.addEventListener("resize", this.onWindowResize);
    if ((_a = this.activeMenu) == null ? void 0 : _a.activateMenu)
      this.activeMenu.activateMenu();
  }
  inactivateMenu() {
    var _a;
    this.isActive = false;
    window.removeEventListener("mousedown", this.onMouseDown);
    window.removeEventListener("mousemove", this.onMouseMove);
    window.removeEventListener("resize", this.onWindowResize);
    if ((_a = this.activeMenu) == null ? void 0 : _a.inactivateMenu)
      this.activeMenu.inactivateMenu();
    this.activeMenu = void 0;
    if (this.searchBox)
      this.searchBox.close();
    this.currentHost = null;
  }
  addSymbolToSearchBox(symbol) {
    if (!this.searchBox || !this.searchBox.isOpen) {
      this.openSearchBox();
    }
    this.searchBox.addSymbol(symbol);
  }
  openSearchBox() {
    var _a;
    if (!this.searchBox) {
      this.searchBox = new MenuSearchBox();
      this.searchBox.menuManager = this;
    }
    this.searchBox.setParentPopup((_a = this.activeMenu) == null ? void 0 : _a.getLastOpenPopup());
    this.searchBox.open();
  }
}
class MenuItems {
}

;// ./src/widgets/tabs/tabManager.ts


const oop = __nested_webpack_require_364669__(387);

const useragent = __nested_webpack_require_364669__(493);




let newTabCounter = 1;
class TabManager {
  constructor(options) {
    this.$setBoxState = (box, state) => {
      if (!box)
        return;
      box.removeAllChildren();
      this.setBoxData(box, state);
      if (!box[0] && box.isMain)
        this.setChildBoxData(box, [{ type: "pane" }], 0);
    };
    this.containers = options.containers;
    this.tabs = {};
    this.fileSystem = options.fileSystem;
    this.commandsInit();
    this.initFileSystem();
  }
  static getInstance(options) {
    if (!TabManager._instance)
      TabManager._instance = new TabManager(options);
    return TabManager._instance;
  }
  initFileSystem() {
    var _a;
    (_a = this.fileSystem) == null ? void 0 : _a.on("openFile", (treeNode, fileContent) => {
      this.open({
        path: treeNode.path,
        title: treeNode.path.split("/").pop()
      }, void 0, fileContent);
    });
  }
  commandsInit() {
    MenuManager.getInstance().addByPath("/context/tabs");
    let commandsKeys = [];
    for (let command of tabCommands) {
      if (command.exec !== void 0) {
        MenuManager.getInstance().addByPath("/context/tabs/" + command.name, {
          position: command.position,
          hotKey: useragent.isMac ? command.mac : command.win,
          exec: command.exec
        });
        commandsKeys.push({
          bindKey: {
            win: command.win,
            mac: command.mac
          },
          exec: command.exec
        });
      }
    }
    CommandManager.registerCommands(commandsKeys, this);
  }
  toJSON() {
    let containers = Object.keys(this.containers);
    return Object.fromEntries(containers.map((container) => {
      var _a;
      return [container, (_a = this.containers[container]) == null ? void 0 : _a.toJSON()];
    }));
  }
  setChildBoxData(box, boxData, index) {
    if (!boxData[index])
      return;
    let boxType = boxData[index].type;
    if (!box[index])
      box.addChildBox(index, boxType === "pane" ? new Pane() : new Box({ vertical: boxType === "vbox" }));
    this.setBoxData(box[index], boxData[index]);
  }
  setBoxData(box, boxData) {
    if (!boxData)
      return;
    if (boxData.fixedSize)
      box.fixedSize = boxData.fixedSize;
    if (box instanceof Pane) {
      if (boxData.tabBar) {
        box.tabBar.scrollLeft = boxData.tabBar.scrollLeft;
        if (boxData.tabBar.tabList) {
          box.tabBar.freeze = true;
          boxData.tabBar.tabList.forEach((tabData) => {
            let tab = box.tabBar.addTab(new Tab(tabData));
            this.tabs[tab.path] = tab;
            if (tab.preview)
              this.previewTab = tab;
          });
          box.tabBar.freeze = false;
          box.tabBar.configure();
        }
      }
    } else {
      box.hidden = boxData.hidden;
      box.ratio = boxData.ratio;
      this.setChildBoxData(box, boxData, 0);
      this.setChildBoxData(box, boxData, 1);
      box.buttons && box.setButtons(box.buttons);
    }
  }
  setState(state) {
    this.activePane = void 0;
    this.tabs = {};
    this.previewTab = void 0;
    for (let container in this.containers) {
      this.setContainerState(container, state[container]);
    }
  }
  setContainerState(container, state) {
    this.$setBoxState(this.containers[container], state);
  }
  clear() {
  }
  getPanes() {
  }
  getTabs() {
    return this.tabs;
  }
  get activeTab() {
    var _a;
    return (_a = this.activePane) == null ? void 0 : _a.tabBar.activeTab;
  }
  open(tabOptions, container, fileContent) {
    var _a;
    let tab = this.tabs[tabOptions.path];
    tabOptions.active = (_a = tabOptions.active) != null ? _a : true;
    if (!tab || !tab.parent) {
      let pane;
      if (container) {
        pane = this.getContainerPane(container);
      } else {
        pane = this.activePane && this.activePane.tabBar.tabList.length > 0 ? this.activePane : this.getContainerPane("main");
      }
      if (this.previewTab)
        this.previewTab.remove();
      tab = pane.tabBar.addTab(new Tab(tabOptions), void 0, fileContent);
      if (tabOptions.preview)
        this.previewTab = tab;
      tab.parent.scrollTabIntoView(tab);
      this.tabs[tab.path] = tab;
    }
    if (!tabOptions.preview) {
      if (this.previewTab == tab) {
        this.clearPreviewStatus(tab);
      } else if (this.previewTab) {
        this.previewTab.remove();
      }
    }
    tab.parent.removeSelections();
    tab.parent.activateTab(tab, fileContent);
    return tab;
  }
  getContainerPane(container) {
    return this.containers[container].element.querySelector(".tabPanel").$host;
  }
  clearPreviewStatus(tab) {
    tab.preview = false;
    tab.element.style.fontStyle = "";
    if (this.previewTab == tab)
      this.previewTab = void 0;
  }
  get newTabPath() {
    return `untitled_${newTabCounter}`;
  }
  addNewTab(pane, options) {
    while (this.tabs.hasOwnProperty(this.newTabPath)) {
      newTabCounter++;
    }
    options != null ? options : options = { title: `Untitled ${newTabCounter}`, path: this.newTabPath };
    options.active = true;
    let newTab = pane.tabBar.addTab(new Tab(options));
    this.tabs[this.newTabPath] = newTab;
    return newTab;
  }
  removeTab(tab) {
    delete this.tabs[tab.path];
  }
  //TODO: move to separate class
  loadFile(tab, fileContent) {
    let editor = tab.parent.parent.getOrCreateEditor(tab.editorType);
    editor.setSession(tab, fileContent);
  }
  navigateToTab(index, tab, tabs) {
    var _a;
    let tabsList = tabs || Object.values(this.tabs);
    let activeTab = tab || this.activeTab;
    if (index >= 0 && tabsList.length > index)
      (_a = activeTab == null ? void 0 : activeTab.parent) == null ? void 0 : _a.activateTab(tabsList[index], void 0, true);
  }
  saveTo(storage) {
    for (let [path, tab] of Object.entries(this.tabs)) {
      storage["@file@" + path] = tab.session ? tab.editor.sessionToJSON(tab) : tab.sessionValue;
    }
  }
  restoreFrom(storage) {
    for (let [path, tab] of Object.entries(this.tabs)) {
      tab.sessionValue = storage["@file@" + path];
      if (tab.session)
        tab.editor.restoreSessionFromJson(tab);
    }
  }
  getTab(path) {
    return this.tabs[path];
  }
}
oop.implement(TabManager.prototype, event_emitter_.EventEmitter);

;// ./src/widgets/toolbars/toolbar.ts

class Toolbar {
  setBox(x, y, w, h) {
    Utils.setBox(this.element, x, y, w, h);
  }
  constructor(options) {
    this.direction = (options == null ? void 0 : options.direction) || "horizontal";
    this.size = (options == null ? void 0 : options.size) || 27;
    this.position = options == null ? void 0 : options.position;
  }
}

;// ./src/widgets/toolbars/tabPanelBar.ts

class TabPanelBar extends Toolbar {
  constructor(options) {
    var _a, _b;
    super(options);
    this.selectedTabs = [];
    this.tabList = [];
    this.scrollLeft = 0;
    this.animationSteps = 0;
    this.MIN_TAB_SIZE = 120;
    this.MAX_TAB_SIZE = 150;
    this.activeTabHistory = [];
    this.onMouseWheel = (e) => {
      let d = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY;
      if (Math.abs(d) > 50) {
        this.animateScroll(d);
      } else {
        this.stopScrollAnimation();
        this.setScrollPosition((this.scrollLeft || 0) + d);
      }
    };
    this.initTabList = (_b = (_a = options.tabList) != null ? _a : options.panelList) != null ? _b : [];
  }
  isVertical() {
    return this.direction === "vertical";
  }
  getDraggingElementSize() {
    if (!this.tabDraggingElement)
      return 0;
    let draggingElementSize = this.isVertical() ? this.tabDraggingElement.style.height : this.tabDraggingElement.style.width;
    return parseInt(draggingElementSize, 10);
  }
  tabMouseDown(tab, expand = false, toggle = false) {
    if (expand) {
      this.expandSelection(tab, toggle);
    } else {
      this.anchorTab = null;
      if (toggle) {
        this.toggleSelection(tab);
      } else {
        this.activateTab(tab, void 0, this.selectedTabs.indexOf(tab) < 0);
      }
    }
  }
  expandSelection(tab, toggle = false) {
    if (!this.anchorTab)
      this.anchorTab = this.activeTab;
    let prevSelectedTabs = this.selectedTabs;
    this.selectedTabs = [];
    let start = this.tabList.indexOf(this.anchorTab);
    let end = this.tabList.indexOf(tab);
    if (end < start) {
      [start, end] = [end, start];
    }
    for (let i = start; i <= end; i++) {
      this.addSelection(this.tabList[i]);
    }
    prevSelectedTabs.forEach((selectedTab) => {
      if (this.selectedTabs.indexOf(selectedTab) < 0) {
        if (!toggle) {
          this.deselectTab(selectedTab);
        } else {
          this.addSelection(selectedTab);
        }
      }
    });
    this.activateTab(tab);
  }
  toggleSelection(tab) {
    let index = this.selectedTabs.indexOf(tab);
    if (index < 0) {
      this.activateTab(tab);
    } else if (tab !== this.activeTab) {
      this.removeSelection(tab);
    }
  }
  addSelection(tab) {
    if (this.selectedTabs.indexOf(tab) < 0) {
      this.selectTab(tab);
      this.selectedTabs.push(tab);
    }
  }
  selectTab(tab) {
    tab.element.classList.add("selected");
  }
  deselectTab(tab) {
    tab.element.classList.remove("selected");
  }
  removeSelection(tab) {
    if (this.selectedTabs.indexOf(tab) < 0)
      return;
    this.deselectTab(tab);
    this.selectedTabs.splice(this.selectedTabs.indexOf(tab), 1);
  }
  removeSelections() {
    this.selectedTabs.forEach((selectedTab) => {
      this.deselectTab(selectedTab);
    });
    this.selectedTabs = [];
  }
  scrollTabIntoView(tab) {
    let index = this.tabList.indexOf(tab);
    this.setScrollPosition((index + 1) * this.tabWidth);
  }
  activateTab(tab, content, removeSelections = false) {
    removeSelections && this.removeSelections();
    this.activeTabClicked = false;
    this.addSelection(tab);
    if (this.activeTab) {
      if (this.activeTab === tab) {
        this.activeTabClicked = true;
        return;
      }
      if (this.activeTabHistory.indexOf(this.activeTab) >= 0)
        this.activeTabHistory.splice(this.activeTabHistory.indexOf(this.activeTab), 1);
      this.activeTabHistory.push(this.activeTab);
      this.activeTab.deactivate();
    }
    tab.activate();
    this.activeTab = tab;
    this.configure();
  }
  removeTab(tab) {
    if (tab === this.activeTab)
      this.activeTab = void 0;
    let index = this.tabList.indexOf(tab);
    if (index >= 0)
      this.tabList.splice(index, 1);
    tab.parent = void 0;
  }
  activatePrevious(index) {
    if (this.tabList.length) {
      let tab = this.tabList[index - 1] || this.tabList[this.tabList.length - 1];
      this.activateTab(tab);
    }
  }
  addTab(tab, index, content) {
    if (!tab.element)
      tab.render();
    tab.parent = this;
    if (index === void 0 || index === null || index >= this.tabList.length) {
      this.tabContainer.appendChild(tab.element);
      this.tabList.push(tab);
    } else {
      this.tabContainer.insertBefore(tab.element, this.tabContainer.childNodes[index]);
      this.tabList.splice(index, 0, tab);
    }
    if (tab.active)
      this.activateTab(tab, content, true);
    this.configure();
    return tab;
  }
  setScrollPosition(scrollLeft) {
    this.scrollLeft = scrollLeft;
    this.configure();
  }
  animateScroll(v) {
    this.vX = v / 80;
    this.animationSteps += 15;
    if (this.animationSteps > 15) {
      this.vX *= 1.2 * this.animationSteps / 10;
      this.animationSteps = 15 + Math.ceil((this.animationSteps - 15) * 0.75);
    }
    if (this.animationTimer)
      return;
    this.animationTimer = setInterval(() => {
      if (this.animationSteps-- <= 0) {
        return this.stopScrollAnimation();
      }
      let vX = this.vX;
      if (Math.abs(this.vX) < 0.01)
        vX = 0;
      vX = 0.9 * vX;
      let oldScrollLeft = this.scrollLeft;
      this.setScrollPosition(this.scrollLeft + 10 * vX);
      if (oldScrollLeft == this.scrollLeft)
        this.animationSteps = 0;
      this.vX = vX;
    }, 10);
  }
  stopScrollAnimation() {
    clearInterval(this.animationTimer);
    this.animationTimer = null;
    this.animationScrollLeft = null;
    this.vX = 0;
  }
  transform(el, dx, dy) {
    el.style.left = Math.round(dx) + "px";
    el.dx = dx;
    el.dy = dy;
  }
  startTabDragging(element, index) {
    if (this.isDragging)
      return;
    this.tabDraggingElement = element;
    this.draggingElementIndex = index;
    this.configure();
    this.isDragging = true;
  }
  finishTabDragging() {
    this.draggingElementIndex = void 0;
    this.tabDraggingElement = void 0;
    if (this.activeTabHistory.length) {
      let removedHistoryTabs = [];
      for (let i = 0; i < this.activeTabHistory.length; i++) {
        if (this.tabList.indexOf(this.activeTabHistory[i]) < 0) {
          removedHistoryTabs.push(this.activeTabHistory[i]);
        }
      }
      removedHistoryTabs.forEach((tab) => {
        let index = this.activeTabHistory.indexOf(tab);
        if (index >= 0) {
          this.activeTabHistory.splice(index, 1);
        }
      });
    }
    this.configure();
    this.isDragging = false;
  }
  toJSON() {
    return {
      tabList: this.tabList.map((tab) => tab.toJSON()),
      scrollLeft: this.scrollLeft
    };
  }
}

;// ./src/widgets/toolbars/tabBar.ts






class TabBar extends TabPanelBar {
  constructor() {
    super(...arguments);
    this.inverted = true;
    this.buttonsWidth = 0;
    this.buttons = [];
    this.onTabMouseUp = (e) => {
      if (e.button == 1) {
        let tab = Utils.findHost(e.target, Tab);
        if (tab)
          tab.remove();
      }
    };
    this.onTabMouseDown = (e) => {
      if (e.button == 0)
        TabbarHandler.tabbarMouseDown(e, Tab, TabBar, true);
    };
    this.onTabPlusClick = (e) => {
      this.removeSelections();
      TabManager.getInstance().addNewTab(this.parent);
    };
    this.onTabClick = (e) => {
      let target = e.target;
      let tab = Utils.findHost(target, Tab);
      if (tab) {
        if (e.button == 0 && target.classList.contains("tabCloseButton")) {
          this.closeTab(tab);
        } else if (e.button == 0 && tab.isActive && tab.editor) {
          tab.editor.focus();
        } else if (e.button == 1) {
          tab.remove();
        }
      }
    };
  }
  setBox(x, y, w, h) {
    super.setBox(x, y, w, h);
    this.width = w;
    this.configure();
  }
  renderElement() {
    this.element = dom.buildDom([
      "div",
      {
        class: "tabbar " + this.direction,
        onwheel: this.onMouseWheel,
        $host: this
      },
      ["span", { class: "tabMenuButton" }],
      [
        "div",
        {
          class: "tabScroller"
        },
        ["div", {
          class: "tabContainer",
          ref: "tabContainer",
          onclick: this.onTabClick,
          onmouseup: this.onTabMouseUp,
          onmousedown: this.onTabMouseDown
        }]
      ],
      ["span", {
        class: "tabPlusButton",
        ref: "tabPlusButton",
        onclick: this.onTabPlusClick
      }, "+"],
      ["span", {
        class: "sizer"
      }],
      ["span", {
        class: "buttons",
        ref: "additionalButtons"
      }]
    ], void 0, this);
    if (this.initTabList && this.initTabList.length) {
      for (let i = 0; i < this.initTabList.length; i++) {
        this.addTab(this.initTabList[i]);
      }
    }
  }
  render() {
    if (!this.element)
      this.renderElement();
    return this.element;
  }
  computeConfig() {
    let draggingElementSize = this.getDraggingElementSize();
    this.plusButtonWidth = this.tabPlusButton.getBoundingClientRect().width;
    this.containerWidth = this.width - this.plusButtonWidth - this.buttonsWidth;
    let tabsCount = this.tabList.length;
    if (tabsCount * this.MAX_TAB_SIZE + draggingElementSize < this.containerWidth) {
      this.tabWidth = this.MAX_TAB_SIZE;
      this.containerWidth = tabsCount * this.tabWidth + draggingElementSize;
    } else if (tabsCount * this.MIN_TAB_SIZE + draggingElementSize < this.containerWidth) {
      this.tabWidth = (this.containerWidth - draggingElementSize) / tabsCount;
    } else {
      this.tabWidth = this.MIN_TAB_SIZE;
    }
    let tabsWidth = this.tabWidth * tabsCount + draggingElementSize;
    this.scrollLeft = Math.min(Math.max(this.scrollLeft, 0), tabsWidth - this.containerWidth);
  }
  configure() {
    if (!this.width || this.freeze)
      return;
    let shadowWidth = 4;
    this.computeConfig();
    this.tabContainer.style.width = this.containerWidth + "px";
    let draggingElementSize = this.getDraggingElementSize();
    if (this.inverted) {
      let zIndex = this.tabList.length;
      let min = shadowWidth - this.tabWidth;
      let max = this.containerWidth;
      let maxPos = (max - this.tabWidth) / 2;
      let i = 0;
      for (; i < this.tabList.length; i++) {
        let tab = this.tabList[i];
        let el = tab.element;
        let pos = this.tabWidth * i - this.scrollLeft;
        if (this.tabDraggingElement && i >= this.draggingElementIndex) {
          pos += draggingElementSize;
        }
        if (tab === this.activeTab) {
          let activeMin = Math.max(min + this.tabWidth * 0.25, -this.tabWidth * 0.75);
          if (pos < activeMin)
            min = activeMin;
        }
        if (pos < min) {
          pos = min;
          min += shadowWidth;
          el.classList.add("scrolledLeft");
        } else if (pos > maxPos) {
          break;
        } else {
          el.classList.remove("scrolledLeft");
        }
        el.style.width = this.tabWidth + "px";
        el.style.zIndex = String(zIndex);
        zIndex--;
        this.transform(el, pos, 0);
      }
      let lastRendered = i;
      zIndex = this.tabList.length;
      for (let i2 = this.tabList.length - 1; i2 >= lastRendered; i2--) {
        let tab = this.tabList[i2];
        let el = tab.element;
        let pos = this.tabWidth * i2 - this.scrollLeft;
        if (this.tabDraggingElement && i2 >= this.draggingElementIndex) {
          pos += draggingElementSize;
        }
        if (tab === this.activeTab) {
          let activeMax = Math.min(max - this.tabWidth * 0.25, this.containerWidth - this.tabWidth * 0.25);
          if (pos > activeMax)
            max = activeMax;
        }
        if (pos > max) {
          pos = max;
          max -= shadowWidth;
          el.classList.add("scrolledLeft");
        } else {
          el.classList.remove("scrolledLeft");
        }
        el.style.width = this.tabWidth + "px";
        el.style.zIndex = String(zIndex);
        zIndex--;
        this.transform(el, pos, 0);
      }
    } else {
    }
  }
  addButton(button) {
    this.buttons.push(button);
    this.setButtons(this.buttons);
  }
  setButtons(buttons) {
    this.additionalButtons.innerHTML = "";
    this.buttons = buttons;
    buttons.forEach((button) => this.additionalButtons.appendChild(button));
    let rect = this.additionalButtons.getBoundingClientRect();
    this.buttonsWidth = rect.width;
    this.configure();
  }
  removeButtons() {
    if (!this.buttons.length)
      return;
    this.buttons = [];
    this.additionalButtons.innerHTML = "";
    this.buttonsWidth = 0;
    this.configure();
  }
  clear() {
    this.removeButtons();
    this.tabList = [];
  }
  remove() {
  }
  closeTab(tab) {
    let index = this.tabList.indexOf(tab);
    let isActiveTab = this.activeTab === tab;
    let isAnchorTab = this.anchorTab === tab;
    this.removeTab(tab);
    this.removeSelection(tab);
    if (isActiveTab) {
      this.activeTab = void 0;
      this.activatePrevious(index);
    }
    if (isAnchorTab)
      this.anchorTab = null;
    if (tab.element)
      tab.element.remove();
    TabManager.getInstance().removeTab(tab);
    this.configure();
  }
  activateTab(tab, content, removeSelections = false) {
    removeSelections && this.removeSelections();
    this.activeTabClicked = false;
    this.addSelection(tab);
    if (this.activeTab) {
      if (this.activeTab === tab) {
        this.activeTabClicked = true;
        tab.activatePane();
        return;
      }
      if (this.activeTabHistory.indexOf(this.activeTab) >= 0)
        this.activeTabHistory.splice(this.activeTabHistory.indexOf(this.activeTab), 1);
      this.activeTabHistory.push(this.activeTab);
      this.activeTab.deactivate();
    }
    tab.activate(content);
    this.activeTab = tab;
    this.configure();
  }
  activatePrevious(index) {
    if (this.tabList.length) {
      let tab = this.tabList[index - 1] || this.tabList[this.tabList.length - 1];
      this.activateTab(tab);
    } else if (this.parent) {
      this.parent.remove();
    }
  }
}

;// ./src/widgets/boxes/pane.ts







class Pane extends Box {
  constructor(options = {}) {
    var _a;
    let tabBar = new TabBar({
      tabList: options.tabList
    });
    options.toolBars = (_a = options.toolBars) != null ? _a : {};
    options.toolBars.top = tabBar;
    super(options);
    tabBar.parent = this;
    this.tabBar = tabBar;
  }
  toJSON() {
    return {
      type: "pane",
      tabBar: this.tabBar.toJSON()
    };
  }
  render() {
    super.render();
    this.element.classList.add("tabPanel");
    this.tabEditorBoxElement = dom.buildDom(["div", {
      class: `tab-editor`
    }]);
    this.element.appendChild(this.tabEditorBoxElement);
    return this.element;
  }
  acceptsTab(tab) {
    return true;
  }
  split(far, vertical) {
    let newPane = new Pane({});
    let root = this.parent;
    let wrapper = new Box({
      [far ? 1 : 0]: this,
      [far ? 0 : 1]: newPane,
      vertical,
      ratio: 0.5
    });
    root.addChildBox(this, wrapper);
    if (this.isButtonHost) {
      let buttons = this.tabBar.buttons;
      this.removeButtons();
      wrapper.setButtons(buttons);
    }
    return newPane;
  }
  setButtons(buttons) {
    this.isButtonHost = true;
    if (buttons) {
      this.tabBar.setButtons(buttons);
    } else {
      this.tabBar.removeButtons();
    }
  }
  addButton(button) {
    this.isButtonHost = true;
    this.tabBar.addButton(button);
  }
  $updateChildSize(x, y, w, h) {
    this.updateToolBarSize(w, h);
    w -= this.padding.left + this.padding.right;
    h -= this.padding.top + this.padding.bottom;
    x = this.padding.left;
    y = this.padding.top;
    if (this.editor) {
      Utils.setBox(this.editor.container, x, y, w, h);
      this.editor.resize();
    }
  }
  removeButtons() {
    this.tabBar.removeButtons();
    this.isButtonHost = false;
  }
  remove() {
    let wrapper = this.parent;
    let root = wrapper.parent;
    let paneIndex = wrapper[0] == this ? 1 : 0;
    let pane = wrapper[paneIndex] || null;
    let rootIndex = root[0] == wrapper ? 0 : 1;
    if (pane) {
      pane.parent = root;
      root[rootIndex] = pane;
      root.element.appendChild(pane.element);
      if (root.fixedChild && root.fixedChild == wrapper) {
        pane.fixedSize = wrapper.fixedSize;
        pane.size = wrapper.size;
        root.fixedChild = pane;
      }
      wrapper.element.remove();
    } else {
      if (wrapper.isMain) {
        root = wrapper;
      } else {
        wrapper.element.remove();
      }
      root.ratio = 1;
    }
    root.recalculateAllMinSizes();
    root.resize();
    if (this.isButtonHost)
      root.setButtons(this.tabBar.buttons);
    this.clearEditors();
    this.tabBar.clear();
  }
  getTopRightPane() {
    return this;
  }
  createEditor() {
    let editor = this.createEditorByType();
    this.emit("editorAdded", editor);
    return editor;
  }
  createEditorByType() {
    switch (this.currentEditorType) {
      case EditorType.preview:
        return new PreviewEditor();
      case EditorType.ace:
      default:
        return new AceEditor();
    }
  }
  initEditor(editorType = EditorType.ace) {
    var _a, _b, _c;
    if (this.currentEditorType == editorType)
      return;
    this.hidePreviousEditor();
    (_a = this.editors) != null ? _a : this.editors = {};
    this.currentEditorType = editorType;
    (_c = (_b = this.editors)[editorType]) != null ? _c : _b[editorType] = this.createEditor();
    this.editor = this.editors[editorType];
    this.element.appendChild(this.editor.container);
  }
  hidePreviousEditor() {
    if (!this.editor)
      return;
    this.element.removeChild(this.editor.container);
  }
  getEditor(editorType = EditorType.ace) {
    return this.editors[editorType];
  }
  getOrCreateEditor(editorType = EditorType.ace) {
    this.initEditor(editorType);
    return this.editor;
  }
  clearEditors() {
    for (let i in this.editors) {
      this.editors[i].destroy();
    }
    this.editors = {};
    this.currentEditorType = void 0;
    this.editor = void 0;
  }
}

// EXTERNAL MODULE: ../../node_modules/css-loader/dist/cjs.js!./assets/styles/button.css
var styles_button = __nested_webpack_require_364669__(382);
;// ./assets/styles/button.css

      
      
      
      
      
      
      
      
      

var button_options = {};

button_options.styleTagTransform = (styleTagTransform_default());
button_options.setAttributes = (setAttributesWithoutAttributes_default());

      button_options.insert = insertBySelector_default().bind(null, "head");
    
button_options.domAPI = (styleDomAPI_default());
button_options.insertStyleElement = (insertStyleElement_default());

var button_update = injectStylesIntoStyleTag_default()(styles_button/* default */.A, button_options);




       /* harmony default export */ const assets_styles_button = (styles_button/* default */.A && styles_button/* default */.A.locals ? styles_button/* default */.A.locals : undefined);

;// ./src/widgets/elements/button.ts
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};


dom.importCssString(button_namespaceObject, "button.css");
class Button {
  constructor(options) {
    let _a = options, {
      disabled,
      value,
      className,
      onClick
    } = _a, other = __objRest(_a, [
      "disabled",
      "value",
      "className",
      "onClick"
    ]);
    this.disabled = disabled;
    this.value = value;
    this.className = className || "blackbutton";
    this.onClick = onClick;
    this.options = other;
  }
  remove() {
  }
  render() {
    var _a;
    this.renderElement();
    this.element.$host = this;
    this.element.onclick = (_a = this.onClick) != null ? _a : null;
    this.disabled && this.element.classList.add("Disabled");
    this.onClick && this.element.addEventListener("click", this.onClick);
    this.element.addEventListener("mousedown", (e) => this.addClass(e, "Down"));
    this.element.addEventListener("mouseup", (e) => this.removeClass(e, "Down"));
    this.element.addEventListener("mouseover", (e) => this.addClass(e, "Over"));
    this.element.addEventListener("mouseout", (e) => this.removeClass(e, "Over"));
    this.element.addEventListener("focus", (e) => this.addClass(e, "Focus"));
    this.element.addEventListener("unfocus", (e) => this.removeClass(e, "Focus"));
    return this.element;
  }
  addClass(e, className) {
    e.preventDefault();
    this.element.classList.add(className);
  }
  removeClass(e, className) {
    this.element.classList.remove(className);
  }
  renderElement() {
    var _a;
    (_a = this.element) != null ? _a : this.element = dom.buildDom(["div", __spreadValues({}, this.options), this.value]);
    this.element.classList.add(this.className);
  }
  toJSON() {
  }
}

// EXTERNAL MODULE: ../../node_modules/css-loader/dist/cjs.js!./assets/styles/dropdown.css
var dropdown = __nested_webpack_require_364669__(593);
;// ./assets/styles/dropdown.css

      
      
      
      
      
      
      
      
      

var dropdown_options = {};

dropdown_options.styleTagTransform = (styleTagTransform_default());
dropdown_options.setAttributes = (setAttributesWithoutAttributes_default());

      dropdown_options.insert = insertBySelector_default().bind(null, "head");
    
dropdown_options.domAPI = (styleDomAPI_default());
dropdown_options.insertStyleElement = (insertStyleElement_default());

var dropdown_update = injectStylesIntoStyleTag_default()(dropdown/* default */.A, dropdown_options);




       /* harmony default export */ const styles_dropdown = (dropdown/* default */.A && dropdown/* default */.A.locals ? dropdown/* default */.A.locals : undefined);

;// ./src/widgets/elements/dropdown.ts
var dropdown_defProp = Object.defineProperty;
var dropdown_getOwnPropSymbols = Object.getOwnPropertySymbols;
var dropdown_hasOwnProp = Object.prototype.hasOwnProperty;
var dropdown_propIsEnum = Object.prototype.propertyIsEnumerable;
var dropdown_defNormalProp = (obj, key, value) => key in obj ? dropdown_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var dropdown_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (dropdown_hasOwnProp.call(b, prop))
      dropdown_defNormalProp(a, prop, b[prop]);
  if (dropdown_getOwnPropSymbols)
    for (var prop of dropdown_getOwnPropSymbols(b)) {
      if (dropdown_propIsEnum.call(b, prop))
        dropdown_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var dropdown_objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (dropdown_hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && dropdown_getOwnPropSymbols)
    for (var prop of dropdown_getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && dropdown_propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};




dom.importCssString(dropdown_namespaceObject, "dropdown.css");
dom.importCssString(menu_namespaceObject, "menu.css");
const DEFAULT_WIDTH = 200;
class Dropdown {
  constructor(options) {
    this.onMouseDown = (e) => {
      e.preventDefault();
      let node = Utils.findNode(e.target, this.className);
      if (node && node == this.element)
        return;
      node = Utils.findNode(e.target, this.popup.element.className);
      if (node && node == this.popup.element)
        return;
      this.closePopup();
    };
    this.onMouseWheel = (e) => {
      this.closePopup();
    };
    let _a = options, { disabled, items, value, className, width } = _a, other = dropdown_objRest(_a, ["disabled", "items", "value", "className", "width"]);
    this.disabled = disabled != null ? disabled : false;
    this.items = items;
    this.value = value != null ? value : items[0].value;
    this.className = className || "black_dropdown";
    this.width = width != null ? width : DEFAULT_WIDTH;
    this.options = other;
  }
  render() {
    this.element = dom.buildDom(["div", dropdown_spreadValues({
      class: this.className + (this.disabled ? this.className + "Disabled" : ""),
      style: "width: " + this.width + "px",
      onmousedown: (e) => {
        e.preventDefault();
        this.element.className = this.className + " " + this.className + "Down";
        this.togglePopup();
      },
      onmouseup: (e) => {
        this.element.className = this.className;
      },
      onmouseover: (e) => {
        this.element.className = this.className + " " + this.className + "Over";
      },
      onfocus: (e) => {
        this.element.className = this.className + " " + this.className + "Focus";
      },
      onunfocus: (e) => {
        this.element.className = this.className;
      },
      onmouseout: (e) => {
        this.element.className = this.className;
      }
    }, this.options), [
      ["div", {
        class: "lbl",
        ref: "lbl"
      }],
      ["div", {
        class: "button"
      }]
    ]], void 0, this);
    this.element.$host = this;
    this.updateLabel();
    return this.element;
  }
  togglePopup() {
    if (this.isPopupOpen) {
      this.closePopup();
    } else {
      this.openPopup();
    }
  }
  openPopup() {
    if (this.isPopupOpen)
      return;
    this.popup = new Popup();
    this.popup.items = this.items;
    this.popup.selectedItem = this.value;
    this.popup.parent = this;
    this.popup.selectCallback = (host) => {
      this.select(host.value);
      this.closePopup();
    };
    this.popup.open();
    window.addEventListener("mousedown", this.onMouseDown);
    window.addEventListener("wheel", this.onMouseWheel);
    this.isPopupOpen = true;
  }
  closePopup() {
    if (!this.isPopupOpen)
      return;
    this.popup.close();
    this.isPopupOpen = false;
    window.removeEventListener("mousedown", this.onMouseDown);
    window.removeEventListener("wheel", this.onMouseWheel);
  }
  select(value) {
    this.setValue(value);
  }
  setValue(value) {
    if (this.value !== value) {
      this.value = value;
      this.updateLabel();
    }
  }
  updateLabel() {
    let items = this.items;
    for (let i = 0; i < items.length; i++) {
      let x = items[i];
      let itemValue = x.value;
      if (this.value === itemValue) {
        this.lbl.innerHTML = x.caption;
        return;
      }
    }
  }
  toJSON() {
  }
}
class Popup {
  open() {
    this.build();
    this.render();
  }
  build() {
    if (this.element) {
      return;
    }
    let result = [];
    if (this.items) {
      let items = Object.values(this.items).sort(function(item1, item2) {
        return item1.position - item2.position;
      });
      let afterDivider = true;
      result = items.map((item) => {
        if (item.caption[0] === "~") {
          if (afterDivider)
            return;
          afterDivider = true;
          return [
            "div",
            {
              class: "menu_divider",
              $host: item
            }
          ];
        }
        afterDivider = false;
        let classList = ["menu_item"];
        if (item.checked)
          classList.push(item.type === "check" ? "checked" : "selected");
        if (item.map)
          classList.push("submenu");
        if (item.disabled)
          classList.push("disabled");
        if (item.value === this.selectedItem)
          classList.push("selected");
        return [
          "div",
          {
            class: classList.join(" "),
            $host: item
          },
          ["u", " "],
          ["a", item.caption + ""],
          [
            "span",
            {
              class: "shortcut"
            },
            item.hotKey
          ]
        ];
      }).filter(Boolean);
      if (afterDivider)
        result.pop();
    }
    this.element = dom.buildDom(
      [
        "blockquote",
        {
          class: "menu",
          style: "display:block",
          $host: this.parent,
          onmousemove: this.onMouseMove.bind(this),
          onclick: this.onClick.bind(this)
        },
        result
      ],
      document.body
    );
  }
  render() {
    if (this.element.style.maxWidth) {
      this.element.style.maxWidth = window.innerWidth + "px";
    }
    if (this.element.style.maxHeight) {
      this.element.style.maxHeight = window.innerHeight + "px";
    }
    let elRect = this.element.getBoundingClientRect();
    let edge = Utils.getElementEdges(this.element);
    let parentRect, top, left;
    if (this.parent && this.parent.element) {
      parentRect = this.parent.element.getBoundingClientRect();
    }
    if (parentRect) {
      if (this.isSubMenu) {
        top = parentRect.top - edge.top;
        left = parentRect.right;
      } else {
        top = parentRect.bottom;
        left = parentRect.left;
      }
    } else {
      top = this.position.y;
      left = this.position.x;
    }
    let targetH = Math.min(elRect.height, window.innerHeight);
    let availableH = window.innerHeight - top - edge.top - edge.bottom - 2;
    if (availableH < targetH && (!parentRect || this.isSubMenu)) {
      let tmpTop = parentRect ? window.innerHeight : top;
      top = tmpTop - targetH - edge.top;
      availableH = window.innerHeight - top - edge.top - edge.bottom - 2;
    }
    this.element.style.maxHeight = availableH - 10 + "px";
    elRect = this.element.getBoundingClientRect();
    let availableW = window.innerWidth - left - edge.left - edge.right - 2;
    if (availableW < elRect.width) {
      if (parentRect) {
        let tmpLeft = this.isSubMenu ? parentRect.left : parentRect.right;
        if (tmpLeft > availableW) {
          this.direction = "left";
          left = tmpLeft - elRect.width + edge.left;
          left = Math.max(left, 0);
          availableW = tmpLeft + edge.left + edge.right;
        }
        if (availableW < elRect.width) {
          this.element.style.maxWidth = availableW + "px";
          this.element.style.overflowX = "auto";
        }
      } else {
        left = window.innerWidth - elRect.width - edge.left - edge.right;
      }
    }
    this.element.style.top = top + "px";
    this.element.style.left = left + "px";
    this.element.style.position = "absolute";
    this.element.style.zIndex = 195055;
    this.element.style.overflowY = "auto";
  }
  close() {
    if (this.element) {
      this.element.remove();
      delete this.element;
    }
  }
  scrollIfNeeded() {
    if (!this.selectedMenu) {
      return;
    }
    let menu = this.element;
    let item = this.selectedMenu.buttonElement;
    let menuRect = menu.getBoundingClientRect();
    let itemRect = item.getBoundingClientRect();
    if (itemRect.top < menuRect.top) {
      item.scrollIntoView(true);
    } else if (itemRect.bottom > menuRect.bottom) {
      item.scrollIntoView(false);
    }
  }
  //handle events
  onMouseMove(e) {
    if (e.target === this.element) {
      return;
    }
    let target = Utils.findHostTarget(e.target);
    if (target === this.element) {
      return;
    }
    if (target == this.activeItem) {
      return;
    }
    if (this.activeItem) {
      this.activeItem.classList.remove("hover");
    }
    this.activeItem = target;
    this.activeItem.classList.add("hover");
  }
  onClick(e) {
    if (e.target === this.element)
      return;
    let target = Utils.findHostTarget(e.target);
    if (target === this.element)
      return;
    let host = target.$host;
    this.selectCallback && this.selectCallback(host);
  }
}

;// ./src/widgets/elements/search.ts

class SettingsSearchBox {
  constructor(prefsParentNode) {
    this.hideFiltered = false;
    this.value = "";
    this.currValue = "";
    this.searchResultsCount = 0;
    this.prefsParentNode = prefsParentNode;
  }
  filter() {
    let childNode;
    let noResult = true;
    this.searchResultsCount = 0;
    for (let i = 0; i < this.prefsParentNode.childNodes.length; i++) {
      childNode = this.prefsParentNode.childNodes[i];
      this.updateVisibility(childNode);
      if (noResult && !childNode.isFiltered) {
        noResult = false;
      }
    }
    if (this.currValue != "") {
      this.searchResults.innerHTML = " " + this.searchResultsCount + " Preferences Found";
    } else {
      this.searchResults.innerHTML = "";
    }
  }
  showHide(item, show) {
    show = show || false;
    item.isFiltered = !show;
    item.style.display = show ? "block" : "none";
  }
  updateVisibility(item) {
    let text = item.innerText;
    let tokens = this.getTokens(text);
    let show = true;
    if (!tokens) {
      show = false;
    } else {
      this.searchResultsCount++;
    }
    this.showHide(item, show);
  }
  getTokens(string) {
    let tokens = [];
    let caption = string.toLowerCase();
    let lower = this.currValue.toLowerCase();
    let upper = this.currValue.toUpperCase();
    function addToken(value, className) {
      value && tokens.push({
        type: className || "",
        value
      });
    }
    let lastIndex = -1;
    let matchMask = 0;
    let index, distance;
    let fullMatchIndex = caption.indexOf(lower);
    if (fullMatchIndex === -1) {
      for (let j = 0; j < this.currValue.length; j++) {
        let i1 = caption.indexOf(lower[j], lastIndex + 1);
        let i2 = caption.indexOf(upper[j], lastIndex + 1);
        index = i1 >= 0 ? i2 < 0 || i1 < i2 ? i1 : i2 : i2;
        if (index < 0)
          return null;
        distance = index - lastIndex - 1;
        if (distance > 0) {
          matchMask = matchMask | 1 << j;
        }
        lastIndex = index;
      }
    }
    let filterText = lower;
    lower = caption.toLowerCase();
    lastIndex = 0;
    let lastI = 0;
    for (let i = 0; i <= filterText.length; i++) {
      if (i !== lastI && (matchMask & 1 << i || i === filterText.length)) {
        let sub = filterText.slice(lastI, i);
        lastI = i;
        index = lower.indexOf(sub, lastIndex);
        if (index === -1)
          continue;
        addToken(string.slice(lastIndex, index), "");
        lastIndex = index + sub.length;
        addToken(string.slice(index, lastIndex), "completion-highlight");
      }
    }
    addToken(string.slice(lastIndex, string.length), "");
    return tokens;
  }
  build() {
    this.element = dom.buildDom([
      "div",
      {},
      ["input", { class: "search_field tbsimple", placeholder: "Search preferences" }],
      ["span", { class: "search_results" }],
      ["span", { class: "searchbtn_close" }]
    ]);
    this.element.$host = this;
    this.searchField = this.element.querySelector(".search_field");
    this.searchResults = this.element.querySelector(".search_results");
    let _this = this;
    this.element.querySelector(".searchbtn_close").addEventListener("mousedown", function(e) {
      _this.clear();
    });
    this.searchField.addEventListener("input", function(e) {
      _this.currValue = e.target.value;
      _this.filter();
    });
  }
  clear() {
    if (this.currValue.length) {
      this.searchField.value = "";
      this.currValue = "";
      this.filter();
    }
  }
}

// EXTERNAL MODULE: ../../node_modules/css-loader/dist/cjs.js!./assets/styles/switcher.css
var switcher = __nested_webpack_require_364669__(915);
;// ./assets/styles/switcher.css

      
      
      
      
      
      
      
      
      

var switcher_options = {};

switcher_options.styleTagTransform = (styleTagTransform_default());
switcher_options.setAttributes = (setAttributesWithoutAttributes_default());

      switcher_options.insert = insertBySelector_default().bind(null, "head");
    
switcher_options.domAPI = (styleDomAPI_default());
switcher_options.insertStyleElement = (insertStyleElement_default());

var switcher_update = injectStylesIntoStyleTag_default()(switcher/* default */.A, switcher_options);




       /* harmony default export */ const styles_switcher = (switcher/* default */.A && switcher/* default */.A.locals ? switcher/* default */.A.locals : undefined);

;// ./src/widgets/elements/switcher.ts
var switcher_defProp = Object.defineProperty;
var switcher_getOwnPropSymbols = Object.getOwnPropertySymbols;
var switcher_hasOwnProp = Object.prototype.hasOwnProperty;
var switcher_propIsEnum = Object.prototype.propertyIsEnumerable;
var switcher_defNormalProp = (obj, key, value) => key in obj ? switcher_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var switcher_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (switcher_hasOwnProp.call(b, prop))
      switcher_defNormalProp(a, prop, b[prop]);
  if (switcher_getOwnPropSymbols)
    for (var prop of switcher_getOwnPropSymbols(b)) {
      if (switcher_propIsEnum.call(b, prop))
        switcher_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var switcher_objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (switcher_hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && switcher_getOwnPropSymbols)
    for (var prop of switcher_getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && switcher_propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};


dom.importCssString(switcher_namespaceObject, "switcher.css");
class Switcher {
  constructor(options) {
    let _a = options, { className, checked } = _a, other = switcher_objRest(_a, ["className", "checked"]);
    this.className = className || "cboffline";
    this.options = other;
    this.checked = checked || false;
  }
  render() {
    this.element = dom.buildDom(["div", switcher_spreadValues({
      class: this.className + (this.checked ? " " + this.className + "Checked" : ""),
      onmousedown: (e) => {
        e.preventDefault();
        this.checked = !this.checked;
        e.target.className = this.className + (this.checked ? " " + this.className + "Down" : "");
      },
      onclick: (e) => {
        e.preventDefault();
        e.target.className = this.className + (this.checked ? " " + this.className + "Checked" : "");
      }
    }, this.options), ""]);
    this.element.$host = this;
    return this.element;
  }
  toJSON() {
    return {};
  }
  remove() {
  }
}

;// ./src/widgets/toolbars/menuToolbar.ts



class MenuToolbar extends Toolbar {
  render() {
    if (!this.element) {
      this.element = dom.buildDom(["div", {
        class: "menuToolBar"
      }, [
        "div",
        {
          class: "menuBar",
          ref: "menuBar"
        }
      ]], void 0, this);
      let menuManager = MenuManager.getInstance();
      menuManager.build();
      menuManager.buildMenuBar(this.menuBar);
      menuManager.bindKeys();
    }
    return this.element;
  }
  remove() {
  }
  toJSON() {
  }
}

;// ./src/widgets/toolbars/panelBar.ts




class PanelBar extends TabPanelBar {
  setBox(x, y, w, h) {
    super.setBox(x, y, w, h);
    this.configure();
  }
  configure() {
    let tabElement;
    let tabSize = 30;
    let position = 0;
    for (let i = 0; i < this.tabList.length; i++) {
      tabElement = this.tabList[i].element;
      if (this.draggingElementIndex === i)
        position += this.getDraggingElementSize();
      if (this.isVertical()) {
        tabElement.style.left = "0px";
        tabElement.style.height = tabSize + "px";
        tabElement.style.top = position + "px";
      } else {
        tabElement.style.top = "0px";
        tabElement.style.width = tabSize + "px";
        tabElement.style.left = position + "px";
      }
      position += tabSize;
    }
  }
  render() {
    if (!this.element) {
      this.element = dom.buildDom(["div", {
        class: "panelbar " + this.direction + " " + this.position
      }, ["div", {
        class: "tabContainer",
        ref: "tabContainer",
        onmousedown: function(e) {
          TabbarHandler.tabbarMouseDown(e, Panel, PanelBar);
        },
        onmouseup: (e) => {
          if (this.activeTabClicked) {
            let activeTab = this.activeTab;
            this.removeSelection(activeTab);
            activeTab.deactivate();
            this.activeTab = void 0;
            if (this.activeTabHistory.length && activeTab.autoHide) {
              let previousTab = activeTab;
              while (previousTab === activeTab && this.activeTabHistory.length) {
                previousTab = this.activeTabHistory.pop();
              }
              if (previousTab !== activeTab)
                this.activateTab(previousTab);
            }
          }
        }
      }]], void 0, this);
    }
    if (this.initTabList && this.initTabList.length) {
      for (let i = 0; i < this.initTabList.length; i++) {
        this.addTab(this.initTabList[i]);
      }
    }
    this.element.$host = this;
    return this.element;
  }
  addTabList(tabList, index) {
    index = index || this.tabList.length;
    let tab;
    for (let i = 0; i < tabList.length; i++) {
      tab = new Panel(tabList[i]);
      this.addTab(tab, index++);
    }
  }
  remove() {
  }
}

;// ./src/widgets/tabs/panelManager.ts



class PanelManager {
  constructor(options) {
    this.layout = options.layout;
    this.locations = options.locations;
  }
  static getInstance(options) {
    if (!PanelManager._instance)
      PanelManager._instance = new PanelManager(options);
    return PanelManager._instance;
  }
  toJSON() {
    return {
      panelBars: this.panelBarsToJSON()
    };
  }
  panelBarsToJSON() {
    let panelBars = {};
    for (let [position, panelBar] of Object.entries(this.layout.toolBars)) {
      if (panelBar instanceof PanelBar)
        panelBars[position] = panelBar.toJSON();
    }
    return panelBars;
  }
  setState(state) {
    var _a;
    let panelBars = (_a = state.panelBars) != null ? _a : {};
    let panelBar, panelList, panel;
    let panelBody, panelBodyData;
    for (let position of Object.keys(panelBars)) {
      panelList = [];
      let tabList = panelBars[position].tabList;
      for (let i = 0; i < tabList.length; i++) {
        panel = tabList[i];
        panelBodyData = panel.panelBody;
        if (panelBodyData.type === "accordion") {
          let accordionSections = [];
          let sections = panelBodyData.sections;
          for (let index = 0; index < sections.length; index++) {
            accordionSections.push({
              title: sections[index].title,
              box: new Box(sections[index].boxData)
            });
          }
          panelBody = new Accordion({
            vertical: panelBodyData.vertical,
            size: panelBodyData.size,
            sections: accordionSections
          });
        } else {
          panelBody = new Box({
            vertical: panelBodyData.type === "vbox",
            color: panelBodyData.color,
            size: panelBodyData.size,
            hidden: panelBodyData.hidden,
            fixedSize: panelBodyData.fixedSize
          });
        }
        panelList.push({
          active: panel.active,
          title: panel.title,
          autoHide: panel.autoHide,
          panelBody
        });
      }
      panelBar = new PanelBar({ panelList: {} });
      this.layout.addToolBar(position, panelBar);
      panelBar.addTabList(panelList);
    }
  }
  activatePanel(panel) {
    let location = this.locations[panel.parent.position];
    if (!location)
      return;
    let index = location.index;
    let parent = location.parent;
    panel.panelBody.size = location.size;
    let newBox = parent.addChildBox(index, panel.panelBody);
    if (newBox.fixedSize && !parent.fixedChild)
      parent.fixedChild = newBox;
    location.box = newBox;
    newBox.show();
  }
  deactivatePanel(panel) {
    let location = this.locations[panel.parent.position];
    location == null ? void 0 : location.box.hide();
  }
}

// EXTERNAL MODULE: ../../node_modules/css-loader/dist/cjs.js!./assets/styles/panel.css
var panel = __nested_webpack_require_364669__(174);
;// ./assets/styles/panel.css

      
      
      
      
      
      
      
      
      

var panel_options = {};

panel_options.styleTagTransform = (styleTagTransform_default());
panel_options.setAttributes = (setAttributesWithoutAttributes_default());

      panel_options.insert = insertBySelector_default().bind(null, "head");
    
panel_options.domAPI = (styleDomAPI_default());
panel_options.insertStyleElement = (insertStyleElement_default());

var panel_update = injectStylesIntoStyleTag_default()(panel/* default */.A, panel_options);




       /* harmony default export */ const styles_panel = (panel/* default */.A && panel/* default */.A.locals ? panel/* default */.A.locals : undefined);

;// ./src/widgets/tabs/panel.ts




dom.importCssString(panel_namespaceObject, "panel.css");
class Panel extends TabPanel {
  constructor(options) {
    var _a;
    super(options);
    this.location = options.location;
    this.panelBody = options.panelBody;
    this.autoHide = (_a = options.autoHide) != null ? _a : false;
    this.title = options.title;
  }
  activate() {
    super.activate();
    PanelManager.getInstance().activatePanel(this);
  }
  deactivate() {
    super.deactivate();
    PanelManager.getInstance().deactivatePanel(this);
  }
  render() {
    this.element = dom.buildDom(["div", {
      class: "panelButton" + (this.active ? " active" : "")
    }, ["span", {
      class: "panelTitle"
    }, this.title]]);
    this.element.$host = this;
    return this.element;
  }
  toJSON() {
    return {
      active: this.active,
      title: this.title,
      autoHide: this.autoHide,
      panelBody: this.panelBody.toJSON()
    };
  }
  remove() {
  }
}

// EXTERNAL MODULE: ../../node_modules/css-loader/dist/cjs.js!./assets/styles/layout.css
var layout = __nested_webpack_require_364669__(0);
;// ./assets/styles/layout.css

      
      
      
      
      
      
      
      
      

var layout_options = {};

layout_options.styleTagTransform = (styleTagTransform_default());
layout_options.setAttributes = (setAttributesWithoutAttributes_default());

      layout_options.insert = insertBySelector_default().bind(null, "head");
    
layout_options.domAPI = (styleDomAPI_default());
layout_options.insertStyleElement = (insertStyleElement_default());

var layout_update = injectStylesIntoStyleTag_default()(layout/* default */.A, layout_options);




       /* harmony default export */ const styles_layout = (layout/* default */.A && layout/* default */.A.locals ? layout/* default */.A.locals : undefined);

;// ./src/widgets/layout.ts


class AceLayout {
  constructor(startBox, css) {
    dom.importCssString(css != null ? css : layout_namespaceObject, "layout.css");
    this.box = startBox;
  }
}

// EXTERNAL MODULE: ./src/widgets/trees/ace-tree-lib.js
var ace_tree_lib = __nested_webpack_require_364669__(532);
;// ./src/file-system/file-type-icons.ts
const getIconUrl = (path, isDir) => {
  return `https://raw.githubusercontent.com/vscode-icons/vscode-icons/master/icons/${getIconName(
    path,
    isDir
  )}.svg`;
};
function getIconName(path, isDir) {
  if (!path)
    return "default_file";
  if (isDir)
    return "default_folder";
  const filename = path.substring(path.lastIndexOf("/") + 1);
  const ext = filename.split(".").pop() || "";
  return getIconNameFromExtension(ext) || getIconNameFromFileName(filename) || "default_file";
}
function getIconNameFromExtension(ext) {
  switch (ext.toLowerCase()) {
    case "js":
      return "file_type_js";
    case "ts":
      return "file_type_typescript";
    case "html":
      return "file_type_html";
    case "css":
      return "file_type_css";
    case "less":
      return "file_type_less";
    case "sass":
      return "file_type_sass";
    case "scss":
      return "file_type_scss";
    case "json":
      return "file_type_json";
    case "py":
      return "file_type_python";
    case "rb":
      return "file_type_ruby";
    case "go":
      return "file_type_go";
    case "rust":
      return "file_type_rust";
    case "java":
      return "file_type_java";
    case "scala":
      return "file_type_scala";
    case "swift":
      return "file_type_swift";
    case "sh":
      return "file_type_shell";
    case "makefile":
      return "file_type_shell";
    case "bat":
      return "file_type_shell";
    case "bash":
      return "file_type_shell";
    case "cs":
      return "file_type_csharp";
    case "yml":
      return "file_type_yaml";
    case "yaml":
      return "file_type_yaml";
    case "xml":
      return "file_type_xml";
    case "md":
      return "file_type_markdown";
    case "sql":
      return "file_type_sql";
    case "jpg":
      return "file_type_image";
    case "svg":
      return "file_type_image";
    case "jpeg":
      return "file_type_image";
    case "png":
      return "file_type_image";
    case "gif":
      return "file_type_image";
    case "bmp":
      return "file_type_image";
    default:
      return null;
  }
}
function getIconNameFromFileName(filename) {
  switch (filename.toLowerCase()) {
    case "dockerfile":
      return "file_type_docker";
    case ".gitignore":
      return "file_type_git2";
    case ".gitattributes":
      return "file_type_git2";
    default:
      return null;
  }
}

// EXTERNAL MODULE: ../../node_modules/css-loader/dist/cjs.js!./assets/styles/ace-tree.css
var ace_tree = __nested_webpack_require_364669__(216);
;// ./assets/styles/ace-tree.css

      
      
      
      
      
      
      
      
      

var ace_tree_options = {};

ace_tree_options.styleTagTransform = (styleTagTransform_default());
ace_tree_options.setAttributes = (setAttributesWithoutAttributes_default());

      ace_tree_options.insert = insertBySelector_default().bind(null, "head");
    
ace_tree_options.domAPI = (styleDomAPI_default());
ace_tree_options.insertStyleElement = (insertStyleElement_default());

var ace_tree_update = injectStylesIntoStyleTag_default()(ace_tree/* default */.A, ace_tree_options);




       /* harmony default export */ const styles_ace_tree = (ace_tree/* default */.A && ace_tree/* default */.A.locals ? ace_tree/* default */.A.locals : undefined);

;// ./src/widgets/trees/ace-tree.ts


const ace_tree_oop = __nested_webpack_require_364669__(387);



dom.importCssString(ace_tree_namespaceObject, "ace-tree.css");
function transform(node) {
  const path = node["path"] || "";
  const name = path.slice(path.lastIndexOf("/") + 1);
  let children = node["nodes"] || node["children"];
  if (children)
    children = children.map(transform);
  return {
    fsNode: node,
    name,
    children
  };
}
class AceTreeWrapper {
  render() {
    var _a;
    if (this.tree) {
      return this.element;
    }
    (_a = this.element) != null ? _a : this.element = dom.buildDom(["div"]);
    this.element.className = "ace-tree-wrapper";
    this.tree = new ace_tree_lib.Tree(this.element);
    this.model = new ace_tree_lib.DataProvider({});
    this.setupAceTree();
    return this.element;
  }
  remove() {
    this.element.remove();
  }
  toJSON() {
    return {};
  }
  setupAceTree() {
    this.tree.setDataProvider(this.model);
    this.provideIcons();
    if (typeof window !== "undefined") {
      window["fileTree"] = this.tree;
    }
  }
  updateTreeData(fileTree) {
    const model = this.model;
    const tree = this.tree;
    if (!model.root || model.root.fsNode != fileTree) {
      const treeNodes = transform(fileTree);
      if (treeNodes.children.length == 1) {
        treeNodes.children[0].isOpen = true;
      }
      model.setRoot(treeNodes);
      tree.on("afterChoose", () => {
        var _a;
        const fsNode = (_a = tree.selection.getCursor()) == null ? void 0 : _a.fsNode;
        if (fsNode && fsNode.kind != "directory") {
          const event = new CustomEvent("item-click", {
            detail: fsNode
          });
          this.element.dispatchEvent(event);
        }
      });
    }
    this.tree.resize();
  }
  provideIcons() {
    this.model.getIconHTML = function(node) {
      const treeNode = node.fsNode;
      const isDir = treeNode.kind === "directory";
      const size = 16;
      return `<span class="file-icon">
<svg width="${size}" height="${size}">
     <image xlink:href="${getIconUrl(
        treeNode.path,
        isDir
      )}" width="${size}" height="${size}"/>
</svg>
</span>`;
    };
  }
}
ace_tree_oop.implement(AceTreeWrapper.prototype, event_emitter_.EventEmitter);

;// ./src/file-system/fileEntries.ts
var __knownSymbol = (name, symbol) => {
  return (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
const MAX_SIZE = 8e6;
class FileSystemEntry {
  constructor(fileSystemHandle, filePath = "") {
    this.fileSystemHandle = fileSystemHandle;
    this.filePath = filePath;
  }
  get path() {
    return [this.filePath, this.name].join("/");
  }
  get name() {
    return this.fileSystemHandle.name;
  }
  get leaf() {
    const { name, kind, path } = this;
    const leaf = { name, kind, path, self: this };
    if (kind == "directory")
      leaf["children"] = [];
    return leaf;
  }
}
class File extends FileSystemEntry {
  constructor(fileSystemHandle, filePath = "") {
    super(fileSystemHandle, filePath);
    this.fileSystemHandle = fileSystemHandle;
    this.filePath = filePath;
    this.kind = "file";
  }
  getFileData() {
    return __async(this, null, function* () {
      return yield this.fileSystemHandle.getFile();
    });
  }
  getFileText() {
    return __async(this, null, function* () {
      const fileData = yield this.getFileData();
      if (fileData.size > MAX_SIZE)
        throw new Error(
          `File size to large: ${fileData.size}, max ${MAX_SIZE} supported`
        );
      return yield fileData.text();
    });
  }
}
class Directory extends FileSystemEntry {
  constructor(fileSystemHandle, filePath = "") {
    super(fileSystemHandle, filePath);
    this.fileSystemHandle = fileSystemHandle;
    this.filePath = filePath;
    this.childNodes = [];
    this.kind = "directory";
  }
  static openFilehandle(fileHandle) {
    return __async(this, null, function* () {
      if (!fileHandle)
        throw new Error("FileHandle undefined");
      return new Directory(fileHandle);
    });
  }
  getFileTee() {
    return __async(this, null, function* () {
      const root = this.leaf;
      const entries = [root];
      while (entries.length) {
        const entry = entries.pop();
        const dir = entry.self;
        for (const childNode of yield dir.children()) {
          const child = childNode.leaf;
          if (child.kind == "directory") {
            entries.push(child);
          }
          entry.children.push(child);
        }
        delete entry.self;
      }
      return root;
    });
  }
  getFileByPath(pathname) {
    return __async(this, null, function* () {
      const entries = yield this.children();
      while (entries.length) {
        const entry = entries.pop();
        if (entry.path == pathname)
          return entry;
        if (entry.kind == "directory")
          entries.push(...yield entry.children());
      }
      throw new Error(`File not found in tree: ${pathname}`);
    });
  }
  getDirectoryHandle(name) {
    return __async(this, null, function* () {
      return this.fileSystemHandle.getDirectoryHandle(name);
    });
  }
  children() {
    return __async(this, null, function* () {
      if (!this.childNodes.length) {
        try {
          for (var iter = __forAwait(this.fileSystemHandle.values()), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
            const child = temp.value;
            let childNode;
            if (child.kind == "directory") {
              const fileHandle = yield this.getDirectoryHandle(
                child.name
              );
              childNode = new Directory(fileHandle, this.path);
            } else {
              const fileHandle = yield this.fileSystemHandle.getFileHandle(child.name);
              childNode = new File(fileHandle, this.path);
            }
            this.childNodes.push(childNode);
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield temp.call(iter));
          } finally {
            if (error)
              throw error[0];
          }
        }
      }
      return [...this.childNodes];
    });
  }
}

;// ./src/file-system/file-system-web.ts
var file_system_web_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


class FileSystemWeb extends events.EventEmitter {
  get dir() {
    if (!this.directory)
      throw new Error("Accessing directory before created");
    return this.directory;
  }
  open() {
    return file_system_web_async(this, null, function* () {
      const handle = yield window.showDirectoryPicker().catch((err) => console.error("showDirectoryPicker:", err.message));
      if (handle) {
        const { err, dir } = yield Directory.openFilehandle(handle).then((dir2) => ({ dir: dir2, err: null })).catch((err2) => ({ err: err2, dir: null }));
        this.directory = dir;
        return this.getFileTree();
      }
    });
  }
  getFileTree() {
    return file_system_web_async(this, null, function* () {
      if (this.directory) {
        const nodes = [yield this.dir.getFileTee()];
        return { nodes };
      }
    });
  }
  openFile(treeNode) {
    return file_system_web_async(this, null, function* () {
      const file = yield this.dir.getFileByPath(treeNode.path);
      const fileText = yield file.getFileText();
      this.emit("openFile", treeNode, fileText);
    });
  }
}

;// ./src/index.ts


























})();

/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=bundle.index.js.map

/***/ }),

/***/ 98306:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


/**
 * @typedef {import("../ace-internal").Ace.Delta} Delta
 * @typedef {import("../ace-internal").Ace.Point} Point
 * @typedef {import("../ace-internal").Ace.IRange} IRange
 * @typedef {import("../ace-internal").Ace.NewLineMode} NewLineMode
 */
var oop = __webpack_require__(2645);
var applyDelta = (__webpack_require__(28646)/* .applyDelta */ .T);
var EventEmitter = (__webpack_require__(87366).EventEmitter);
var Range = (__webpack_require__(91902)/* .Range */ .Q);
var Anchor = (__webpack_require__(67490)/* .Anchor */ .M);

/**
 * Contains the text of the document. Document can be attached to several [[EditSession `EditSession`]]s. 
 * At its core, `Document`s are just an array of strings, with each row in the document matching up to the array index.
 **/
class Document {
    /**
     *
     * Creates a new `Document`. If `text` is included, the `Document` contains those strings; otherwise, it's empty.
     * @param {String | String[]} textOrLines text The starting text
     **/
    constructor(textOrLines) {
        /**@type {string[]}*/
        this.$lines = [""];

        // There has to be one line at least in the document. If you pass an empty
        // string to the insert function, nothing will happen. Workaround.
        if (textOrLines.length === 0) {
            this.$lines = [""];
        } else if (Array.isArray(textOrLines)) {
            this.insertMergedLines({row: 0, column: 0}, textOrLines);
        } else {
            this.insert({row: 0, column:0}, textOrLines);
        }
    }
    
    /**
     * Replaces all the lines in the current `Document` with the value of `text`.
     *
     * @param {String} text The text to use
     **/
    setValue(text) {
        var len = this.getLength() - 1;
        this.remove(new Range(0, 0, len, this.getLine(len).length));
        this.insert({row: 0, column: 0}, text || "");
    }

    /**
     * Returns all the lines in the document as a single string, joined by the new line character.
     * @returns {String}
     **/
   getValue() {
        return this.getAllLines().join(this.getNewLineCharacter());
    }

    /** 
     * Creates a new `Anchor` to define a floating point in the document.
     * @param {Number} row The row number to use
     * @param {Number} column The column number to use
     * @returns {Anchor}
     **/
    createAnchor(row, column) {
        return new Anchor(this, row, column);
    }

    /**
     * @param {string} text
     */
    $detectNewLine(text) {
        var match = text.match(/^.*?(\r\n|\r|\n)/m);
        this.$autoNewLine = match ? match[1] : "\n";
        this._signal("changeNewLineMode");
    }

    /**
     * Returns the newline character that's being used, depending on the value of `newLineMode`. 
     * @returns {String} If `newLineMode == windows`, `\r\n` is returned.  
     *  If `newLineMode == unix`, `\n` is returned.  
     *  If `newLineMode == auto`, the value of `autoNewLine` is returned.
     *
     **/
    getNewLineCharacter() {
        switch (this.$newLineMode) {
          case "windows":
            return "\r\n";
          case "unix":
            return "\n";
          default:
            return this.$autoNewLine || "\n";
        }
    }

    /**
     * [Sets the new line mode.]{: #Document.setNewLineMode.desc}
     * @param {NewLineMode} newLineMode [The newline mode to use; can be either `windows`, `unix`, or `auto`]
     
     **/
    setNewLineMode(newLineMode) {
        if (this.$newLineMode === newLineMode)
            return;

        this.$newLineMode = newLineMode;
        this._signal("changeNewLineMode");
    }

    /**
     * Returns the type of newlines being used; either `windows`, `unix`, or `auto`
     * @returns {NewLineMode}
     **/
    getNewLineMode() {
        return this.$newLineMode;
    }

    /**
     * Returns `true` if `text` is a newline character (either `\r\n`, `\r`, or `\n`).
     * @param {String} text The text to check
     * @returns {boolean}
     **/
    isNewLine(text) {
        return (text == "\r\n" || text == "\r" || text == "\n");
    }

    /**
     * Returns a verbatim copy of the given line as it is in the document
     * @param {Number} row The row index to retrieve
     * @returns {string}
     **/
    getLine(row) {
        return this.$lines[row] || "";
    }

    /**
     * Returns an array of strings of the rows between `firstRow` and `lastRow`. This function is inclusive of `lastRow`.
     * @param {Number} firstRow The first row index to retrieve
     * @param {Number} lastRow The final row index to retrieve
     * @returns {string[]}
     **/
    getLines(firstRow, lastRow) {
        return this.$lines.slice(firstRow, lastRow + 1);
    }

    /**
     * Returns all lines in the document as string array.
     * @returns {string[]}
     **/
    getAllLines() {
        return this.getLines(0, this.getLength());
    }

    /**
     * Returns the number of rows in the document.
     * @returns {Number}
     **/
    getLength() {
        return this.$lines.length;
    }

    /**
     * Returns all the text within `range` as a single string.
     * @param {IRange} range The range to work with.
     * 
     * @returns {String}
     **/
    getTextRange(range) {
        return this.getLinesForRange(range).join(this.getNewLineCharacter());
    }
    
    /**
     * Returns all the text within `range` as an array of lines.
     * @param {IRange} range The range to work with.
     * 
     * @returns {string[]}
     **/
    getLinesForRange(range) {
        var lines;
        if (range.start.row === range.end.row) {
            // Handle a single-line range.
            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
        } else {
            // Handle a multi-line range.
            lines = this.getLines(range.start.row, range.end.row);
            lines[0] = (lines[0] || "").substring(range.start.column);
            var l = lines.length - 1;
            if (range.end.row - range.start.row == l)
                lines[l] = lines[l].substring(0, range.end.column);
        }
        return lines;
    }

    // Deprecated methods retained for backwards compatibility.
    /**
     * @param row
     * @param lines
     
     * @deprecated
     */
    insertLines(row, lines) {
        console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
        return this.insertFullLines(row, lines);
    }

    /**
     * @param firstRow
     * @param lastRow
     * @returns {String[]}
     
     * @deprecated
     */
    removeLines(firstRow, lastRow) {
        console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
        return this.removeFullLines(firstRow, lastRow);
    }

    /**
     * @param position
     * @returns {Point}
     
     * @deprecated
     */
    insertNewLine(position) {
        console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
        return this.insertMergedLines(position, ["", ""]);
    }

    /**
     * Inserts a block of `text` at the indicated `position`.
     * @param {Point} position The position to start inserting at; it's an object that looks like `{ row: row, column: column}`
     * @param {String} text A chunk of text to insert
     * @returns {Point} The position ({row, column}) of the last line of `text`. If the length of `text` is 0, this function simply returns `position`. 
     
     **/
    insert(position, text) {
        // Only detect new lines if the document has no line break yet.
        if (this.getLength() <= 1)
            this.$detectNewLine(text);
        
        return this.insertMergedLines(position, this.$split(text));
    }
    
    /**
     * Inserts `text` into the `position` at the current row. This method also triggers the `"change"` event.
     * 
     * This differs from the `insert` method in two ways:
     *   1. This does NOT handle newline characters (single-line text only).
     *   2. This is faster than the `insert` method for single-line text insertions.
     * 
     * @param {Point} position The position to insert at; it's an object that looks like `{ row: row, column: column}`
     * @param {String} text A chunk of text without new lines
     * @returns {Point} Returns the position of the end of the inserted text
     **/
    insertInLine(position, text) {
        var start = this.clippedPos(position.row, position.column);
        var end = this.pos(position.row, position.column + text.length);
        
        this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: [text]
        }, true);
        
        return this.clonePos(end);
    }

    /**
     * 
     * @param {number} row
     * @param {number} column
     * @return {Point}
     */
    clippedPos(row, column) {
        var length = this.getLength();
        if (row === undefined) {
            row = length;
        } else if (row < 0) {
            row = 0;
        } else if (row >= length) {
            row = length - 1;
            column = undefined;
        }
        var line = this.getLine(row);
        if (column == undefined)
            column = line.length;
        column = Math.min(Math.max(column, 0), line.length);
        return {row: row, column: column};
    }

    /**
     * @param {Point} pos
     * @return {Point}
     */
    clonePos(pos) {
        return {row: pos.row, column: pos.column};
    }

    /**
     * @param {number} row
     * @param {number} column
     * @return {Point}
     */
    pos(row, column) {
        return {row: row, column: column};
    }

    /**
     * @param {Point} position
     * @return {Point}
     * @private
     */
    $clipPosition(position) {
        var length = this.getLength();
        if (position.row >= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length - 1).length;
        } else {
            position.row = Math.max(0, position.row);
            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
        }
        return position;
    }
    
    /**
     * Inserts the elements in `lines` into the document as full lines (does not merge with existing line), starting at the row index given by `row`. This method also triggers the `"change"` event.
     * @param {Number} row The index of the row to insert at
     * @param {string[]} lines An array of strings
     
     **/
    insertFullLines(row, lines) {
        // Clip to document.
        // Allow one past the document end.
        row = Math.min(Math.max(row, 0), this.getLength());
        
        // Calculate insertion point.
        var column = 0;
        if (row < this.getLength()) {
            // Insert before the specified row.
            lines = lines.concat([""]);
            column = 0;
        } else {
            // Insert after the last row in the document.
            lines = [""].concat(lines);
            row--;
            column = this.$lines[row].length;
        }
        
        // Insert.
        this.insertMergedLines({row: row, column: column}, lines);
    }

    /**
     * Inserts the elements in `lines` into the document, starting at the position index given by `row`. This method also triggers the `"change"` event.
     * @param {Point} position
     * @param {string[]} lines An array of strings
     * @returns {Point} Contains the final row and column, like this:  
     *   ```
     *   {row: endRow, column: 0}
     *   ```  
     *   If `lines` is empty, this function returns an object containing the current row, and column, like this:  
     *   ``` 
     *   {row: row, column: 0}
     *   ```
     **/    
    insertMergedLines(position, lines) {
        var start = this.clippedPos(position.row, position.column);
        var end = {
            row: start.row + lines.length - 1,
            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
        };
        
        this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: lines
        });
        
        return this.clonePos(end);
    }

    /**
     * Removes the `range` from the document.
     * @param {IRange} range A specified Range to remove
     * @returns {Point} Returns the new `start` property of the range, which contains `startRow` and `startColumn`. If `range` is empty, this function returns the unmodified value of `range.start`.
     
     **/
    remove(range) {
        var start = this.clippedPos(range.start.row, range.start.column);
        var end = this.clippedPos(range.end.row, range.end.column);
        this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({start: start, end: end})
        });
        return this.clonePos(start);
    }

    /**
     * Removes the specified columns from the `row`. This method also triggers a `"change"` event.
     * @param {Number} row The row to remove from
     * @param {Number} startColumn The column to start removing at 
     * @param {Number} endColumn The column to stop removing at
     * @returns {Point} Returns an object containing `startRow` and `startColumn`, indicating the new row and column values.<br/>If `startColumn` is equal to `endColumn`, this function returns nothing.
     
     **/
    removeInLine(row, startColumn, endColumn) {
        var start = this.clippedPos(row, startColumn);
        var end = this.clippedPos(row, endColumn);
        
        this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({start: start, end: end})
        }, true);
        
        return this.clonePos(start);
    }

    /**
     * Removes a range of full lines. This method also triggers the `"change"` event.
     * @param {Number} firstRow The first row to be removed
     * @param {Number} lastRow The last row to be removed
     * @returns {String[]} Returns all the removed lines.
     
     **/
    removeFullLines(firstRow, lastRow) {
        // Clip to document.
        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
        lastRow  = Math.min(Math.max(0, lastRow ), this.getLength() - 1);
        
        // Calculate deletion range.
        // Delete the ending new line unless we're at the end of the document.
        // If we're at the end of the document, delete the starting new line.
        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
        var deleteLastNewLine  = lastRow  < this.getLength() - 1;
        var startRow = ( deleteFirstNewLine ? firstRow - 1                  : firstRow                    );
        var startCol = ( deleteFirstNewLine ? this.getLine(startRow).length : 0                           );
        var endRow   = ( deleteLastNewLine  ? lastRow + 1                   : lastRow                     );
        var endCol   = ( deleteLastNewLine  ? 0                             : this.getLine(endRow).length ); 
        var range = new Range(startRow, startCol, endRow, endCol);
        
        // Store delelted lines with bounding newlines ommitted (maintains previous behavior).
        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
        
        this.applyDelta({
            start: range.start,
            end: range.end,
            action: "remove",
            lines: this.getLinesForRange(range)
        });
        
        // Return the deleted lines.
        return deletedLines;
    }

    /**
     * Removes the new line between `row` and the row immediately following it. This method also triggers the `"change"` event.
     * @param {Number} row The row to check
     *
     **/
    removeNewLine(row) {
        if (row < this.getLength() - 1 && row >= 0) {
            this.applyDelta({
                start: this.pos(row, this.getLine(row).length),
                end: this.pos(row + 1, 0),
                action: "remove",
                lines: ["", ""]
            });
        }
    }

    /**
     * Replaces a range in the document with the new `text`.
     * @param {Range | IRange} range A specified Range to replace
     * @param {String} text The new text to use as a replacement
     * @returns {Point} Returns an object containing the final row and column, like this:
     *     {row: endRow, column: 0}
     * If the text and range are empty, this function returns an object containing the current `range.start` value.
     * If the text is the exact same as what currently exists, this function returns an object containing the current `range.end` value.
     *
     **/
    replace(range, text) {
        if (!(range instanceof Range))
            range = Range.fromPoints(range.start, range.end);
        // @ts-expect-error
        if (text.length === 0 && range.isEmpty())
            return range.start;

        // Shortcut: If the text we want to insert is the same as it is already
        // in the document, we don't have to replace anything.
        if (text == this.getTextRange(range))
            return range.end;

        this.remove(range);
        var end;
        if (text) {
            end = this.insert(range.start, text);
        }
        else {
            end = range.start;
        }
        
        return end;
    }

    /**
     * Applies all changes in `deltas` to the document.
     * @param {Delta[]} deltas An array of delta objects (can include "insert" and "remove" actions)
     **/
    applyDeltas(deltas) {
        for (var i=0; i<deltas.length; i++) {
            this.applyDelta(deltas[i]);
        }
    }
    
    /**
     * Reverts all changes in `deltas` from the document.
     * @param {Delta[]} deltas An array of delta objects (can include "insert" and "remove" actions)
     **/
    revertDeltas(deltas) {
        for (var i=deltas.length-1; i>=0; i--) {
            this.revertDelta(deltas[i]);
        }
    }
    
    /**
     * Applies `delta` to the document.
     * @param {Delta} delta A delta object (can include "insert" and "remove" actions)
     * @param {boolean} [doNotValidate]
     **/
    applyDelta(delta, doNotValidate) {
        var isInsert = delta.action == "insert";
        // An empty range is a NOOP.
        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]
            : !Range.comparePoints(delta.start, delta.end)) {
            return;
        }
        
        if (isInsert && delta.lines.length > 20000) {
            this.$splitAndapplyLargeDelta(delta, 20000);
        }
        else {
            applyDelta(this.$lines, delta, doNotValidate);
            this._signal("change", delta);
        }
    }

    /**
     * @param {Delta} delta
     */
    $safeApplyDelta(delta) {
        var docLength = this.$lines.length;
        // verify that delta is in the document to prevent applyDelta from corrupting lines array 
        if (
            delta.action == "remove" && delta.start.row < docLength && delta.end.row < docLength
            || delta.action == "insert" && delta.start.row <= docLength
        ) {
            this.applyDelta(delta);
        }
    }

    /**
     * 
     * @param {Delta} delta
     * @param {number} MAX
     */
    $splitAndapplyLargeDelta(delta, MAX) {
        // Split large insert deltas. This is necessary because:
        //    1. We need to support splicing delta lines into the document via $lines.splice.apply(...)
        //    2. fn.apply() doesn't work for a large number of params. The smallest threshold is on chrome 40 ~42000.
        // we use 20000 to leave some space for actual stack
        // 
        // To Do: Ideally we'd be consistent and also split 'delete' deltas. We don't do this now, because delete
        //        delta handling is too slow. If we make delete delta handling faster we can split all large deltas
        //        as shown in https://gist.github.com/aldendaniels/8367109#file-document-snippet-js
        //        If we do this, update validateDelta() to limit the number of lines in a delete delta.
        var lines = delta.lines;
        var l = lines.length - MAX + 1;
        var row = delta.start.row; 
        var column = delta.start.column;
        for (var from = 0, to = 0; from < l; from = to) {
            to += MAX - 1;
            var chunk = lines.slice(from, to);
            chunk.push("");
            this.applyDelta({
                start: this.pos(row + from, column),
                end: this.pos(row + to, column = 0),
                action: delta.action,
                lines: chunk
            }, true);
        }
        // Update remaining delta.
        delta.lines = lines.slice(from);
        delta.start.row = row + from;
        delta.start.column = column;
        this.applyDelta(delta, true);
    }
    
    /**
     * Reverts `delta` from the document.
     * @param {Delta} delta A delta object (can include "insert" and "remove" actions)
     **/
    revertDelta(delta) {
        this.$safeApplyDelta({
            start: this.clonePos(delta.start),
            end: this.clonePos(delta.end),
            action: (delta.action == "insert" ? "remove" : "insert"),
            lines: delta.lines.slice()
        });
    }
    
    /**
     * Converts an index position in a document to a `{row, column}` object.
     *
     * Index refers to the "absolute position" of a character in the document. For example:
     *
     * ```javascript
     * var x = 0; // 10 characters, plus one for newline
     * var y = -1;
     * ```
     * 
     * Here, `y` is an index 15: 11 characters for the first row, and 5 characters until `y` in the second.
     *
     * @param {Number} index An index to convert
     * @param {Number} [startRow=0] The row from which to start the conversion
     * @returns {Point} A `{row, column}` object of the `index` position
     */
    indexToPosition(index, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        for (var i = startRow || 0, l = lines.length; i < l; i++) {
            index -= lines[i].length + newlineLength;
            if (index < 0)
                return {row: i, column: index + lines[i].length + newlineLength};
        }
        return {row: l-1, column: index + lines[l-1].length + newlineLength};
    }

    /**
     * Converts the `{row, column}` position in a document to the character's index.
     *
     * Index refers to the "absolute position" of a character in the document. For example:
     *
     * ```javascript
     * var x = 0; // 10 characters, plus one for newline
     * var y = -1;
     * ```
     * 
     * Here, `y` is an index 15: 11 characters for the first row, and 5 characters until `y` in the second.
     *
     * @param {Point} pos The `{row, column}` to convert
     * @param {Number} [startRow=0] The row from which to start the conversion
     * @returns {Number} The index position in the document
     */
    positionToIndex(pos, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        var index = 0;
        var row = Math.min(pos.row, lines.length);
        for (var i = startRow || 0; i < row; ++i)
            index += lines[i].length + newlineLength;

        return index + pos.column;
    }

    /**
     * Splits a string of text on any newline (`\n`) or carriage-return (`\r`) characters.
     *
     * @method $split
     * @param {String} text The text to work with
     * @returns {String[]} A String array, with each index containing a piece of the original `text` string.
     *
     **/
    $split(text) {
        return text.split(/\r\n|\r|\n/);
    }
}

Document.prototype.$autoNewLine = "";
Document.prototype.$newLineMode = "auto";

oop.implement(Document.prototype, EventEmitter);

exports.y = Document;


/***/ }),

/***/ 98345:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var oop = __webpack_require__(2645);
var lang = __webpack_require__(39955);
var EventEmitter = (__webpack_require__(87366).EventEmitter);
var Range = (__webpack_require__(91902)/* .Range */ .Q);
/**
 * @typedef {import("./edit_session").EditSession} EditSession
 * @typedef {import("./anchor").Anchor} Anchor
 * @typedef {import("../ace-internal").Ace.Point} Point
 */

class Selection {
    /**
     * Creates a new `Selection` object.
     * @param {EditSession} session The session to use
     * @constructor
     **/
    constructor(session) {
        /**@type {EditSession}*/
        this.session = session;
        /**@type {import("./document").Document}*/
        this.doc = session.getDocument();
    
        this.clearSelection();
        /**@type {Anchor}*/
        this.cursor = this.lead = this.doc.createAnchor(0, 0);
        /**@type {Anchor}*/
        this.anchor = this.doc.createAnchor(0, 0);
        this.$silent = false;
    
        var self = this;
        this.cursor.on("change", function(e) {
            self.$cursorChanged = true;
            if (!self.$silent)
                self._emit("changeCursor");
            if (!self.$isEmpty && !self.$silent)
                self._emit("changeSelection");
            if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)
                self.$desiredColumn = null;
        });
    
        this.anchor.on("change", function() {
            self.$anchorChanged = true;
            if (!self.$isEmpty && !self.$silent)
                self._emit("changeSelection");
        });
    }
    
    /**
     * Returns `true` if the selection is empty.
     * @returns {Boolean}
     **/
   isEmpty() {
        return this.$isEmpty || (
            this.anchor.row == this.lead.row &&
            this.anchor.column == this.lead.column
        );
    }

    /**
     * Returns `true` if the selection is a multi-line.
     * @returns {Boolean}
     **/
    isMultiLine() {
        return !this.$isEmpty && this.anchor.row != this.cursor.row;
    }

    /**
     * Returns an object containing the `row` and `column` current position of the cursor.
     * @returns {Point}
     **/
    getCursor() {
        return this.lead.getPosition();
    }

    /**
     * Sets the row and column position of the anchor. This function also emits the `'changeSelection'` event.
     * @param {Number} row The new row
     * @param {Number} column The new column
     *
     **/
    setAnchor(row, column) {
        this.$isEmpty = false;
        this.anchor.setPosition(row, column);
    }


    /**
     * Returns an object containing the `row` and `column` of the calling selection anchor.
     *
     * @returns {Point}
     * @related Anchor.getPosition
     **/
    getAnchor() {
        if (this.$isEmpty)
            return this.getSelectionLead();

        return this.anchor.getPosition();
    }


    /**
     * Returns an object containing the `row` and `column` of the calling selection lead.
     * @returns {Object}
     **/
    getSelectionLead() {
        return this.lead.getPosition();
    }

    /**
     * Returns `true` if the selection is going backwards in the document.
     * @returns {Boolean}
     **/
    isBackwards() {
        var anchor = this.anchor;
        var lead = this.lead;
        return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));
    }

    /**
     * [Returns the [[Range]] for the selected text.]{: #Selection.getRange}
     * @returns {Range}
     **/
    getRange() {
        var anchor = this.anchor;
        var lead = this.lead;

        if (this.$isEmpty)
            return Range.fromPoints(lead, lead);

        return this.isBackwards()
            ? Range.fromPoints(lead, anchor)
            : Range.fromPoints(anchor, lead);
    }

    /**
     * [Empties the selection (by de-selecting it). This function also emits the `'changeSelection'` event.]{: #Selection.clearSelection}
     **/
    clearSelection() {
        if (!this.$isEmpty) {
            this.$isEmpty = true;
            this._emit("changeSelection");
        }
    }

    /**
     * Selects all the text in the document.
     **/
    selectAll() {
        this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
    }

    /**
     * Sets the selection to the provided range.
     * @param {import("../ace-internal").Ace.IRange} range The range of text to select
     * @param {Boolean} [reverse] Indicates if the range should go backwards (`true`) or not
     **/
    setRange(range, reverse) {
        var start = reverse ? range.end : range.start;
        var end = reverse ? range.start : range.end;
        this.$setSelection(start.row, start.column, end.row, end.column);
    }

    /**
     * @param {number} anchorRow
     * @param {number} anchorColumn
     * @param {number} cursorRow
     * @param {number} cursorColumn
     */
    $setSelection(anchorRow, anchorColumn, cursorRow, cursorColumn) {
        if (this.$silent)
            return;
        var wasEmpty = this.$isEmpty;
        var wasMultiselect = this.inMultiSelectMode;
        this.$silent = true;
        this.$cursorChanged = this.$anchorChanged = false;
        this.anchor.setPosition(anchorRow, anchorColumn);
        this.cursor.setPosition(cursorRow, cursorColumn);
        this.$isEmpty = !Range.comparePoints(this.anchor, this.cursor);
        this.$silent = false;
        if (this.$cursorChanged)
            this._emit("changeCursor");
        if (this.$cursorChanged || this.$anchorChanged || wasEmpty != this.$isEmpty || wasMultiselect)
            this._emit("changeSelection");
    }

    $moveSelection(mover) {
        var lead = this.lead;
        if (this.$isEmpty)
            this.setSelectionAnchor(lead.row, lead.column);

        mover.call(this);
    }

    /**
     * Moves the selection cursor to the indicated row and column.
     * @param {Number} row The row to select to
     * @param {Number} column The column to select to
     **/
    selectTo(row, column) {
        this.$moveSelection(function() {
            this.moveCursorTo(row, column);
        });
    }

    /**
     * Moves the selection cursor to the row and column indicated by `pos`.
     * @param {Point} pos An object containing the row and column
     **/
    selectToPosition(pos) {
        this.$moveSelection(function() {
            this.moveCursorToPosition(pos);
        });
    }

    /**
     * Moves the selection cursor to the indicated row and column.
     * @param {Number} row The row to select to
     * @param {Number} column The column to select to
     **/
    moveTo(row, column) {
        this.clearSelection();
        this.moveCursorTo(row, column);
    }

    /**
     * Moves the selection cursor to the row and column indicated by `pos`.
     * @param {Object} pos An object containing the row and column
     **/
    moveToPosition(pos) {
        this.clearSelection();
        this.moveCursorToPosition(pos);
    }


    /**
     * Moves the selection up one row.
     **/
    selectUp() {
        this.$moveSelection(this.moveCursorUp);
    }

    /**
     * Moves the selection down one row.
     **/
    selectDown() {
        this.$moveSelection(this.moveCursorDown);
    }

    /**
     * Moves the selection right one column.
     **/
    selectRight() {
        this.$moveSelection(this.moveCursorRight);
    }

    /**
     * Moves the selection left one column.
     **/
    selectLeft() {
        this.$moveSelection(this.moveCursorLeft);
    }

    /**
     * Moves the selection to the beginning of the current line.
     **/
    selectLineStart() {
        this.$moveSelection(this.moveCursorLineStart);
    }

    /**
     * Moves the selection to the end of the current line.
     **/
    selectLineEnd() {
        this.$moveSelection(this.moveCursorLineEnd);
    }

    /**
     * Moves the selection to the end of the file.
     **/
    selectFileEnd() {
        this.$moveSelection(this.moveCursorFileEnd);
    }

    /**
     * Moves the selection to the start of the file.
     **/
    selectFileStart() {
        this.$moveSelection(this.moveCursorFileStart);
    }

    /**
     * Moves the selection to the first word on the right.
     **/
    selectWordRight() {
        this.$moveSelection(this.moveCursorWordRight);
    }

    /**
     * Moves the selection to the first word on the left.
     **/
    selectWordLeft() {
        this.$moveSelection(this.moveCursorWordLeft);
    }

    /**
     * Moves the selection to highlight the entire word.
     * @related EditSession.getWordRange
     **/
    getWordRange(row, column) {
        if (typeof column == "undefined") {
            var cursor = row || this.lead;
            row = cursor.row;
            column = cursor.column;
        }
        return this.session.getWordRange(row, column);
    }

    /**
     * Selects an entire word boundary.
     **/
    selectWord() {
        this.setSelectionRange(this.getWordRange());
    }

    /**
     * Selects a word, including its right whitespace.
     * @related EditSession.getAWordRange
     **/
    selectAWord() {
        var cursor = this.getCursor();
        var range = this.session.getAWordRange(cursor.row, cursor.column);
        this.setSelectionRange(range);
    }

    getLineRange(row, excludeLastChar) {
        var rowStart = typeof row == "number" ? row : this.lead.row;
        var rowEnd;

        var foldLine = this.session.getFoldLine(rowStart);
        if (foldLine) {
            rowStart = foldLine.start.row;
            rowEnd = foldLine.end.row;
        } else {
            rowEnd = rowStart;
        }
        if (excludeLastChar === true)
            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
        else
            return new Range(rowStart, 0, rowEnd + 1, 0);
    }

    /**
     * Selects the entire line.
     **/
    selectLine() {
        this.setSelectionRange(this.getLineRange());
    }

    /**
     * Moves the cursor up one row.
     **/
    moveCursorUp() {
        this.moveCursorBy(-1, 0);
    }

    /**
     * Moves the cursor down one row.
     **/
    moveCursorDown() {
        this.moveCursorBy(1, 0);
    }

    /**
     *
     * Returns `true` if moving the character next to the cursor in the specified direction is a soft tab.
     * @param {Point} cursor the current cursor position
     * @param {Number} tabSize the tab size
     * @param {Number} direction 1 for right, -1 for left
     */
    wouldMoveIntoSoftTab(cursor, tabSize, direction) {
        var start = cursor.column;
        var end = cursor.column + tabSize;

        if (direction < 0) {
            start = cursor.column - tabSize;
            end = cursor.column;
        }
        return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(" ").length-1 == tabSize;
    }

    /**
     * Moves the cursor left one column.
     **/
    moveCursorLeft() {
        var cursor = this.lead.getPosition(),
            fold;

        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
        } else if (cursor.column === 0) {
            // cursor is a line (start
            if (cursor.row > 0) {
                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
            }
        }
        else {
            var tabSize = this.session.getTabSize();
            if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {
                this.moveCursorBy(0, -tabSize);
            } else {
                this.moveCursorBy(0, -1);
            }
        }
    }

    /**
     * Moves the cursor right one column.
     **/
    moveCursorRight() {
        var cursor = this.lead.getPosition(),
            fold;
        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
            this.moveCursorTo(fold.end.row, fold.end.column);
        }
        else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
            if (this.lead.row < this.doc.getLength() - 1) {
                this.moveCursorTo(this.lead.row + 1, 0);
            }
        }
        else {
            var tabSize = this.session.getTabSize();
            /**
             * @type {Point}
             */
            var cursor = this.lead;
            if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {
                this.moveCursorBy(0, tabSize);
            } else {
                this.moveCursorBy(0, 1);
            }
        }
    }

    /**
     * Moves the cursor to the start of the line.
     **/
    moveCursorLineStart() {
        var row = this.lead.row;
        var column = this.lead.column;
        var screenRow = this.session.documentToScreenRow(row, column);

        // Determ the doc-position of the first character at the screen line.
        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);

        // Determ the line
        var beforeCursor = this.session.getDisplayLine(
            row, null, firstColumnPosition.row,
            firstColumnPosition.column
        );

        var leadingSpace = beforeCursor.match(/^\s*/);
        // TODO find better way for emacs mode to override selection behaviors
        if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
            firstColumnPosition.column += leadingSpace[0].length;
        this.moveCursorToPosition(firstColumnPosition);
    }

    /**
     * Moves the cursor to the end of the line.
     **/
    moveCursorLineEnd() {
        var lead = this.lead;
        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
        if (this.lead.column == lineEnd.column) {
            var line = this.session.getLine(lineEnd.row);
            if (lineEnd.column == line.length) {
                var textEnd = line.search(/\s+$/);
                if (textEnd > 0)
                    lineEnd.column = textEnd;
            }
        }

        this.moveCursorTo(lineEnd.row, lineEnd.column);
    }

    /**
     * Moves the cursor to the end of the file.
     **/
    moveCursorFileEnd() {
        var row = this.doc.getLength() - 1;
        var column = this.doc.getLine(row).length;
        this.moveCursorTo(row, column);
    }

    /**
     * Moves the cursor to the start of the file.
     **/
    moveCursorFileStart() {
        this.moveCursorTo(0, 0);
    }

    /**
     * Moves the cursor to the word on the right.
     **/
    moveCursorLongWordRight() {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);

        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;

        // skip folds
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
            this.moveCursorTo(fold.end.row, fold.end.column);
            return;
        }

        // first skip space
        if (this.session.nonTokenRe.exec(rightOfCursor)) {
            column += this.session.nonTokenRe.lastIndex;
            this.session.nonTokenRe.lastIndex = 0;
            rightOfCursor = line.substring(column);
        }

        // if at line end proceed with next line
        if (column >= line.length) {
            this.moveCursorTo(row, line.length);
            this.moveCursorRight();
            if (row < this.doc.getLength() - 1)
                this.moveCursorWordRight();
            return;
        }

        // advance to the end of the next token
        if (this.session.tokenRe.exec(rightOfCursor)) {
            column += this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
        }

        this.moveCursorTo(row, column);
    }

    /**
    *
    * Moves the cursor to the word on the left.
    **/
    moveCursorLongWordLeft() {
        var row = this.lead.row;
        var column = this.lead.column;

        // skip folds
        var fold;
        if (fold = this.session.getFoldAt(row, column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
            return;
        }

        var str = this.session.getFoldStringAt(row, column, -1);
        if (str == null) {
            str = this.doc.getLine(row).substring(0, column);
        }

        var leftOfCursor = lang.stringReverse(str);
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;

        // skip whitespace
        if (this.session.nonTokenRe.exec(leftOfCursor)) {
            column -= this.session.nonTokenRe.lastIndex;
            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
            this.session.nonTokenRe.lastIndex = 0;
        }

        // if at begin of the line proceed in line above
        if (column <= 0) {
            this.moveCursorTo(row, 0);
            this.moveCursorLeft();
            if (row > 0)
                this.moveCursorWordLeft();
            return;
        }

        // move to the begin of the word
        if (this.session.tokenRe.exec(leftOfCursor)) {
            column -= this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
        }

        this.moveCursorTo(row, column);
    }

    $shortWordEndIndex(rightOfCursor) {
        var index = 0, ch;
        var whitespaceRe = /\s/;
        var tokenRe = this.session.tokenRe;

        tokenRe.lastIndex = 0;
        if (this.session.tokenRe.exec(rightOfCursor)) {
            index = this.session.tokenRe.lastIndex;
        } else {
            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                index ++;

            if (index < 1) {
                tokenRe.lastIndex = 0;
                 while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                    tokenRe.lastIndex = 0;
                    index ++;
                    if (whitespaceRe.test(ch)) {
                        if (index > 2) {
                            index--;
                            break;
                        } else {
                            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                                index ++;
                            if (index > 2)
                                break;
                        }
                    }
                }
            }
        }
        tokenRe.lastIndex = 0;

        return index;
    }

    moveCursorShortWordRight() {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);

        var fold = this.session.getFoldAt(row, column, 1);
        if (fold)
            return this.moveCursorTo(fold.end.row, fold.end.column);

        if (column == line.length) {
            var l = this.doc.getLength();
            do {
                row++;
                rightOfCursor = this.doc.getLine(row);
            } while (row < l && /^\s*$/.test(rightOfCursor));

            if (!/^\s+/.test(rightOfCursor))
                rightOfCursor = "";
            column = 0;
        }

        var index = this.$shortWordEndIndex(rightOfCursor);

        this.moveCursorTo(row, column + index);
    }

    moveCursorShortWordLeft() {
        var row = this.lead.row;
        var column = this.lead.column;

        var fold;
        if (fold = this.session.getFoldAt(row, column, -1))
            return this.moveCursorTo(fold.start.row, fold.start.column);

        var line = this.session.getLine(row).substring(0, column);
        if (column === 0) {
            do {
                row--;
                line = this.doc.getLine(row);
            } while (row > 0 && /^\s*$/.test(line));

            column = line.length;
            if (!/\s+$/.test(line))
                line = "";
        }

        var leftOfCursor = lang.stringReverse(line);
        var index = this.$shortWordEndIndex(leftOfCursor);

        return this.moveCursorTo(row, column - index);
    }

    moveCursorWordRight() {
        if (this.session.$selectLongWords)
            this.moveCursorLongWordRight();
        else
            this.moveCursorShortWordRight();
    }

    moveCursorWordLeft() {
        if (this.session.$selectLongWords)
            this.moveCursorLongWordLeft();
        else
            this.moveCursorShortWordLeft();
    }

    /**
     * Moves the cursor to position indicated by the parameters. Negative numbers move the cursor backwards in the document.
     * @param {Number} rows The number of rows to move by
     * @param {Number} chars The number of characters to move by
     *
     * @related EditSession.documentToScreenPosition
     **/
    moveCursorBy(rows, chars) {
        var screenPos = this.session.documentToScreenPosition(
            this.lead.row,
            this.lead.column
        );

        var offsetX;

        if (chars === 0) {
            if (rows !== 0) {
                if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {
                    offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);
                    screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);
                } else {
                    offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];
                }
            }

            if (this.$desiredColumn)
                screenPos.column = this.$desiredColumn;
            else
                this.$desiredColumn = screenPos.column;
        }

        if (rows != 0 && this.session.lineWidgets && this.session.lineWidgets[this.lead.row]) {
            var widget = this.session.lineWidgets[this.lead.row];
            if (rows < 0)
                rows -= widget.rowsAbove || 0;
            else if (rows > 0)
                rows += widget.rowCount - (widget.rowsAbove || 0);
        }

        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);

        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {

        }

        // move the cursor and update the desired column
        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
    }

    /**
     * Moves the selection to the position indicated by its `row` and `column`.
     * @param {Point} position The position to move to
     **/
    moveCursorToPosition(position) {
        this.moveCursorTo(position.row, position.column);
    }

    /**
     * Moves the cursor to the row and column provided. [If `preventUpdateDesiredColumn` is `true`, then the cursor stays in the same column position as its original point.]{: #preventUpdateBoolDesc}
     * @param {Number} row The row to move to
     * @param {Number} column The column to move to
     * @param {Boolean} [keepDesiredColumn] [If `true`, the cursor move does not respect the previous column]{: #preventUpdateBool}
     **/
    moveCursorTo(row, column, keepDesiredColumn) {
        // Ensure the row/column is not inside of a fold.
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
            row = fold.start.row;
            column = fold.start.column;
        }

        this.$keepDesiredColumnOnChange = true;
        var line = this.session.getLine(row);
        // do not allow putting cursor in the middle of surrogate pairs
        if (/[\uDC00-\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {
            if (this.lead.row == row && this.lead.column == column + 1)
                column = column - 1;
            else
                column = column + 1;
        }
        this.lead.setPosition(row, column);
        this.$keepDesiredColumnOnChange = false;

        if (!keepDesiredColumn)
            this.$desiredColumn = null;
    }

    /**
     * Moves the cursor to the screen position indicated by row and column. {:preventUpdateBoolDesc}
     * @param {Number} row The row to move to
     * @param {Number} column The column to move to
     * @param {Boolean} keepDesiredColumn {:preventUpdateBool}
     **/
    moveCursorToScreen(row, column, keepDesiredColumn) {
        var pos = this.session.screenToDocumentPosition(row, column);
        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
    }

    // remove listeners from document
    detach() {
        this.lead.detach();
        this.anchor.detach();
    }

    /**
     * @param {Range & {desiredColumn?: number}} range
     */
    fromOrientedRange(range) {
        this.setSelectionRange(range, range.cursor == range.start);
        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
    }

    /**
     * @param {Range & {desiredColumn?: number}} [range]
     */
    toOrientedRange(range) {
        var r = this.getRange();
        if (range) {
            range.start.column = r.start.column;
            range.start.row = r.start.row;
            range.end.column = r.end.column;
            range.end.row = r.end.row;
        } else {
            range = r;
        }

        range.cursor = this.isBackwards() ? range.start : range.end;
        range.desiredColumn = this.$desiredColumn;
        return range;
    }

    /**
     * Saves the current cursor position and calls `func` that can change the cursor
     * postion. The result is the range of the starting and eventual cursor position.
     * Will reset the cursor position.
     * @param {Function} func The callback that should change the cursor position
     * @returns {Range}
     **/
    getRangeOfMovements(func) {
        var start = this.getCursor();
        try {
            func(this);
            var end = this.getCursor();
            return Range.fromPoints(start, end);
        } catch(e) {
            return Range.fromPoints(start, start);
        } finally {
            this.moveCursorToPosition(start);
        }
    }

    /**
     * 
     * @returns {Range|Range[]}
     */
    toJSON() {
        if (this.rangeCount) {
            /**@type{Range|Range[]}*/var data = this.ranges.map(function(r) {
                var r1 = r.clone();
                r1.isBackwards = r.cursor == r.start;
                return r1;
            });
        } else {
            /**@type{Range|Range[]}*/var data = this.getRange();
            data.isBackwards = this.isBackwards();
        }
        return data;
    }

    /**
     * 
     * @param data
     */
    fromJSON(data) {
        if (data.start == undefined) {
            if (this.rangeList && data.length > 1) {
                this.toSingleRange(data[0]);
                for (var i = data.length; i--; ) {
                    var r = Range.fromPoints(data[i].start, data[i].end);
                    if (data[i].isBackwards)
                        r.cursor = r.start;
                    this.addRange(r, true);
                }
                return;
            } else {
                data = data[0];
            }
        }
        if (this.rangeList)
            this.toSingleRange(data);
        this.setSelectionRange(data, data.isBackwards);
    }

    /**
     * 
     * @param data
     * @return {boolean}
     */
    isEqual(data) {
        if ((data.length || this.rangeCount) && data.length != this.rangeCount)
            return false;
        if (!data.length || !this.ranges)
            return this.getRange().isEqual(data);

        for (var i = this.ranges.length; i--; ) {
            if (!this.ranges[i].isEqual(data[i]))
                return false;
        }
        return true;
    }

}

/**
 * Left for backward compatibility
 * @deprecated
 */
Selection.prototype.setSelectionAnchor = Selection.prototype.setAnchor;
/**
 * Left for backward compatibility
 * @deprecated
 */
Selection.prototype.getSelectionAnchor = Selection.prototype.getAnchor;

Selection.prototype.setSelectionRange = Selection.prototype.setRange;

oop.implement(Selection.prototype, EventEmitter);
exports.L = Selection;


/***/ }),

/***/ 99339:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./edit_session").EditSession} EditSession
 */

var Range = (__webpack_require__(91902)/* .Range */ .Q);

/**
 * This class provides an essay way to treat the document as a stream of tokens, and provides methods to iterate over these tokens.
 **/
class TokenIterator {
    /**
     * Creates a new token iterator object. The inital token index is set to the provided row and column coordinates.
     * @param {EditSession} session The session to associate with
     * @param {Number} initialRow The row to start the tokenizing at
     * @param {Number} initialColumn The column to start the tokenizing at
     **/
    constructor(session, initialRow, initialColumn) {
        this.$session = session;
        this.$row = initialRow;
        this.$rowTokens = session.getTokens(initialRow);

        var token = session.getTokenAt(initialRow, initialColumn);
        this.$tokenIndex = token ? token.index : -1;
    }
    
    /**
     * Moves iterator position to the start of previous token.
     * @returns {import("../ace-internal").Ace.Token|null}
     **/ 
    stepBackward() {
        this.$tokenIndex -= 1;
        
        while (this.$tokenIndex < 0) {
            this.$row -= 1;
            if (this.$row < 0) {
                this.$row = 0;
                return null;
            }
                
            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = this.$rowTokens.length - 1;
        }
            
        return this.$rowTokens[this.$tokenIndex];
    }

    /**
     * Moves iterator position to the start of next token.
     * @returns {import("../ace-internal").Ace.Token|null}
     **/   
    stepForward() {
        this.$tokenIndex += 1;
        var rowCount;
        while (this.$tokenIndex >= this.$rowTokens.length) {
            this.$row += 1;
            if (!rowCount)
                rowCount = this.$session.getLength();
            if (this.$row >= rowCount) {
                this.$row = rowCount - 1;
                return null;
            }

            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = 0;
        }
            
        return this.$rowTokens[this.$tokenIndex];
    }
 
    /**
     * 
     * Returns current token.
     * @returns {import("../ace-internal").Ace.Token}
     **/      
    getCurrentToken() {
        return this.$rowTokens[this.$tokenIndex];
    }

    /**
     * 
     * Returns the current row.
     * @returns {Number}
     **/      
    getCurrentTokenRow() {
        return this.$row;
    }

    /**
     * 
     * Returns the current column.
     * @returns {Number}
     **/     
    getCurrentTokenColumn() {
        var rowTokens = this.$rowTokens;
        var tokenIndex = this.$tokenIndex;
        
        // If a column was cached by EditSession.getTokenAt, then use it
        var column = rowTokens[tokenIndex].start;
        if (column !== undefined)
            return column;
            
        column = 0;
        while (tokenIndex > 0) {
            tokenIndex -= 1;
            column += rowTokens[tokenIndex].value.length;
        }
        
        return column;  
    }

    /**
     * Return the current token position.
     * @returns {import("../ace-internal").Ace.Point}
     */
    getCurrentTokenPosition() {
        return {row: this.$row, column: this.getCurrentTokenColumn()};
    }
    
    /**
     * Return the current token range.
     * @returns {Range}
     */
    getCurrentTokenRange() {
        var token = this.$rowTokens[this.$tokenIndex];
        var column = this.getCurrentTokenColumn();
        return new Range(this.$row, column, this.$row, column + token.value.length);
    }
    
}

exports.TokenIterator = TokenIterator;


/***/ }),

/***/ 99427:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @typedef {import("./edit_session").EditSession} EditSession
 * @typedef {import("../ace-internal").Ace.SearchOptions} SearchOptions
 */
var lang = __webpack_require__(39955);
var oop = __webpack_require__(2645);
var Range = (__webpack_require__(91902)/* .Range */ .Q);

/**
 * A class designed to handle all sorts of text searches within a [[Document `Document`]].
 **/
class Search {

    constructor() {
        /**@type {Partial<SearchOptions>}*/
        this.$options = {};
    }

    /**
     * Sets the search options via the `options` parameter.
     * @param {Partial<SearchOptions>} options An object containing all the new search properties
     * @returns {Search}
     * @chainable
    **/
    set(options) {
        oop.mixin(this.$options, options);
        return this;
    }

    /**
     * [Returns an object containing all the search options.]{: #Search.getOptions}
     * @returns {Partial<SearchOptions>}
    **/
    getOptions() {
        return lang.copyObject(this.$options);
    }

    /**
     * Sets the search options via the `options` parameter.
     * @param {Partial<SearchOptions>} options object containing all the search propertie
     * @related Search.set
    **/
    setOptions(options) {
        this.$options = options;
    }

    /**
     * Searches for `options.needle`. If found, this method returns the [[Range `Range`]] where the text first occurs. If `options.backwards` is `true`, the search goes backwards in the session.
     * @param {EditSession} session The session to search with
     * @returns {Range | null | false}
     **/
    find(session) {
        var options = this.$options;
        var iterator = this.$matchIterator(session, options);
        if (!iterator)
            return false;

        var firstRange = null;
        iterator.forEach(function(sr, sc, er, ec) {
            firstRange = new Range(sr, sc, er, ec);
            if (sc == ec && options.start && /**@type{Range}*/(options.start).start
                && options.skipCurrent != false && firstRange.isEqual(/**@type{Range}*/(options.start))
            ) {
                firstRange = null;
                return false;
            }

            return true;
        });

        return firstRange;
    }

    /**
     * Searches for all occurrances `options.needle`. If found, this method returns an array of [[Range `Range`s]] where the text first occurs. If `options.backwards` is `true`, the search goes backwards in the session.
     * @param {EditSession} session The session to search with
     * @returns {Range[]}
    **/
    findAll(session) {
        var options = this.$options;
        if (!options.needle)
            return [];
        this.$assembleRegExp(options);

        var range = options.range;
        var lines = range
            ? session.getLines(range.start.row, range.end.row)
            : session.doc.getAllLines();

        var ranges = [];
        var re = options.re;
        if (options.$isMultiLine) {
            var len = re.length;
            var maxRow = lines.length - len;
            var prevRange;
            outer: for (var row = re.offset || 0; row <= maxRow; row++) {
                for (var j = 0; j < len; j++)
                    if (lines[row + j].search(re[j]) == -1)
                        continue outer;

                var startLine = lines[row];
                var line = lines[row + len - 1];
                var startIndex = startLine.length - startLine.match(re[0])[0].length;
                var endIndex = line.match(re[len - 1])[0].length;

                if (prevRange && prevRange.end.row === row &&
                    prevRange.end.column > startIndex
                ) {
                    continue;
                }
                ranges.push(prevRange = new Range(
                    row, startIndex, row + len - 1, endIndex
                ));
                if (len > 2)
                    row = row + len - 2;
            }
        } else {
            for (var matches, i = 0; i < lines.length; i++) {
                if (this.$isMultilineSearch(options)) {
                    var lng = lines.length - 1;
                    matches = this.$multiLineForward(session, re, i, lng);
                    if (matches) {
                        var end_row = matches.endRow <= lng ? matches.endRow - 1 : lng;
                        if (end_row > i)
                            i = end_row;
                        ranges.push(new Range(matches.startRow, matches.startCol, matches.endRow, matches.endCol));
                    }
                }
                else {
                    matches = lang.getMatchOffsets(lines[i], re);
                    for (var j = 0; j < matches.length; j++) {
                        var match = matches[j];
                        ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                    }
                }
            }
        }

        if (range) {
            var startColumn = range.start.column;
            var endColumn = range.end.column;
            var i = 0, j = ranges.length - 1;
            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == 0)
                i++;

            var endRow = range.end.row - range.start.row;
            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == endRow)
                j--;

            ranges = ranges.slice(i, j + 1);
            for (i = 0, j = ranges.length; i < j; i++) {
                ranges[i].start.row += range.start.row;
                ranges[i].end.row += range.start.row;
            }
        }

        return ranges;
    }

    parseReplaceString(replaceString) {
        var CharCode = {
            DollarSign: 36,
            Ampersand: 38,
            Digit0: 48,
            Digit1: 49,
            Digit9: 57,
            Backslash: 92,
            n: 110,
            t: 116
        };

        var replacement = '';
        for (var i = 0, len = replaceString.length; i < len; i++) {
            var chCode = replaceString.charCodeAt(i);
            if (chCode === CharCode.Backslash) {
                // move to next char
                i++;
                if (i >= len) {
                    // string ends with a \
                    replacement += "\\";
                    break;
                }
                var nextChCode = replaceString.charCodeAt(i);
                switch (nextChCode) {
                    case CharCode.Backslash:
                        // \\ => inserts a "\"
                        replacement += "\\";
                        break;
                    case CharCode.n:
                        // \n => inserts a LF
                        replacement += "\n";
                        break;
                    case CharCode.t:
                        // \t => inserts a TAB
                        replacement += "\t";
                        break;
                }
                continue;
            }

            if (chCode === CharCode.DollarSign) {
                // move to next char
                i++;
                if (i >= len) {
                    // string ends with a $
                    replacement += "$";
                    break;
                }
                const nextChCode = replaceString.charCodeAt(i);
                if (nextChCode === CharCode.DollarSign) {
                    // $$ => inserts a "$"
                    replacement += "$$";
                    continue;
                }
                if (nextChCode === CharCode.Digit0 || nextChCode === CharCode.Ampersand) {
                    // replace $0 to $&, making it compatible with JavaScript
                    // $0 and $& => inserts the matched substring.
                    replacement += "$&";
                    continue;
                }
                if (CharCode.Digit1 <= nextChCode && nextChCode <= CharCode.Digit9) {
                    // $n
                    replacement += "$" + replaceString[i];
                    continue;
                }
            }

            replacement += replaceString[i];
        }
        return replacement || replaceString;
    }

    /**
     * Searches for `options.needle` in `input`, and, if found, replaces it with `replacement`.
     * @param {String} input The text to search in
     * @param {any} replacement The replacing text
     * + (String): If `options.regExp` is `true`, this function returns `input` with the replacement already made. Otherwise, this function just returns `replacement`.<br/>
     * If `options.needle` was not found, this function returns `null`.
     *
     *
     * @returns {String}
    **/
    replace(input, replacement) {
        var options = this.$options;

        var re = this.$assembleRegExp(options);
        if (options.$isMultiLine)
            return replacement;

        if (!re)
            return;

        /**
         * Convert all line ending variations to Unix-style = \n
         * Windows (\r\n), MacOS Classic (\r), and Unix (\n)
         */
        var mtSearch = this.$isMultilineSearch(options);
        if (mtSearch)
            input = input.replace(/\r\n|\r|\n/g, "\n");

        var match = re.exec(input);
        if (!match || (!mtSearch && match[0].length != input.length))
            return null;

        replacement = options.regExp
            ? this.parseReplaceString(replacement)
            : replacement.replace(/\$/g, "$$$$");

        replacement = input.replace(re, replacement);
        if (options.preserveCase) {
            replacement = replacement.split("");
            for (var i = Math.min(input.length, input.length); i--; ) {
                var ch = input[i];
                if (ch && ch.toLowerCase() != ch)
                    replacement[i] = replacement[i].toUpperCase();
                else
                    replacement[i] = replacement[i].toLowerCase();
            }
            replacement = replacement.join("");
        }

        return replacement;
    }

    /**
     *
     * @param {Partial<SearchOptions>} options
     * @param {boolean} [$disableFakeMultiline]
     * @return {RegExp|boolean|*[]|*}
     */
    $assembleRegExp(options, $disableFakeMultiline) {
        if (options.needle instanceof RegExp)
            return options.re = options.needle;

        var needle = options.needle;

        if (!options.needle)
            return options.re = false;

        if (!options.regExp)
            needle = lang.escapeRegExp(needle);

        var modifier = options.caseSensitive ? "gm" : "gmi";

        try {
            new RegExp(needle, "u");
            options.$supportsUnicodeFlag = true;
            modifier += "u";
        } catch (e) {
            options.$supportsUnicodeFlag = false; //left for backward compatibility with previous versions for cases like /ab\{2}/gu
        }

        if (options.wholeWord)
            needle = addWordBoundary(needle, options);

        options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
        if (options.$isMultiLine)
            return options.re = this.$assembleMultilineRegExp(needle, modifier);

        try {
            /**@type {RegExp|false}*/
            var re = new RegExp(needle, modifier);
        } catch(e) {
            re = false;
        }
        return options.re = re;
    }

    /**
     * @param {string} needle
     * @param {string} modifier
     */
    $assembleMultilineRegExp(needle, modifier) {
        var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
        var re = [];
        for (var i = 0; i < parts.length; i++) try {
            re.push(new RegExp(parts[i], modifier));
        } catch(e) {
            return false;
        }
        return re;
    }

    $isMultilineSearch(options) {
        return options.re && /\\r\\n|\\r|\\n/.test(options.re.source) && options.regExp && !options.$isMultiLine;
    }

    $multiLineForward(session, re, start, last) {
        var line,
            chunk = chunkEnd(session, start);

        for (var row = start; row <= last;) {
            for (var i = 0; i < chunk; i++) {
                if (row > last)
                    break;
                var next = session.getLine(row++);
                line = line == null ? next : line + "\n" + next;
            }

            var match = re.exec(line);
            re.lastIndex = 0;
            if (match) {
                var beforeMatch = line.slice(0, match.index).split("\n");
                var matchedText = match[0].split("\n");
                var startRow = start + beforeMatch.length - 1;
                var startCol = beforeMatch[beforeMatch.length - 1].length;
                var endRow = startRow + matchedText.length - 1;
                var endCol = matchedText.length == 1
                    ? startCol + matchedText[0].length
                    : matchedText[matchedText.length - 1].length;

                return {
                    startRow: startRow,
                    startCol: startCol,
                    endRow: endRow,
                    endCol: endCol
                };
            }
        }
        return null;
    }

    $multiLineBackward(session, re, endIndex, start, first) {
        var line,
            chunk = chunkEnd(session, start),
            endMargin = session.getLine(start).length - endIndex;

        for (var row = start; row >= first;) {
            for (var i = 0; i < chunk && row >= first; i++) {
                var next = session.getLine(row--);
                line = line == null ? next : next + "\n" + line;
            }

            var match = multiLineBackwardMatch(line, re, endMargin);
            if (match) {
                var beforeMatch = line.slice(0, match.index).split("\n");
                var matchedText = match[0].split("\n");
                var startRow = row + beforeMatch.length;
                var startCol = beforeMatch[beforeMatch.length - 1].length;
                var endRow = startRow + matchedText.length - 1;
                var endCol = matchedText.length == 1
                    ? startCol + matchedText[0].length
                    : matchedText[matchedText.length - 1].length;

                return {
                    startRow: startRow,
                    startCol: startCol,
                    endRow: endRow,
                    endCol: endCol
                };
            }
        }
        return null;
    }

    /**
     * @param {EditSession} session
     */
    $matchIterator(session, options) {
        var re = this.$assembleRegExp(options);
        if (!re)
            return false;

        var mtSearch = this.$isMultilineSearch(options);
        var mtForward = this.$multiLineForward;
        var mtBackward = this.$multiLineBackward;

        var backwards = options.backwards == true;
        var skipCurrent = options.skipCurrent != false;
        var supportsUnicodeFlag = re.unicode;

        var range = options.range;
        var start = options.start;
        if (!start)
            start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();

        if (start.start)
            start = start[skipCurrent != backwards ? "end" : "start"];

        var firstRow = range ? range.start.row : 0;
        var lastRow = range ? range.end.row : session.getLength() - 1;

        if (backwards) {
            var forEach = function(callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                    return;
                for (row--; row >= firstRow; row--)
                    if (forEachInLine(row, Number.MAX_VALUE, callback))
                        return;
                if (options.wrap == false)
                    return;
                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
                    if (forEachInLine(row, Number.MAX_VALUE, callback))
                        return;
            };
        }
        else {
            var forEach = function(callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                    return;
                for (row = row + 1; row <= lastRow; row++)
                    if (forEachInLine(row, 0, callback))
                        return;
                if (options.wrap == false)
                    return;
                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
                    if (forEachInLine(row, 0, callback))
                        return;
            };
        }

        if (options.$isMultiLine) {
            var len = re.length;
            var forEachInLine = function(row, offset, callback) {
                var startRow = backwards ? row - len + 1 : row;
                if (startRow < 0 || startRow + len > session.getLength()) return;
                var line = session.getLine(startRow);
                var startIndex = line.search(re[0]);
                if (!backwards && startIndex < offset || startIndex === -1) return;
                for (var i = 1; i < len; i++) {
                    line = session.getLine(startRow + i);
                    if (line.search(re[i]) == -1)
                        return;
                }
                var endIndex = line.match(re[len - 1])[0].length;
                if (backwards && endIndex > offset) return;
                if (callback(startRow, startIndex, startRow + len - 1, endIndex))
                    return true;
            };
        }
        else if (backwards) {
            var forEachInLine = function(row, endIndex, callback) {
                if (mtSearch) {
                    var pos = mtBackward(session, re, endIndex, row, firstRow);
                    if (!pos)
                        return false;
                    if (callback(pos.startRow, pos.startCol, pos.endRow, pos.endCol))
                        return true;
                }
                else {
                    var line = session.getLine(row);
                    var matches = [];
                    var m, last = 0;
                    re.lastIndex = 0;
                    while((m = re.exec(line))) {
                        var length = m[0].length;
                        last = m.index;
                        if (!length) {
                            if (last >= line.length) break;
                            re.lastIndex = last += lang.skipEmptyMatch(line, last, supportsUnicodeFlag);
                        }
                        if (m.index + length > endIndex)
                            break;
                        matches.push(m.index, length);
                    }
                    for (var i = matches.length - 1; i >= 0; i -= 2) {
                        var column = matches[i - 1];
                        var length = matches[i];
                        if (callback(row, column, row, column + length))
                            return true;
                    }
                }
            };
        }
        else {
            var forEachInLine = function(row, startIndex, callback) {
                re.lastIndex = startIndex;
                if (mtSearch) {
                    var pos = mtForward(session, re, row, lastRow);
                    if (pos) {
                        var end_row = pos.endRow <= lastRow ? pos.endRow - 1 : lastRow;
                        if (end_row > row)
                            row = end_row;
                    }
                    if (!pos)
                        return false;
                    if (callback(pos.startRow, pos.startCol, pos.endRow, pos.endCol))
                        return true;
                }
                else {
                    var line = session.getLine(row);
                    var last;
                    var m;
                    while((m = re.exec(line))) {
                        var length = m[0].length;
                        last = m.index;
                        if (callback(row, last, row, last + length))
                            return true;
                        if (!length) {
                            re.lastIndex = last += lang.skipEmptyMatch(line, last, supportsUnicodeFlag);
                            if (last >= line.length) return false;
                        }
                    }
                }
            };
        }
        return {forEach: forEach};
    }

}

/**
 *
 * @param {string} needle
 * @param {Partial<SearchOptions>} options
 * @return {string}
 */
function addWordBoundary(needle, options) {
    let supportsLookbehind = lang.supportsLookbehind();

    function wordBoundary(c, firstChar = true) {
        let wordRegExp = supportsLookbehind && options.$supportsUnicodeFlag ? new RegExp("[\\p{L}\\p{N}_]","u") : new RegExp("\\w");

        if (wordRegExp.test(c) || options.regExp) {
            if (supportsLookbehind && options.$supportsUnicodeFlag) {
                if (firstChar) return "(?<=^|[^\\p{L}\\p{N}_])";
                return "(?=[^\\p{L}\\p{N}_]|$)";
            }
            return "\\b";
        }
        return "";
    }

    let needleArray = Array.from(needle);
    let firstChar = needleArray[0];
    let lastChar = needleArray[needleArray.length - 1];

    return wordBoundary(firstChar) + needle + wordBoundary(lastChar, false);
}

function multiLineBackwardMatch(line, re, endMargin) {
    var match = null;
    var from = 0;
    while (from <= line.length) {
        re.lastIndex = from;
        var newMatch = re.exec(line);
        if (!newMatch)
            break;
        var end = newMatch.index + newMatch[0].length;
        if (end > line.length - endMargin)
            break;
        if (!match || end > match.index + match[0].length)
            match = newMatch;
        from = newMatch.index + 1;
    }
    return match;
}

function chunkEnd(session, start) {
    var base = 5000,
        startPosition = { row: start, column: 0 },
        startIndex = session.doc.positionToIndex(startPosition),
        targetIndex = startIndex + base,
        targetPosition = session.doc.indexToPosition(targetIndex),
        targetLine = targetPosition.row;
    return targetLine + 1;
}

exports.v = Search;


/***/ }),

/***/ 99481:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var event = __webpack_require__(19631);

/**
 * Batches changes (that force something to be redrawn) in the background.
 **/
class RenderLoop {
    
    constructor(onRender, win) {
        this.onRender = onRender;
        this.pending = false;
        this.changes = 0;
        this.$recursionLimit = 2;
        this.window = win || window;
        var _self = this;
        this._flush = function (ts) {
            _self.pending = false;
            var changes = _self.changes;

            if (changes) {
                event.blockIdle(100);
                _self.changes = 0;
                _self.onRender(changes);
            }

            if (_self.changes) {
                if (_self.$recursionLimit-- < 0) return;
                _self.schedule();
            }
            else {
                _self.$recursionLimit = 2;
            }
        };
    }

    schedule(change) {
        this.changes = this.changes | change;
        if (this.changes && !this.pending) {
            event.nextFrame(this._flush);
            this.pending = true;
        }
    }

    clear(change) {
        var changes = this.changes;
        this.changes = 0;
        return changes;
    }
    
}

exports.x = RenderLoop;


/***/ }),

/***/ 99847:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var dom = __webpack_require__(71435);

class FoldHandler {
    constructor(editor) {

        editor.on("click", function(e) {
            var position = e.getDocumentPosition();
            var session = editor.session;

            // If the user clicked on a fold, then expand it.
            var fold = session.getFoldAt(position.row, position.column, 1);
            if (fold) {
                if (e.getAccelKey())
                    session.removeFold(fold);
                else
                    session.expandFold(fold);

                e.stop();
            }

            var target = e.domEvent && e.domEvent.target;
            if (target && dom.hasCssClass(target, "ace_inline_button")) {
                if (dom.hasCssClass(target, "ace_toggle_wrap")) {
                    session.setOption("wrap", !session.getUseWrapMode());
                    editor.renderer.scrollCursorIntoView();
                }
            }
        });

        editor.on("gutterclick", function(e) {
            var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

            if (gutterRegion == "foldWidgets") {
                var row = e.getDocumentPosition().row;
                var session = editor.session;
                if (session.foldWidgets && session.foldWidgets[row])
                    editor.session.onFoldWidgetClick(row, e);
                if (!editor.isFocused())
                    editor.focus();
                e.stop();
            }
        });

        editor.on("gutterdblclick", function(e) {
            var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

            if (gutterRegion == "foldWidgets") {
                var row = e.getDocumentPosition().row;
                var session = editor.session;
                var data = session.getParentFoldRangeData(row, true);
                var range = data.range || data.firstRange;

                if (range) {
                    row = range.start.row;
                    var fold = session.getFoldAt(row, session.getLine(row).length, 1);

                    if (fold) {
                        session.removeFold(fold);
                    } else {
                        session.addFold("...", range);
                        editor.renderer.scrollCursorIntoView({row: range.start.row, column: 0});
                    }
                }
                e.stop();
            }
        });
    }
}

exports.e = FoldHandler;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "bundle." + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "ace-playground:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			8269: 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkace_playground"] = self["webpackChunkace_playground"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ky: () => (/* binding */ createButtons),
  CL: () => (/* binding */ getTabData),
  dv: () => (/* binding */ initTabs),
  Kc: () => (/* binding */ runSample)
});

// EXTERNAL MODULE: ./node_modules/ace-layout/build/bundle.index.js
var bundle_index = __webpack_require__(95862);
;// ./src/samples.ts
const SAMPLES = {
    "Creating-ACE-Editor": [
        'Hello-World',
        'Autocompletion',
        'Shadow-DOM',
        'Basic-options',
        'Hard-wrapping'
    ],
    "Interacting-with-editor": [
        'Autoresize',
        'Keyboard-shortcuts',
        'Adding-new-command',
        'Scrollable-page',
        'Settings-menu',
        'Static-Code-Highlighter',
        'StatusBar',
        'ToolBar',
        'Transform',
        'Reveal-range',
        'Providing-custom-annotations',
        'Listening-to-events',
        'Scrollbars',
        'Creating-own-validation',
        'Customizing-line-numbers'
    ],
    "Customising-the-appearance": [
        'Creating-new-theme'
    ],
    "Extensions": [
        'Code-Lens',
        'Custom-completions'
    ],
    "Language-features": [
        'Validation-against-JSON-schema',
        'Typescript-language-service'
    ],
    "Diff-extension": [
        'Inline-diff-example',
        'Side-by-side-diff-example'
    ]
};

;// ./src/utils.ts
function request(url) {
    let req;
    return new Promise(function(callback, error) {
        req = new XMLHttpRequest();
        req.onreadystatechange = function() {
            if (req.readyState === 4) {
                if (req.status >= 200 && req.status < 300 || req.status === 1223) {
                    callback(req);
                } else {
                    error(req);
                }
                req.onreadystatechange = function() {};
            }
        };
        req.open('GET', url);
        req.responseType = '';
        req.send(null);
    });
}
function pathToTitle(path) {
    return path.replaceAll("-", " ");
}

;// ./src/layouts/two-columns-bottom.json
const two_columns_bottom_namespaceObject = /*#__PURE__*/JSON.parse('{"0":{"0":{"type":"pane","tabBar":{"tabList":[{"title":"JavaScript","active":true,"path":"sample.js"}],"scrollLeft":0}},"1":{"0":{"type":"pane","tabBar":{"tabList":[{"title":"CSS","active":true,"path":"sample.css"}],"scrollLeft":0}},"1":{"type":"pane","tabBar":{"tabList":[{"title":"HTML","active":true,"path":"sample.html"}],"scrollLeft":0}},"ratio":0.5,"type":"hbox","fixedSize":null,"hidden":false},"ratio":0.5,"type":"vbox","fixedSize":null,"hidden":false},"ratio":0.5,"type":"hbox","fixedSize":null,"hidden":false}');
var layouts_two_columns_bottom_namespaceObject = /*#__PURE__*/__webpack_require__.t(two_columns_bottom_namespaceObject, 2);
;// ./src/layouts/three-rows.json
const three_rows_namespaceObject = /*#__PURE__*/JSON.parse('{"0":{"0":{"0":{"type":"pane","tabBar":{"tabList":[{"title":"JavaScript","active":true,"path":"sample.js"}],"scrollLeft":0}},"1":{"type":"pane","tabBar":{"tabList":[{"title":"HTML","active":true,"path":"sample.html"}],"scrollLeft":0}},"ratio":0.5854125901267062,"type":"vbox","fixedSize":null,"hidden":false},"1":{"type":"pane","tabBar":{"tabList":[{"title":"CSS","active":true,"path":"sample.css"}],"scrollLeft":0}},"ratio":0.7420322161481484,"type":"vbox","fixedSize":null,"hidden":false},"ratio":0.5,"type":"hbox","fixedSize":null,"hidden":false}');
var layouts_three_rows_namespaceObject = /*#__PURE__*/__webpack_require__.t(three_rows_namespaceObject, 2);
;// ./src/layouts/single.json
const single_namespaceObject = /*#__PURE__*/JSON.parse('{"0":{"type":"pane","tabBar":{"tabList":[{"title":"CSS","path":"sample.css"},{"title":"HTML","path":"sample.html"},{"title":"JavaScript","active":true,"path":"sample.js"}],"scrollLeft":0}},"ratio":0.5,"type":"hbox","fixedSize":null,"hidden":false}');
var layouts_single_namespaceObject = /*#__PURE__*/__webpack_require__.t(single_namespaceObject, 2);
;// ./src/layouts/three-columns.json
const three_columns_namespaceObject = /*#__PURE__*/JSON.parse('{"0":{"0":{"type":"pane","tabBar":{"tabList":[{"title":"JavaScript","active":true,"path":"sample.js"}],"scrollLeft":0}},"1":{"0":{"type":"pane","tabBar":{"tabList":[{"title":"CSS","active":true,"path":"sample.css"}],"scrollLeft":0}},"1":{"type":"pane","tabBar":{"tabList":[{"title":"HTML","active":true,"path":"sample.html"}],"scrollLeft":0}},"ratio":0.5,"type":"hbox","fixedSize":null,"hidden":false},"ratio":0.33,"type":"hbox","fixedSize":null,"hidden":false},"ratio":0.33,"type":"hbox","fixedSize":null,"hidden":false}');
var layouts_three_columns_namespaceObject = /*#__PURE__*/__webpack_require__.t(three_columns_namespaceObject, 2);
;// ./src/layouts/layouts.ts




const Layouts = {
    "Single": layouts_single_namespaceObject,
    "Two columns bottom": layouts_two_columns_bottom_namespaceObject,
    "Three rows": layouts_three_rows_namespaceObject,
    "Three columns": layouts_three_columns_namespaceObject
};

;// ./src/menu.ts





function addMenu(callback) {
    let menuManager = bundle_index.MenuManager.getInstance();
    let position = 0;
    let root = "Samples";
    menuManager.addByPath(root, {
        position: position
    });
    Object.keys(SAMPLES).forEach(function(i) {
        let items = SAMPLES[i];
        for (let name of items){
            position++;
            let path = [
                root,
                name
            ].join('/');
            menuManager.addByPath(pathToTitle(path), {
                position: position,
                exec: ()=>callback(path.toLowerCase())
            });
        }
        position++;
        menuManager.addByPath(root + '/~' + position, {
            position: position
        });
    });
    root = "View";
    menuManager.addByPath(root, {
        position: 50
    });
    let toggle = ()=>bundle_index.TabManager.getInstance().containers["console"].toggleShowHide();
    menuManager.addByPath(root + "/Toggle Console", {
        position: 0,
        exec: toggle,
        hotKey: "F6"
    });
    bundle_index.CommandManager.registerCommands([
        {
            bindKey: {
                win: "F6",
                mac: "F6"
            },
            exec: toggle
        }
    ]);
    root = "View/Layout";
    menuManager.addByPath(root, {
        position: 100
    });
    position = 0;
    Object.keys(Layouts).forEach(function(i) {
        let changeLayout = ()=>{
            let storage = getTabData();
            let tabManager = bundle_index.TabManager.getInstance();
            tabManager.setState({
                "main": Layouts[i]
            });
            initTabs();
            tabManager.restoreFrom(storage);
            createButtons();
            runSample();
        };
        menuManager.addByPath(root + '/' + i, {
            position: position,
            exec: changeLayout
        });
        position++;
    });
}

;// ./src/template.ts
function generateTemplate(js, html, css) {
    if (useCustomUserCode(html)) {
        html += `<script>${js}</script>`;
        html += `<style>${css}</style>`;
        return html;
    }
    return `<html>
<head>
  <style>
      html, body {
          margin: 0;
          padding: 0;
          border: 0;
          font-size: 100%;
          font: inherit;
          vertical-align: baseline;
          height: 100%
      }
      ${css}
  </style>
</head>
<body>
<script>
  function wrapConsole(level) {
    console[level] = (...args) => {
      parent.postMessage({log: level, elements: args});
    };
  }
  wrapConsole("log");
  wrapConsole("warn");
  wrapConsole("error");
  
  window.addEventListener("error", e => console.error(e.error || e.message));

</script>
${html}
<script>${js}</script>
</body>
</html>`;
}
function useCustomUserCode(html) {
    return /^\s*(?:<html|<doctype)/i.test(html);
}

// EXTERNAL MODULE: ./node_modules/ace-linters/build/ace-linters.js
var ace_linters = __webpack_require__(19564);
// EXTERNAL MODULE: ./node_modules/ace-code/src/lib/event.js
var lib_event = __webpack_require__(19631);
// EXTERNAL MODULE: ./node_modules/ace-code/src/keyboard/hash_handler.js
var hash_handler = __webpack_require__(93050);
// EXTERNAL MODULE: ./node_modules/ace-code/src/lib/keys.js
var keys = __webpack_require__(29451);
var keys_default = /*#__PURE__*/__webpack_require__.n(keys);
;// ./src/linters/linters.ts






let languageProvider;
async function requestDeclarations() {
    const declarationFiles = [
        'ace.d.ts',
        'ace-modes.d.ts',
        'ace-modules.d.ts',
        'ace-linters.d.ts',
        'ace-lib.d.ts',
        'ace-ext.d.ts',
        'ace-snippets.d.ts',
        'ace-theme.d.ts'
    ];
    try {
        const requests = declarationFiles.map((filename)=>request(filename).then((response)=>({
                    filename,
                    content: response.responseText
                })));
        const declarations = await Promise.all(requests);
        const extraLibs = declarations.reduce((libs, { filename, content })=>{
            let processedContent = content;
            if (filename === 'ace.d.ts') {
                processedContent = correctAceDeclaration(content);
            } else if (filename === 'ace-linters.d.ts') {
                processedContent = correctDeclaration(content);
            }
            libs[filename] = {
                content: processedContent,
                version: 1
            };
            return libs;
        }, {});
        languageProvider.setGlobalOptions("typescript", {
            extraLibs,
            compilerOptions: {
                allowJs: true,
                checkJs: true
            }
        }, true);
    } catch (error) {
        console.error('Failed to load declaration files:', error);
    }
}
function correctAceDeclaration(declaration) {
    return declaration + `

declare module ace {
  export * from "ace-builds";
}`;
}
function correctDeclaration(declaration) {
    return declaration.replaceAll(/^\s*import\s.*$/gm, "").replaceAll(/export\s+/g, "declare ");
}
function registerCommands() {
    let menuKb = new hash_handler.HashHandler([
        {
            bindKey: "Ctrl-Shift-B",
            name: "format",
            exec: function() {
                languageProvider.format();
            }
        }
    ]);
    lib_event.addCommandKeyListener(window, function(e, hashId, keyCode) {
        let keyString = keys_default().keyCodeToString(keyCode);
        let command = menuKb.findKeyCommand(hashId, keyString);
        if (command === null || command === void 0 ? void 0 : command.exec) {
            command.exec();
            e.preventDefault();
        }
    });
}
function registerLanguageProvider(box) {
    let worker = new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(6760), __webpack_require__.b));
    languageProvider = ace_linters.LanguageProvider.create(worker);
    requestDeclarations();
    registerCommands();
    box.on("editorAdded", (editor)=>{
        if (editor instanceof bundle_index.AceEditor) languageProvider.registerEditor(editor.editor);
    });
}

;// ./src/error_handler.ts

function ctorName(obj) {
    var _obj_constructor;
    let ctor = (_obj_constructor = obj.constructor) === null || _obj_constructor === void 0 ? void 0 : _obj_constructor.name;
    if (ctor) return ctor;
    let m = /\[object (\w+)\]/.exec(obj + "");
    return m ? m[1] : null;
}
function serialize(val) {
    let seen = new Set;
    function inner(val) {
        if (val instanceof Error) return {
            error: val.toString(),
            stack: val.stack
        };
        if (typeof val == "function") return {
            function: val.name || "?"
        };
        if (val == null || typeof val != "object") return val;
        if (seen.has(val)) return {
            cycle: true
        };
        seen.add(val);
        if (Array.isArray(val)) return {
            array: val.map(inner)
        };
        let result = {
            object: Object.create(null),
            ctor: ctorName(val)
        };
        for (let prop of Object.keys(val)){
            try {
                result.object[prop] = inner(val[prop]);
            } catch  {}
        }
        return result;
    }
    return inner(val);
}
function windowError(e) {
    var _errorData_type;
    let errorData = e.data;
    if (errorData === null || errorData === void 0 ? void 0 : (_errorData_type = errorData.type) === null || _errorData_type === void 0 ? void 0 : _errorData_type.startsWith("webpack")) return;
    let errorMessage = "";
    if (errorData.log) {
        let log = errorData.log;
        errorMessage = errorData.elements.filter((el)=>el != null).map((el)=>{
            let element = serialize(el);
            return log + ": " + ((element === null || element === void 0 ? void 0 : element.error) || element);
        }).join("\n");
    }
    displayError(errorMessage);
}
function displayError(errorMessage) {
    let tabManager = bundle_index.TabManager.getInstance();
    let terminal = tabManager.open({
        title: "Log",
        path: 'terminal',
        editorType: bundle_index.EditorType.ace
    }, "console");
    terminal.session.setValue(errorMessage);
    tabManager.loadFile(terminal);
}

;// ./src/playground.ts








let editorBox, exampleBox, consoleBox;
let currentPath;
let serializedTabData = "";
let previewTab;
document.body.innerHTML = "";
let base = new bundle_index.Box({
    toolBars: {
        top: new bundle_index.MenuToolbar()
    },
    vertical: false,
    0: new bundle_index.Box({
        0: editorBox = new bundle_index.Box({
            isMain: true
        }),
        1: new bundle_index.Box({
            vertical: true,
            0: exampleBox = new bundle_index.Box({
                isMain: true
            }),
            1: consoleBox = new bundle_index.Box({
                size: 100,
                isMain: true
            })
        })
    })
});
new bundle_index.AceLayout(base);
addMenu(setSample);
base.render();
document.body.appendChild(base.element);
registerLanguageProvider(editorBox);
function onResize() {
    base.setBox(0, 0, window.innerWidth, window.innerHeight);
}
let tabManager = bundle_index.TabManager.getInstance({
    containers: {
        main: editorBox,
        example: exampleBox,
        console: consoleBox
    }
});
let tabState = localStorage.playground_tabs ? JSON.parse(localStorage.playground_tabs) : {
    "main": layouts_two_columns_bottom_namespaceObject
};
tabManager.setState(tabState);
onResize();
let allSamples = Object.values(SAMPLES).reduce((prev, curr)=>prev.concat(curr.map((path)=>path.toLowerCase())), []);
let tabCSS, tabHTML, tabJs;
function getTab(title, path) {
    let tab = tabManager.open({
        title: title,
        path: path
    }, "main");
    onSessionValueChange(tab.session);
    return tab;
}
function initTabs() {
    tabCSS = getTab("CSS", "sample.css");
    tabHTML = getTab("HTML", "sample.html");
    tabJs = getTab("JavaScript", "sample.js");
}
let hashSample;
let sampleValues;
function loadHashSample() {
    hashSample = new URL(document.URL).hash.replace("#", "");
    let path = 'samples/' + (allSamples.includes(hashSample) ? hashSample : "hello-world");
    let value = new URL(document.URL).searchParams.get("value");
    if (value) {
        try {
            let data = window.atob(value).split("\\0");
            if (data.length == 3) sampleValues = data;
        } catch (e) {}
    } else {
        let state = new URL(document.URL).searchParams.get("state");
        if (state) {
            try {
                localStorage[path] = window.atob(state);
            } catch (e) {}
        }
    }
    setSample(path);
}
function createEditorButton(textContent, title, onclick) {
    let button = document.createElement("button");
    button.textContent = textContent;
    button.style.marginLeft = "auto";
    button.style.marginRight = "5px";
    button.setAttribute('title', title);
    button.onclick = onclick;
    editorBox.addButton(button);
}
function createRollbackButton() {
    createEditorButton("Rollback", 'Rollback to default sample', function() {
        localStorage[currentPath] = null;
        initTabs();
        loadSample(currentPath);
    });
}
function createRunButton() {
    createEditorButton("Run", "Ctrl+Enter", runSample);
}
function serializeTabsData() {
    return [
        tabJs,
        tabCSS,
        tabHTML
    ].map((tab)=>tab.session.getValue()).join("\\0");
}
function createCopyLinkButton() {
    createEditorButton("Copy link", "Copy link", function() {
        let url = new URL(document.URL);
        url.searchParams.set("value", window.btoa(serializeTabsData()));
        navigator.clipboard.writeText(url.toString()).then((r)=>{});
    });
}
function createCopyStateButton() {
    createEditorButton("Copy state", "Copy state", function() {
        saveSample();
        let url = new URL(document.URL);
        url.searchParams.set("state", window.btoa(localStorage[currentPath]));
        navigator.clipboard.writeText(url.toString()).then((r)=>{});
    });
}
function createCloseConsoleButton() {
    consoleBox.renderButtons([
        {
            class: "consoleCloseBtn",
            title: "F6",
            onclick: function() {
                consoleBox.hide();
            },
            content: "x"
        }
    ]);
}
function createButtons() {
    createRollbackButton();
    createCopyLinkButton();
    // createCopyStateButton();
    createRunButton();
    createCloseConsoleButton();
}
function runSample() {
    var _window;
    var _onmessage;
    (_onmessage = (_window = window).onmessage) !== null && _onmessage !== void 0 ? _onmessage : _window.onmessage = windowError;
    let html = generateTemplate(tabJs.session.getValue(), tabHTML.session.getValue(), tabCSS.session.getValue());
    previewTab = tabManager.open({
        title: "Result",
        editorType: bundle_index.EditorType.preview,
        path: "result"
    }, "example");
    displayError("");
    previewTab.editor.setSession(previewTab, html);
    serializedTabData = serializeTabsData();
    tabDataIsRun();
}
bundle_index.CommandManager.registerCommands([
    {
        bindKey: {
            win: "Ctrl-Enter",
            mac: "Command-Enter"
        },
        exec: runSample
    }
]);
createButtons();
function setSample(path) {
    saveSample();
    let hash = path.split("/").pop();
    if (hash != hashSample) {
        let url = new URL(document.URL);
        url.hash = hash;
        url.searchParams.delete("value");
        url.searchParams.delete("state");
        document.location.href = url.href;
    }
    initTabs();
    if (sampleValues) {
        setTabValues(sampleValues);
        sampleValues = undefined;
    } else if (localStorage[path]) {
        restoreSample(path);
    } else {
        loadSample(path);
    }
    currentPath = path;
}
function restoreSample(path) {
    let storage = JSON.parse(localStorage[path]);
    if (!storage) {
        loadSample(path);
        return;
    }
    if (storage["@file@sample.html"]) {
        var html = JSON.parse(storage["@file@sample.html"]);
        html.value = addMissingAceScript(html.value);
        storage["@file@sample.html"] = JSON.stringify(html);
    }
    tabManager.restoreFrom(storage);
    runSample();
}
function saveSample() {
    if (!currentPath) return;
    let storage = getTabData();
    localStorage[currentPath] = JSON.stringify(storage);
}
function getTabData() {
    let storage = {};
    function saveTabData(tab) {
        storage["@file@" + tab.path] = bundle_index.AceEditor.getSessionState(tab);
    }
    saveTabData(tabJs);
    saveTabData(tabCSS);
    saveTabData(tabHTML);
    return storage;
}
function setTabValues(samples) {
    tabJs.session.setValue(samples[0]);
    tabCSS.session.setValue(samples[1]);
    tabHTML.session.setValue(addMissingAceScript(samples[2]));
    runSample();
}
function loadSample(path) {
    let js = request(path + '/sample.js').then(function(response) {
        return `//${pathToTitle(path)}\n\n` + response.responseText;
    });
    let css = request(path + '/sample.css').then(function(response) {
        return response.responseText;
    });
    let html = request(path + '/sample.html').then(function(response) {
        return response.responseText;
    });
    Promise.all([
        js,
        css,
        html
    ]).then(function(samples) {
        setTabValues(samples);
    }, function(err) {
        displayError("");
    });
}
/**
 * Add ace script to html if it is not present, and replace cdnjs url to unpkg. Returns non-changed html if it
 * contains custom user code with html or doctype.
 *
 * @param html
 */ function addMissingAceScript(html) {
    if (useCustomUserCode(html)) {
        return html;
    }
    if (!/script\s+src=["'](.+ace\.js)['"]/.test(html)) {
        html = '<script src="https://www.unpkg.com/ace-builds@latest/src-noconflict/ace.js" crossorigin="anonymous"></script>\n' + html;
    }
    html = html.replaceAll(/cdnjs\.cloudflare\.com\/ajax\/libs\/ace\/[\d.]+\/([\w-]+)(?:\.min)?/g, "www.unpkg.com/ace-builds@latest/src-noconflict/$1");
    return html;
}
function tabDataIsChanged() {
    previewTab.setTitle("Result*");
    previewTab.element.style.fontStyle = "italic";
}
function tabDataIsRun() {
    previewTab.setTitle("Result");
    previewTab.element.style.fontStyle = "";
}
function onSessionValueChange(session) {
    session.on("change", ()=>{
        if (!previewTab) return;
        let newTabData = serializeTabsData();
        if (newTabData != serializedTabData) {
            tabDataIsChanged();
        } else {
            tabDataIsRun();
        }
    });
}
window.onpopstate = loadHashSample;
window.onload = loadHashSample;
window.onresize = onResize;
window.onbeforeunload = function() {
    localStorage.playground_tabs = JSON.stringify(tabManager.toJSON());
    saveSample();
};

})();

/******/ })()
;
//# sourceMappingURL=bundle.simple.js.map