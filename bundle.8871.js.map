{"version":3,"file":"bundle.8871.js","mappings":";;;;;;AAAa;;AAEb,UAAU,mBAAO,CAAC,IAAY;AAC9B,+BAA+B,8DAAiE;AAChG,yBAAyB,wDAAoD;;AAE7E;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,qBAAqB,sFAAsF;AAC3G,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,qBAAqB,qDAAqD,EAAE;AAC5E,qBAAqB,sFAAsF;AAC3G,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,wCAAwC;AACxC,aAAa;AACb;AACA,6BAA6B;AAC7B,aAAa;AACb;AACA,+BAA+B;AAC/B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,SAA4B;;;;;;;;AC/Ff;;AAEb,UAAU,mBAAO,CAAC,IAAY;AAC9B,yBAAyB,wDAAoD;;AAE7E;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAAgC;;;;;;;;AC7CnB;;AAEb,UAAU,mBAAO,CAAC,IAAY;AAC9B,eAAe,iCAAsB;AACrC,0BAA0B,yDAAsD;AAChF,uBAAuB,sDAA+C;AACtE,sBAAsB,4CAA6C;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED,YAAY;;;;;;;;AC/BC;;AAEb,oBAAoB,mDAA0C;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA,CAAC;;AAED,SAAwB;;;;;;;;;AC9EX;;AAEb,UAAU,mBAAO,CAAC,IAAY;AAC9B,WAAW,mBAAO,CAAC,KAAa;AAChC,+BAA+B,8DAAiE;AAChG,yBAAyB,+CAAoD;AAC7E,2BAA2B,0DAAwD;;AAEnF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;;AAEL;AACA,UAAU,KAAK;AACf;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;AAEA,oBAAoB;;AAEpB;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB;AACA,oBAAoB,IAAI;AACxB;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,SAA2B;AAC3B,yBAA+B","sources":["webpack://ace-playground/./node_modules/ace-code/src/mode/csharp_highlight_rules.js","webpack://ace-playground/./node_modules/ace-code/src/mode/doc_comment_highlight_rules.js","webpack://ace-playground/./node_modules/ace-code/src/mode/razor.js","webpack://ace-playground/./node_modules/ace-code/src/mode/razor_completions.js","webpack://ace-playground/./node_modules/ace-code/src/mode/razor_highlight_rules.js"],"sourcesContent":["\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar DocCommentHighlightRules = require(\"./doc_comment_highlight_rules\").DocCommentHighlightRules;\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\nvar CSharpHighlightRules = function() {\n    var keywordMapper = this.createKeywordMapper({\n        \"variable.language\": \"this\",\n        \"keyword\": \"abstract|async|await|event|new|struct|as|explicit|null|switch|base|extern|object|this|bool|false|operator|throw|break|finally|out|true|byte|fixed|override|try|case|float|params|typeof|catch|for|private|uint|char|foreach|protected|ulong|checked|goto|public|unchecked|class|if|readonly|unsafe|const|implicit|ref|ushort|continue|in|return|using|decimal|int|sbyte|virtual|default|interface|sealed|volatile|delegate|internal|partial|short|void|do|is|sizeof|while|double|lock|stackalloc|else|long|static|enum|namespace|string|var|dynamic\",\n        \"constant.language\": \"null|true|false\"\n    }, \"identifier\");\n\n    // regexp must not have capturing parentheses. Use (?:) instead.\n    // regexps are ordered -> the first match is used\n\n    this.$rules = {\n        \"start\" : [\n            {\n                token : \"comment\",\n                regex : \"\\\\/\\\\/.*$\"\n            },\n            DocCommentHighlightRules.getStartRule(\"doc-start\"),\n            {\n                token : \"comment\", // multi line comment\n                regex : \"\\\\/\\\\*\",\n                next : \"comment\"\n            }, {\n                token : \"string\", // character\n                regex : /'(?:.|\\\\(:?u[\\da-fA-F]+|x[\\da-fA-F]+|[tbrf'\"n]))?'/\n            }, {\n                token : \"string\", start : '\"', end : '\"|$', next: [\n                    {token: \"constant.language.escape\", regex: /\\\\(:?u[\\da-fA-F]+|x[\\da-fA-F]+|[tbrf'\"n])/},\n                    {token: \"invalid\", regex: /\\\\./}\n                ]\n            }, {\n                token : \"string\", start : '@\"', end : '\"', next:[\n                    {token: \"constant.language.escape\", regex: '\"\"'}\n                ]\n            }, {\n                token : \"string\", start : /\\$\"/, end : '\"|$', next: [\n                    {token: \"constant.language.escape\", regex: /\\\\(:?$)|{{/},\n                    {token: \"constant.language.escape\", regex: /\\\\(:?u[\\da-fA-F]+|x[\\da-fA-F]+|[tbrf'\"n])/},\n                    {token: \"invalid\", regex: /\\\\./}\n                ]\n            }, {\n                token : \"constant.numeric\", // hex\n                regex : \"0[xX][0-9a-fA-F]+\\\\b\"\n            }, {\n                token : \"constant.numeric\", // float\n                regex : \"[+-]?\\\\d+(?:(?:\\\\.\\\\d*)?(?:[eE][+-]?\\\\d+)?)?\\\\b\"\n            }, {\n                token : \"constant.language.boolean\",\n                regex : \"(?:true|false)\\\\b\"\n            }, {\n                token : keywordMapper,\n                regex : \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"\n            }, {\n                token : \"keyword.operator\",\n                regex : \"!|\\\\$|%|&|\\\\*|\\\\-\\\\-|\\\\-|\\\\+\\\\+|\\\\+|~|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|&&|\\\\|\\\\||\\\\?\\\\:|\\\\*=|%=|\\\\+=|\\\\-=|&=|\\\\^=|\\\\b(?:in|instanceof|new|delete|typeof|void)\"\n            }, {\n                token : \"keyword\",\n                regex : \"^\\\\s*#(if|else|elif|endif|define|undef|warning|error|line|region|endregion|pragma)\"\n            }, {\n                token : \"punctuation.operator\",\n                regex : \"\\\\?|\\\\:|\\\\,|\\\\;|\\\\.\"\n            }, {\n                token : \"paren.lparen\",\n                regex : \"[[({]\"\n            }, {\n                token : \"paren.rparen\",\n                regex : \"[\\\\])}]\"\n            }, {\n                token : \"text\",\n                regex : \"\\\\s+\"\n            }\n        ],\n        \"comment\" : [\n            {\n                token : \"comment\", // closing comment\n                regex : \"\\\\*\\\\/\",\n                next : \"start\"\n            }, {\n                defaultToken : \"comment\"\n            }\n        ]\n    };\n\n    this.embedRules(DocCommentHighlightRules, \"doc-\",\n        [ DocCommentHighlightRules.getEndRule(\"start\") ]);\n    this.normalizeRules();\n};\n\noop.inherits(CSharpHighlightRules, TextHighlightRules);\n\nexports.CSharpHighlightRules = CSharpHighlightRules;\n","\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\nvar DocCommentHighlightRules = function () {\n    this.$rules = {\n        \"start\": [\n            {\n                token: \"comment.doc.tag\",\n                regex: \"@\\\\w+(?=\\\\s|$)\"\n            }, DocCommentHighlightRules.getTagRule(), {\n                defaultToken: \"comment.doc\",\n                caseInsensitive: true\n            }\n        ]\n    };\n};\n\noop.inherits(DocCommentHighlightRules, TextHighlightRules);\n\nDocCommentHighlightRules.getTagRule = function(start) {\n    return {\n        token : \"comment.doc.tag.storage.type\",\n        regex : \"\\\\b(?:TODO|FIXME|XXX|HACK)\\\\b\"\n    };\n};\n\nDocCommentHighlightRules.getStartRule = function(start) {\n    return {\n        token : \"comment.doc\", // doc comment\n        regex : \"\\\\/\\\\*(?=\\\\*)\",\n        next  : start\n    };\n};\n\nDocCommentHighlightRules.getEndRule = function (start) {\n    return {\n        token : \"comment.doc\", // closing comment\n        regex : \"\\\\*\\\\/\",\n        next  : start\n    };\n};\n\n\nexports.DocCommentHighlightRules = DocCommentHighlightRules;\n","\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar HtmlMode = require(\"./html\").Mode;\nvar RazorHighlightRules = require(\"./razor_highlight_rules\").RazorHighlightRules;\nvar RazorCompletions = require(\"./razor_completions\").RazorCompletions;\nvar HtmlCompletions = require(\"./html_completions\").HtmlCompletions;\n\nvar Mode = function() {\n    HtmlMode.call(this);\n    this.$highlightRules = new RazorHighlightRules();\n    this.$completer = new RazorCompletions();\n    this.$htmlCompleter = new HtmlCompletions();\n};\noop.inherits(Mode, HtmlMode);\n\n(function() {\n    this.getCompletions = function(state, session, pos, prefix) {\n        var razorToken = this.$completer.getCompletions(state, session, pos, prefix);\n        var htmlToken = this.$htmlCompleter.getCompletions(state, session, pos, prefix);\n        return razorToken.concat(htmlToken);\n    };\n    \n    this.createWorker = function(session) {\n        return null;\n    };\n\n    this.$id = \"ace/mode/razor\";\n    this.snippetFileId = \"ace/snippets/razor\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n","\"use strict\";\n\nvar TokenIterator = require(\"../token_iterator\").TokenIterator;\n\nvar keywords = [\n    \"abstract\", \"as\", \"base\", \"bool\",\n    \"break\", \"byte\", \"case\", \"catch\",\n    \"char\", \"checked\", \"class\", \"const\",\n    \"continue\", \"decimal\", \"default\", \"delegate\",\n    \"do\", \"double\",\"else\",\"enum\",\n    \"event\", \"explicit\", \"extern\", \"false\",\n    \"finally\", \"fixed\", \"float\", \"for\",\n    \"foreach\", \"goto\", \"if\", \"implicit\",\n    \"in\", \"int\", \"interface\", \"internal\",\n    \"is\", \"lock\", \"long\", \"namespace\",\n    \"new\", \"null\", \"object\", \"operator\",\n    \"out\", \"override\", \"params\", \"private\",\n    \"protected\", \"public\", \"readonly\", \"ref\",\n    \"return\", \"sbyte\", \"sealed\", \"short\",\n    \"sizeof\", \"stackalloc\", \"static\", \"string\",\n    \"struct\", \"switch\", \"this\", \"throw\",\n    \"true\", \"try\", \"typeof\", \"uint\",\n    \"ulong\", \"unchecked\", \"unsafe\", \"ushort\",\n    \"using\", \"var\", \"virtual\", \"void\",\n    \"volatile\", \"while\"];\n\nvar shortHands  = [\n    \"Html\", \"Model\", \"Url\", \"Layout\"\n];\n    \nvar RazorCompletions = function() {\n\n};\n\n(function() {\n\n    this.getCompletions = function(state, session, pos, prefix) {\n        \n        if(state.lastIndexOf(\"razor-short-start\") == -1 && state.lastIndexOf(\"razor-block-start\") == -1)\n            return [];\n        \n        var token = session.getTokenAt(pos.row, pos.column);\n        if (!token)\n            return [];\n        \n        if(state.lastIndexOf(\"razor-short-start\") != -1) {\n            return this.getShortStartCompletions(state, session, pos, prefix);\n        }\n        \n        if(state.lastIndexOf(\"razor-block-start\") != -1) {\n            return this.getKeywordCompletions(state, session, pos, prefix);\n        }\n\n        \n    };\n    \n    this.getShortStartCompletions = function(state, session, pos, prefix) {\n        return shortHands.map(function(element){\n            return {\n                value: element,\n                meta: \"keyword\",\n                score: 1000000\n            };\n        });\n    };\n\n    this.getKeywordCompletions = function(state, session, pos, prefix) {\n        return shortHands.concat(keywords).map(function(element){\n            return {\n                value: element,\n                meta: \"keyword\",\n                score: 1000000\n            };\n        });\n    };\n\n}).call(RazorCompletions.prototype);\n\nexports.RazorCompletions = RazorCompletions;\n","\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar lang = require(\"../lib/lang\");\nvar DocCommentHighlightRules = require(\"./doc_comment_highlight_rules\").DocCommentHighlightRules;\nvar HtmlHighlightRules = require(\"./html_highlight_rules\").HtmlHighlightRules;\nvar CSharpHighlightRules = require(\"./csharp_highlight_rules\").CSharpHighlightRules;\n\nvar blockPrefix = 'razor-block-';\nvar RazorLangHighlightRules = function() {\n    CSharpHighlightRules.call(this);\n\n    var processPotentialCallback = function(value, stackItem) {\n        if (typeof stackItem === \"function\")\n            return stackItem(value);\n\n        return stackItem;\n    };\n\n    var inBraces = 'in-braces';\n    this.$rules.start.unshift({\n        regex: '[\\\\[({]',\n        onMatch: function(value, state, stack) {\n            var prefix = /razor-[^\\-]+-/.exec(state)[0];\n\n            stack.unshift(value);\n            stack.unshift(prefix + inBraces);\n            this.next = prefix + inBraces;\n            return 'paren.lparen';\n        }\n    }, {\n        start: \"@\\\\*\",\n        end: \"\\\\*@\",\n        token: \"comment\"\n    });\n\n    var parentCloseMap = {\n        '{': '}',\n        '[': ']',\n        '(': ')'\n    };\n\n    this.$rules[inBraces] = lang.deepCopy(this.$rules.start);\n    this.$rules[inBraces].unshift({\n        regex: '[\\\\])}]',\n        onMatch: function(value, state, stack) {\n            var open = stack[1];\n            if (parentCloseMap[open] !== value)\n                return 'invalid.illegal';\n\n            stack.shift(); // exit in-braces block\n            stack.shift(); // exit brace marker\n            this.next = processPotentialCallback(value, stack[0]) || 'start';\n            return 'paren.rparen';\n        }\n    });\n};\n\noop.inherits(RazorLangHighlightRules, CSharpHighlightRules);\n\nvar RazorHighlightRules = function() {\n    HtmlHighlightRules.call(this);\n\n    // 'Blocks': @{}, @(), @functions{}\n\n    var blockStartRule = {\n        regex: '@[({]|@functions{',\n        onMatch: function(value, state, stack) {\n            stack.unshift(value);\n            stack.unshift('razor-block-start');\n            this.next = 'razor-block-start';\n            return 'punctuation.block.razor';\n        }\n    };\n\n    var blockEndMap = {\n        '@{': '}',\n        '@(': ')',\n        '@functions{':'}'\n    };\n\n    var blockEndRule = {\n        regex: '[})]',\n        onMatch: function(value, state, stack) {\n            var blockStart = stack[1];\n            if (blockEndMap[blockStart] !== value)\n                return 'invalid.illegal';\n\n            stack.shift(); // exit razor block\n            stack.shift(); // remove block type marker\n            this.next = stack.shift() || 'start';\n            return 'punctuation.block.razor';\n        }\n    };\n\n    // Short: @Abc.Cde(Xyz).Ef\n\n    var shortStartRule = {\n        regex: \"@(?![{(])\",\n        onMatch: function(value, state, stack) {\n            stack.unshift(\"razor-short-start\");\n            this.next = \"razor-short-start\";\n            return 'punctuation.short.razor';\n        }\n    };\n\n    var shortEndRule = {\n        token: \"\",\n        regex: \"(?=[^A-Za-z_\\\\.()\\\\[\\\\]])\",\n        next: 'pop'\n    };\n\n    // Control flow: @if, etc\n\n    var ifStartRule = {\n        regex: \"@(?=if)\",\n        onMatch: function(value, state, stack) {\n            stack.unshift(function(value) {\n                if (value !== '}')\n                    return 'start';\n\n                return stack.shift() || 'start';\n            });\n            this.next = 'razor-block-start';\n            return 'punctuation.control.razor';\n        }\n    };\n\n    // Combined:\n\n    var razorStartRules = [\n        {\n            start: \"@\\\\*\",\n            end: \"\\\\*@\",\n            token: \"comment\"\n        },\n        {\n            token: [\"meta.directive.razor\", \"text\", \"identifier\"],\n            regex: \"^(\\\\s*@model)(\\\\s+)(.+)$\"\n        },\n        blockStartRule,\n        //ifStartRule,\n        shortStartRule\n    ];\n\n    for (var key in this.$rules)\n        this.$rules[key].unshift.apply(this.$rules[key], razorStartRules);\n\n    this.embedRules(RazorLangHighlightRules, \"razor-block-\", [blockEndRule], [\"start\"]);\n    this.embedRules(RazorLangHighlightRules, \"razor-short-\", [shortEndRule], [\"start\"]);\n\n    this.normalizeRules();\n};\n\noop.inherits(RazorHighlightRules, HtmlHighlightRules);\n\nexports.RazorHighlightRules = RazorHighlightRules;\nexports.RazorLangHighlightRules = RazorLangHighlightRules;\n"],"names":[],"sourceRoot":""}