{"version":3,"file":"bundle.2545.js","mappings":";;;;;;AAAa;;AAEb,UAAU,mBAAO,CAAC,IAAe;AACjC,mBAAmB,qCAA+B;AAClD,YAAY,2CAA4B;;AAExC,eAAe,SAAgB;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;;;;;;AC3FD;AACA;AACA;;AAEa;;AAEb,UAAU,mBAAO,CAAC,IAAY;AAC9B,eAAe,iCAAsB;AACrC,yBAAyB,sDAAoD;AAC7E,eAAe,8CAAoC;;AAEnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,YAAY;;;;;;;;ACzBC;;AAEb,UAAU,mBAAO,CAAC,IAAY;AAC9B,yBAAyB,+CAAoD;AAC7E,kBAAkB,mBAAO,CAAC,KAAwB;AAClD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,0BAA0B;AAC1B;AACA,aAAa;AACb;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,kCAAkC;AAClC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,SAA0B","sources":["webpack://ace-playground/./node_modules/ace-code/src/mode/folding/coffee.js","webpack://ace-playground/./node_modules/ace-code/src/mode/haml.js","webpack://ace-playground/./node_modules/ace-code/src/mode/haml_highlight_rules.js"],"sourcesContent":["\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\n\nvar FoldMode = exports.FoldMode = function() {};\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n    this.commentBlock = function(session, row) {\n        var re = /\\S/;\n        var line = session.getLine(row);\n        var startLevel = line.search(re);\n        if (startLevel == -1 || line[startLevel] != \"#\")\n            return;\n\n        var startColumn = line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var level = line.search(re);\n\n            if (level == -1)\n                continue;\n\n            if (line[level] != \"#\")\n                break;\n\n            endRow = row;\n        }\n\n        if (endRow > startRow) {\n            var endColumn = session.getLine(endRow).length;\n            return new Range(startRow, startColumn, endRow, endColumn);\n        }\n    };\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var range = this.indentationBlock(session, row);\n        if (range)\n            return range;\n\n        range = this.commentBlock(session, row);\n        if (range)\n            return range;\n    };\n\n    // must return \"\" if there's no fold, to enable caching\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        var indent = line.search(/\\S/);\n        var next = session.getLine(row + 1);\n        var prev = session.getLine(row - 1);\n        var prevIndent = prev.search(/\\S/);\n        var nextIndent = next.search(/\\S/);\n\n        if (indent == -1) {\n            session.foldWidgets[row - 1] = prevIndent!= -1 && prevIndent < nextIndent ? \"start\" : \"\";\n            return \"\";\n        }\n\n        // documentation comments\n        if (prevIndent == -1) {\n            if (indent == nextIndent && line[indent] == \"#\" && next[indent] == \"#\") {\n                session.foldWidgets[row - 1] = \"\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"start\";\n            }\n        } else if (prevIndent == indent && line[indent] == \"#\" && prev[indent] == \"#\") {\n            if (session.getLine(row - 2).search(/\\S/) == -1) {\n                session.foldWidgets[row - 1] = \"start\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"\";\n            }\n        }\n\n        if (prevIndent!= -1 && prevIndent < indent)\n            session.foldWidgets[row - 1] = \"start\";\n        else\n            session.foldWidgets[row - 1] = \"\";\n\n        if (indent < nextIndent)\n            return \"start\";\n        else\n            return \"\";\n    };\n\n}).call(FoldMode.prototype);\n","/*\n  THIS FILE WAS AUTOGENERATED BY mode.tmpl.js\n*/\n\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar HamlHighlightRules = require(\"./haml_highlight_rules\").HamlHighlightRules;\nvar FoldMode = require(\"./folding/coffee\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = HamlHighlightRules;\n    this.foldingRules = new FoldMode();\n    this.$behaviour = this.$defaultBehaviour;\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n    this.lineCommentStart = \"//\";\n    \n    this.$id = \"ace/mode/haml\";\n    this.snippetFileId = \"ace/snippets/haml\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n","\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar HtmlHighlightRules = require(\"./html_highlight_rules\").HtmlHighlightRules;\nvar RubyExports = require(\"./ruby_highlight_rules\");\nvar RubyHighlightRules = RubyExports.RubyHighlightRules;\n\nvar HamlHighlightRules = function() {\n\n    // regexp must not have capturing parentheses. Use (?:) instead.\n    // regexps are ordered -> the first match is used\n    HtmlHighlightRules.call(this);\n\n    this.$rules = {\n        \"start\": [\n            {\n                token: \"comment.block\", // multiline HTML comment\n                regex: /^\\/$/,\n                next: \"comment\"\n            },\n            {\n                token: \"comment.block\", // multiline HAML comment\n                regex: /^\\-#$/,\n                next: \"comment\"\n            },\n            {\n                token: \"comment.line\", // HTML comment\n                regex: /\\/\\s*.*/\n            },\n            {\n                token: \"comment.line\", // HAML comment\n                regex: /-#\\s*.*/\n            },\n            {\n                token: \"keyword.other.doctype\",\n                regex: \"^!!!\\\\s*(?:[a-zA-Z0-9-_]+)?\"\n            },\n            RubyExports.qString,\n            RubyExports.qqString,\n            RubyExports.tString,\n            {\n                token: \"meta.tag.haml\",\n                regex: /(%[\\w:\\-]+)/\n            },\n            {\n                token: \"keyword.attribute-name.class.haml\",\n                regex: /\\.[\\w-]+/\n            },\n            {\n                token: \"keyword.attribute-name.id.haml\",\n                regex: /#[\\w-]+/,\n                next: \"element_class\"\n            },\n            RubyExports.constantNumericHex,\n            RubyExports.constantNumericFloat,\n            RubyExports.constantOtherSymbol,\n            {\n                token: \"text\",\n                regex: /=|-|~/,\n                next: \"embedded_ruby\"\n            }\n        ],\n        \"element_class\": [\n            {\n                token: \"keyword.attribute-name.class.haml\",\n                regex: /\\.[\\w-]+/\n            },\n            {\n                token: \"punctuation.section\",\n                regex: /\\{/,\n                next: \"element_attributes\"\n            },\n            RubyExports.constantOtherSymbol,\n            {\n                token: \"empty\",\n                regex: \"$|(?!\\\\.|#|\\\\{|\\\\[|=|-|~|\\\\/])\",\n                next: \"start\"\n            }\n        ],\n        \"element_attributes\": [\n            RubyExports.constantOtherSymbol,\n            RubyExports.qString,\n            RubyExports.qqString,\n            RubyExports.tString,\n            RubyExports.constantNumericHex,\n            RubyExports.constantNumericFloat,\n            {\n                token: \"punctuation.section\",\n                regex: /$|\\}/,\n                next: \"start\"\n            }\n        ],\n        \"embedded_ruby\": [\n            RubyExports.constantNumericHex,\n            RubyExports.constantNumericFloat,\n            RubyExports.instanceVariable,\n            RubyExports.qString,\n            RubyExports.qqString,\n            RubyExports.tString,\n            {\n                token : \"support.class\", // class name\n                regex : \"[A-Z][a-zA-Z_\\\\d]+\"\n            },\n            {\n                token : new RubyHighlightRules().getKeywords(),\n                regex : \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"\n            },\n            {\n                token : [\"keyword\", \"text\", \"text\"],\n                regex : \"(?:do|\\\\{)(?: \\\\|[^|]+\\\\|)?$\",\n                next  : \"start\"\n            },\n            {\n                token : [\"text\"],\n                regex : \"^$\",\n                next  : \"start\"\n            },\n            {\n                token : [\"text\"],\n                regex : \"^(?!.*\\\\|\\\\s*$)\",\n                next  : \"start\"\n            }\n        ],\n        \"comment\": [\n            {\n                token: \"comment.block\",\n                regex: /^$/,\n                next: \"start\"\n            },\n            {\n                token: \"comment.block\", // comment spanning the whole line\n                regex: /\\s+.*/\n            }\n        ]\n\n    };\n\n    this.normalizeRules();\n};\n\noop.inherits(HamlHighlightRules, HtmlHighlightRules);\n\nexports.HamlHighlightRules = HamlHighlightRules;\n"],"names":[],"sourceRoot":""}