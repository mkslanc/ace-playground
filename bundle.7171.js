"use strict";
(self["webpackChunkace_playground"] = self["webpackChunkace_playground"] || []).push([[7171],{

/***/ 94726:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
  THIS FILE WAS AUTOGENERATED BY mode_highlight_rules.tmpl.js (UUID: C5B73B98-5F2A-42E3-9F0E-028A74A9FE4B)
*/



var oop = __webpack_require__(2645);
var TextHighlightRules = (__webpack_require__(16387)/* .TextHighlightRules */ .r);
var MarkdownHighlightRules = (__webpack_require__(98137)/* .MarkdownHighlightRules */ .R);
var SassHighlightRules = (__webpack_require__(23124).ScssHighlightRules);
var LessHighlightRules = (__webpack_require__(41425).LessHighlightRules);
var CoffeeHighlightRules = (__webpack_require__(28068).CoffeeHighlightRules);
var JavaScriptHighlightRules = (__webpack_require__(15903).JavaScriptHighlightRules);

function mixin_embed(tag, prefix) {
    return { 
        token : "entity.name.function.jade",
        regex : "^\\s*\\:" + tag,
        next  : prefix + "start"
    };
}

var JadeHighlightRules = function() {

    var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|" + // hex
        "u[0-9a-fA-F]{4}|" + // unicode
        "[0-2][0-7]{0,2}|" + // oct
        "3[0-6][0-7]?|" + // oct
        "37[0-7]?|" + // oct
        "[4-7][0-7]?|" + //oct
        ".)";

    // regexp must not have capturing parentheses. Use (?:) instead.
    // regexps are ordered -> the first match is used

    this.$rules = 
        {
    "start": [
        {
            token: "keyword.control.import.include.jade",
            regex: "\\s*\\binclude\\b"
        },
        {
            token: "keyword.other.doctype.jade",
            regex: "^!!!\\s*(?:[a-zA-Z0-9-_]+)?"
        },
        {
            onMatch: function(value, currentState, stack) {
                stack.unshift(this.next, value.length - 2, currentState);
                return "comment";
            },
            regex: /^\s*\/\//,
            next: "comment_block"
        },
        mixin_embed("markdown", "markdown-"),
        mixin_embed("sass", "sass-"),
        mixin_embed("less", "less-"),
        mixin_embed("coffee", "coffee-"),
        /*
        {
            token: {
                "2": {
                    "name": "entity.name.function.jade"
                }
            },
            regex: "^(\\s*)(\\:cdata)",
            next: "state_9"
        },*/
        // match stuff like: mixin dialog-title-desc(title, desc)
        {
            token: [ "storage.type.function.jade",
                       "entity.name.function.jade",
                       "punctuation.definition.parameters.begin.jade",
                       "variable.parameter.function.jade",
                       "punctuation.definition.parameters.end.jade"
                    ],
            regex: "^(\\s*mixin)( [\\w\\-]+)(\\s*\\()(.*?)(\\))"
        },
        // match stuff like: mixin dialog-title-desc
        {
            token: [ "storage.type.function.jade", "entity.name.function.jade"],
            regex: "^(\\s*mixin)( [\\w\\-]+)"
        },
        {
            token: "source.js.embedded.jade",
            regex: "^\\s*(?:-|=|!=)",
            next: "js-start"
        },
        /*{
            token: "entity.name.tag.script.jade",
            regex: "^\\s*script",
            next: "js_code_tag"
        },*/
        {
            token: "string.interpolated.jade",
            regex: "[#!]\\{[^\\}]+\\}"
        },
        // Match any tag, id or class. skip AST filters
        {
            token: "meta.tag.any.jade",
            regex: /^\s*(?!\w+:)(?:[\w-]+|(?=\.|#)])/,
            next: "tag_single"
        },
        {
            token: "suport.type.attribute.id.jade",
            regex: "#\\w+"
        },
        {
            token: "suport.type.attribute.class.jade",
            regex: "\\.\\w+"
        },
        {
            token: "punctuation",
            regex: "\\s*(?:\\()",
            next: "tag_attributes"
        }
    ],
    "comment_block": [
        {regex: /^\s*(?:\/\/)?/, onMatch: function(value, currentState, stack) {
            if (value.length <= stack[1]) {
                if (value.slice(-1) == "/") {
                    stack[1] = value.length - 2;
                    this.next = "";
                    return "comment";
                }
                stack.shift();
                stack.shift();
                this.next = stack.shift();
                return "text";
            } else {
                this.next = "";
                return "comment";
            }
        }, next: "start"},
        {defaultToken: "comment"}
    ],
    /*
    
    "state_9": [
        {
            token: "TODO",
            regex: "^(?!\\1\\s+)",
            next: "start"
        },
        {
            token: "TODO",
            regex: ".+",
            next: "state_9"
        }
    ],*/
    /*"js_code": [
        {
            token: "keyword.control.js",
            regex: "\\beach\\b"
        },
        {
            token: "text",
            regex: "$",
            next: "start"
        }
    ],*/
    /*"js_code_tag": [
        {
            "include": "source.js"
        },
        {
            token: "TODO",
            regex: "^((?=(\\1)([\\w#\\.]|$\\n?))|^$\\n?)",
            next: "start"
        }
    ],*/
    "tag_single": [
        {
            token: "entity.other.attribute-name.class.jade",
            regex: "\\.[\\w-]+"
        },
        {
            token: "entity.other.attribute-name.id.jade",
            regex: "#[\\w-]+"
        },
        {
            token: ["text", "punctuation"],
            regex: "($)|((?!\\.|#|=|-))",
            next: "start"
        }
    ],
    "tag_attributes": [ 
        {
            token : "string",
            regex : "'(?=.)",
            next  : "qstring"
        }, 
        {
            token : "string",
            regex : '"(?=.)',
            next  : "qqstring"
        },
        {
            token: ["entity.other.attribute-name.jade", "punctuation"],
            regex: "([a-zA-Z:\\.-]+)(=)?",
            next: "attribute_strings"
        },
        {
            token: "punctuation",
            regex: "\\)",
            next: "start"
        }
    ],
    "attribute_strings": [
        {
            token : "string",
            regex : "'(?=.)",
            next  : "qstring"
        }, 
        {
            token : "string",
            regex : '"(?=.)',
            next  : "qqstring"
        },
        {
            token : "string",
            regex : '(?=\\S)',
            next  : "tag_attributes"
        }
    ],
    "qqstring" : [
        {
            token : "constant.language.escape",
            regex : escapedRe
        }, {
            token : "string",
            regex : '[^"\\\\]+'
        }, {
            token : "string",
            regex : "\\\\$",
            next  : "qqstring"
        }, {
            token : "string",
            regex : '"|$',
            next  : "tag_attributes"
        }
    ],
    "qstring" : [
        {
            token : "constant.language.escape",
            regex : escapedRe
        }, {
            token : "string",
            regex : "[^'\\\\]+"
        }, {
            token : "string",
            regex : "\\\\$",
            next  : "qstring"
        }, {
            token : "string",
            regex : "'|$",
            next  : "tag_attributes"
        }
    ]
};

    this.embedRules(JavaScriptHighlightRules, "js-", [{
        token: "text",
        regex: ".$",
        next: "start"
    }]);
/*
    this.embedRules(MarkdownHighlightRules, "markdown-", [{
       token : "support.function",
       regex : "^\\1\\s+",
       captures: "1",
       next  : "start"
    }]);

    this.embedRules(SassHighlightRules, "sass-", [{
       token : "support.function",
       regex : "^(?!\\1\\s+)",
       captures: "1",
       next  : "start"
    }]);

    this.embedRules(LessHighlightRules, "less-", [{
       token : "support.function",
       regex : "^(?!\\1\\s+)",
       captures: "1",
       next  : "start"
    }]);

    this.embedRules(CoffeeHighlightRules, "coffee-", [{
       token : "support.function",
       regex : "^(?!\\1\\s+)",
       captures: "1",
       next  : "start"
    }]);

    this.embedRules(JavaScriptHighlightRules, "js-", [{
       token : "support.function",
       regex : "$",
       captures: "1",
       next  : "start"
    }]); */
};

oop.inherits(JadeHighlightRules, TextHighlightRules);

exports.JadeHighlightRules = JadeHighlightRules;


/***/ }),

/***/ 16430:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
  THIS FILE WAS AUTOGENERATED BY Stylus.tmlanguage (UUID: 60519324-6A3A-4382-9E0B-546993A3869A) */



var oop = __webpack_require__(2645);
var TextHighlightRules = (__webpack_require__(16387)/* .TextHighlightRules */ .r);
var CssHighlightRules = __webpack_require__(74275);

var StylusHighlightRules = function() {

    // regexp must not have capturing parentheses. Use (?:) instead.
    // regexps are ordered -> the first match is used

    var keywordMapper = this.createKeywordMapper({
        "support.type": CssHighlightRules.supportType,
        "support.function": CssHighlightRules.supportFunction,
        "support.constant": CssHighlightRules.supportConstant,
        "support.constant.color": CssHighlightRules.supportConstantColor,
        "support.constant.fonts": CssHighlightRules.supportConstantFonts
    }, "text", true);

    this.$rules = {
    start: [
        {
            token : "comment",
            regex : /\/\/.*$/
        },
        {
            token : "comment", // multi line comment
            regex : /\/\*/,
            next : "comment"
        },
        {
            token: ["entity.name.function.stylus", "text"],
            regex: "^([-a-zA-Z_][-\\w]*)?(\\()"
        },
        {
            token: ["entity.other.attribute-name.class.stylus"],
            regex: "\\.-?[_a-zA-Z]+[_a-zA-Z0-9-]*"
        },
        {
            token: ["entity.language.stylus"],
            regex: "^ *&"
        },
        {
            token: ["variable.language.stylus"],
            regex: "(arguments)"
        },
        {
            token: ["keyword.stylus"],
            regex: "@[-\\w]+"
        },
        {
            token : ["punctuation", "entity.other.attribute-name.pseudo-element.css"],
            regex : CssHighlightRules.pseudoElements
        }, {
            token : ["punctuation", "entity.other.attribute-name.pseudo-class.css"],
            regex : CssHighlightRules.pseudoClasses
        }, 
        {
            token: ["entity.name.tag.stylus"],
            regex: "(?:\\b)(a|abbr|acronym|address|area|article|aside|audio|b|base|big|blockquote|body|br|button|canvas|caption|cite|code|col|colgroup|datalist|dd|del|details|dfn|dialog|div|dl|dt|em|eventsource|fieldset|figure|figcaption|footer|form|frame|frameset|(?:h[1-6])|head|header|hgroup|hr|html|i|iframe|img|input|ins|kbd|label|legend|li|link|map|mark|menu|meta|meter|nav|noframes|noscript|object|ol|optgroup|option|output|p|param|pre|progress|q|samp|script|section|select|small|span|strike|strong|style|sub|summary|sup|table|tbody|td|textarea|tfoot|th|thead|time|title|tr|tt|ul|var|video)(?:\\b)"
        },
        {
            token: "constant.numeric",  // hex6 color
            regex: "#[a-fA-F0-9]{6}"
        }, 
        {
            token: "constant.numeric", // hex3 color
            regex: "#[a-fA-F0-9]{3}"
        }, 
        {
            token: ["punctuation.definition.entity.stylus", "entity.other.attribute-name.id.stylus"],
            regex: "(#)([a-zA-Z][a-zA-Z0-9_-]*)"
        },
        {
            token: "meta.vendor-prefix.stylus",
            regex: "-webkit-|-moz\\-|-ms-|-o-"
        },
        {
            token: "keyword.control.stylus",
            regex: "(?:!important|for|in|return|true|false|null|if|else|unless|return)\\b"
        },
        {
            token: "keyword.operator.stylus",
            regex: "!|~|\\+|-|(?:\\*)?\\*|\\/|%|(?:\\.)\\.\\.|<|>|(?:=|:|\\?|\\+|-|\\*|\\/|%|<|>)?=|!="
        },
        {
            token: "keyword.operator.stylus",
            regex: "(?:in|is(?:nt)?|not)\\b"
        },
        {
            token : "string",
            regex : "'(?=.)",
            next  : "qstring"
        }, {
            token : "string",
            regex : '"(?=.)',
            next  : "qqstring"
        }, 
        {
            token : "constant.numeric",
            regex : CssHighlightRules.numRe
        }, 
        {
            token : "keyword",
            regex : "(?:ch|cm|deg|em|ex|fr|gd|grad|Hz|in|kHz|mm|ms|pc|pt|px|rad|rem|s|turn|vh|vm|vw|%)\\b"
        }, 
        {
            token : keywordMapper,
            regex : "\\-?[a-zA-Z_][a-zA-Z0-9_\\-]*"
        }
    ],
    "comment" : [
        {
            token : "comment", // closing comment
            regex : "\\*\\/",
            next : "start"
        }, {
            defaultToken : "comment"
        }
    ],
    "qqstring" : [
        {
            token : "string",
            regex : '[^"\\\\]+'
        }, 
        {
            token : "string",
            regex : "\\\\$",
            next  : "qqstring"
        }, 
        {
            token : "string",
            regex : '"|$',
            next  : "start"
        }
    ],
    "qstring" : [
        {
            token : "string",
            regex : "[^'\\\\]+"
        }, 
        {
            token : "string",
            regex : "\\\\$",
            next  : "qstring"
        }, 
        {
            token : "string",
            regex : "'|$",
            next  : "start"
        }
    ]
};

};

oop.inherits(StylusHighlightRules, TextHighlightRules);

exports.StylusHighlightRules = StylusHighlightRules;


/***/ }),

/***/ 58791:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
  THIS FILE WAS AUTOGENERATED BY mode_highlight_rules.tmpl.js (UUID: 21e323af-f665-4161-96e7-5087d262557e) */



var oop = __webpack_require__(2645);
var JavaScriptHighlightRules = (__webpack_require__(15903).JavaScriptHighlightRules);

var TypeScriptHighlightRules = function (options) {

    var tsRules = [
        // Match stuff like: function name: return type)
        {
            token: ["storage.type", "text", "entity.name.function.ts"],
            regex: "(function)(\\s+)([a-zA-Z0-9\$_\u00a1-\uffff][a-zA-Z0-9\d\$_\u00a1-\uffff]*)"
        },
        {
            token: "keyword",
            regex: "(?:\\b(constructor|declare|interface|as|AS|public|private|extends|export|super|readonly|module|namespace|abstract|implements)\\b)"
        },
        {
            token: ["keyword", "storage.type.variable.ts"],
            regex: "(class|type)(\\s+[a-zA-Z0-9_?.$][\\w?.$]*)"
         },
        {
            token: "keyword",
            regex: "\\b(?:super|export|import|keyof|infer)\\b"
        }, 
        {
            token: ["storage.type.variable.ts"],
            regex: "(?:\\b(this\\.|string\\b|bool\\b|boolean\\b|number\\b|true\\b|false\\b|undefined\\b|any\\b|null\\b|(?:unique )?symbol\\b|object\\b|never\\b|enum\\b))"
        }
    ];

    var JSRules = new JavaScriptHighlightRules({jsx: (options && options.jsx) == true}).getRules();
    
    JSRules.no_regex = tsRules.concat(JSRules.no_regex);
    this.$rules = JSRules;
};

oop.inherits(TypeScriptHighlightRules, JavaScriptHighlightRules);

exports.TypeScriptHighlightRules = TypeScriptHighlightRules;


/***/ }),

/***/ 47171:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



var oop = __webpack_require__(2645);
const {FoldMode: HtmlFoldMode} = __webpack_require__(6944);
const lang = __webpack_require__(39955);
const {XmlBehaviour} = __webpack_require__(63458);
const {HtmlCompletions} = __webpack_require__(14402);
var HTMLMode = (__webpack_require__(32234).Mode);
var VueHighlightRules = (__webpack_require__(80920)/* .VueHighlightRules */ .s);

var voidElements = [
    "area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "menuitem", "param", "source",
    "track", "wbr"
];
var optionalEndTags = ["li", "dt", "dd", "p", "rt", "rp", "optgroup", "option", "colgroup", "td", "th"];
var Mode = function () {
    this.HighlightRules = VueHighlightRules;
    this.foldingRules = new HtmlFoldMode(this.voidElements, lang.arrayToMap(optionalEndTags));
    this.$behaviour = new XmlBehaviour();
    this.$completer = new HtmlCompletions();
};
oop.inherits(Mode, HTMLMode);

(function () {
    this.blockComment = {
        start: "<!--",
        end: "-->"
    };
    this.voidElements = lang.arrayToMap(voidElements);

    this.getCompletions = function (state, session, pos, prefix) {
        return this.$completer.getCompletions(state, session, pos, prefix);
    };

    this.$id = "ace/mode/vue";
}).call(Mode.prototype);

exports.Mode = Mode;


/***/ }),

/***/ 80920:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



var oop = __webpack_require__(2645);
var {CssHighlightRules} = __webpack_require__(74275);
var {TypeScriptHighlightRules} = __webpack_require__(58791);
var {CoffeeHighlightRules} = __webpack_require__(28068);
var {HtmlHighlightRules} = __webpack_require__(10413);
var {JavaScriptHighlightRules} = __webpack_require__(15903);
var {StylusHighlightRules} = __webpack_require__(16430);
var {SassHighlightRules} = __webpack_require__(96930);
var {ScssHighlightRules} = __webpack_require__(23124);
var {LessHighlightRules} = __webpack_require__(41425);
var {Tokenizer} = __webpack_require__(32934);
var {SlimHighlightRules} = __webpack_require__(95253);
var {JadeHighlightRules} = __webpack_require__(94726);

var JavaScriptMode = (__webpack_require__(93388).Mode);

var VueHighlightRules = function (options) {

    /**
     * @param {{new(): Ace.HighlightRules}|Ace.HighlightRulesMap} HighlightRules
     * @param {string} tag
     * @param {string} value
     * @param {string} [attribute]
     */
    this.embedLangRules = function (HighlightRules, tag, value, attribute) {
        var condition = attribute ? "(?=[^>]*" + attribute + "\\s*=\\s*['\"]" + value + "['\"]))" : "(?=\\s|>|$))";
        this.$rules.start.unshift({
            token: ["meta.tag.punctuation.tag-open.xml", "meta.tag." + tag + ".tag-name.xml"],
            regex: "(<)(" + tag + condition,
            next: [
                {
                    token: "meta.tag.punctuation.tag-close." + tag + ".xml",
                    regex: "/?>",
                    next: value + "-start"
                }, {include: "attributes"}
            ]
        });

        this.$rules[tag + "-end"] = [
            {include: "attributes"}, {
                token: "meta.tag.punctuation.tag-close.xml",
                regex: "/?>",
                next: "start",
                onMatch: function (value, currentState, stack) {
                    stack.splice(0);
                    return this.token;
                }
            }
        ];

        this.embedRules(HighlightRules, value + "-", [
            {
                token: ["meta.tag.punctuation.end-tag-open.xml", "meta.tag." + tag + ".tag-name.xml"],
                regex: "(</)(" + tag + "(?=\\s|>|$))",
                next: tag + "-end"
            }, {
                token: "string.cdata.xml",
                regex: "<\\!\\[CDATA\\["
            }, {
                token: "string.cdata.xml",
                regex: "\\]\\]>"
            }
        ]);
    };

    var vueRules = [
        {
            include: "vue-interpolations"
        }
    ];

    var VueRules = new HtmlHighlightRules().getRules();
    VueRules.start = vueRules.concat(VueRules.start);
    VueRules["vue-interpolations"] = [
        {
            token: "punctuation",
            regex: /\{\{\{?/,
            next: "js-interpolation-start"
        }
    ];

    var self = this;
    VueRules.tag_stuff.unshift({//vue-directives 
        token: "string",
        regex: /(?:\b(v-)|(:|@))([a-zA-Z\-.]+)(?:\:([a-zA-Z\-]+))?(?:\.([a-zA-Z\-]+))*(\s*)(=)(\s*)(["'])/,
        onMatch: function (value, currentState, stack) {
            var quote = value[value.length - 1];
            stack.unshift(quote, currentState);

            var values = new RegExp(this.regex).exec(value);
            if (!values) return "text";
            var tokens = [];
            var types = [
                "entity.other.attribute-name.xml", "punctuation.separator.key-value.xml",
                "entity.other.attribute-name.xml", "entity.other.attribute-name.xml", "entity.other.attribute-name.xml",
                "text", "punctuation.separator.key-value.xml", "text", "string"
            ];
            for (var i = 0, l = types.length; i < l; i++) {
                if (values[i + 1]) tokens[tokens.length] = {
                    type: types[i],
                    value: values[i + 1]
                };
            }
            return tokens;
        },
        next: [
            {
                token: "string",
                regex: /$/,
                next: "tag_stuff"
            }, {
                token: "string",
                regex: /.*/,
                onMatch: function (value, currentState, stack, line) {
                    var quote = stack[0];
                    var parts = value.split(quote);
                    let text = parts[0];
                    this.next = "";
                    if (parts.length > 1) {
                        stack.shift();
                        var nextState = stack.shift();
                        var currentData = new Tokenizer(self.$rules).getLineTokens(
                            parts.slice(1).join(quote), nextState);
                        currentData.tokens.unshift({
                            type: "string",
                            value: quote
                        });
                        this.next = Array.isArray(currentData.state) ? currentData.state[currentData.state.length - 1]
                            : currentData.state;
                    }
                    var data = new JavaScriptMode().getTokenizer().getLineTokens(text, "start");
                    var tokens = data.tokens;
                    if (currentData) {
                        tokens.push(...currentData.tokens);
                    }
                    return tokens;
                }
            }
        ]
    }, {
        token: "string",
        regex: '"',
        next: [
            {
                token: "string",
                regex: '"|$',
                next: "tag_stuff"
            }, {
                include: "vue-interpolations"
            }, {
                defaultToken: "string"
            }
        ]
    }, {
        token: "string",
        regex: "'",
        next: [
            {
                token: "string",
                regex: "'|$",
                next: "tag_stuff"
            }, {
                include: "vue-interpolations"
            }, {
                defaultToken: "string"
            }
        ]
    });
    this.$rules = VueRules;

    this.embedRules(JavaScriptHighlightRules, "js-interpolation-", [
        {
            token: "punctuation",
            regex: /\}\}\}?/,
            next: "start"
        }
    ]);

    this.embedLangRules(CssHighlightRules, "style", "css");
    this.embedLangRules(StylusHighlightRules, "style", "stylus", "lang");
    //TODO: postcss is missing: this.embedLangRules(StylusHighlightRules, "style", "lang", "postcss");
    this.embedLangRules(SassHighlightRules, "style", "sass", "lang");
    this.embedLangRules(ScssHighlightRules, "style", "scss", "lang");
    this.embedLangRules(LessHighlightRules, "style", "less", "lang");
    this.embedLangRules(TypeScriptHighlightRules, "script", "ts", "lang");
    this.embedLangRules(CoffeeHighlightRules, "script", "coffee", "lang");
    //TODO: this.embedLangRules(CoffeeHighlightRules, "script", "livescript", "lang");
    this.embedLangRules(SlimHighlightRules, "template", "slm", "lang");
    this.embedLangRules(JadeHighlightRules, "template", "jade", "lang");
    //TODO: this.embedLangRules(Pug, "template", "pug", "lang");
    this.embedLangRules(StylusHighlightRules, "template", "stylus", "lang");
    
    this.normalizeRules();
};

oop.inherits(VueHighlightRules, HtmlHighlightRules);

exports.s = VueHighlightRules;


/***/ })

}]);
//# sourceMappingURL=bundle.7171.js.map