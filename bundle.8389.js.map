{"version":3,"file":"bundle.8389.js","mappings":";;;;;;AAAa;;AAEb,UAAU,mBAAO,CAAC,IAAe;AACjC,mBAAmB,qCAA+B;AAClD,YAAY,2CAA4B;AACxC,oBAAoB,0CAA6C;;;AAGjE,eAAe,SAAgB;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;;;;;;ACnHY;;AAEb,UAAU,mBAAO,CAAC,IAAY;AAC9B,eAAe,iCAAsB;AACrC,0BAA0B,yDAAsD;AAChF,eAAe,8CAAmC;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED,YAAY;;;;;;;;ACvCC;;AAEb,UAAU,mBAAO,CAAC,IAAY;AAC9B,yBAAyB,wDAAoD;;AAE7E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,6CAA6C,KAAK;AAClD,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,2BAA2B;;AAE3B;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,SAA2B","sources":["webpack://ace-playground/./node_modules/ace-code/src/mode/folding/basic.js","webpack://ace-playground/./node_modules/ace-code/src/mode/basic.js","webpack://ace-playground/./node_modules/ace-code/src/mode/basic_highlight_rules.js"],"sourcesContent":["\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\n\n\nvar FoldMode = exports.FoldMode = function() {};\n\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n    this.indentKeywords = {\n        \"tron\": 1,\n        \"while\": 1,\n        \"for\": 1,\n        \"troff\": -1,\n        \"wend\": -1,\n        \"next\": -1\n    };\n\n    this.foldingStartMarker = /(?:\\s|^)(tron|while|for)\\b/i;\n    this.foldingStopMarker = /(?:\\b)(troff|next|wend)\\b/i;\n\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n        var line = session.getLine(row);\n        var isStart = this.foldingStartMarker.test(line);\n        var isEnd = this.foldingStopMarker.test(line);\n        if (isStart || isEnd) {\n            var match = (isEnd) ? this.foldingStopMarker.exec(line) : this.foldingStartMarker.exec(line);\n            var keyword = match && match[1].toLowerCase();\n            if (keyword) {\n                var type = session.getTokenAt(row, match.index + 2).type;\n                if (type === \"keyword.control\")\n                    return this.basicBlock(session, row, match.index + 2);\n            }\n        }\n    };\n\n\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        var isStart = this.foldingStartMarker.test(line);\n        var isEnd = this.foldingStopMarker.test(line);\n        if (isStart && !isEnd) {\n            var match = this.foldingStartMarker.exec(line);\n            var keyword = match && match[1].toLowerCase();\n            if (keyword) {\n                var type = session.getTokenAt(row, match.index + 2).type;\n                if (type == \"keyword.control\") {\n                    return \"start\";\n                }\n            }\n        }\n        if (foldStyle != \"markbeginend\" || !isEnd || isStart && isEnd)\n            return \"\";\n\n        var match = line.match(this.foldingStopMarker);\n        var keyword = match && match[1].toLowerCase();\n        if (this.indentKeywords[keyword]) {\n            if (session.getTokenAt(row, match.index + 2).type === \"keyword.control\")\n                return \"end\";\n        }\n\n        return \"\";\n    };\n\n    this.basicBlock = function(session, row, column, tokenRange) {\n        var stream = new TokenIterator(session, row, column);\n\n        var token = stream.getCurrentToken();\n        if (!token || token.type != \"keyword.control\")\n            return;\n\n        var val = token.value.toLowerCase();\n        var stack = [val];\n        var dir = this.indentKeywords[val];\n\n        if (!dir)\n            return;\n\n        var startColumn = dir === -1 ? stream.getCurrentTokenColumn() : session.getLine(row).length;\n        var startRow = row;\n\n        stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n        while(token = stream.step()) {\n            val = token.value.toLowerCase();\n            if (token.type !== \"keyword.control\" || !this.indentKeywords[val])\n                continue;\n            var level = dir * this.indentKeywords[val];\n\n            if (level > 0) {\n                stack.unshift(val);\n            } else if (level <= 0) {\n                stack.shift();\n            }\n            if (stack.length === 0) {\n                break;\n            }\n        }\n\n        if (!token)\n            return null;\n\n        if (tokenRange)\n            return stream.getCurrentTokenRange();\n\n        var row = stream.getCurrentTokenRow();\n        if (dir === -1)\n            return new Range(row, session.getLine(row).length, startRow, startColumn);\n        else\n            return new Range(startRow, startColumn, row, stream.getCurrentTokenColumn());\n    };\n\n}).call(FoldMode.prototype);\n","\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar BasicHighlightRules = require(\"./basic_highlight_rules\").BasicHighlightRules;\nvar FoldMode = require(\"./folding/basic\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = BasicHighlightRules;\n    this.foldingRules = new FoldMode();\n    this.$behaviour = this.$defaultBehaviour;\n    this.indentKeywords = this.foldingRules.indentKeywords;\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n\n    this.lineCommentStart = [\"REM\"];\n\n    this.getMatching = function(session, row, column, tokenRange) {\n        if (row == undefined) {\n            var pos = session.selection.lead;\n            column = pos.column;\n            row = pos.row;\n        }\n        if (tokenRange == undefined)\n            tokenRange = true;\n\n        var startToken = session.getTokenAt(row, column);\n        if (startToken) {\n            var val = startToken.value.toLowerCase();\n            if (val in this.indentKeywords)\n                return this.foldingRules.basicBlock(session, row, column, tokenRange);\n        }\n    };\n\n    this.$id = \"ace/mode/basic\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n","\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\nvar BasicHighlightRules = function () {\n\n    var keywordMapper = this.createKeywordMapper({\n        \"keyword.control\": \"FOR|TO|NEXT|GOSUB|RETURN|IF|THEN|ELSE|GOTO|ON|WHILE|WEND|TRON|TROFF\",\n        \"entity.name\": \"Auto|Call|Chain|Clear|Close|Common|Cont|Data|MERGE|ALL|Delete|DIM|EDIT|END|ERASE|ERROR|FIELD|\"\n            + \"GET|INPUT|KILL|LET|LIST|LLIST|LOAD|LSET|RSET|MERGE|NEW|NULL|OPEN|OUT|POKE|PRINT|PUT|RANDOMIZE|READ|\"\n            + \"RENUM|RESTORE|RESUME|RUN|SAVE|STOP|SWAP|WAIT|WIDTH\",\n        \"keyword.operator\": \"Mod|And|Not|Or|Xor|Eqv|Imp\",\n        \"support.function\": \"ABS|ASC|ATN|CDBL|CINT|COS|CSNG|CVI|CVS|CVD|EOF|EXP|FIX|FRE|INP|INSTR|INT|LEN|LOC|LOG|LPOS|\"\n            + \"PEEK|POS|RND|SGN|SIN|SPC|SQR|TAB|TAN|USR|VAL|VARPTR\"\n    }, \"identifier\", true);\n\n    this.$rules = {\n        \"start\": [\n            {\n                token: \"string\",\n                regex: /\"(?:\\\\.|[^\"\\\\])*\"/\n            },\n            {\n                token: \"support.function\",\n                regex: /(HEX|CHR|INPUT|LEFT|MID|MKI|MKS|MKD|OCT|RIGHT|SPACE|STR|STRING)\\$/\n            }, {\n                token: \"entity.name\",\n                regex: /(?:DEF\\s(?:SEG|USR|FN[a-zA-Z]+)|LINE\\sINPUT|L?PRINT#?(?:\\sUSING)?|MID\\$|ON\\sERROR\\sGOTO|OPTION\\sBASE|WRITE#?|DATE\\$|INKEY\\$|TIME\\$)/\n            }, {\n                token: \"variable\",\n                regex: /[a-zA-Z][a-zA-Z0-9_]{0,38}[$%!#]?(?=\\s*=)/\n            }, {\n                token: \"keyword.operator\",\n                regex: /\\\\|=|\\^|\\*|\\/|\\+|\\-|<|>|-/\n            }, {\n                token: \"paren.lparen\",\n                regex: /[([]/\n            }, {\n                token: \"paren.rparen\",\n                regex: /[\\)\\]]/\n            }, {\n                token: \"constant.numeric\",\n                regex: /[+-]?\\d+(\\.\\d+)?([ED][+-]?\\d+)?(?:[!#])?/\n            }, {\n                token: \"constant.numeric\", //hexal, octal\n                regex: /&[HO]?[0-9A-F]+/\n            }, {\n                token: \"comment\",\n                regex: /REM\\s+.*$/\n            }, {\n                regex: \"\\\\w+\",\n                token: keywordMapper\n            },{\n                token: \"punctiation\",\n                regex: /[,;]/\n\n            }\n        ]\n\n    };\n    this.normalizeRules();\n};\n\noop.inherits(BasicHighlightRules, TextHighlightRules);\n\nexports.BasicHighlightRules = BasicHighlightRules;\n"],"names":[],"sourceRoot":""}