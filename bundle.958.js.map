{"version":3,"file":"bundle.958.js","mappings":";;;;;;AAAa;AACb;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;;AAEA,gDAAgD,cAAc;AAC9D;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB;AACjB;;AAEA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,YAAY;AACzD;;AAEA,+CAA+C,SAAS;AACxD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;;AAEA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,iBAAiB;AACjE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,8DAA8D,YAAY;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iEAAiE,yBAAyB;AAC1F;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,aAAa;AACrC;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;;AAEA;;AAEA,2BAA2B;;AAE3B,aAAa,mCAA2B;AACxC,0CAAkC;AAClC;AACA;AACA,mBAAmB,SAAS;AAC5B,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","sources":["webpack://ace-playground/./node_modules/ace-code/src/ext/elastic_tabstops_lite.js"],"sourcesContent":["\"use strict\";\nclass ElasticTabstopsLite {\n    /**\n     * @param {Editor} editor\n     */\n    constructor(editor) {\n        this.$editor = editor;\n        var self = this;\n        var changedRows = [];\n        var recordChanges = false;\n        this.onAfterExec = function() {\n            recordChanges = false;\n            self.processRows(changedRows);\n            changedRows = [];\n        };\n        this.onExec = function() {\n            recordChanges = true;\n        };\n        this.onChange = function(delta) {\n            if (recordChanges) {\n                if (changedRows.indexOf(delta.start.row) == -1)\n                    changedRows.push(delta.start.row);\n                if (delta.end.row != delta.start.row)\n                    changedRows.push(delta.end.row);\n            }\n        };\n    }\n\n    /**\n     * @param {number[]} rows\n     */\n    processRows(rows) {\n        this.$inChange = true;\n        var checkedRows = [];\n\n        for (var r = 0, rowCount = rows.length; r < rowCount; r++) {\n            var row = rows[r];\n\n            if (checkedRows.indexOf(row) > -1)\n                continue;\n\n            var cellWidthObj = this.$findCellWidthsForBlock(row);\n            var cellWidths = this.$setBlockCellWidthsToMax(cellWidthObj.cellWidths);\n            var rowIndex = cellWidthObj.firstRow;\n\n            for (var w = 0, l = cellWidths.length; w < l; w++) {\n                var widths = cellWidths[w];\n                checkedRows.push(rowIndex);\n                this.$adjustRow(rowIndex, widths);\n                rowIndex++;\n            }\n        }\n        this.$inChange = false;\n    }\n\n    /**\n     * @param {number} row\n     */\n    $findCellWidthsForBlock(row) {\n        var cellWidths = [], widths;\n\n        // starting row and backward\n        var rowIter = row;\n        while (rowIter >= 0) {\n            widths = this.$cellWidthsForRow(rowIter);\n            if (widths.length == 0)\n                break;\n\n            cellWidths.unshift(widths);\n            rowIter--;\n        }\n        var firstRow = rowIter + 1;\n\n        // forward (not including starting row)\n        rowIter = row;\n        var numRows = this.$editor.session.getLength();\n\n        while (rowIter < numRows - 1) {\n            rowIter++;\n\n            widths = this.$cellWidthsForRow(rowIter);\n            if (widths.length == 0)\n                break;\n\n            cellWidths.push(widths);\n        }\n\n        return { cellWidths: cellWidths, firstRow: firstRow };\n    }\n\n    /**\n     * @param {number} row\n     * @returns {number[]}\n     */\n    $cellWidthsForRow(row) {\n        var selectionColumns = this.$selectionColumnsForRow(row);\n        // todo: support multicursor\n\n        var tabs = [-1].concat(this.$tabsForRow(row));\n        var widths = tabs.map(function(el) { return 0; } ).slice(1);\n        var line = this.$editor.session.getLine(row);\n\n        for (var i = 0, len = tabs.length - 1; i < len; i++) {\n            var leftEdge = tabs[i]+1;\n            var rightEdge = tabs[i+1];\n\n            var rightmostSelection = this.$rightmostSelectionInCell(selectionColumns, rightEdge);\n            var cell = line.substring(leftEdge, rightEdge);\n            widths[i] = Math.max(cell.replace(/\\s+$/g,'').length, rightmostSelection - leftEdge);\n        }\n\n        return widths;\n    }\n\n    /**\n     * @param {number} row\n     * @returns {number[]}\n     */\n    $selectionColumnsForRow(row) {\n        var selections = [], cursor = this.$editor.getCursorPosition();\n        if (this.$editor.session.getSelection().isEmpty()) {\n            // todo: support multicursor\n            if (row == cursor.row)\n                selections.push(cursor.column);\n        }\n\n        return selections;\n    }\n\n    /**\n     * @param {number[][]} cellWidths\n     */\n    $setBlockCellWidthsToMax(cellWidths) {\n        var startingNewBlock = true, blockStartRow, blockEndRow, maxWidth;\n        var columnInfo = this.$izip_longest(cellWidths);\n\n        for (var c = 0, l = columnInfo.length; c < l; c++) {\n            var column = columnInfo[c];\n            if (!column.push) {\n                console.error(column);\n                continue;\n            }\n            // add an extra None to the end so that the end of the column automatically\n            // finishes a block\n            column.push(NaN);\n\n            for (var r = 0, s = column.length; r < s; r++) {\n                var width = column[r];\n                if (startingNewBlock) {\n                    blockStartRow = r;\n                    maxWidth = 0;\n                    startingNewBlock = false;\n                }\n                if (isNaN(width)) {\n                    // block ended\n                    blockEndRow = r;\n\n                    for (var j = blockStartRow; j < blockEndRow; j++) {\n                        cellWidths[j][c] = maxWidth;\n                    }\n                    startingNewBlock = true;\n                }\n\n                maxWidth = Math.max(maxWidth, width);\n            }\n        }\n\n        return cellWidths;\n    }\n\n    /**\n     * @param {number[]} selectionColumns\n     * @param {number} cellRightEdge\n     * @returns {number}\n     */\n    $rightmostSelectionInCell(selectionColumns, cellRightEdge) {\n        var rightmost = 0;\n\n        if (selectionColumns.length) {\n            var lengths = [];\n            for (var s = 0, length = selectionColumns.length; s < length; s++) {\n                if (selectionColumns[s] <= cellRightEdge)\n                    lengths.push(s);\n                else\n                    lengths.push(0);\n            }\n            rightmost = Math.max.apply(Math, lengths);\n        }\n\n        return rightmost;\n    }\n\n    /**\n     * @param {number} row\n     * @returns {number[]}\n     */\n    $tabsForRow(row) {\n        var rowTabs = [], line = this.$editor.session.getLine(row),\n            re = /\\t/g, match;\n\n        while ((match = re.exec(line)) != null) {\n            rowTabs.push(match.index);\n        }\n\n        return rowTabs;\n    }\n\n    /**\n     * @param {number} row\n     * @param {number[]} widths\n     */\n    $adjustRow(row, widths) {\n        var rowTabs = this.$tabsForRow(row);\n\n        if (rowTabs.length == 0)\n            return;\n\n        var bias = 0, location = -1;\n\n        // this always only contains two elements, so we're safe in the loop below\n        var expandedSet = this.$izip(widths, rowTabs);\n\n        for (var i = 0, l = expandedSet.length; i < l; i++) {\n            var w = expandedSet[i][0], it = expandedSet[i][1];\n            location += 1 + w;\n            it += bias;\n            var difference = location - it;\n\n            if (difference == 0)\n                continue;\n\n            var partialLine = this.$editor.session.getLine(row).substr(0, it );\n            var strippedPartialLine = partialLine.replace(/\\s*$/g, \"\");\n            var ispaces = partialLine.length - strippedPartialLine.length;\n\n            if (difference > 0) {\n                // put the spaces after the tab and then delete the tab, so any insertion\n                // points behave as expected\n                this.$editor.session.getDocument().insertInLine({row: row, column: it + 1}, Array(difference + 1).join(\" \") + \"\\t\");\n                this.$editor.session.getDocument().removeInLine(row, it, it + 1);\n\n                bias += difference;\n            }\n\n            if (difference < 0 && ispaces >= -difference) {\n                this.$editor.session.getDocument().removeInLine(row, it + difference, it);\n                bias += difference;\n            }\n        }\n    }\n\n    /**\n     * The is a (naive) Python port--but works for these purposes\n     * @param {any[][]} iterables\n     */\n    $izip_longest(iterables) {\n        if (!iterables[0])\n            return [];\n        var longest = iterables[0].length;\n        var iterablesLength = iterables.length;\n\n        for (var i = 1; i < iterablesLength; i++) {\n            var iLength = iterables[i].length;\n            if (iLength > longest)\n                longest = iLength;\n        }\n\n        var expandedSet = [];\n\n        for (var l = 0; l < longest; l++) {\n            var set = [];\n            for (var i = 0; i < iterablesLength; i++) {\n                if (iterables[i][l] === \"\")\n                    set.push(NaN);\n                else\n                    set.push(iterables[i][l]);\n            }\n\n            expandedSet.push(set);\n        }\n\n\n        return expandedSet;\n    }\n\n    /**\n     * an even more (naive) Python port\n     * @param {string | any[]} widths\n     * @param {string | any[]} tabs\n     */\n    $izip(widths, tabs) {\n        // grab the shorter size\n        var size = widths.length >= tabs.length ? tabs.length : widths.length;\n\n        var expandedSet = [];\n        for (var i = 0; i < size; i++) {\n            var set = [ widths[i], tabs[i] ];\n            expandedSet.push(set);\n        }\n        return expandedSet;\n    }\n\n}\n\nexports.ElasticTabstopsLite = ElasticTabstopsLite;\n\nvar Editor = require(\"../editor\").Editor;\nrequire(\"../config\").defineOptions(Editor.prototype, \"editor\", {\n    useElasticTabstops: {\n        /**\n         * @param {boolean} val\n         * @this {Editor}\n         */\n        set: function(val) {\n            if (val) {\n                if (!this.elasticTabstops)\n                    this.elasticTabstops = new ElasticTabstopsLite(this);\n                this.commands.on(\"afterExec\", this.elasticTabstops.onAfterExec);\n                this.commands.on(\"exec\", this.elasticTabstops.onExec);\n                this.on(\"change\", this.elasticTabstops.onChange);\n            } else if (this.elasticTabstops) {\n                this.commands.removeListener(\"afterExec\", this.elasticTabstops.onAfterExec);\n                this.commands.removeListener(\"exec\", this.elasticTabstops.onExec);\n                this.removeListener(\"change\", this.elasticTabstops.onChange);\n            }\n        }\n    }\n});\n"],"names":[],"sourceRoot":""}