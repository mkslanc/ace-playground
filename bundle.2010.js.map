{"version":3,"file":"bundle.2010.js","mappings":";;;;;;AAAa;;AAEb,gDAAmD;AACnD,aAAa;;;;;;;;ACHb;AACA;AACA,MAAM;AACN;AACA;AACA,WAAW,QAAQ,GAAG;AACtB,MAAM,EAAE;AACR;AACA,SAAS,EAAE;AACX;AACA,eAAe,WAAW,IAAI,aAAa,KAAK,gBAAgB,IAAI,OAAO;AAC3E,MAAM,EAAE;AACR;AACA,cAAc,QAAQ,IAAI,aAAa,KAAK,cAAc;AAC1D;AACA,cAAc,QAAQ,IAAI,aAAa,KAAK,cAAc;AAC1D;AACA,UAAU,QAAQ,IAAI,aAAa,MAAM,WAAW;AACpD,MAAM,EAAE;AACR;AACA,iBAAiB;AACjB,MAAM,EAAE;AACR;AACA,eAAe,QAAQ,IAAI,SAAS;AACpC,MAAM;AACN,MAAM,EAAE;AACR;AACA,aAAa;AACb,eAAe,YAAY;AAC3B,MAAM,EAAE;AACR;AACA,WAAW,GAAG,GAAG,EAAE;AACnB;AACA,aAAa,QAAQ,IAAI,SAAS;AAClC,MAAM;AACN,MAAM,EAAE;AACR;AACA,YAAY,QAAQ,GAAG,OAAO;AAC9B,MAAM,EAAE;AACR;AACA,SAAS,WAAW,KAAK,EAAE;AAC3B;AACA,QAAQ;AACR,MAAM;AACN,MAAM,YAAY;AAClB;AACA,aAAa,UAAU,GAAG,YAAY;AACtC,MAAM,aAAa;AACnB,MAAM,YAAY;AAClB;AACA,cAAc,UAAU;AACxB,IAAI,UAAU,OAAO,OAAO,GAAG;AAC/B;AACA,UAAU,QAAQ,GAAG,OAAO;AAC5B,KAAK,EAAE;AACP;AACA,aAAa,YAAY,OAAO;AAChC,cAAc,EAAE;AAChB;AACA,SAAS,QAAQ,GAAG,OAAO;AAC3B;AACA,WAAW,SAAS,KAAK,OAAO;AAChC;AACA,KAAK,QAAQ,IAAI,QAAQ,GAAG,OAAO;AACnC,MAAM,EAAE;AACR;AACA,QAAQ;AACR,MAAM,EAAE;AACR;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,UAAU,EAAE;AACZ;AACA,KAAK,QAAQ,IAAI,QAAQ,GAAG,OAAO;AACnC;AACA,8BAA8B,EAAE;AAChC;AACA,eAAe,aAAa,QAAQ,EAAE;AACtC;AACA,WAAW,aAAa,UAAU,EAAE;AACpC;AACA,aAAa,EAAE;AACf;AACA,YAAY,eAAe,EAAE,GAAG,GAAG,EAAE;AACrC;AACA,UAAU,QAAQ,GAAG,OAAO;AAC5B;AACA,eAAe,UAAU,GAAG,OAAO;AACnC,KAAK,OAAO;AACZ","sources":["webpack://ace-playground/./node_modules/ace-code/src/snippets/clojure.js","webpack://ace-playground/./node_modules/ace-code/src/snippets/clojure.snippets.js"],"sourcesContent":["\"use strict\";\n\nexports.snippetText = require(\"./clojure.snippets\");\nexports.scope = \"clojure\";\n","module.exports = `snippet comm\n\t(comment\n\t  \\${1}\n\t  )\nsnippet condp\n\t(condp \\${1:pred} \\${2:expr}\n\t  \\${3})\nsnippet def\n\t(def \\${1})\nsnippet defm\n\t(defmethod \\${1:multifn} \"\\${2:doc-string}\" \\${3:dispatch-val} [\\${4:args}]\n\t  \\${5})\nsnippet defmm\n\t(defmulti \\${1:name} \"\\${2:doc-string}\" \\${3:dispatch-fn})\nsnippet defma\n\t(defmacro \\${1:name} \"\\${2:doc-string}\" \\${3:dispatch-fn})\nsnippet defn\n\t(defn \\${1:name} \"\\${2:doc-string}\" [\\${3:arg-list}]\n\t  \\${4})\nsnippet defp\n\t(defprotocol \\${1:name}\n\t  \\${2})\nsnippet defr\n\t(defrecord \\${1:name} [\\${2:fields}]\n\t  \\${3:protocol}\n\t  \\${4})\nsnippet deft\n\t(deftest \\${1:name}\n\t    (is (= \\${2:assertion})))\n\t  \\${3})\nsnippet is\n\t(is (= \\${1} \\${2}))\nsnippet defty\n\t(deftype \\${1:Name} [\\${2:fields}]\n\t  \\${3:Protocol}\n\t  \\${4})\nsnippet doseq\n\t(doseq [\\${1:elem} \\${2:coll}]\n\t  \\${3})\nsnippet fn\n\t(fn [\\${1:arg-list}] \\${2})\nsnippet if\n\t(if \\${1:test-expr}\n\t  \\${2:then-expr}\n\t  \\${3:else-expr})\nsnippet if-let \n\t(if-let [\\${1:result} \\${2:test-expr}]\n\t\t(\\${3:then-expr} \\$1)\n\t\t(\\${4:else-expr}))\nsnippet imp\n\t(:import [\\${1:package}])\n\t& {:keys [\\${1:keys}] :or {\\${2:defaults}}}\nsnippet let\n\t(let [\\${1:name} \\${2:expr}]\n\t\t\\${3})\nsnippet letfn\n\t(letfn [(\\${1:name) [\\${2:args}]\n\t          \\${3})])\nsnippet map\n\t(map \\${1:func} \\${2:coll})\nsnippet mapl\n\t(map #(\\${1:lambda}) \\${2:coll})\nsnippet met\n\t(\\${1:name} [\\${2:this} \\${3:args}]\n\t  \\${4})\nsnippet ns\n\t(ns \\${1:name}\n\t  \\${2})\nsnippet dotimes\n\t(dotimes [_ 10]\n\t  (time\n\t    (dotimes [_ \\${1:times}]\n\t      \\${2})))\nsnippet pmethod\n\t(\\${1:name} [\\${2:this} \\${3:args}])\nsnippet refer\n\t(:refer-clojure :exclude [\\${1}])\nsnippet require\n\t(:require [\\${1:namespace} :as [\\${2}]])\nsnippet use\n\t(:use [\\${1:namespace} :only [\\${2}]])\nsnippet print\n\t(println \\${1})\nsnippet reduce\n\t(reduce \\${1:(fn [p n] \\${3})} \\${2})\nsnippet when\n\t(when \\${1:test} \\${2:body})\nsnippet when-let\n\t(when-let [\\${1:result} \\${2:test}]\n\t\t\\${3:body})\n`;\n"],"names":[],"sourceRoot":""}