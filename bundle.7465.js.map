{"version":3,"file":"bundle.7465.js","mappings":";;;;;;AAAa;;AAEb,UAAU,mBAAO,CAAC,IAAY;AAC9B,eAAe,iCAAsB;AACrC,4BAA4B,2DAA0D;AACtF,2BAA2B,iDAAwD;AACnF,YAAY,2CAAyB;AACrC,eAAe,8CAAoC;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED,YAAY;;;;;;;;AClEC;;AAEb,cAAc,mBAAO,CAAC,IAAY;AAClC,6BAA6B,wDAAoD;;AAEjF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,2DAA2D,EAAE,aAAa,EAAE,aAAa,EAAE,GAAG,WAAW,KAAK;AAC9G,gEAAgE,EAAE,aAAa,EAAE,aAAa,EAAE,GAAG,WAAW,KAAK,GAAG,cAAc,EAAE,eAAe,GAAG;AACxJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iDAAiD;AACjD;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,+BAA+B;AAC/B,6CAA6C;AAC7C,qCAAqC;AACrC;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,oCAAoC;AACpC,qBAAqB;AACrB;AACA,kCAAkC;AAClC;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,oCAAoC;AACpC,qBAAqB;AACrB;AACA,kCAAkC;AAClC;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,kCAAkC;AAClC;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,kCAAkC;AAClC;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iCAAiC;AACjC;AACA,qBAAqB;AACrB;AACA,iCAAiC;AACjC;AACA,qBAAqB;AACrB;AACA,kCAAkC;AAClC;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,kCAAkC;AAClC;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,kCAAkC;AAClC;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,oCAAoC;AACpC;AACA;AACA,iCAAiC;AACjC;AACA,qBAAqB;AACrB;AACA,iCAAiC;AACjC;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,8BAA8B,IAAI;AAClC,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mCAAmC;AAChE,6BAA6B,iCAAiC;AAC9D,6BAA6B,wCAAwC;AACrE,6BAA6B;AAC7B;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,iCAAiC;AACjC,iBAAiB;AACjB;AACA,gCAAgC;AAChC,iBAAiB;AACjB;AACA,kCAAkC;AAClC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,IAAI,SAA6B;;;;;;;;ACpbpB;;AAEb,UAAU,mBAAO,CAAC,IAAe;AACjC,mBAAmB,qCAA+B;AAClD,YAAY,2CAA4B;;AAExC,eAAe,SAAgB;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;;;;;;AC3FY;;AAEb,YAAY,2CAAyB;;AAErC;;AAEA;;AAEA;AACA;AACA;;AAEA,sBAAsB;AACtB;;AAEA;AACA;AACA,uCAAuC;;AAEvC;;AAEA;AACA,oDAAoD,yBAAyB;;AAE7E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED,4BAA4B","sources":["webpack://ace-playground/./node_modules/ace-code/src/mode/crystal.js","webpack://ace-playground/./node_modules/ace-code/src/mode/crystal_highlight_rules.js","webpack://ace-playground/./node_modules/ace-code/src/mode/folding/coffee.js","webpack://ace-playground/./node_modules/ace-code/src/mode/matching_brace_outdent.js"],"sourcesContent":["\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar CrystalHighlightRules = require(\"./crystal_highlight_rules\").CrystalHighlightRules;\nvar MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\nvar Range = require(\"../range\").Range;\nvar FoldMode = require(\"./folding/coffee\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = CrystalHighlightRules;\n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = this.$defaultBehaviour;\n    this.foldingRules = new FoldMode();\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n\n\n    this.lineCommentStart = \"#\";\n\n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n\n        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n        var tokens = tokenizedLine.tokens;\n\n        if (tokens.length && tokens[tokens.length-1].type == \"comment\") {\n            return indent;\n        }\n\n        if (state == \"start\") {\n            var match = line.match(/^.*[\\{\\(\\[]\\s*$/);\n            var startingClassOrMethod = line.match(/^\\s*(class|def|module)\\s.*$/);\n            var startingDoBlock = line.match(/.*do(\\s*|\\s+\\|.*\\|\\s*)$/);\n            var startingConditional = line.match(/^\\s*(if|else|when)\\s*/);\n            if (match || startingClassOrMethod || startingDoBlock || startingConditional) {\n                indent += tab;\n            }\n        }\n\n        return indent;\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return /^\\s+(end|else)$/.test(line + input) || this.$outdent.checkOutdent(line, input);\n    };\n\n    this.autoOutdent = function(state, session, row) {\n        var line = session.getLine(row);\n        if (/}/.test(line))\n            return this.$outdent.autoOutdent(session, row);\n        var indent = this.$getIndent(line);\n        var prevLine = session.getLine(row - 1);\n        var prevIndent = this.$getIndent(prevLine);\n        var tab = session.getTabString();\n        if (prevIndent.length <= indent.length) {\n            if (indent.slice(-tab.length) == tab)\n                session.remove(new Range(row, indent.length-tab.length, row, indent.length));\n        }\n    };\n\n    this.$id = \"ace/mode/crystal\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n","\"use strict\";\n\n    var oop = require(\"../lib/oop\");\n    var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\n    var CrystalHighlightRules = function () {\n\n        var builtinFunctions = (\n            \"puts|initialize|previous_def|typeof|as|pointerof|sizeof|instance_sizeof\"\n        );\n\n        var keywords = (\n            \"if|end|else|elsif|unless|case|when|break|while|next|until|def|return|class|new|getter|setter|property|lib\"\n            + \"|fun|do|struct|private|protected|public|module|super|abstract|include|extend|begin|enum|raise|yield|with\"\n            + \"|alias|rescue|ensure|macro|uninitialized|union|type|require\"\n        );\n\n        var buildinConstants = (\n            \"true|TRUE|false|FALSE|nil|NIL|__LINE__|__END_LINE__|__FILE__|__DIR__\"\n        );\n\n        var builtinVariables = (\n            \"$DEBUG|$defout|$FILENAME|$LOAD_PATH|$SAFE|$stdin|$stdout|$stderr|$VERBOSE|\" +\n            \"root_url|flash|session|cookies|params|request|response|logger|self\"\n        );\n\n        var keywordMapper = this.$keywords = this.createKeywordMapper({\n            \"keyword\": keywords,\n            \"constant.language\": buildinConstants,\n            \"variable.language\": builtinVariables,\n            \"support.function\": builtinFunctions\n        }, \"identifier\");\n\n        var hexNumber = \"(?:0[xX][\\\\dA-Fa-f]+)\";\n        var decNumber = \"(?:[0-9][\\\\d_]*)\";\n        var octNumber = \"(?:0o[0-7][0-7]*)\";\n        var binNumber = \"(?:0[bB][01]+)\";\n        var intNumber = \"(?:[+-]?)(?:\" + hexNumber + \"|\" + decNumber + \"|\" + octNumber + \"|\" + binNumber + \")(?:_?[iIuU](?:8|16|32|64))?\\\\b\";\n        var escapeExpression = /\\\\(?:[nsrtvfbae'\"\\\\]|[0-7]{3}|x[\\da-fA-F]{2}|u[\\da-fA-F]{4}|u{[\\da-fA-F]{1,6}})/;\n        var extEscapeExspresssion = /\\\\(?:[nsrtvfbae'\"\\\\]|[0-7]{3}|x[\\da-fA-F]{2}|u[\\da-fA-F]{4}|u{[\\da-fA-F]{1,6}}|u{(:?[\\da-fA-F]{2}\\s)*[\\da-fA-F]{2}})/;\n        // regexp must not have capturing parentheses. Use (?:) instead.\n        // regexps are ordered -> the first match is used\n\n        this.$rules = {\n            \"start\": [\n                {\n                    token: \"comment\",\n                    regex: \"#.*$\"\n                }, {\n                    token: \"string.regexp\",\n                    regex: \"[/]\",\n                    push: [{\n                        token: \"constant.language.escape\",\n                        regex: extEscapeExspresssion\n                    }, {\n                        token: \"string.regexp\",\n                        regex: \"[/][imx]*(?=[).,;\\\\s]|$)\",\n                        next: \"pop\"\n                    }, {\n                        defaultToken: \"string.regexp\"\n                    }]\n                },\n                [{\n                    regex: \"[{}]\", onMatch: function (val, state, stack) {\n                        this.next = val == \"{\" ? this.nextState : \"\";\n                        if (val == \"{\" && stack.length) {\n                            stack.unshift(\"start\", state);\n                            return \"paren.lparen\";\n                        }\n                        if (val == \"}\" && stack.length) {\n                            stack.shift();\n                            this.next = stack.shift();\n                            if (this.next.indexOf(\"string\") != -1)\n                                return \"paren.end\";\n                        }\n                        return val == \"{\" ? \"paren.lparen\" : \"paren.rparen\";\n                    },\n                    nextState: \"start\"\n                }, {\n                    token: \"string.start\",\n                    regex: /\"/,\n                    push: [{\n                        token: \"constant.language.escape\",\n                        regex: extEscapeExspresssion\n                    }, {\n                        token: \"string\",\n                        regex: /\\\\#{/\n                    }, {\n                        token: \"paren.start\",\n                        regex: /#{/,\n                        push: \"start\"\n                    }, {\n                        token: \"string.end\",\n                        regex: /\"/,\n                        next: \"pop\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    token: \"string.start\",\n                    regex: /`/,\n                    push: [{\n                        token: \"constant.language.escape\",\n                        regex: extEscapeExspresssion\n                    }, {\n                        token: \"string\",\n                        regex: /\\\\#{/\n                    }, {\n                        token: \"paren.start\",\n                        regex: /#{/,\n                        push: \"start\"\n                    }, {\n                        token: \"string.end\",\n                        regex: /`/,\n                        next: \"pop\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    stateName: \"rpstring\",\n                    token: \"string.start\",\n                    regex: /%[Qx]?\\(/,\n                    push: [{\n                        token: \"constant.language.escape\",\n                        regex: extEscapeExspresssion\n                    }, {\n                        token: \"string.start\",\n                        regex: /\\(/,\n                        push: \"rpstring\"\n                    }, {\n                        token: \"string.end\",\n                        regex: /\\)/,\n                        next: \"pop\"\n                    }, {\n                        token: \"paren.start\",\n                        regex: /#{/,\n                        push: \"start\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    stateName: \"spstring\",\n                    token: \"string.start\",\n                    regex: /%[Qx]?\\[/,\n                    push: [{\n                        token: \"constant.language.escape\",\n                        regex: extEscapeExspresssion\n                    }, {\n                        token: \"string.start\",\n                        regex: /\\[/,\n                        push: \"spstring\"\n                    }, {\n                        token: \"string.end\",\n                        regex: /]/,\n                        next: \"pop\"\n                    }, {\n                        token: \"paren.start\",\n                        regex: /#{/,\n                        push: \"start\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    stateName: \"fpstring\",\n                    token: \"string.start\",\n                    regex: /%[Qx]?{/,\n                    push: [{\n                        token: \"constant.language.escape\",\n                        regex: extEscapeExspresssion\n                    }, {\n                        token: \"string.start\",\n                        regex: /{/,\n                        push: \"fpstring\"\n                    }, {\n                        token: \"string.end\",\n                        regex: /}/,\n                        next: \"pop\"\n                    }, {\n                        token: \"paren.start\",\n                        regex: /#{/,\n                        push: \"start\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    stateName: \"tpstring\",\n                    token: \"string.start\",\n                    regex: /%[Qx]?</,\n                    push: [{\n                        token: \"constant.language.escape\",\n                        regex: extEscapeExspresssion\n                    }, {\n                        token: \"string.start\",\n                        regex: /</,\n                        push: \"tpstring\"\n                    }, {\n                        token: \"string.end\",\n                        regex: />/,\n                        next: \"pop\"\n                    }, {\n                        token: \"paren.start\",\n                        regex: /#{/,\n                        push: \"start\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    stateName: \"ppstring\",\n                    token: \"string.start\",\n                    regex: /%[Qx]?\\|/,\n                    push: [{\n                        token: \"constant.language.escape\",\n                        regex: extEscapeExspresssion\n                    }, {\n                        token: \"string.end\",\n                        regex: /\\|/,\n                        next: \"pop\"\n                    }, {\n                        token: \"paren.start\",\n                        regex: /#{/,\n                        push: \"start\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    stateName: \"rpqstring\",\n                    token: \"string.start\",\n                    regex: /%[qwir]\\(/,\n                    push: [{\n                        token: \"string.start\",\n                        regex: /\\(/,\n                        push: \"rpqstring\"\n                    }, {\n                        token: \"string.end\",\n                        regex: /\\)/,\n                        next: \"pop\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    stateName: \"spqstring\",\n                    token: \"string.start\",\n                    regex: /%[qwir]\\[/,\n                    push: [{\n                        token: \"string.start\",\n                        regex: /\\[/,\n                        push: \"spqstring\"\n                    }, {\n                        token: \"string.end\",\n                        regex: /]/,\n                        next: \"pop\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    stateName: \"fpqstring\",\n                    token: \"string.start\",\n                    regex: /%[qwir]{/,\n                    push: [{\n                        token: \"string.start\",\n                        regex: /{/,\n                        push: \"fpqstring\"\n                    }, {\n                        token: \"string.end\",\n                        regex: /}/,\n                        next: \"pop\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    stateName: \"tpqstring\",\n                    token: \"string.start\",\n                    regex: /%[qwir]</,\n                    push: [{\n                        token: \"string.start\",\n                        regex: /</,\n                        push: \"tpqstring\"\n                    }, {\n                        token: \"string.end\",\n                        regex: />/,\n                        next: \"pop\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    stateName: \"ppqstring\",\n                    token: \"string.start\",\n                    regex: /%[qwir]\\|/,\n                    push: [{\n                        token: \"string.end\",\n                        regex: /\\|/,\n                        next: \"pop\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    token: \"string.start\",\n                    regex: /'/,\n                    push: [{\n                        token: \"constant.language.escape\",\n                        regex: escapeExpression\n                    }, {\n                        token: \"string.end\",\n                        regex: /'|$/,\n                        next: \"pop\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }], {\n                    token: \"text\", // namespaces aren't symbols\n                    regex: \"::\"\n                }, {\n                    token: \"variable.instance\", // instance variable\n                    regex: \"@{1,2}[a-zA-Z_\\\\d]+\"\n                }, {\n                    token: \"variable.fresh\", // fresh variable\n                    regex: \"%[a-zA-Z_\\\\d]+\"\n                }, {\n                    token: \"support.class\", // class name\n                    regex: \"[A-Z][a-zA-Z_\\\\d]+\"\n                }, {\n                    token: \"constant.other.symbol\", // symbol\n                    regex: \"[:](?:(?:===|<=>|\\\\[]\\\\?|\\\\[]=|\\\\[]|>>|\\\\*\\\\*|<<|==|!=|>=|<=|!~|=~|<|\\\\+|-|\\\\*|\\\\/|%|&|\\\\||\\\\^|>|!|~)|(?:(?:[A-Za-z_]|[@$](?=[a-zA-Z0-9_]))[a-zA-Z0-9_]*[!=?]?))\"\n                }, {\n                    token: \"constant.numeric\", // float\n                    regex: \"[+-]?\\\\d(?:\\\\d|_(?=\\\\d))*(?:(?:\\\\.\\\\d(?:\\\\d|_(?=\\\\d))*)?(?:[eE][+-]?\\\\d+)?)?(?:_?[fF](?:32|64))?\\\\b\"\n                }, {\n                    token: \"constant.numeric\",\n                    regex: intNumber\n                }, {\n                    token: \"constant.other.symbol\",\n                    regex: ':\"',\n                    push: [{\n                        token: \"constant.language.escape\",\n                        regex: extEscapeExspresssion\n                    }, {\n                        token: \"constant.other.symbol\",\n                        regex: '\"',\n                        next: \"pop\"\n                    }, {\n                        defaultToken: \"constant.other.symbol\"\n                    }]\n                }, {\n                    token: \"constant.language.boolean\",\n                    regex: \"(?:true|false)\\\\b\"\n                }, {\n                    token: \"support.function\",\n                    regex: \"(?:is_a\\\\?|nil\\\\?|responds_to\\\\?|as\\\\?)\"\n                }, {\n                    token: keywordMapper,\n                    regex: \"[a-zA-Z_$][a-zA-Z0-9_$!?]*\\\\b\"\n                }, {\n                    token: \"variable.system\",\n                    regex: \"\\\\$\\\\!|\\\\$\\\\?\"\n                }, {\n                    token: \"punctuation.separator.key-value\",\n                    regex: \"=>\"\n                }, {\n                    stateName: \"heredoc\",\n                    onMatch: function (value, currentState, stack) {\n                        var next = \"heredoc\";\n                        var tokens = value.split(this.splitRegex);\n                        stack.push(next, tokens[3]);\n                        return [\n                            {type: \"constant\", value: tokens[1]},\n                            {type: \"string\", value: tokens[2]},\n                            {type: \"support.class\", value: tokens[3]},\n                            {type: \"string\", value: tokens[4]}\n                        ];\n                    },\n                    regex: \"(<<-)([']?)([\\\\w]+)([']?)\",\n                    rules: {\n                        heredoc: [{\n                            token: \"string\",\n                            regex: \"^ +\"\n                        }, {\n                            onMatch: function (value, currentState, stack) {\n                                if (value === stack[1]) {\n                                    stack.shift();\n                                    stack.shift();\n                                    this.next = stack[0] || \"start\";\n                                    return \"support.class\";\n                                }\n                                this.next = \"\";\n                                return \"string\";\n                            },\n                            regex: \".*$\",\n                            next: \"start\"\n                        }]\n                    }\n                }, {\n                    regex: \"$\",\n                    token: \"empty\",\n                    next: function (currentState, stack) {\n                        if (stack[0] === \"heredoc\")\n                            return stack[0];\n                        return currentState;\n                    }\n                }, {\n                    token: \"punctuation.operator\",\n                    regex: /[.]\\s*(?![.])/,\n                    push: [{\n                        token : \"punctuation.operator\",\n                        regex : /[.]\\s*(?![.])/\n                    }, {\n                        token : \"support.function\",\n                        regex : \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"\n                    }, {\n                        regex: \"\",\n                        token: \"empty\",\n                        next: \"pop\"\n                    }]\n                }, {\n                    token: \"keyword.operator\",\n                    regex: \"!|\\\\$|%|&|\\\\*|\\\\-\\\\-|\\\\-|\\\\+\\\\+|\\\\+|~|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|\\\\?|\\\\:|&&|\\\\|\\\\||\\\\?\\\\:|\\\\*=|%=|\\\\+=|\\\\-=|&=|\\\\^=|\\\\^|\\\\|\"\n                }, {\n                    token: \"punctuation.operator\",\n                    regex: /[?:,;.]/\n                }, {\n                    token: \"paren.lparen\",\n                    regex: \"[[({]\"\n                }, {\n                    token: \"paren.rparen\",\n                    regex: \"[\\\\])}]\"\n                }, {\n                    token: \"text\",\n                    regex: \"\\\\s+\"\n                }\n            ]\n        };\n\n        this.normalizeRules();\n    };\n\n    oop.inherits(CrystalHighlightRules, TextHighlightRules);\n\n    exports.CrystalHighlightRules = CrystalHighlightRules;\n","\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\n\nvar FoldMode = exports.FoldMode = function() {};\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n    this.commentBlock = function(session, row) {\n        var re = /\\S/;\n        var line = session.getLine(row);\n        var startLevel = line.search(re);\n        if (startLevel == -1 || line[startLevel] != \"#\")\n            return;\n\n        var startColumn = line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var level = line.search(re);\n\n            if (level == -1)\n                continue;\n\n            if (line[level] != \"#\")\n                break;\n\n            endRow = row;\n        }\n\n        if (endRow > startRow) {\n            var endColumn = session.getLine(endRow).length;\n            return new Range(startRow, startColumn, endRow, endColumn);\n        }\n    };\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var range = this.indentationBlock(session, row);\n        if (range)\n            return range;\n\n        range = this.commentBlock(session, row);\n        if (range)\n            return range;\n    };\n\n    // must return \"\" if there's no fold, to enable caching\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        var indent = line.search(/\\S/);\n        var next = session.getLine(row + 1);\n        var prev = session.getLine(row - 1);\n        var prevIndent = prev.search(/\\S/);\n        var nextIndent = next.search(/\\S/);\n\n        if (indent == -1) {\n            session.foldWidgets[row - 1] = prevIndent!= -1 && prevIndent < nextIndent ? \"start\" : \"\";\n            return \"\";\n        }\n\n        // documentation comments\n        if (prevIndent == -1) {\n            if (indent == nextIndent && line[indent] == \"#\" && next[indent] == \"#\") {\n                session.foldWidgets[row - 1] = \"\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"start\";\n            }\n        } else if (prevIndent == indent && line[indent] == \"#\" && prev[indent] == \"#\") {\n            if (session.getLine(row - 2).search(/\\S/) == -1) {\n                session.foldWidgets[row - 1] = \"start\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"\";\n            }\n        }\n\n        if (prevIndent!= -1 && prevIndent < indent)\n            session.foldWidgets[row - 1] = \"start\";\n        else\n            session.foldWidgets[row - 1] = \"\";\n\n        if (indent < nextIndent)\n            return \"start\";\n        else\n            return \"\";\n    };\n\n}).call(FoldMode.prototype);\n","\"use strict\";\n\nvar Range = require(\"../range\").Range;\n\nvar MatchingBraceOutdent = function() {};\n\n(function() {\n\n    this.checkOutdent = function(line, input) {\n        if (! /^\\s+$/.test(line))\n            return false;\n\n        return /^\\s*\\}/.test(input);\n    };\n\n    this.autoOutdent = function(doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\})/);\n\n        if (!match) return 0;\n\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n        if (!openBracePos || openBracePos.row == row) return 0;\n\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column-1), indent);\n    };\n\n    this.$getIndent = function(line) {\n        return line.match(/^\\s*/)[0];\n    };\n\n}).call(MatchingBraceOutdent.prototype);\n\nexports.MatchingBraceOutdent = MatchingBraceOutdent;\n"],"names":[],"sourceRoot":""}