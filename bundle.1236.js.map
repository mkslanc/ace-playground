{"version":3,"file":"bundle.1236.js","mappings":";;;;;;AAAa;;AAEb,UAAU,mBAAO,CAAC,IAAY;AAC9B,uBAAuB,8CAAsC;AAC7D,WAAW,mBAAO,CAAC,KAAa;AAChC,eAAe,iCAAsB;AACrC,6BAA6B,4DAA4D;;AAEzF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED,YAAY;;;;;;;;AC5BC;;AAEb,UAAU,mBAAO,CAAC,IAAY;AAC9B,yBAAyB,wDAAoD;AAC7E,yBAAyB,+CAAoD;;AAE7E;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,wBAAwB;AACxB;AACA,SAAS;AACT,aAAa;AACb;AACA,KAAK;AACL;AACA,iBAAiB;AACjB;AACA;AACA,wBAAwB;AACxB;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,aAAa;AACb;AACA,KAAK;AACL;AACA,iBAAiB;AACjB;AACA;AACA,sBAAsB;AACtB;AACA,SAAS;AACT,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,iBAAiB,6DAA6D;AAC9E;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,oCAAoC;AACpC;AACA,qBAAqB;AACrB,yBAAyB;AACzB;AACA,iBAAiB;AACjB,iBAAiB,0BAA0B;AAC3C,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,iBAAiB,6DAA6D;AAC9E;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,oCAAoC;AACpC;AACA,qBAAqB;AACrB,yBAAyB;AACzB;AACA,iBAAiB;AACjB,iBAAiB,0BAA0B;AAC3C,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iBAAiB,yBAAyB;AAC1C,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iBAAiB,yBAAyB;AAC1C,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,yBAAyB;AACzB,SAAS;AACT;AACA,yBAAyB;AACzB,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mCAAmC,EAAE,iBAAiB,EAAE,kBAAkB,EAAE,OAAO,WAAW;AAC9F,SAAS;AACT,KAAK;;AAEL;AACA;;AAEA;;AAEA,SAA8B;;;;;;;;ACrKjB;;AAEb,UAAU,mBAAO,CAAC,IAAe;AACjC,OAAO,yBAAyB,EAAE,mBAAO,CAAC,KAAS;AACnD,mBAAmB,oCAA0B;AAC7C,YAAY,2CAA4B;AACxC,oBAAoB,0CAA6C;;;AAGjE,eAAe,SAAgB;AAC/B;AACA;;AAEA;;AAEA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,oGAAoG;AAChJ,2CAA2C,wFAAwF;;AAEnI;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,CAAC","sources":["webpack://ace-playground/./node_modules/ace-code/src/mode/nunjucks.js","webpack://ace-playground/./node_modules/ace-code/src/mode/nunjucks_highlight_rules.js","webpack://ace-playground/./node_modules/ace-code/src/mode/folding/nunjucks.js"],"sourcesContent":["\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar NunjucksFoldMode = require(\"./folding/nunjucks\").FoldMode;\nvar lang = require(\"../lib/lang\");\nvar HtmlMode = require(\"./html\").Mode;\nvar NunjucksHighlightRules = require(\"./nunjucks_highlight_rules\").NunjucksHighlightRules;\n\n// http://www.w3.org/TR/html5/syntax.html#void-elements\nvar voidElements = [\n    \"area\", \"base\", \"br\", \"col\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"menuitem\", \"param\", \"source\",\n    \"track\", \"wbr\"\n];\nvar optionalEndTags = [\"li\", \"dt\", \"dd\", \"p\", \"rt\", \"rp\", \"optgroup\", \"option\", \"colgroup\", \"td\", \"th\"];\n\nvar Mode = function () {\n    this.HighlightRules = NunjucksHighlightRules;\n    this.foldingRules = new NunjucksFoldMode(this.voidElements, lang.arrayToMap(optionalEndTags));\n};\n\noop.inherits(Mode, HtmlMode);\n\n(function () {\n    this.$id = \"ace/mode/nunjucks\";\n    this.voidElements = lang.arrayToMap(voidElements);\n\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n","\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\nvar HtmlHighlightRules = require(\"./html_highlight_rules\").HtmlHighlightRules;\n\nvar NunjucksHighlightRules = function() {\n    HtmlHighlightRules.call(this);\n    this.$rules[\"start\"].unshift({\n        token: \"punctuation.begin\",\n        regex: /{{-?/,\n        push: [{\n            token: \"punctuation.end\",\n            regex: /-?}}/,\n            next: \"pop\"\n        },\n            {include: \"expression\"}\n        ]\n    }, {\n        token: \"punctuation.begin\",\n        regex: /{%-?/,\n        push: [{\n            token: \"punctuation.end\",\n            regex: /-?%}/,\n            next: \"pop\"\n        }, {\n            token: \"constant.language.escape\",\n            regex: /\\b(r\\/.*\\/[gimy]?)\\b/\n        },\n            {include: \"statement\"}\n        ]\n    }, {\n        token: \"comment.begin\",\n        regex: /{#/,\n        push: [{\n            token: \"comment.end\",\n            regex: /#}/,\n            next: \"pop\"\n        },\n            {defaultToken: \"comment\"}\n        ]\n    });\n    this.addRules({\n        attribute_value: [{\n            token: \"string.attribute-value.xml\",\n            regex: \"'\",\n            push: [\n                {token: \"string.attribute-value.xml\", regex: \"'\", next: \"pop\"},\n                {\n                    token: \"punctuation.begin\",\n                    regex: /{{-?/,\n                    push: [{\n                        token: \"punctuation.end\",\n                        regex: /-?}}/,\n                        next: \"pop\"\n                    },\n                        {include: \"expression\"}\n                    ]\n                },\n                {include: \"attr_reference\"},\n                {defaultToken: \"string.attribute-value.xml\"}\n            ]\n        }, {\n            token: \"string.attribute-value.xml\",\n            regex: '\"',\n            push: [\n                {token: \"string.attribute-value.xml\", regex: '\"', next: \"pop\"},\n                {\n                    token: \"punctuation.begin\",\n                    regex: /{{-?/,\n                    push: [{\n                        token: \"punctuation.end\",\n                        regex: /-?}}/,\n                        next: \"pop\"\n                    },\n                        {include: \"expression\"}\n                    ]\n                },\n                {include: \"attr_reference\"},\n                {defaultToken: \"string.attribute-value.xml\"}\n            ]\n        }],\n        \"statement\": [{\n            token: \"keyword.control\",\n            regex: /\\b(block|endblock|extends|endif|elif|for|endfor|asyncEach|endeach|include|asyncAll|endall|macro|endmacro|set|endset|ignore missing|as|from|raw|verbatim|filter|endfilter)\\b/\n        },\n            {include: \"expression\"}\n        ],\n        \"expression\": [{\n            token: \"constant.language\",\n            regex: /\\b(true|false|none)\\b/\n        }, {\n            token: \"string\",\n            regex: /\"/,\n            push: [{\n                token: \"string\",\n                regex: /\"/,\n                next: \"pop\"\n            },\n                {include: \"escapeStrings\"},\n                {defaultToken: \"string\"}\n            ]\n        }, {\n            token: \"string\",\n            regex: /'/,\n            push: [{\n                token: \"string\",\n                regex: /'/,\n                next: \"pop\"\n            },\n                {include: \"escapeStrings\"},\n                {defaultToken: \"string\"}\n            ]\n        }, {\n            token: \"constant.numeric\", // hexadecimal, octal and binary\n            regex: /0(?:[xX][0-9a-fA-F]+|[oO][0-7]+|[bB][01]+)\\b/\n        }, {\n            token: \"constant.numeric\", // decimal integers and floats\n            regex: /(?:\\d\\d*(?:\\.\\d*)?|\\.\\d+)(?:[eE][+-]?\\d+\\b)?/\n        }, {\n            token: \"keyword.operator\",\n            regex: /\\+|-|\\/\\/|\\/|%|\\*\\*|\\*|===|==|!==|!=|>=|>|<=|</\n        }, {\n            token: \"keyword.control\",\n            regex: /\\b(and|else|if|in|import|not|or)\\b/\n        }, {\n            token: \"support.function\",\n            regex: /[a-zA-Z_]+(?=\\()/\n        }, {\n            token: \"paren.lpar\",\n            regex: /[(\\[{]/\n        }, {\n            token: \"paren.rpar\",\n            regex: /[)\\]}]/\n        }, {\n            token: \"punctuation\",\n            regex: /[,]/\n        }, {\n            token: [\"punctuation\", \"support.function\"],\n            regex: /(\\.)([a-zA-Z_][a-zA-Z0-9_]*)(?=\\()/\n        }, {\n            token: [\"punctuation\", \"variable.parameter\"],\n            regex: /(\\.)([a-zA-Z_][a-zA-Z0-9_]*)/\n        }, {\n            token: [\"punctuation\", \"text\", \"support.other\"],\n            regex: /(\\|)(\\s)*([a-zA-Z_][a-zA-Z0-9_]*)/\n        }, {\n            token: \"variable\",\n            regex: /[a-zA-Z_][a-zA-Z0-9_]*/\n        }\n        ],\n        \"escapeStrings\": [{\n            token: \"constant.language.escape\",\n            regex: /(\\\\\\\\n)|(\\\\\\\\)|(\\\\\")|(\\\\')|(\\\\a)|(\\\\b)|(\\\\f)|(\\\\n)|(\\\\r)|(\\\\t)|(\\\\v)/\n        }, {\n            token: \"constant.language.escape\",\n            regex: /\\\\(?:x[0-9A-F]{2}|(?:U[0-9A-Fa-f]{8})|(?:u[0-9A-Fa-f]{4})|(?:N{[a-zA-Z ]+}))/\n        }]\n    });\n\n    this.normalizeRules();\n};\n\noop.inherits(NunjucksHighlightRules, TextHighlightRules);\n\nexports.NunjucksHighlightRules = NunjucksHighlightRules;\n","\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nconst {FoldMode: MixedFoldMode} = require(\"./mixed\");\nvar HtmlFoldMode = require(\"./html\").FoldMode;\nvar Range = require(\"../../range\").Range;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\n\n\nvar FoldMode = exports.FoldMode = function (voidElements, optionalTags) {\n    HtmlFoldMode.call(this, voidElements, optionalTags);\n};\n\noop.inherits(FoldMode, HtmlFoldMode);\n\n(function () {//TODO: set|endset\n    this.getFoldWidgetRangeBase = this.getFoldWidgetRange;\n    this.getFoldWidgetBase = this.getFoldWidget;\n\n    this.indentKeywords = {\n        \"block\": 1,\n        \"if\": 1,\n        \"for\": 1,\n        \"asyncEach\": 1,\n        \"asyncAll\": 1,\n        \"macro\": 1,\n        \"filter\": 1,\n        \"call\": 1,\n        \"else\": 0,\n        \"elif\": 0,\n        \"set\": 1,\n        \"endblock\": -1,\n        \"endif\": -1,\n        \"endfor\": -1,\n        \"endeach\": -1,\n        \"endall\": -1,\n        \"endmacro\": -1,\n        \"endfilter\": -1,\n        \"endcall\": -1,\n        \"endset\": -1\n    };\n\n    this.foldingStartMarkerNunjucks = /(?:\\{%-?\\s*)(?:(block|if|else|elif|for|asyncEach|asyncAll|macro|filter|call)\\b.*)|(?:\\bset(?:[^=]*))(?=%})/i;\n    this.foldingStopMarkerNunjucks = /(?:\\{%-?\\s*)(endblock|endif|endfor|endeach|endall|endmacro|endfilter|endcall|endset)\\b.*(?=%})/i;\n\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n        var line = session.doc.getLine(row);\n        let offset = calculateOffset(this.foldingStartMarkerNunjucks, line);\n        if (offset) {\n            return this.nunjucksBlock(session, row, offset);\n        }\n\n        offset = calculateOffset(this.foldingStopMarkerNunjucks, line);\n        if (offset) {\n            return this.nunjucksBlock(session, row, offset);\n        }\n        return this.getFoldWidgetRangeBase(session, foldStyle, row);\n    };\n\n    /**\n     *\n     * @param {RegExp} regExp\n     * @param line\n     * @return {*}\n     */\n    function calculateOffset(regExp, line) {\n        var match = regExp.exec(line);\n        if (match) {\n            var keyword = match[0].includes(\"set\") ? \"set\" : match[1].toLowerCase();\n            if (keyword) {\n                var offsetInMatch = match[0].toLowerCase().indexOf(keyword);\n                return match.index + offsetInMatch + 1;\n            }\n        }\n    }\n\n    // must return \"\" if there's no fold, to enable caching\n    this.getFoldWidget = function (session, foldStyle, row) {\n        var line = session.getLine(row);\n        var isStart = this.foldingStartMarkerNunjucks.test(line);\n        var isEnd = this.foldingStopMarkerNunjucks.test(line);\n        if (isStart && !isEnd) {\n            var offset = calculateOffset(this.foldingStartMarkerNunjucks, line);\n            if (offset) {\n                var type = session.getTokenAt(row, offset).type;\n                if (type === \"keyword.control\") {\n                    return \"start\";\n                }\n            }\n        }\n        if (isEnd && !isStart && foldStyle === \"markbeginend\") {\n            var offset = calculateOffset(this.foldingStopMarkerNunjucks, line);\n            if (offset) {\n                var type = session.getTokenAt(row, offset).type;\n                if (type === \"keyword.control\") {\n                    return \"end\";\n                }\n            }\n        }\n        return this.getFoldWidgetBase(session, foldStyle, row);\n    };\n\n    /**\n     *\n     * @param {TokenIterator} stream\n     */\n    function getTokenPosition(stream, findStart) {\n        let token;\n        const currentIndex = stream.$tokenIndex;\n        const type = findStart ? \"punctuation.begin\" : \"punctuation.end\";\n        stream.step = findStart ? stream.stepBackward : stream.stepForward;\n        while (token = stream.step()) {\n            if (token.type !== type) continue;\n            break;\n        }\n        if (!token) return;\n        let pos = stream.getCurrentTokenPosition();\n        if (!findStart) {\n            pos.column = pos.column + token.value.length;\n        }\n        stream.$tokenIndex = currentIndex;\n        return pos;\n    }\n\n    this.nunjucksBlock = function (session, row, column) {\n        var stream = new TokenIterator(session, row, column);\n\n        var token = stream.getCurrentToken();\n        if (!token || token.type != \"keyword.control\") return;\n\n        var val = token.value;\n        var stack = [val];\n        var dir = this.indentKeywords[val];\n\n        if (val === \"else\" || val === \"elif\") {\n            dir = 1;\n        }\n\n        if (!dir) return;\n\n        var start = getTokenPosition(stream, dir === -1);\n\n        if (!token) return;\n\n        stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n        while (token = stream.step()) {\n            if (token.type !== \"keyword.control\") continue;\n            var level = dir * this.indentKeywords[token.value];\n\n            if (token.value === \"set\") {\n                var tokenPos = stream.getCurrentTokenPosition();\n                var line = session.getLine(tokenPos.row).substring(tokenPos.column);\n                if (!/^[^=]*%}/.test(line)) {\n                    continue;\n                }\n            }\n            if (level > 0) {\n                stack.unshift(token.value);\n            }\n            else if (level <= 0) {\n                stack.shift();\n                if (!stack.length) break;\n                if (level === 0) stack.unshift(token.value);\n            }\n        }\n\n        if (!token) return null;\n\n        var end = getTokenPosition(stream, dir === 1);\n        return dir === 1 ? Range.fromPoints(start, end) : Range.fromPoints(end, start);\n    };\n\n}).call(FoldMode.prototype);\n"],"names":[],"sourceRoot":""}