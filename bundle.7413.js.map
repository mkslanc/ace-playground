{"version":3,"file":"bundle.7413.js","mappings":";;;;;;AAAa;;AAEb;AACA;AACA,eAAe,qDAAqD;AACpE;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA,eAAe,sDAAsD;AACrE;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED,aAAa,mCAA2B;AACxC,0CAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,wCAAwC;AACnD,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,wCAAwC,qBAAqB;AAC7D;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB,WAAW,+CAA+C;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,WAAW,+CAA+C;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://ace-playground/./node_modules/ace-code/src/ext/rtl.js"],"sourcesContent":["\"use strict\";\n\nvar commands = [{\n    name: \"leftToRight\",\n    bindKey: { win: \"Ctrl-Alt-Shift-L\", mac: \"Command-Alt-Shift-L\" },\n    exec: function(editor) {\n        editor.session.$bidiHandler.setRtlDirection(editor, false);\n    },\n    readOnly: true\n}, {\n    name: \"rightToLeft\",\n    bindKey: { win: \"Ctrl-Alt-Shift-R\",  mac: \"Command-Alt-Shift-R\" },\n    exec: function(editor) {\n        editor.session.$bidiHandler.setRtlDirection(editor, true);\n    },\n    readOnly: true\n}];\n\nvar Editor = require(\"../editor\").Editor;\nrequire(\"../config\").defineOptions(Editor.prototype, \"editor\", {\n    rtlText: {\n        set: function(val) {\n            if (val) {\n                this.on(\"change\", onChange);\n                this.on(\"changeSelection\", onChangeSelection);\n                this.renderer.on(\"afterRender\", updateLineDirection);\n                this.commands.on(\"exec\", onCommandEmitted);\n                this.commands.addCommands(commands);\n            } else {\n                this.off(\"change\", onChange);\n                this.off(\"changeSelection\", onChangeSelection);\n                this.renderer.off(\"afterRender\", updateLineDirection);\n                this.commands.off(\"exec\", onCommandEmitted);\n                this.commands.removeCommands(commands);\n                clearTextLayer(this.renderer);\n            }\n            this.renderer.updateFull();\n        }\n    },\n    rtl: {\n        set: function(val) {\n            this.session.$bidiHandler.$isRtl = val;\n            if (val) {\n                this.setOption(\"rtlText\", false);\n                this.renderer.on(\"afterRender\", updateLineDirection);\n                this.session.$bidiHandler.seenBidi = true;\n            } else {\n                this.renderer.off(\"afterRender\", updateLineDirection);\n                clearTextLayer(this.renderer);\n            }\n            this.renderer.updateFull();\n        }\n    }\n});\n\n/**\n * Whenever the selection is changed, prevent cursor (lead) to be positioned at\n * position 0 of right-to-left line in order to maintain the RLE marker at this position.\n * When cursor reaches position 0, either advance it to position 1 of current line (default) \n * or to last position of previous line (if it comes from position 1 as the result of commands\n * mentioned in 'onCommandEmitted' event handler).\n * This serves few purposes:\n * - ensures cursor visual movement as if RLE mark doesn't exist.\n * - prevents character insertion before RLE mark.\n * - prevents RLE mark removal when 'delete' is pressed when cursot stays at position 0.         \n * - ensures RLE mark removal on line merge, when 'delete' is pressed and cursor stays \n *   at last position of previous line and when 'backspace' is pressed and cursor  stays at\n *   first position of current line. This is achived by hacking range boundaries on 'remove' operation.\n * @param {any} e\n * @param {Editor} editor\n */\nfunction onChangeSelection(e, editor) {\n    var lead = editor.getSelection().lead;\n    if (editor.session.$bidiHandler.isRtlLine(lead.row)) {\n        if (lead.column === 0) {\n            if (editor.session.$bidiHandler.isMoveLeftOperation && lead.row > 0) {\n                editor.getSelection().moveCursorTo(lead.row - 1, editor.session.getLine(lead.row - 1).length);\n            } else {\n                if (editor.getSelection().isEmpty())\n                    lead.column += 1;\n                else\n                    lead.setPosition(lead.row, lead.column + 1);\n            }\n        }\n    }\n}\n\nfunction onCommandEmitted(commadEvent) {\n    commadEvent.editor.session.$bidiHandler.isMoveLeftOperation = /gotoleft|selectleft|backspace|removewordleft/.test(commadEvent.command.name);\n}\n\n/**\n * Whenever the document is changed make sure that line break operatin\n * on right-to-left line (like pressing Enter or pasting multi-line text)\n * produces new right-to-left lines\n * @param {import(\"../../ace-internal\").Ace.Delta} delta\n * @param {Editor} editor\n */\nfunction onChange(delta, editor) {\n    var session = editor.session;\n    session.$bidiHandler.currentRow = null;\n    if (session.$bidiHandler.isRtlLine(delta.start.row) && delta.action === 'insert' && delta.lines.length > 1) {\n        for (var row = delta.start.row; row < delta.end.row; row++) {\n            if (session.getLine(row + 1).charAt(0) !== session.$bidiHandler.RLE)\n                session.doc.$lines[row + 1] = session.$bidiHandler.RLE + session.getLine(row + 1);\n        }\n    }\n}\n\n/**\n * @param {any} e\n * @param {import(\"../virtual_renderer\").VirtualRenderer} renderer\n */\nfunction updateLineDirection(e, renderer) {\n    var session = renderer.session;\n    var $bidiHandler = session.$bidiHandler;\n    var cells = renderer.$textLayer.$lines.cells;\n    var width = renderer.layerConfig.width - renderer.layerConfig.padding + \"px\";\n    cells.forEach(function(cell) {\n        var style = cell.element.style;\n        if ($bidiHandler && $bidiHandler.isRtlLine(cell.row)) {\n            style.direction = \"rtl\";\n            style.textAlign = \"right\";\n            style.width = width;\n        } else {\n            style.direction = \"\";\n            style.textAlign = \"\";\n            style.width = \"\";\n        }\n    });\n}\n\n/**\n * @param {import(\"../virtual_renderer\").VirtualRenderer} renderer\n */\nfunction clearTextLayer(renderer) {\n    var lines = renderer.$textLayer.$lines;\n    lines.cells.forEach(clear);\n    lines.cellCache.forEach(clear);\n    function clear(cell) {\n        var style = cell.element.style;\n        style.direction = style.textAlign = style.width = \"\";\n    }\n}\n"],"names":[],"sourceRoot":""}