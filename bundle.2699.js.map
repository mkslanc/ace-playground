{"version":3,"file":"bundle.2699.js","mappings":";;;;;;AAAa;;AAEb,UAAU,mBAAO,CAAC,IAAe;AACjC,gBAAgB,+CAAiC;AACjD,sBAAsB,qDAAmC;AACzD,oBAAoB,mDAA6C;;AAEjE;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,uBAAuB;AACvB;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,SAAoB;;;;;;;;ACzFP;;AAEb,UAAU,mBAAO,CAAC,IAAe;AACjC,YAAY,2CAA4B;AACxC,mBAAmB,qCAA+B;;AAElD,eAAe,SAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,UAAU;AAC7C,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;;;;;;AC9JY;;AAEb,YAAY,mCAA2B;;AAEvC,UAAU,mBAAO,CAAC,IAAY;AAC9B,WAAW,mBAAO,CAAC,KAAa;AAChC,yBAAyB,wDAAoD;AAC7E,yBAAyB,+CAAoD;;AAE7E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT,oBAAoB,IAAI;AACxB;AACA,KAAK;AACL;AACA,MAAM;AACN;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA,oBAAoB,IAAI,aAAa,GAAG,WAAW,GAAG,WAAW,GAAG;AACpE;AACA,KAAK,IAAI;AACT;AACA,sBAAsB,IAAI;AAC1B;AACA,KAAK;AACL;AACA,KAAK;;AAEL;AACA;AACA;AACA,+BAA+B;AAC/B,SAAS,IAAI;AACb;AACA;AACA,SAAS,IAAI;AACb;AACA,2BAA2B,IAAI;AAC/B,SAAS,IAAI;AACb;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA,0BAA0B,EAAE,KAAK,EAAE;AACnC,SAAS,IAAI;AACb;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,aAAa,wCAAwC,EAAE,yBAAyB;AAChF,aAAa,uDAAuD;AACpE,aAAa;AACb;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,SAAS;;AAET,0BAA0B;AAC1B;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA,0BAA0B,IAAI;AAC9B;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,UAAU;;AAEV,2BAA2B;AAC3B;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,UAAU;;AAEV;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,SAA8B;;;;;;;;AC5LjB;;AAEb,UAAU,mBAAO,CAAC,IAAY;AAC9B,eAAe,iCAAsB;AACrC,yBAAyB,wDAAoD;AAC7E,2BAA2B,iDAAwD;AACnF,mBAAmB,kDAAuC;AAC1D,qBAAqB,8CAAoC;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED,YAAY;;;;;;;;AClDC;;AAEb,SAA0B;;AAE1B,UAAU,mBAAO,CAAC,IAAY;AAC9B,WAAW,mBAAO,CAAC,KAAa;AAChC,kBAAkB,wDAAoD;AACtE,kBAAkB,qDAAgE;AAClF,kBAAkB,8CAAkD;AACpE,kBAAkB,4DAA4D;AAC9E,kBAAkB,+CAAoD;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,EAAE;AACtC,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,EAAE;AACxC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnRa;;AAEb,YAAY,2CAAyB;;AAErC;;AAEA;;AAEA;AACA;AACA;;AAEA,sBAAsB;AACtB;;AAEA;AACA;AACA,uCAAuC;;AAEvC;;AAEA;AACA,oDAAoD,yBAAyB;;AAE7E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED,4BAA4B","sources":["webpack://ace-playground/./node_modules/ace-code/src/mode/behaviour/css.js","webpack://ace-playground/./node_modules/ace-code/src/mode/folding/cstyle.js","webpack://ace-playground/./node_modules/ace-code/src/mode/markdown_highlight_rules.js","webpack://ace-playground/./node_modules/ace-code/src/mode/mask.js","webpack://ace-playground/./node_modules/ace-code/src/mode/mask_highlight_rules.js","webpack://ace-playground/./node_modules/ace-code/src/mode/matching_brace_outdent.js"],"sourcesContent":["\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar Behaviour = require(\"../behaviour\").Behaviour;\nvar CstyleBehaviour = require(\"./cstyle\").CstyleBehaviour;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\n\nvar CssBehaviour = function () {\n\n    this.inherit(CstyleBehaviour);\n\n    this.add(\"colon\", \"insertion\", function (state, action, editor, session, text) {\n        if (text === ':' && editor.selection.isEmpty()) {\n            var cursor = editor.getCursorPosition();\n            var iterator = new TokenIterator(session, cursor.row, cursor.column);\n            var token = iterator.getCurrentToken();\n            if (token && token.value.match(/\\s+/)) {\n                token = iterator.stepBackward();\n            }\n            if (token && token.type === 'support.type') {\n                var line = session.doc.getLine(cursor.row);\n                var rightChar = line.substring(cursor.column, cursor.column + 1);\n                if (rightChar === ':') {\n                    return {\n                       text: '',\n                       selection: [1, 1]\n                    };\n                }\n                if (/^(\\s+[^;]|\\s*$)/.test(line.substring(cursor.column))) {\n                    return {\n                       text: ':;',\n                       selection: [1, 1]\n                    };\n                }\n            }\n        }\n    });\n\n    this.add(\"colon\", \"deletion\", function (state, action, editor, session, range) {\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && selected === ':') {\n            var cursor = editor.getCursorPosition();\n            var iterator = new TokenIterator(session, cursor.row, cursor.column);\n            var token = iterator.getCurrentToken();\n            if (token && token.value.match(/\\s+/)) {\n                token = iterator.stepBackward();\n            }\n            if (token && token.type === 'support.type') {\n                var line = session.doc.getLine(range.start.row);\n                var rightChar = line.substring(range.end.column, range.end.column + 1);\n                if (rightChar === ';') {\n                    range.end.column ++;\n                    return range;\n                }\n            }\n        }\n    });\n\n    this.add(\"semicolon\", \"insertion\", function (state, action, editor, session, text) {\n        if (text === ';' && editor.selection.isEmpty()) {\n            var cursor = editor.getCursorPosition();\n            var line = session.doc.getLine(cursor.row);\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar === ';') {\n                return {\n                   text: '',\n                   selection: [1, 1]\n                };\n            }\n        }\n    });\n\n    this.add(\"!important\", \"insertion\", function (state, action, editor, session, text) {\n        if (text === '!' && editor.selection.isEmpty()) {\n            var cursor = editor.getCursorPosition();\n            var line = session.doc.getLine(cursor.row);\n\n            if (/^\\s*(;|}|$)/.test(line.substring(cursor.column))) {\n                return {\n                    text: '!important',\n                    selection: [10, 10]\n                };\n            }\n        }\n    });\n\n};\noop.inherits(CssBehaviour, CstyleBehaviour);\n\nexports.CssBehaviour = CssBehaviour;\n","\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar Range = require(\"../../range\").Range;\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\n\nvar FoldMode = exports.FoldMode = function(commentRegex) {\n    if (commentRegex) {\n        this.foldingStartMarker = new RegExp(\n            this.foldingStartMarker.source.replace(/\\|[^|]*?$/, \"|\" + commentRegex.start)\n        );\n        this.foldingStopMarker = new RegExp(\n            this.foldingStopMarker.source.replace(/\\|[^|]*?$/, \"|\" + commentRegex.end)\n        );\n    }\n};\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n    \n    this.foldingStartMarker = /([\\{\\[\\(])[^\\}\\]\\)]*$|^\\s*(\\/\\*)/;\n    this.foldingStopMarker = /^[^\\[\\{\\(]*([\\}\\]\\)])|^[\\s\\*]*(\\*\\/)/;\n    this.singleLineBlockCommentRe= /^\\s*(\\/\\*).*\\*\\/\\s*$/;\n    this.tripleStarBlockCommentRe = /^\\s*(\\/\\*\\*\\*).*\\*\\/\\s*$/;\n    this.startRegionRe = /^\\s*(\\/\\*|\\/\\/)#?region\\b/;\n    \n    //prevent naming conflict with any modes that inherit from cstyle and override this (like csharp)\n    this._getFoldWidgetBase = this.getFoldWidget;\n    \n    /**\n     * Gets fold widget with some non-standard extras:\n     *\n     * @example lineCommentRegionStart\n     *      //#region [optional description]\n     *\n     * @example blockCommentRegionStart\n     *      /*#region [optional description] *[/]\n     *\n     * @example tripleStarFoldingSection\n     *      /*** this folds even though 1 line because it has 3 stars ***[/]\n     * \n     * @note the pound symbol for region tags is optional\n     */\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n    \n        if (this.singleLineBlockCommentRe.test(line)) {\n            // No widget for single line block comment unless region or triple star\n            if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))\n                return \"\";\n        }\n    \n        var fw = this._getFoldWidgetBase(session, foldStyle, row);\n    \n        if (!fw && this.startRegionRe.test(line))\n            return \"start\"; // lineCommentRegionStart\n    \n        return fw;\n    };\n\n    this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {\n        var line = session.getLine(row);\n        \n        if (this.startRegionRe.test(line))\n            return this.getCommentRegionBlock(session, line, row);\n        \n        var match = line.match(this.foldingStartMarker);\n        if (match) {\n            var i = match.index;\n\n            if (match[1])\n                return this.openingBracketBlock(session, match[1], row, i);\n                \n            var range = session.getCommentFoldRange(row, i + match[0].length, 1);\n            \n            if (range && !range.isMultiLine()) {\n                if (forceMultiline) {\n                    range = this.getSectionRange(session, row);\n                } else if (foldStyle != \"all\")\n                    range = null;\n            }\n            \n            return range;\n        }\n\n        if (foldStyle === \"markbegin\")\n            return;\n\n        var match = line.match(this.foldingStopMarker);\n        if (match) {\n            var i = match.index + match[0].length;\n\n            if (match[1])\n                return this.closingBracketBlock(session, match[1], row, i);\n\n            return session.getCommentFoldRange(row, i, -1);\n        }\n    };\n    \n    this.getSectionRange = function(session, row) {\n        var line = session.getLine(row);\n        var startIndent = line.search(/\\S/);\n        var startRow = row;\n        var startColumn = line.length;\n        row = row + 1;\n        var endRow = row;\n        var maxRow = session.getLength();\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var indent = line.search(/\\S/);\n            if (indent === -1)\n                continue;\n            if  (startIndent > indent)\n                break;\n            var subRange = this.getFoldWidgetRange(session, \"all\", row);\n            \n            if (subRange) {\n                if (subRange.start.row <= startRow) {\n                    break;\n                } else if (subRange.isMultiLine()) {\n                    row = subRange.end.row;\n                } else if (startIndent == indent) {\n                    break;\n                }\n            }\n            endRow = row;\n        }\n        \n        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);\n    };\n    \n    /**\n     * gets comment region block with end region assumed to be start of comment in any cstyle mode or SQL mode (--) which inherits from this.\n     * There may optionally be a pound symbol before the region/endregion statement\n     */\n    this.getCommentRegionBlock = function(session, line, row) {\n        var startColumn = line.search(/\\s*$/);\n        var maxRow = session.getLength();\n        var startRow = row;\n        \n        var re = /^\\s*(?:\\/\\*|\\/\\/|--)#?(end)?region\\b/;\n        var depth = 1;\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var m = re.exec(line);\n            if (!m) continue;\n            if (m[1]) depth--;\n            else depth++;\n\n            if (!depth) break;\n        }\n\n        var endRow = row;\n        if (endRow > startRow) {\n            return new Range(startRow, startColumn, endRow, line.length);\n        }\n    };\n\n}).call(FoldMode.prototype);\n","\"use strict\";\n\nvar modes = require(\"../config\").$modes;\n\nvar oop = require(\"../lib/oop\");\nvar lang = require(\"../lib/lang\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\nvar HtmlHighlightRules = require(\"./html_highlight_rules\").HtmlHighlightRules;\n\nvar escaped = function(ch) {\n    return \"(?:[^\" + lang.escapeRegExp(ch) + \"\\\\\\\\]|\\\\\\\\.)*\";\n};\n\nvar MarkdownHighlightRules = function() {\n    HtmlHighlightRules.call(this);\n    // regexp must not have capturing parentheses\n    // regexps are ordered -> the first match is used\n    var codeBlockStartRule = {\n        token : \"support.function\",\n        regex : /^\\s*(```+[^`]*|~~~+[^~]*)$/,\n        onMatch: function(value, state, stack, line) {\n            var m = value.match(/^(\\s*)([`~]+)(.*)/);\n            var language = /[\\w-]+|$/.exec(m[3])[0];\n            // TODO lazy-load modes\n            if (!modes[language])\n                language = \"\";\n            stack.unshift(\"githubblock\", [], [m[1], m[2], language], state);\n            return this.token;\n        },\n        next  : \"githubblock\"\n    };\n    var codeBlockRules = [{\n        token : \"support.function\",\n        regex : \".*\",\n        onMatch: function(value, state, stack, line) {\n            var embedState = stack[1];\n            var indent = stack[2][0];\n            var endMarker = stack[2][1];\n            var language = stack[2][2];\n            \n            var m = /^(\\s*)(`+|~+)\\s*$/.exec(value);\n            if (\n                m && m[1].length < indent.length + 3\n                && m[2].length >= endMarker.length && m[2][0] == endMarker[0]\n            ) {\n                stack.splice(0, 3);\n                this.next = stack.shift();\n                return this.token;\n            }\n            this.next = \"\";\n            if (language && modes[language]) {\n                var data = modes[language].getTokenizer().getLineTokens(value, embedState.slice(0));\n                stack[1] = data.state;\n                return data.tokens;\n            }\n            return this.token;\n        }\n    }];\n\n    this.$rules[\"start\"].unshift({\n        token : \"empty_line\",\n        regex : '^$',\n        next: \"allowBlock\"\n    }, { // h1\n        token: \"markup.heading.1\",\n        regex: \"^=+(?=\\\\s*$)\"\n    }, { // h2\n        token: \"markup.heading.2\",\n        regex: \"^\\\\-+(?=\\\\s*$)\"\n    }, {\n        token : function(value) {\n            return \"markup.heading.\" + value.length;\n        },\n        regex : /^#{1,6}(?=\\s|$)/,\n        next : \"header\"\n    },\n    codeBlockStartRule,\n    { // block quote\n        token : \"string.blockquote\",\n        regex : \"^\\\\s*>\\\\s*(?:[*+-]|\\\\d+\\\\.)?\\\\s+\",\n        next  : \"blockquote\"\n    }, { // HR * - _\n        token : \"constant\",\n        regex : \"^ {0,3}(?:(?:\\\\* ?){3,}|(?:\\\\- ?){3,}|(?:\\\\_ ?){3,})\\\\s*$\",\n        next: \"allowBlock\"\n    }, { // list\n        token : \"markup.list\",\n        regex : \"^\\\\s{0,3}(?:[*+-]|\\\\d+\\\\.)\\\\s+\",\n        next  : \"listblock-start\"\n    }, {\n        include : \"basic\"\n    });\n\n    this.addRules({\n        \"basic\" : [{\n            token : \"constant.language.escape\",\n            regex : /\\\\[\\\\`*_{}\\[\\]()#+\\-.!]/\n        }, { // code span `\n            token : \"support.function\",\n            regex : \"(`+)(.*?[^`])(\\\\1)\"\n        }, { // reference\n            token : [\"text\", \"constant\", \"text\", \"url\", \"string\", \"text\"],\n            regex : \"^([ ]{0,3}\\\\[)([^\\\\]]+)(\\\\]:\\\\s*)([^ ]+)(\\\\s*(?:[\\\"][^\\\"]+[\\\"])?(\\\\s*))$\"\n        }, { // link by reference\n            token : [\"text\", \"string\", \"text\", \"constant\", \"text\"],\n            regex : \"(\\\\[)(\" + escaped(\"]\") + \")(\\\\]\\\\s*\\\\[)(\"+ escaped(\"]\") + \")(\\\\])\"\n        }, { // link by url\n            token : [\"text\", \"string\", \"text\", \"markup.underline\", \"string\", \"text\"],\n            regex : \"(\\\\!?\\\\[)(\" +                                        // [\n                    escaped(\"]\") +                                    // link text or alt text\n                    \")(\\\\]\\\\()\"+                                      // ](\n                    '((?:[^\\\\)\\\\s\\\\\\\\]|\\\\\\\\.|\\\\s(?=[^\"]))*)' +        // href or image\n                    '(\\\\s*\"' +  escaped('\"') + '\"\\\\s*)?' +            // \"title\"\n                    \"(\\\\))\"                                           // )\n        }, { // strong ** __\n            token : \"string.strong\",\n            regex : \"([*]{2}|[_]{2}(?=\\\\S))(.*?\\\\S[*_]*)(\\\\1)\"\n        }, { // emphasis * _\n            token : \"string.emphasis\",\n            regex : \"([*]|[_](?=\\\\S))(.*?\\\\S[*_]*)(\\\\1)\"\n        }, { //\n            token : [\"text\", \"url\", \"text\"],\n            regex : \"(<)(\"+\n                      \"(?:https?|ftp|dict):[^'\\\">\\\\s]+\"+\n                      \"|\"+\n                      \"(?:mailto:)?[-.\\\\w]+\\\\@[-a-z0-9]+(?:\\\\.[-a-z0-9]+)*\\\\.[a-z]+\"+\n                    \")(>)\"\n        }],\n\n        // code block\n        \"allowBlock\": [\n            {token : \"support.function\", regex : \"^ {4}.+\", next : \"allowBlock\"},\n            {token : \"empty_line\", regex : '^$', next: \"allowBlock\"},\n            {token : \"empty\", regex : \"\", next : \"start\"}\n        ],\n\n        \"header\" : [{\n            regex: \"$\",\n            next : \"start\"\n        }, {\n            include: \"basic\"\n        }, {\n            defaultToken : \"heading\"\n        } ],\n\n        \"listblock-start\" : [{\n            token : \"support.variable\",\n            regex : /(?:\\[[ x]\\])?/,\n            next  : \"listblock\"\n        }],\n\n        \"listblock\" : [ { // Lists only escape on completely blank lines.\n            token : \"empty_line\",\n            regex : \"^$\",\n            next  : \"start\"\n        }, { // list\n            token : \"markup.list\",\n            regex : \"^\\\\s{0,3}(?:[*+-]|\\\\d+\\\\.)\\\\s+\",\n            next  : \"listblock-start\"\n        }, {\n            include : \"basic\", noEscape: true\n        },\n        codeBlockStartRule,\n        {\n            defaultToken : \"list\" //do not use markup.list to allow stling leading `*` differntly\n        } ],\n\n        \"blockquote\" : [ { // Blockquotes only escape on blank lines.\n            token : \"empty_line\",\n            regex : \"^\\\\s*$\",\n            next  : \"start\"\n        }, { // block quote\n            token : \"string.blockquote\",\n            regex : \"^\\\\s*>\\\\s*(?:[*+-]|\\\\d+\\\\.)?\\\\s+\",\n            next  : \"blockquote\"\n        }, {\n            include : \"basic\", noEscape: true\n        }, {\n            defaultToken : \"string.blockquote\"\n        } ],\n\n        \"githubblock\" : codeBlockRules\n    });\n\n    this.normalizeRules();\n};\noop.inherits(MarkdownHighlightRules, TextHighlightRules);\n\nexports.MarkdownHighlightRules = MarkdownHighlightRules;\n","\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar MaskHighlightRules = require(\"./mask_highlight_rules\").MaskHighlightRules;\nvar MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\nvar CssBehaviour = require(\"./behaviour/css\").CssBehaviour;\nvar CStyleFoldMode = require(\"./folding/cstyle\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = MaskHighlightRules;\n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = new CssBehaviour();\n    this.foldingRules = new CStyleFoldMode();\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n   \n    this.lineCommentStart = \"//\";\n    this.blockComment = {start: \"/*\", end: \"*/\"};\n\n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n\n        // ignore braces in comments\n        var tokens = this.getTokenizer().getLineTokens(line, state).tokens;\n        if (tokens.length && tokens[tokens.length-1].type == \"comment\") {\n            return indent;\n        }\n\n        var match = line.match(/^.*\\{\\s*$/);\n        if (match) {\n            indent += tab;\n        }\n\n        return indent;\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return this.$outdent.checkOutdent(line, input);\n    };\n\n    this.autoOutdent = function(state, doc, row) {\n        this.$outdent.autoOutdent(doc, row);\n    };\n\n    this.$id = \"ace/mode/mask\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n","\"use strict\";\n\nexports.MaskHighlightRules = MaskHighlightRules;\n\nvar oop = require(\"../lib/oop\");\nvar lang = require(\"../lib/lang\");\nvar TextRules   = require(\"./text_highlight_rules\").TextHighlightRules;\nvar JSRules     = require(\"./javascript_highlight_rules\").JavaScriptHighlightRules;\nvar CssRules    = require(\"./css_highlight_rules\").CssHighlightRules;\nvar MDRules     = require(\"./markdown_highlight_rules\").MarkdownHighlightRules;\nvar HTMLRules   = require(\"./html_highlight_rules\").HtmlHighlightRules;\n\nvar token_TAG       = \"keyword.support.constant.language\",\n    token_COMPO     = \"support.function.markup.bold\",\n    token_KEYWORD   = \"keyword\",\n    token_LANG      = \"constant.language\",\n    token_UTIL      = \"keyword.control.markup.italic\",\n    token_ATTR      = \"support.variable.class\",\n    token_PUNKT     = \"keyword.operator\",\n    token_ITALIC    = \"markup.italic\",\n    token_BOLD      = \"markup.bold\",\n    token_LPARE     = \"paren.lparen\",\n    token_RPARE     = \"paren.rparen\";\n\nvar const_FUNCTIONS,\n    const_KEYWORDS,\n    const_CONST,\n    const_TAGS;\n(function(){\n    const_FUNCTIONS = lang.arrayToMap(\n        (\"log\").split(\"|\")\n    );\n    const_CONST = lang.arrayToMap(\n        (\":dualbind|:bind|:import|slot|event|style|html|markdown|md\").split(\"|\")\n    );\n    const_KEYWORDS = lang.arrayToMap(\n        (\"debugger|define|var|if|each|for|of|else|switch|case|with|visible|+if|+each|+for|+switch|+with|+visible|include|import\").split(\"|\")\n    );\n    const_TAGS = lang.arrayToMap(\n        (\"a|abbr|acronym|address|applet|area|article|aside|audio|b|base|basefont|bdo|\" + \n         \"big|blockquote|body|br|button|canvas|caption|center|cite|code|col|colgroup|\" + \n         \"command|datalist|dd|del|details|dfn|dir|div|dl|dt|em|embed|fieldset|\" + \n         \"figcaption|figure|font|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|\" + \n         \"header|hgroup|hr|html|i|iframe|img|input|ins|keygen|kbd|label|legend|li|\" + \n         \"link|map|mark|menu|meta|meter|nav|noframes|noscript|object|ol|optgroup|\" + \n         \"option|output|p|param|pre|progress|q|rp|rt|ruby|s|samp|script|section|select|\" + \n         \"small|source|span|strike|strong|style|sub|summary|sup|table|tbody|td|\" + \n         \"textarea|tfoot|th|thead|time|title|tr|tt|u|ul|var|video|wbr|xmp\").split(\"|\")\n    );\n}());\n\nfunction MaskHighlightRules () {\n\n    this.$rules = {\n        \"start\" : [\n            Token(\"comment\", \"\\\\/\\\\/.*$\"),\n            Token(\"comment\", \"\\\\/\\\\*\", [\n                Token(\"comment\", \".*?\\\\*\\\\/\", \"start\"),\n                Token(\"comment\", \".+\")\n            ]),\n            \n            Blocks.string(\"'''\"),\n            Blocks.string('\"\"\"'),\n            Blocks.string('\"'),\n            Blocks.string(\"'\"),\n            \n            Blocks.syntax(/(markdown|md)\\b/, \"md-multiline\", \"multiline\"),\n            Blocks.syntax(/html\\b/, \"html-multiline\", \"multiline\"),\n            Blocks.syntax(/(slot|event)\\b/, \"js-block\", \"block\"),\n            Blocks.syntax(/style\\b/, \"css-block\", \"block\"),\n            Blocks.syntax(/var\\b/, \"js-statement\", \"attr\"),\n            \n            Blocks.tag(),\n            \n            Token(token_LPARE, \"[[({>]\"),\n            Token(token_RPARE, \"[\\\\])};]\", \"start\"),\n            {\n                caseInsensitive: true\n            }\n        ]\n    };\n    var rules = this;\n    \n    addJavaScript(\"interpolation\", /\\]/, token_RPARE + \".\" + token_ITALIC);\n    addJavaScript(\"statement\", /\\)|}|;/);\n    addJavaScript(\"block\", /\\}/);\n    addCss();\n    addMarkdown();\n    addHtml();\n    \n    function addJavaScript(name, escape, closeType) {\n        var prfx  =  \"js-\" + name + \"-\",\n            rootTokens = name === \"block\" ? [\"start\"] : [\"start\", \"no_regex\"];\n        add(\n            JSRules\n            , prfx\n            , escape\n            , rootTokens\n            , closeType\n        );\n    }\n    function addCss() {\n        add(CssRules, \"css-block-\", /\\}/);\n    }\n    function addMarkdown() {\n        add(MDRules, \"md-multiline-\", /(\"\"\"|''')/, []);\n    }\n    function addHtml() {\n        add(HTMLRules, \"html-multiline-\", /(\"\"\"|''')/);\n    }\n    function add(Rules, strPrfx, rgxEnd, rootTokens, closeType) {\n        var next = \"pop\";\n        var tokens = rootTokens || [ \"start\" ];\n        if (tokens.length === 0) {\n            tokens = null;\n        }\n        if (/block|multiline/.test(strPrfx)) {\n            next = strPrfx + \"end\";\n            rules.$rules[next] = [\n                Token(\"empty\", \"\", \"start\")\n            ];\n        }\n        rules.embedRules(\n            Rules\n            , strPrfx\n            , [ Token(closeType || token_RPARE, rgxEnd, next) ]\n            , tokens\n            , tokens == null ? true : false\n        );\n    }\n\n    this.normalizeRules();\n}\noop.inherits(MaskHighlightRules, TextRules);\n\nvar Blocks = {\n    string: function(str, next){\n        var token = Token(\n            \"string.start\"\n            , str\n            , [\n                Token(token_LPARE + \".\" + token_ITALIC, /~\\[/, Blocks.interpolation()),\n                Token(\"string.end\", str, \"pop\"),\n                {\n                    defaultToken: \"string\"\n                }\n            ]\n            , next\n        );\n        if (str.length === 1){\n            var escaped = Token(\"string.escape\", \"\\\\\\\\\" + str);\n            token.push.unshift(escaped);\n        }\n        return token;\n    },\n    interpolation: function(){\n        return [\n            Token(token_UTIL, /\\s*\\w*\\s*:/),\n            \"js-interpolation-start\"\n        ];\n    },\n    tagHead: function (rgx) {\n      return Token(token_ATTR, rgx, [\n            Token(token_ATTR, /[\\w\\-_]+/),\n            Token(token_LPARE + \".\" + token_ITALIC, /~\\[/, Blocks.interpolation()),\n            Blocks.goUp()\n        ]);\n    },\n    tag: function () {\n        return {\n            token: 'tag',\n            onMatch :  function(value) {\n                if (void 0 !== const_KEYWORDS[value])\n                    return token_KEYWORD;\n                if (void 0 !== const_CONST[value])\n                    return token_LANG;\n                if (void 0 !== const_FUNCTIONS[value])\n                    return \"support.function\";\n                if (void 0 !== const_TAGS[value.toLowerCase()])\n                    return token_TAG;\n                \n                return token_COMPO;\n            },\n            regex : /([@\\w\\-_:+]+)|((^|\\s)(?=\\s*(\\.|#)))/,\n            push: [\n                Blocks.tagHead(/\\./) ,\n                Blocks.tagHead(/#/) ,\n                Blocks.expression(),\n                Blocks.attribute(),\n                \n                Token(token_LPARE, /[;>{]/, \"pop\")\n            ]\n        };\n    },\n    syntax: function(rgx, next, type){\n        return {\n            token: token_LANG,\n            regex : rgx,\n            push: ({\n                \"attr\": [\n                    next + \"-start\",\n                    Token(token_PUNKT, /;/, \"start\")\n                ],\n                \"multiline\": [\n                    Blocks.tagHead(/\\./) ,\n                    Blocks.tagHead(/#/) ,\n                    Blocks.attribute(),\n                    Blocks.expression(),\n                    Token(token_LPARE, /[>\\{]/),\n                    Token(token_PUNKT, /;/, \"start\"),\n                    Token(token_LPARE, /'''|\"\"\"/, [ next + \"-start\" ])\n                ],\n                \"block\": [\n                    Blocks.tagHead(/\\./) ,\n                    Blocks.tagHead(/#/) ,\n                    Blocks.attribute(),\n                    Blocks.expression(),\n                    Token(token_LPARE, /\\{/, [ next + \"-start\" ])\n                ]\n            })[type]\n        };\n    },\n    attribute: function(){\n        return Token(function(value){\n            return  /^x\\-/.test(value)\n                ? token_ATTR + \".\" + token_BOLD\n                : token_ATTR;\n        }, /[\\w_-]+/, [\n            Token(token_PUNKT, /\\s*=\\s*/, [\n                Blocks.string('\"'),\n                Blocks.string(\"'\"),\n                Blocks.word(),\n                Blocks.goUp()\n            ]),\n            Blocks.goUp()\n        ]);\n    },\n    expression: function(){\n        return Token(token_LPARE, /\\(/, [ \"js-statement-start\" ]);\n    },\n    word: function(){\n        return Token(\"string\", /[\\w-_]+/);\n    },\n    goUp: function(){\n        return Token(\"text\", \"\", \"pop\");\n    },\n    goStart: function(){\n        return Token(\"text\", \"\", \"start\");\n    }\n};\n\n\nfunction Token(token, rgx, mix) {\n    var push, next, onMatch;\n    if (arguments.length === 4) {\n        push = mix;\n        next = arguments[3];\n    }\n    else if (typeof mix === \"string\") {\n        next = mix;\n    }\n    else {\n        push = mix;\n    }\n    if (typeof token === \"function\") {\n        onMatch = token;\n        token   = \"empty\";\n    }\n    return {\n        token: token,\n        regex: rgx,\n        push: push,\n        next: next,\n        onMatch: onMatch\n    };\n}\n","\"use strict\";\n\nvar Range = require(\"../range\").Range;\n\nvar MatchingBraceOutdent = function() {};\n\n(function() {\n\n    this.checkOutdent = function(line, input) {\n        if (! /^\\s+$/.test(line))\n            return false;\n\n        return /^\\s*\\}/.test(input);\n    };\n\n    this.autoOutdent = function(doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\})/);\n\n        if (!match) return 0;\n\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n        if (!openBracePos || openBracePos.row == row) return 0;\n\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column-1), indent);\n    };\n\n    this.$getIndent = function(line) {\n        return line.match(/^\\s*/)[0];\n    };\n\n}).call(MatchingBraceOutdent.prototype);\n\nexports.MatchingBraceOutdent = MatchingBraceOutdent;\n"],"names":[],"sourceRoot":""}