{"version":3,"file":"bundle.540.js","mappings":";;;;;;AAAa;;AAEb,UAAU,mBAAO,CAAC,IAAe;AACjC,mBAAmB,qCAA+B;AAClD,YAAY,2CAA4B;;AAExC,eAAe,SAAgB;AAC/B;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;;;;;;ACtFD;AACA;AACA;;AAEa;;AAEb,UAAU,mBAAO,CAAC,IAAY;AAC9B,eAAe,iCAAsB;AACrC,6BAA6B,4DAA4D;AACzF,eAAe,8CAAsC;;AAErD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,CAAC;;AAED,YAAY;;;;;;;;ACzBC;;AAEb,UAAU,mBAAO,CAAC,IAAY;AAC9B,WAAW,mBAAO,CAAC,KAAa;AAChC,yBAAyB,wDAAoD;AAC7E,yBAAyB,+CAAoD;;AAE7E;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,6FAA6F;AAC7F,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,yBAAyB;AACzB,SAAS;AACT;AACA,2BAA2B;AAC3B,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,SAAS;AACT;AACA,6FAA6F;AAC7F,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,yBAAyB;AACzB,SAAS;AACT;AACA,2BAA2B;AAC3B,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;;AAEA,SAA8B","sources":["webpack://ace-playground/./node_modules/ace-code/src/mode/folding/velocity.js","webpack://ace-playground/./node_modules/ace-code/src/mode/velocity.js","webpack://ace-playground/./node_modules/ace-code/src/mode/velocity_highlight_rules.js"],"sourcesContent":["\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\n\nvar FoldMode = exports.FoldMode = function() {};\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var range = this.indentationBlock(session, row);\n        if (range)\n            return range;\n\n        var re = /\\S/;\n        var line = session.getLine(row);\n        var startLevel = line.search(re);\n        if (startLevel == -1 || line[startLevel] != \"##\")\n            return;\n\n        var startColumn = line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var level = line.search(re);\n\n            if (level == -1)\n                continue;\n\n            if (line[level] != \"##\")\n                break;\n\n            endRow = row;\n        }\n\n        if (endRow > startRow) {\n            var endColumn = session.getLine(endRow).length;\n            return new Range(startRow, startColumn, endRow, endColumn);\n        }\n    };\n\n    // must return \"\" if there's no fold, to enable caching\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        var indent = line.search(/\\S/);\n        var next = session.getLine(row + 1);\n        var prev = session.getLine(row - 1);\n        var prevIndent = prev.search(/\\S/);\n        var nextIndent = next.search(/\\S/);\n\n        if (indent == -1) {\n            session.foldWidgets[row - 1] = prevIndent!= -1 && prevIndent < nextIndent ? \"start\" : \"\";\n            return \"\";\n        }\n\n        // documentation comments\n        if (prevIndent == -1) {\n            if (indent == nextIndent && line[indent] == \"##\" && next[indent] == \"##\") {\n                session.foldWidgets[row - 1] = \"\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"start\";\n            }\n        } else if (prevIndent == indent && line[indent] == \"##\" && prev[indent] == \"##\") {\n            if (session.getLine(row - 2).search(/\\S/) == -1) {\n                session.foldWidgets[row - 1] = \"start\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"\";\n            }\n        }\n\n        if (prevIndent!= -1 && prevIndent < indent)\n            session.foldWidgets[row - 1] = \"start\";\n        else\n            session.foldWidgets[row - 1] = \"\";\n\n        if (indent < nextIndent)\n            return \"start\";\n        else\n            return \"\";\n    };\n\n}).call(FoldMode.prototype);\n","/*\n  THIS FILE WAS AUTOGENERATED BY mode.tmpl.js\n*/\n\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar HtmlMode = require(\"./html\").Mode;\nvar VelocityHighlightRules = require(\"./velocity_highlight_rules\").VelocityHighlightRules;\nvar FoldMode = require(\"./folding/velocity\").FoldMode;\n\nvar Mode = function() {\n    HtmlMode.call(this);\n    this.HighlightRules = VelocityHighlightRules;\n    this.foldingRules = new FoldMode();\n};\noop.inherits(Mode, HtmlMode);\n\n(function() {\n    this.lineCommentStart = \"##\";\n    this.blockComment = {start: \"#*\", end: \"*#\"};\n    this.$id = \"ace/mode/velocity\";\n    this.snippetFileId = \"ace/snippets/velocity\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n","\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar lang = require(\"../lib/lang\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\nvar HtmlHighlightRules = require(\"./html_highlight_rules\").HtmlHighlightRules;\n\nvar VelocityHighlightRules = function() {\n    HtmlHighlightRules.call(this);\n\n    var builtinConstants = lang.arrayToMap(\n        ('true|false|null').split('|')\n    );\n\n    var builtinFunctions = lang.arrayToMap(\n        (\"_DateTool|_DisplayTool|_EscapeTool|_FieldTool|_MathTool|_NumberTool|_SerializerTool|_SortTool|_StringTool|_XPathTool\").split('|')\n    );\n\n    var builtinVariables = lang.arrayToMap(\n        ('$contentRoot|$foreach').split('|')\n    );\n\n    var keywords = lang.arrayToMap(\n        (\"#set|#macro|#include|#parse|\" +\n        \"#if|#elseif|#else|#foreach|\" +\n        \"#break|#end|#stop\"\n        ).split('|')\n    );\n\n    // regexp must not have capturing parentheses. Use (?:) instead.\n    // regexps are ordered -> the first match is used\n\n    this.$rules.start.push(\n        {\n            token : \"comment\",\n            regex : \"##.*$\"\n        },{\n            token : \"comment.block\", // multi line comment\n            regex : \"#\\\\*\",\n            next : \"vm_comment\"\n        }, {\n            token : \"string.regexp\",\n            regex : \"[/](?:(?:\\\\[(?:\\\\\\\\]|[^\\\\]])+\\\\])|(?:\\\\\\\\/|[^\\\\]/]))*[/]\\\\w*\\\\s*(?=[).,;]|$)\"\n        }, {\n            token : \"string\", // single line\n            regex : '[\"](?:(?:\\\\\\\\.)|(?:[^\"\\\\\\\\]))*?[\"]'\n        }, {\n            token : \"string\", // single line\n            regex : \"['](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[']\"\n        }, {\n            token : \"constant.numeric\", // hex\n            regex : \"0[xX][0-9a-fA-F]+\\\\b\"\n        }, {\n            token : \"constant.numeric\", // float\n            regex : \"[+-]?\\\\d+(?:(?:\\\\.\\\\d*)?(?:[eE][+-]?\\\\d+)?)?\\\\b\"\n        }, {\n            token : \"constant.language.boolean\",\n            regex : \"(?:true|false)\\\\b\"\n        }, {\n            token : function(value) {\n                if (keywords.hasOwnProperty(value))\n                    return \"keyword\";\n                else if (builtinConstants.hasOwnProperty(value))\n                    return \"constant.language\";\n                else if (builtinVariables.hasOwnProperty(value))\n                    return \"variable.language\";\n                else if (builtinFunctions.hasOwnProperty(value) || builtinFunctions.hasOwnProperty(value.substring(1)))\n                    return \"support.function\";\n                else if (value == \"debugger\")\n                    return \"invalid.deprecated\";\n                else\n                    if(value.match(/^(\\$[a-zA-Z_][a-zA-Z0-9_]*)$/))\n                        return \"variable\";\n                    return \"identifier\";\n            },\n            // TODO: Unicode escape sequences\n            // TODO: Unicode identifiers\n            regex : \"[a-zA-Z$#][a-zA-Z0-9_]*\\\\b\"\n        }, {\n            token : \"keyword.operator\",\n            regex : \"!|&|\\\\*|\\\\-|\\\\+|=|!=|<=|>=|<|>|&&|\\\\|\\\\|\"\n        }, {\n            token : \"lparen\",\n            regex : \"[[({]\"\n        }, {\n            token : \"rparen\",\n            regex : \"[\\\\])}]\"\n        }, {\n            token : \"text\",\n            regex : \"\\\\s+\"\n        }\n    );\n\n    this.$rules[\"vm_comment\"] = [\n        {\n            token : \"comment\", // closing comment\n            regex : \"\\\\*#|-->\",\n            next : \"start\"\n        }, {\n            defaultToken: \"comment\"\n        }\n    ];\n\n    this.$rules[\"vm_start\"] = [\n        {\n            token: \"variable\",\n            regex: \"}\",\n            next: \"pop\"\n        }, {\n            token : \"string.regexp\",\n            regex : \"[/](?:(?:\\\\[(?:\\\\\\\\]|[^\\\\]])+\\\\])|(?:\\\\\\\\/|[^\\\\]/]))*[/]\\\\w*\\\\s*(?=[).,;]|$)\"\n        }, {\n            token : \"string\", // single line\n            regex : '[\"](?:(?:\\\\\\\\.)|(?:[^\"\\\\\\\\]))*?[\"]'\n        }, {\n            token : \"string\", // single line\n            regex : \"['](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[']\"\n        }, {\n            token : \"constant.numeric\", // hex\n            regex : \"0[xX][0-9a-fA-F]+\\\\b\"\n        }, {\n            token : \"constant.numeric\", // float\n            regex : \"[+-]?\\\\d+(?:(?:\\\\.\\\\d*)?(?:[eE][+-]?\\\\d+)?)?\\\\b\"\n        }, {\n            token : \"constant.language.boolean\",\n            regex : \"(?:true|false)\\\\b\"\n        }, {\n            token : function(value) {\n                if (keywords.hasOwnProperty(value))\n                    return \"keyword\";\n                else if (builtinConstants.hasOwnProperty(value))\n                    return \"constant.language\";\n                else if (builtinVariables.hasOwnProperty(value))\n                    return \"variable.language\";\n                else if (builtinFunctions.hasOwnProperty(value) || builtinFunctions.hasOwnProperty(value.substring(1)))\n                    return \"support.function\";\n                else if (value == \"debugger\")\n                    return \"invalid.deprecated\";\n                else\n                    if(value.match(/^(\\$[a-zA-Z_$][a-zA-Z0-9_]*)$/))\n                        return \"variable\";\n                    return \"identifier\";\n            },\n            // TODO: Unicode escape sequences\n            // TODO: Unicode identifiers\n            regex : \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"\n        }, {\n            token : \"keyword.operator\",\n            regex : \"!|&|\\\\*|\\\\-|\\\\+|=|!=|<=|>=|<|>|&&|\\\\|\\\\|\"\n        }, {\n            token : \"lparen\",\n            regex : \"[[({]\"\n        }, {\n            token : \"rparen\",\n            regex : \"[\\\\])}]\"\n        }, {\n            token : \"text\",\n            regex : \"\\\\s+\"\n        }\n    ];\n\n    for (var i in this.$rules) {\n        this.$rules[i].unshift({\n            token: \"variable\",\n            regex: \"\\\\${\",\n            push: \"vm_start\"\n        });\n    }\n\n    this.normalizeRules();\n};\n\noop.inherits(VelocityHighlightRules, TextHighlightRules);\n\nexports.VelocityHighlightRules = VelocityHighlightRules;\n"],"names":[],"sourceRoot":""}